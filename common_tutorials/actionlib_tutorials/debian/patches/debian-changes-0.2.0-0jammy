Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ros-noetic-actionlib-tutorials (0.2.0-0jammy) jammy; urgency=high
 .
   * Autogenerated, no changelog for this version found in CHANGELOG.rst.
Author: Daniel Stonier <d.stonier@gmail.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2024-08-18

--- /dev/null
+++ ros-noetic-actionlib-tutorials-0.2.0/CHANGELOG.rst
@@ -0,0 +1,21 @@
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Changelog for package actionlib_tutorials
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+0.1.10 (2016-12-12)
+-------------------
+* Export message_runtime to generate wiki documentation for actionlib tutorial actions
+
+0.1.9 (2016-12-11)
+------------------
+* Fix the runtime error 'SyntaxError: from __future_\_ imports must occur at the beginning of the file'
+* Fix on comments
+* Remove roslib references that catkin doesn't need
+* Pull old fibonacci python scripts from those linked on the wiki page
+* Contributors: Isaac I.Y. Saito, Kei Okada, Steven Peters, Vincent Rabaud
+
+0.1.8 (2014-11-05)
+------------------
+* update package maintainer.
+* Use _EXPORTED_TARGETS target suffix instead of _generate_messages_cpp
+* Contributors: Daniel Stonier, Esteve Fernandez
--- /dev/null
+++ ros-noetic-actionlib-tutorials-0.2.0/CMakeLists.txt
@@ -0,0 +1,67 @@
+cmake_minimum_required(VERSION 3.0.2)
+project(actionlib_tutorials)
+
+## Find catkin dependencies
+find_package(catkin REQUIRED COMPONENTS actionlib message_generation)
+
+## Find Boost
+find_package(Boost REQUIRED COMPONENTS system thread)
+
+## Add actions
+add_action_files(DIRECTORY action FILES Fibonacci.action Averaging.action)
+
+## Generate messages
+generate_messages(DEPENDENCIES std_msgs actionlib_msgs)
+
+## Define catkin exports
+catkin_package(
+  CATKIN_DEPENDS message_runtime roscpp actionlib
+  DEPENDS Boost
+)
+
+## Setup include dirs
+include_directories(include ${catkin_INCLUDE_DIRS} ${Boost_INCLUDE_DIRS})
+
+## Averaging server
+add_executable(averaging_server src/averaging_server.cpp)
+target_link_libraries(averaging_server ${catkin_LIBRARIES})
+add_dependencies(averaging_server ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
+
+## Averaging client
+add_executable(averaging_client src/averaging_client.cpp)
+target_link_libraries(averaging_client ${catkin_LIBRARIES} ${Boost_LIBRARIES})
+add_dependencies(averaging_client ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
+
+## Fibonacci server
+add_executable(fibonacci_server src/fibonacci_server.cpp)
+target_link_libraries(fibonacci_server ${catkin_LIBRARIES})
+add_dependencies(fibonacci_server ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
+
+## Fibonacci clients
+add_executable(fibonacci_client src/fibonacci_client.cpp)
+add_executable(fibonacci_callback_client src/fibonacci_callback_client.cpp)
+add_executable(fibonacci_class_client src/fibonacci_class_client.cpp)
+target_link_libraries(fibonacci_client ${catkin_LIBRARIES})
+target_link_libraries(fibonacci_callback_client ${catkin_LIBRARIES})
+target_link_libraries(fibonacci_class_client ${catkin_LIBRARIES})
+if(catkin_EXPORTED_TARGETS)
+  add_dependencies(fibonacci_client ${catkin_EXPORTED_TARGETS})
+  add_dependencies(fibonacci_callback_client ${catkin_EXPORTED_TARGETS})
+  add_dependencies(fibonacci_class_client ${catkin_EXPORTED_TARGETS})
+endif()
+add_dependencies(fibonacci_client ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
+add_dependencies(fibonacci_callback_client ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
+add_dependencies(fibonacci_class_client ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
+
+## Install scripts and executables
+install(PROGRAMS
+  scripts/fibonacci_client.py
+  scripts/fibonacci_server.py
+  scripts/gen_numbers.py
+  DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})
+
+install(TARGETS averaging_server averaging_client fibonacci_server fibonacci_client
+  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})
+
--- /dev/null
+++ ros-noetic-actionlib-tutorials-0.2.0/action/Averaging.action
@@ -0,0 +1,12 @@
+#goal definition
+int32 samples
+---
+#result definition
+float32 mean
+float32 std_dev
+---
+#feedback
+int32 sample
+float32 data
+float32 mean
+float32 std_dev
--- /dev/null
+++ ros-noetic-actionlib-tutorials-0.2.0/action/Fibonacci.action
@@ -0,0 +1,8 @@
+#goal definition
+int32 order
+---
+#result definition
+int32[] sequence
+---
+#feedback
+int32[] sequence
--- /dev/null
+++ ros-noetic-actionlib-tutorials-0.2.0/package.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0"?>
+<package>
+  <name>actionlib_tutorials</name>
+  <version>0.2.0</version>
+  <description>The actionlib_tutorials package</description>
+  <maintainer email="d.stonier@gmail.com">Daniel Stonier</maintainer>
+  <license>BSD</license>
+
+  <url type="website">http://www.ros.org/wiki/actionlib/Tutorials</url>
+  <url type="repository">https://github.com/ros/common_tutorials</url>
+  <url type="bugtracker">https://github.com/ros/common_tutorials/issues</url>
+
+  <author>Melonee Wise</author>
+
+  <buildtool_depend>catkin</buildtool_depend>
+
+  <build_depend>roscpp</build_depend>
+  <build_depend>actionlib</build_depend>
+  <build_depend>message_generation</build_depend>
+  <build_depend>std_msgs</build_depend>
+  <build_depend>actionlib_msgs</build_depend>
+
+  <run_depend>roscpp</run_depend>
+  <run_depend>actionlib</run_depend>
+  <run_depend>message_runtime</run_depend>
+
+</package>
--- /dev/null
+++ ros-noetic-actionlib-tutorials-0.2.0/scripts/fibonacci_client.py
@@ -0,0 +1,44 @@
+#! /usr/bin/env python3
+
+from __future__ import print_function
+
+import sys
+
+import rospy
+# Brings in the SimpleActionClient
+import actionlib
+
+# Brings in the messages used by the fibonacci action, including the
+# goal message and the result message.
+import actionlib_tutorials.msg
+
+def fibonacci_client():
+    # Creates the SimpleActionClient, passing the type of the action
+    # (FibonacciAction) to the constructor.
+    client = actionlib.SimpleActionClient('fibonacci', actionlib_tutorials.msg.FibonacciAction)
+
+    # Waits until the action server has started up and started
+    # listening for goals.
+    client.wait_for_server()
+
+    # Creates a goal to send to the action server.
+    goal = actionlib_tutorials.msg.FibonacciGoal(order=20)
+
+    # Sends the goal to the action server.
+    client.send_goal(goal)
+
+    # Waits for the server to finish performing the action.
+    client.wait_for_result()
+
+    # Prints out the result of executing the action
+    return client.get_result()  # A FibonacciResult
+
+if __name__ == '__main__':
+    try:
+        # Initializes a rospy node so that the SimpleActionClient can
+        # publish and subscribe over ROS.
+        rospy.init_node('fibonacci_client_py')
+        result = fibonacci_client()
+        print("Result:", ', '.join([str(n) for n in result.sequence]))
+    except rospy.ROSInterruptException:
+        print("program interrupted before completion", file=sys.stderr)
--- /dev/null
+++ ros-noetic-actionlib-tutorials-0.2.0/scripts/fibonacci_server.py
@@ -0,0 +1,54 @@
+#! /usr/bin/env python3
+
+import rospy
+
+import actionlib
+
+import actionlib_tutorials.msg
+
+class FibonacciAction(object):
+    # create messages that are used to publish feedback/result
+    _feedback = actionlib_tutorials.msg.FibonacciFeedback()
+    _result = actionlib_tutorials.msg.FibonacciResult()
+
+    def __init__(self, name):
+        self._action_name = name
+        self._as = actionlib.SimpleActionServer(self._action_name, actionlib_tutorials.msg.FibonacciAction, execute_cb=self.execute_cb, auto_start = False)
+        self._as.start()
+      
+    def execute_cb(self, goal):
+        # helper variables
+        r = rospy.Rate(1)
+        success = True
+        
+        # append the seeds for the fibonacci sequence
+        self._feedback.sequence = []
+        self._feedback.sequence.append(0)
+        self._feedback.sequence.append(1)
+        
+        # publish info to the console for the user
+        rospy.loginfo('%s: Executing, creating fibonacci sequence of order %i with seeds %i, %i' % (self._action_name, goal.order, self._feedback.sequence[0], self._feedback.sequence[1]))
+        
+        # start executing the action
+        for i in range(1, goal.order):
+            # check that preempt has not been requested by the client
+            if self._as.is_preempt_requested():
+                rospy.loginfo('%s: Preempted' % self._action_name)
+                self._as.set_preempted()
+                success = False
+                break
+            self._feedback.sequence.append(self._feedback.sequence[i] + self._feedback.sequence[i-1])
+            # publish the feedback
+            self._as.publish_feedback(self._feedback)
+            # this step is not necessary, the sequence is computed at 1 Hz for demonstration purposes
+            r.sleep()
+          
+        if success:
+            self._result.sequence = self._feedback.sequence
+            rospy.loginfo('%s: Succeeded' % self._action_name)
+            self._as.set_succeeded(self._result)
+        
+if __name__ == '__main__':
+    rospy.init_node('fibonacci')
+    server = FibonacciAction(rospy.get_name())
+    rospy.spin()
--- /dev/null
+++ ros-noetic-actionlib-tutorials-0.2.0/scripts/gen_numbers.py
@@ -0,0 +1,26 @@
+#!/usr/bin/env python3
+from __future__ import print_function
+
+import rospy
+
+import random
+
+from std_msgs.msg import Float32
+
+
+def gen_number():
+    rospy.init_node('random_number_generator')
+
+    pub = rospy.Publisher('random_number', Float32)
+
+    rospy.loginfo("Generating random numbers")
+    rate = rospy.Rate(20)
+    while not rospy.is_shutdown():
+        pub.publish(Float32(random.normalvariate(5, 1)))
+        rate.sleep()
+
+if __name__ == '__main__':
+    try:
+        gen_number()
+    except KeyboardInterrupt:
+        print("done")
--- /dev/null
+++ ros-noetic-actionlib-tutorials-0.2.0/src/averaging_client.cpp
@@ -0,0 +1,46 @@
+#include <ros/ros.h>
+#include <actionlib/client/simple_action_client.h>
+#include <actionlib/client/terminal_state.h>
+#include <actionlib_tutorials/AveragingAction.h>
+#include <boost/thread.hpp>
+
+void spinThread()
+{
+  ros::spin();
+}
+
+int main (int argc, char **argv)
+{
+  ros::init(argc, argv, "test_averaging");
+
+  // create the action client
+  actionlib::SimpleActionClient<actionlib_tutorials::AveragingAction> ac("averaging");
+  boost::thread spin_thread(&spinThread);
+
+  ROS_INFO("Waiting for action server to start.");
+  ac.waitForServer();
+
+  ROS_INFO("Action server started, sending goal.");
+  // send a goal to the action
+  actionlib_tutorials::AveragingGoal goal;
+  goal.samples = 100;
+  ac.sendGoal(goal);
+
+  //wait for the action to return
+  bool finished_before_timeout = ac.waitForResult(ros::Duration(30.0));
+
+  if (finished_before_timeout)
+  {
+    actionlib::SimpleClientGoalState state = ac.getState();
+    ROS_INFO("Action finished: %s",state.toString().c_str());
+  }
+  else
+    ROS_INFO("Action did not finish before the time out.");
+
+  // shutdown the node and join the thread back before exiting
+  ros::shutdown();
+  spin_thread.join();
+
+  //exit
+  return 0;
+}
--- /dev/null
+++ ros-noetic-actionlib-tutorials-0.2.0/src/averaging_server.cpp
@@ -0,0 +1,100 @@
+#include <ros/ros.h>
+#include <std_msgs/Float32.h>
+#include <actionlib/server/simple_action_server.h>
+#include <actionlib_tutorials/AveragingAction.h>
+
+class AveragingAction
+{
+public:
+    
+  AveragingAction(std::string name) : 
+    as_(nh_, name, false),
+    action_name_(name)
+  {
+    //register the goal and feeback callbacks
+    as_.registerGoalCallback(boost::bind(&AveragingAction::goalCB, this));
+    as_.registerPreemptCallback(boost::bind(&AveragingAction::preemptCB, this));
+
+    //subscribe to the data topic of interest
+    sub_ = nh_.subscribe("/random_number", 1, &AveragingAction::analysisCB, this);
+    as_.start();
+  }
+
+  ~AveragingAction(void)
+  {
+  }
+
+  void goalCB()
+  {
+    // reset helper variables
+    data_count_ = 0;
+    sum_ = 0;
+    sum_sq_ = 0;
+    // accept the new goal
+    goal_ = as_.acceptNewGoal()->samples;
+  }
+
+  void preemptCB()
+  {
+    ROS_INFO("%s: Preempted", action_name_.c_str());
+    // set the action state to preempted
+    as_.setPreempted();
+  }
+
+  void analysisCB(const std_msgs::Float32::ConstPtr& msg)
+  {
+    // make sure that the action hasn't been canceled
+    if (!as_.isActive())
+      return;
+    
+    data_count_++;
+    feedback_.sample = data_count_;
+    feedback_.data = msg->data;
+    //compute the std_dev and mean of the data 
+    sum_ += msg->data;
+    feedback_.mean = sum_ / data_count_;
+    sum_sq_ += pow(msg->data, 2);
+    feedback_.std_dev = sqrt(fabs((sum_sq_/data_count_) - pow(feedback_.mean, 2)));
+    as_.publishFeedback(feedback_);
+
+    if(data_count_ > goal_) 
+    {
+      result_.mean = feedback_.mean;
+      result_.std_dev = feedback_.std_dev;
+
+      if(result_.mean < 5.0)
+      {
+        ROS_INFO("%s: Aborted", action_name_.c_str());
+        //set the action state to aborted
+        as_.setAborted(result_);
+      }
+      else 
+      {
+        ROS_INFO("%s: Succeeded", action_name_.c_str());
+        // set the action state to succeeded
+        as_.setSucceeded(result_);
+      }
+    } 
+  }
+
+protected:
+    
+  ros::NodeHandle nh_;
+  actionlib::SimpleActionServer<actionlib_tutorials::AveragingAction> as_;
+  std::string action_name_;
+  int data_count_, goal_;
+  float sum_, sum_sq_;
+  actionlib_tutorials::AveragingFeedback feedback_;
+  actionlib_tutorials::AveragingResult result_;
+  ros::Subscriber sub_;
+};
+
+int main(int argc, char** argv)
+{
+  ros::init(argc, argv, "averaging");
+
+  AveragingAction averaging(ros::this_node::getName());
+  ros::spin();
+
+  return 0;
+}
--- /dev/null
+++ ros-noetic-actionlib-tutorials-0.2.0/src/fibonacci_callback_client.cpp
@@ -0,0 +1,47 @@
+#include <ros/ros.h>
+#include <actionlib/client/simple_action_client.h>
+#include <actionlib_tutorials/FibonacciAction.h>
+
+using namespace actionlib_tutorials;
+typedef actionlib::SimpleActionClient<FibonacciAction> Client;
+
+// Called once when the goal completes
+void doneCb(const actionlib::SimpleClientGoalState& state,
+            const FibonacciResultConstPtr& result)
+{
+  ROS_INFO("Finished in state [%s]", state.toString().c_str());
+  ROS_INFO("Answer: %i", result->sequence.back());
+  ros::shutdown();
+}
+
+// Called once when the goal becomes active
+void activeCb()
+{
+  ROS_INFO("Goal just went active");
+}
+
+// Called every time feedback is received for the goal
+void feedbackCb(const FibonacciFeedbackConstPtr& feedback)
+{
+  ROS_INFO("Got Feedback of length %lu", feedback->sequence.size());
+}
+
+int main (int argc, char **argv)
+{
+  ros::init(argc, argv, "test_fibonacci_callback");
+
+  // Create the action client
+  Client ac("fibonacci", true);
+
+  ROS_INFO("Waiting for action server to start.");
+  ac.waitForServer();
+  ROS_INFO("Action server started, sending goal.");
+
+  // Send Goal
+  FibonacciGoal goal;
+  goal.order = 20;
+  ac.sendGoal(goal, &doneCb, &activeCb, &feedbackCb);
+
+  ros::spin();
+  return 0;
+}
--- /dev/null
+++ ros-noetic-actionlib-tutorials-0.2.0/src/fibonacci_class_client.cpp
@@ -0,0 +1,50 @@
+#include <ros/ros.h>
+#include <actionlib/client/simple_action_client.h>
+#include <actionlib_tutorials/FibonacciAction.h>
+
+using namespace actionlib_tutorials;
+typedef actionlib::SimpleActionClient<FibonacciAction> Client;
+
+class MyNode
+{
+public:
+  MyNode() : ac("fibonacci", true)
+  {
+    ROS_INFO("Waiting for action server to start.");
+    ac.waitForServer();
+    ROS_INFO("Action server started, sending goal.");
+  }
+
+  void doStuff(int order)
+  {
+    FibonacciGoal goal;
+    goal.order = order;
+
+    // Need boost::bind to pass in the 'this' pointer
+    ac.sendGoal(goal,
+                boost::bind(&MyNode::doneCb, this, _1, _2),
+                Client::SimpleActiveCallback(),
+                Client::SimpleFeedbackCallback());
+
+  }
+
+  void doneCb(const actionlib::SimpleClientGoalState& state,
+              const FibonacciResultConstPtr& result)
+  {
+    ROS_INFO("Finished in state [%s]", state.toString().c_str());
+    ROS_INFO("Answer: %i", result->sequence.back());
+    ros::shutdown();
+  }
+
+private:
+  Client ac;
+};
+
+int main (int argc, char **argv)
+{
+  ros::init(argc, argv, "test_fibonacci_class_client");
+  MyNode my_node;
+  my_node.doStuff(10);
+  ros::spin();
+  return 0;
+}
--- /dev/null
+++ ros-noetic-actionlib-tutorials-0.2.0/src/fibonacci_client.cpp
@@ -0,0 +1,42 @@
+#include <ros/ros.h>
+#include <actionlib/client/simple_action_client.h>
+#include <actionlib/client/terminal_state.h>
+#include <actionlib_tutorials/FibonacciAction.h>
+
+int main (int argc, char **argv)
+{
+  ros::init(argc, argv, "test_fibonacci");
+
+  // create the action client
+  // true causes the client to spin its own thread
+  actionlib::SimpleActionClient<actionlib_tutorials::FibonacciAction> ac("fibonacci", true);
+
+  ROS_INFO("Waiting for action server to start.");
+  // wait for the action server to start
+  ac.waitForServer(); //will wait for infinite time
+
+  ROS_INFO("Action server started, sending goal.");
+  // send a goal to the action
+  actionlib_tutorials::FibonacciGoal goal;
+  goal.order = 20;
+  ac.sendGoal(goal);
+
+  //wait for the action to return
+  bool finished_before_timeout = ac.waitForResult(ros::Duration(30.0));
+
+  if (finished_before_timeout)
+  {
+    actionlib::SimpleClientGoalState state = ac.getState();
+    ROS_INFO("Action finished: %s",state.toString().c_str());
+    actionlib_tutorials::FibonacciResult result = *(ac.getResult());
+    std::stringstream result_string;
+    std::copy(result.sequence.begin(), result.sequence.end(),
+              std::ostream_iterator<int>(result_string, " "));
+    ROS_INFO("Action result: %s", result_string.str().c_str());
+  }
+  else
+    ROS_INFO("Action did not finish before the time out.");
+
+  //exit
+  return 0;
+}
--- /dev/null
+++ ros-noetic-actionlib-tutorials-0.2.0/src/fibonacci_server.cpp
@@ -0,0 +1,83 @@
+#include <ros/ros.h>
+#include <actionlib/server/simple_action_server.h>
+#include <actionlib_tutorials/FibonacciAction.h>
+
+class FibonacciAction
+{
+protected:
+
+  ros::NodeHandle nh_;
+  actionlib::SimpleActionServer<actionlib_tutorials::FibonacciAction> as_; // NodeHandle instance must be created before this line. Otherwise strange error occurs.
+  std::string action_name_;
+  // create messages that are used to published feedback/result
+  actionlib_tutorials::FibonacciFeedback feedback_;
+  actionlib_tutorials::FibonacciResult result_;
+
+public:
+
+  FibonacciAction(std::string name) :
+    as_(nh_, name, boost::bind(&FibonacciAction::executeCB, this, _1), false),
+    action_name_(name)
+  {
+    as_.start();
+  }
+
+  ~FibonacciAction(void)
+  {
+  }
+
+  void executeCB(const actionlib_tutorials::FibonacciGoalConstPtr &goal)
+  {
+    // helper variables
+    ros::Rate r(1);
+    bool success = true;
+
+    // push_back the seeds for the fibonacci sequence
+    feedback_.sequence.clear();
+    feedback_.sequence.push_back(0);
+    feedback_.sequence.push_back(1);
+
+    // publish info to the console for the user
+    ROS_INFO("%s: Executing, creating fibonacci sequence of order %i with seeds %i, %i", action_name_.c_str(), goal->order, feedback_.sequence[0], feedback_.sequence[1]);
+
+    // start executing the action
+    for(int i=1; i<=goal->order; i++)
+    {
+      // check that preempt has not been requested by the client
+      if (as_.isPreemptRequested() || !ros::ok())
+      {
+        ROS_INFO("%s: Preempted", action_name_.c_str());
+        // set the action state to preempted
+        as_.setPreempted();
+        success = false;
+        break;
+      }
+      feedback_.sequence.push_back(feedback_.sequence[i] + feedback_.sequence[i-1]);
+      // publish the feedback
+      as_.publishFeedback(feedback_);
+      // this sleep is not necessary, the sequence is computed at 1 Hz for demonstration purposes
+      r.sleep();
+    }
+
+    if(success)
+    {
+      result_.sequence = feedback_.sequence;
+      ROS_INFO("%s: Succeeded", action_name_.c_str());
+      // set the action state to succeeded
+      as_.setSucceeded(result_);
+    }
+  }
+
+
+};
+
+
+int main(int argc, char** argv)
+{
+  ros::init(argc, argv, "fibonacci");
+
+  FibonacciAction fibonacci("fibonacci");
+  ros::spin();
+
+  return 0;
+}
