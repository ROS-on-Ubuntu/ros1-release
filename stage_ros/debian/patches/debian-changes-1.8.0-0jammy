Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ros-noetic-stage-ros (1.8.0-0jammy) jammy; urgency=high
 .
   * Now uses Stage's native event loop properly and added reassuring startup output.
   * Added a GUI section so that the world starts in a good place.
   * Fixed issue such that ranger intensity values are no longer clipped to 256
     See: #31 <https://github.com/ros-simulation/stage_ros/issues/31>
   * Contributors: Richard Vaughan, Shane Loretz, William Woodall, gerkey
Author: William Woodall <william@osrfoundation.org>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2024-08-18

--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/.travis.yml
@@ -0,0 +1,39 @@
+
+sudo: required
+dist: trusty
+# Force travis to use its minimal image with default Python settings
+language: generic
+compiler:
+  - gcc
+env:
+  global:
+    - CATKIN_WS=~/catkin_ws
+    - CATKIN_WS_SRC=${CATKIN_WS}/src
+  matrix:
+    - CI_ROS_DISTRO="indigo"
+    - CI_ROS_DISTRO="jade"
+install:
+  - sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu trusty main" > /etc/apt/sources.list.d/ros-latest.list'
+  - wget http://packages.ros.org/ros.key -O - | sudo apt-key add -
+  - sudo apt-get update -qq
+  - sudo apt-get install -qq -y python-rosdep python-catkin-tools
+  - sudo rosdep init
+  - rosdep update
+  # Use rosdep to install all dependencies (including ROS itself)
+  - rosdep install --from-paths ./ -i -y --rosdistro $CI_ROS_DISTRO
+script:
+  - source /opt/ros/$CI_ROS_DISTRO/setup.bash
+  - mkdir -p $CATKIN_WS_SRC
+  - ln -s $TRAVIS_BUILD_DIR $CATKIN_WS_SRC
+  - cd $CATKIN_WS
+  - catkin init
+  # Enable install space
+  - catkin config --install
+  # Build [and Install] packages
+  - catkin build --no-status -vi --no-notify -DCMAKE_BUILD_TYPE=Release
+  # Build tests
+  - catkin build --no-status -vi --no-notify --make-args tests
+  # Run tests
+  - catkin run_tests
+  # Assert tests all passed
+  - catkin_test_results ./build
--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/CHANGELOG.rst
@@ -0,0 +1,57 @@
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Changelog for package stage_ros
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+1.8.0 (2017-04-30)
+------------------
+* Now uses Stage's native event loop properly and added reassuring startup output.
+* Added a GUI section so that the world starts in a good place.
+* Fixed issue such that ranger intensity values are no longer clipped to 256
+  See: `#31 <https://github.com/ros-simulation/stage_ros/issues/31>`_
+* Contributors: Richard Vaughan, Shane Loretz, William Woodall, gerkey
+
+1.7.5 (2015-09-16)
+------------------
+* Removed all references to FLTK/Fluid and use the upstream CMake config file instead.
+* Added ``reset_positions`` service to stage (adds dependency on ``std_srvs``).
+* Contributors: Aurélien Ballier, Daniel Claes, Scott K Logan, William Woodall
+
+1.7.4 (2015-03-04)
+------------------
+* Added missing -ldl flag on newer versions of Ubuntu
+* Contributors: William Woodall
+
+1.7.3 (2015-01-26)
+------------------
+* Split up ``fltk`` dep into ``libfltk-dev`` and ``fluid``, only ``run_depend``'ing on fluid.
+* Now supports multiple robots with multiple sensors.
+* Fixed a bug on systems that cannot populate FLTK_INCLUDE_DIRS.
+* Updated topurg model from "laser" to "ranger".
+* Added -u option to use name property of position models as its namespace instead of "robot_0", "robot_1", etc.
+* Contributors: Gustavo Velasco Hernández, Gustavo Velasco-Hernández, Pablo Urcola, Wayne Chang, William Woodall
+
+1.7.2 (2013-09-19)
+------------------
+* Changed default GUI window size to 600x400
+* Added velocity to ground truth odometry
+* Fixed tf (yaw component) for the base_link->camera transform.
+* Fixed ground truth pose coordinate system
+
+1.7.1 (2013-08-30)
+------------------
+* Fixing warnings
+* Small fixes
+* Added RGB+3D-sensor interface (Primesense/Kinect/Xtion).
+  * Publishes CameraInfo, depth image, RGBA image, tf (takes world-file pantilt paremeter into account)
+  * Supports the "old" configuration (laser+odom) as well as camera+odom, laser+camera+odom and odom-only.
+  Fixed laser transform height (previously was hardcoded at 0.15, now it takes robot height into account).
+* Introduced changes from https://github.com/rtv/Stage/issues/34 with some changes (does not require lasers to be present and works without cameras).
+
+1.7.0 (2013-06-27 18:15:07 -0700)
+---------------------------------
+- Initial move over from old repository: https://code.ros.org/svn/ros-pkg/stacks/stage
+- Catkinized
+- Stage itself is released as a third party package now
+- Had to disable velocities in the output odometry as Stage no longer implements it internally.
+- Updated rostest
+- Updated rviz configurations
--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/CMakeLists.txt
@@ -0,0 +1,66 @@
+cmake_minimum_required(VERSION 2.8.3)
+project(stage_ros)
+
+find_package(catkin REQUIRED
+  COMPONENTS
+    geometry_msgs
+    nav_msgs
+    roscpp
+    sensor_msgs
+    std_msgs
+    std_srvs
+    tf
+)
+
+find_package(Boost REQUIRED COMPONENTS system thread)
+
+find_package(stage REQUIRED)
+
+include_directories(
+  ${catkin_INCLUDE_DIRS}
+  ${Boost_INCLUDE_DIRS}
+  ${STAGE_INCLUDE_DIRS}
+)
+
+catkin_package()
+
+# Declare a cpp executable
+add_executable(stageros src/stageros.cpp)
+set(${PROJECT_NAME}_extra_libs "")
+if(UNIX AND NOT APPLE)
+  set(${PROJECT_NAME}_extra_libs dl)
+endif()
+target_link_libraries(stageros
+  ${catkin_LIBRARIES}
+  ${Boost_LIBRARIES}
+  ${STAGE_LIBRARIES}
+  ${${PROJECT_NAME}_extra_libs}
+)
+if(catkin_EXPORTED_TARGETS)
+  add_dependencies(stageros ${catkin_EXPORTED_TARGETS})
+endif()
+
+## Install
+
+install(PROGRAMS scripts/upgrade-world.sh
+  DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})
+
+install(TARGETS stageros
+  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
+)
+
+install(DIRECTORY rviz
+  DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION})
+
+install(DIRECTORY world
+  DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION})
+
+## Tests
+
+if(CATKIN_ENABLE_TESTING)
+  find_package(rostest REQUIRED)
+  add_rostest(test/hztest.xml)
+  add_rostest(test/intensity_test.xml)
+endif()
--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/package.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0"?>
+<package>
+  <name>stage_ros</name>
+  <version>1.8.0</version>
+  <description>This package provides ROS specific hooks for stage</description>
+
+  <maintainer email="william@osrfoundation.org">William Woodall</maintainer>
+
+  <license>BSD</license>
+
+  <url type="website">http://ros.org/wiki/stage_ros</url>
+  <url type="repository">https://github.com/ros-simulation/stage_ros</url>
+  <url type="bugtracker">https://github.com/ros-simulation/stage_ros/issues</url>
+
+  <author email="gerky@osrfoundation.org">Brian Gerky</author>
+
+  <buildtool_depend>catkin</buildtool_depend>
+
+  <build_depend>boost</build_depend>
+  <build_depend>geometry_msgs</build_depend>
+  <build_depend>nav_msgs</build_depend>
+  <build_depend>roscpp</build_depend>
+  <build_depend>rostest</build_depend>
+  <build_depend>sensor_msgs</build_depend>
+  <build_depend>stage</build_depend>
+  <build_depend>std_msgs</build_depend>
+  <build_depend>std_srvs</build_depend>
+  <build_depend>tf</build_depend>
+
+  <run_depend>boost</run_depend>
+  <run_depend>geometry_msgs</run_depend>
+  <run_depend>nav_msgs</run_depend>
+  <run_depend>roscpp</run_depend>
+  <run_depend>sensor_msgs</run_depend>
+  <run_depend>stage</run_depend>
+  <run_depend>std_msgs</run_depend>
+  <run_depend>std_srvs</run_depend>
+  <run_depend>tf</run_depend>
+</package>
--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/rviz/stage.rviz
@@ -0,0 +1,157 @@
+Panels:
+  - Class: rviz/Displays
+    Help Height: 78
+    Name: Displays
+    Property Tree Widget:
+      Expanded:
+        - /Global Options1
+        - /TF1/Frames1
+      Splitter Ratio: 0.5
+    Tree Height: 479
+  - Class: rviz/Selection
+    Name: Selection
+  - Class: rviz/Tool Properties
+    Expanded:
+      - /2D Pose Estimate1
+      - /2D Nav Goal1
+      - /Publish Point1
+    Name: Tool Properties
+    Splitter Ratio: 0.588679
+  - Class: rviz/Views
+    Expanded:
+      - /Current View1
+    Name: Views
+    Splitter Ratio: 0.5
+  - Class: rviz/Time
+    Experimental: false
+    Name: Time
+    SyncMode: 0
+    SyncSource: LaserScan
+Visualization Manager:
+  Class: ""
+  Displays:
+    - Alpha: 0.5
+      Cell Size: 1
+      Class: rviz/Grid
+      Color: 160; 160; 164
+      Enabled: true
+      Line Style:
+        Line Width: 0.03
+        Value: Lines
+      Name: Grid
+      Normal Cell Count: 0
+      Offset:
+        X: 0
+        Y: 0
+        Z: 0
+      Plane: XY
+      Plane Cell Count: 10
+      Reference Frame: <Fixed Frame>
+      Value: true
+    - Class: rviz/TF
+      Enabled: true
+      Frame Timeout: 15
+      Frames:
+        /base_footprint:
+          Value: true
+        /base_laser_link:
+          Value: true
+        /base_link:
+          Value: true
+        /odom:
+          Value: true
+        All Enabled: false
+      Marker Scale: 1
+      Name: TF
+      Show Arrows: false
+      Show Axes: true
+      Show Names: false
+      Tree:
+        /odom:
+          /base_footprint:
+            /base_link:
+              /base_laser_link:
+                {}
+      Update Interval: 0
+      Value: true
+    - Alpha: 1
+      Autocompute Intensity Bounds: true
+      Autocompute Value Bounds:
+        Max Value: 10
+        Min Value: -10
+        Value: true
+      Axis: Z
+      Channel Name: intensity
+      Class: rviz/LaserScan
+      Color: 255; 255; 255
+      Color Transformer: Intensity
+      Decay Time: 0
+      Enabled: true
+      Max Color: 255; 255; 255
+      Max Intensity: 1
+      Min Color: 0; 0; 0
+      Min Intensity: 1
+      Name: LaserScan
+      Position Transformer: XYZ
+      Queue Size: 10
+      Selectable: true
+      Size (Pixels): 3
+      Size (m): 0.01
+      Style: Flat Squares
+      Topic: /base_scan
+      Use Fixed Frame: true
+      Use rainbow: true
+      Value: true
+  Enabled: true
+  Global Options:
+    Background Color: 48; 48; 48
+    Fixed Frame: /odom
+  Name: root
+  Tools:
+    - Class: rviz/Interact
+      Hide Inactive Objects: true
+    - Class: rviz/MoveCamera
+    - Class: rviz/Select
+    - Class: rviz/FocusCamera
+    - Class: rviz/Measure
+    - Class: rviz/SetInitialPose
+      Topic: /initialpose
+    - Class: rviz/SetGoal
+      Topic: /move_base_simple/goal
+    - Class: rviz/PublishPoint
+      Single click: true
+      Topic: /clicked_point
+  Value: true
+  Views:
+    Current:
+      Class: rviz/Orbit
+      Distance: 5.68654
+      Focal Point:
+        X: 0
+        Y: 0
+        Z: 0
+      Name: Current View
+      Near Clip Distance: 0.01
+      Pitch: 0.529796
+      Target Frame: <Fixed Frame>
+      Value: Orbit (rviz)
+      Yaw: 3.2654
+    Saved: ~
+Window Geometry:
+  Displays:
+    collapsed: false
+  Height: 756
+  Hide Left Dock: false
+  Hide Right Dock: false
+  QMainWindow State: 000000ff00000000fd00000004000000000000013c0000026dfc0200000008fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005600fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000002540000011a00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb000000100044006900730070006c006100790073010000002c0000026d000000dc00fffffffb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261000000010000010f0000026dfc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000000a00560069006500770073010000002c0000026d000000a500fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000004fc0000003efc0100000002fb0000000800540069006d00650100000000000004fc0000020b00fffffffb0000000800540069006d00650100000000000004500000000000000000000002af0000026d00000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  Selection:
+    collapsed: false
+  Time:
+    collapsed: false
+  Tool Properties:
+    collapsed: false
+  Views:
+    collapsed: false
+  Width: 1276
+  X: 60
+  Y: 22
--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/scripts/upgrade-world.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+
+USAGE="USAGE: upgrade-world.sh in.world out.world"
+
+if [ $# != 2 ]; then
+  echo $USAGE
+  exit 1
+fi
+
+cat < $1 | sed 's/size3/size/' | sed 's/origin3/origin/' | sed 's/.*interval_real.*//' | sed 's/.*range_min.*//' | sed 's/.*center.*//' | sed 's/.*gui_movemask.*//' | sed 's/\(.*pose *\[\)\([^ ]*\) *\([^ ]*\) *\([^ ]*\) *\(\].*\)/\1 \2 \3 0 \4 \5/' > $2
--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/src/stageros.cpp
@@ -0,0 +1,785 @@
+/*
+ *  stageros
+ *  Copyright (c) 2008, Willow Garage, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/**
+
+@mainpage
+
+@htmlinclude manifest.html
+**/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <signal.h>
+
+
+// libstage
+#include <stage.hh>
+
+
+// roscpp
+#include <ros/ros.h>
+#include <boost/thread/mutex.hpp>
+#include <boost/thread/thread.hpp>
+#include <sensor_msgs/LaserScan.h>
+#include <sensor_msgs/Image.h>
+#include <sensor_msgs/image_encodings.h>
+#include <sensor_msgs/CameraInfo.h>
+#include <nav_msgs/Odometry.h>
+#include <geometry_msgs/Twist.h>
+#include <rosgraph_msgs/Clock.h>
+
+#include <std_srvs/Empty.h>
+
+#include "tf/transform_broadcaster.h"
+
+#define USAGE "stageros <worldfile>"
+#define IMAGE "image"
+#define DEPTH "depth"
+#define CAMERA_INFO "camera_info"
+#define ODOM "odom"
+#define BASE_SCAN "base_scan"
+#define BASE_POSE_GROUND_TRUTH "base_pose_ground_truth"
+#define CMD_VEL "cmd_vel"
+
+// Our node
+class StageNode
+{
+private:
+
+    // roscpp-related bookkeeping
+    ros::NodeHandle n_;
+
+    // A mutex to lock access to fields that are used in message callbacks
+    boost::mutex msg_lock;
+
+    // The models that we're interested in
+    std::vector<Stg::ModelCamera *> cameramodels;
+    std::vector<Stg::ModelRanger *> lasermodels;
+    std::vector<Stg::ModelPosition *> positionmodels;
+
+    //a structure representing a robot inthe simulator
+    struct StageRobot
+    {
+        //stage related models
+        Stg::ModelPosition* positionmodel; //one position
+        std::vector<Stg::ModelCamera *> cameramodels; //multiple cameras per position
+        std::vector<Stg::ModelRanger *> lasermodels; //multiple rangers per position
+
+        //ros publishers
+        ros::Publisher odom_pub; //one odom
+        ros::Publisher ground_truth_pub; //one ground truth
+
+        std::vector<ros::Publisher> image_pubs; //multiple images
+        std::vector<ros::Publisher> depth_pubs; //multiple depths
+        std::vector<ros::Publisher> camera_pubs; //multiple cameras
+        std::vector<ros::Publisher> laser_pubs; //multiple lasers
+
+        ros::Subscriber cmdvel_sub; //one cmd_vel subscriber
+    };
+
+    std::vector<StageRobot const *> robotmodels_;
+
+    // Used to remember initial poses for soft reset
+    std::vector<Stg::Pose> initial_poses;
+    ros::ServiceServer reset_srv_;
+  
+    ros::Publisher clock_pub_;
+    
+    bool isDepthCanonical;
+    bool use_model_names;
+
+    // A helper function that is executed for each stage model.  We use it
+    // to search for models of interest.
+    static void ghfunc(Stg::Model* mod, StageNode* node);
+
+    static bool s_update(Stg::World* world, StageNode* node)
+    {
+        node->WorldCallback();
+        // We return false to indicate that we want to be called again (an
+        // odd convention, but that's the way that Stage works).
+        return false;
+    }
+
+    // Appends the given robot ID to the given message name.  If omitRobotID
+    // is true, an unaltered copy of the name is returned.
+    const char *mapName(const char *name, size_t robotID, Stg::Model* mod) const;
+    const char *mapName(const char *name, size_t robotID, size_t deviceID, Stg::Model* mod) const;
+
+    tf::TransformBroadcaster tf;
+
+    // Last time that we received a velocity command
+    ros::Time base_last_cmd;
+    ros::Duration base_watchdog_timeout;
+
+    // Current simulation time
+    ros::Time sim_time;
+    
+    // Last time we saved global position (for velocity calculation).
+    ros::Time base_last_globalpos_time;
+    // Last published global pose of each robot
+    std::vector<Stg::Pose> base_last_globalpos;
+
+public:
+    // Constructor; stage itself needs argc/argv.  fname is the .world file
+    // that stage should load.
+    StageNode(int argc, char** argv, bool gui, const char* fname, bool use_model_names);
+    ~StageNode();
+
+    // Subscribe to models of interest.  Currently, we find and subscribe
+    // to the first 'laser' model and the first 'position' model.  Returns
+    // 0 on success (both models subscribed), -1 otherwise.
+    int SubscribeModels();
+
+    // Our callback
+    void WorldCallback();
+    
+    // Do one update of the world.  May pause if the next update time
+    // has not yet arrived.
+    bool UpdateWorld();
+
+    // Message callback for a MsgBaseVel message, which set velocities.
+    void cmdvelReceived(int idx, const boost::shared_ptr<geometry_msgs::Twist const>& msg);
+
+    // Service callback for soft reset
+    bool cb_reset_srv(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);
+
+    // The main simulator object
+    Stg::World* world;
+};
+
+// since stageros is single-threaded, this is OK. revisit if that changes!
+const char *
+StageNode::mapName(const char *name, size_t robotID, Stg::Model* mod) const
+{
+    //ROS_INFO("Robot %lu: Device %s", robotID, name);
+    bool umn = this->use_model_names;
+
+    if ((positionmodels.size() > 1 ) || umn)
+    {
+        static char buf[100];
+        std::size_t found = std::string(((Stg::Ancestor *) mod)->Token()).find(":");
+
+        if ((found==std::string::npos) && umn)
+        {
+            snprintf(buf, sizeof(buf), "/%s/%s", ((Stg::Ancestor *) mod)->Token(), name);
+        }
+        else
+        {
+            snprintf(buf, sizeof(buf), "/robot_%u/%s", (unsigned int)robotID, name);
+        }
+
+        return buf;
+    }
+    else
+        return name;
+}
+
+const char *
+StageNode::mapName(const char *name, size_t robotID, size_t deviceID, Stg::Model* mod) const
+{
+    //ROS_INFO("Robot %lu: Device %s:%lu", robotID, name, deviceID);
+    bool umn = this->use_model_names;
+
+    if ((positionmodels.size() > 1 ) || umn)
+    {
+        static char buf[100];
+        std::size_t found = std::string(((Stg::Ancestor *) mod)->Token()).find(":");
+
+        if ((found==std::string::npos) && umn)
+        {
+            snprintf(buf, sizeof(buf), "/%s/%s_%u", ((Stg::Ancestor *) mod)->Token(), name, (unsigned int)deviceID);
+        }
+        else
+        {
+            snprintf(buf, sizeof(buf), "/robot_%u/%s_%u", (unsigned int)robotID, name, (unsigned int)deviceID);
+        }
+
+        return buf;
+    }
+    else
+    {
+        static char buf[100];
+        snprintf(buf, sizeof(buf), "/%s_%u", name, (unsigned int)deviceID);
+        return buf;
+    }
+}
+
+void
+StageNode::ghfunc(Stg::Model* mod, StageNode* node)
+{
+  //printf( "inspecting %s, parent\n", mod->Token() );
+
+  if (dynamic_cast<Stg::ModelRanger *>(mod)) {
+     node->lasermodels.push_back(dynamic_cast<Stg::ModelRanger *>(mod));
+  }
+  if (dynamic_cast<Stg::ModelPosition *>(mod)) {
+     Stg::ModelPosition * p = dynamic_cast<Stg::ModelPosition *>(mod);
+      // remember initial poses
+      node->positionmodels.push_back(p);
+      node->initial_poses.push_back(p->GetGlobalPose());
+    }
+  if (dynamic_cast<Stg::ModelCamera *>(mod)) {
+     node->cameramodels.push_back(dynamic_cast<Stg::ModelCamera *>(mod));
+  }
+}
+
+
+
+
+bool
+StageNode::cb_reset_srv(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response)
+{
+  ROS_INFO("Resetting stage!");
+  for (size_t r = 0; r < this->positionmodels.size(); r++) {
+    this->positionmodels[r]->SetPose(this->initial_poses[r]);
+    this->positionmodels[r]->SetStall(false);
+  }
+  return true;
+}
+
+
+
+void
+StageNode::cmdvelReceived(int idx, const boost::shared_ptr<geometry_msgs::Twist const>& msg)
+{
+    boost::mutex::scoped_lock lock(msg_lock);
+    this->positionmodels[idx]->SetSpeed(msg->linear.x,
+                                        msg->linear.y,
+                                        msg->angular.z);
+    this->base_last_cmd = this->sim_time;
+}
+
+StageNode::StageNode(int argc, char** argv, bool gui, const char* fname, bool use_model_names)
+{
+    this->use_model_names = use_model_names;
+    this->sim_time.fromSec(0.0);
+    this->base_last_cmd.fromSec(0.0);
+    double t;
+    ros::NodeHandle localn("~");
+    if(!localn.getParam("base_watchdog_timeout", t))
+        t = 0.2;
+    this->base_watchdog_timeout.fromSec(t);
+
+    if(!localn.getParam("is_depth_canonical", isDepthCanonical))
+        isDepthCanonical = true;
+
+    // We'll check the existence of the world file, because libstage doesn't
+    // expose its failure to open it.  Could go further with checks (e.g., is
+    // it readable by this user).
+    struct stat s;
+    if(stat(fname, &s) != 0)
+    {
+        ROS_FATAL("The world file %s does not exist.", fname);
+        ROS_BREAK();
+    }
+
+    // initialize libstage
+    Stg::Init( &argc, &argv );
+
+    if(gui)
+        this->world = new Stg::WorldGui(600, 400, "Stage (ROS)");
+    else
+        this->world = new Stg::World();
+
+    this->world->Load(fname);
+
+    // todo: reverse the order of these next lines? try it .
+
+    this->world->AddUpdateCallback((Stg::world_callback_t)s_update, this);
+
+    // inspect every model to locate the things we care about
+    this->world->ForEachDescendant((Stg::model_callback_t)ghfunc, this);
+}
+
+
+// Subscribe to models of interest.  Currently, we find and subscribe
+// to the first 'laser' model and the first 'position' model.  Returns
+// 0 on success (both models subscribed), -1 otherwise.
+//
+// Eventually, we should provide a general way to map stage models onto ROS
+// topics, similar to Player .cfg files.
+int
+StageNode::SubscribeModels()
+{
+    n_.setParam("/use_sim_time", true);
+
+    for (size_t r = 0; r < this->positionmodels.size(); r++)
+    {
+        StageRobot* new_robot = new StageRobot;
+        new_robot->positionmodel = this->positionmodels[r];
+        new_robot->positionmodel->Subscribe();
+
+	ROS_INFO( "Subscribed to Stage position model \"%s\"", this->positionmodels[r]->Token() ); 
+		      
+        for (size_t s = 0; s < this->lasermodels.size(); s++)
+        {
+	  if (this->lasermodels[s] and this->lasermodels[s]->Parent() == new_robot->positionmodel)
+            {
+                new_robot->lasermodels.push_back(this->lasermodels[s]);
+                this->lasermodels[s]->Subscribe();
+	      ROS_INFO( "subscribed to Stage ranger \"%s\"", this->lasermodels[s]->Token() ); 
+            }
+        }
+
+        for (size_t s = 0; s < this->cameramodels.size(); s++)
+        {
+            if (this->cameramodels[s] and this->cameramodels[s]->Parent() == new_robot->positionmodel)
+            {
+                new_robot->cameramodels.push_back(this->cameramodels[s]);
+                this->cameramodels[s]->Subscribe();
+
+		ROS_INFO( "subscribed to Stage camera model \"%s\"", this->cameramodels[s]->Token() ); 
+            }
+        }
+
+	// TODO - print the topic names nicely as well
+        ROS_INFO("Robot %s provided %lu rangers and %lu cameras",
+		 new_robot->positionmodel->Token(),
+		 new_robot->lasermodels.size(),
+		 new_robot->cameramodels.size() );
+
+        new_robot->odom_pub = n_.advertise<nav_msgs::Odometry>(mapName(ODOM, r, static_cast<Stg::Model*>(new_robot->positionmodel)), 10);
+        new_robot->ground_truth_pub = n_.advertise<nav_msgs::Odometry>(mapName(BASE_POSE_GROUND_TRUTH, r, static_cast<Stg::Model*>(new_robot->positionmodel)), 10);
+        new_robot->cmdvel_sub = n_.subscribe<geometry_msgs::Twist>(mapName(CMD_VEL, r, static_cast<Stg::Model*>(new_robot->positionmodel)), 10, boost::bind(&StageNode::cmdvelReceived, this, r, _1));
+
+        for (size_t s = 0;  s < new_robot->lasermodels.size(); ++s)
+        {
+            if (new_robot->lasermodels.size() == 1)
+                new_robot->laser_pubs.push_back(n_.advertise<sensor_msgs::LaserScan>(mapName(BASE_SCAN, r, static_cast<Stg::Model*>(new_robot->positionmodel)), 10));
+            else
+                new_robot->laser_pubs.push_back(n_.advertise<sensor_msgs::LaserScan>(mapName(BASE_SCAN, r, s, static_cast<Stg::Model*>(new_robot->positionmodel)), 10));
+
+        }
+
+        for (size_t s = 0;  s < new_robot->cameramodels.size(); ++s)
+        {
+            if (new_robot->cameramodels.size() == 1)
+            {
+                new_robot->image_pubs.push_back(n_.advertise<sensor_msgs::Image>(mapName(IMAGE, r, static_cast<Stg::Model*>(new_robot->positionmodel)), 10));
+                new_robot->depth_pubs.push_back(n_.advertise<sensor_msgs::Image>(mapName(DEPTH, r, static_cast<Stg::Model*>(new_robot->positionmodel)), 10));
+                new_robot->camera_pubs.push_back(n_.advertise<sensor_msgs::CameraInfo>(mapName(CAMERA_INFO, r, static_cast<Stg::Model*>(new_robot->positionmodel)), 10));
+            }
+            else
+            {
+                new_robot->image_pubs.push_back(n_.advertise<sensor_msgs::Image>(mapName(IMAGE, r, s, static_cast<Stg::Model*>(new_robot->positionmodel)), 10));
+                new_robot->depth_pubs.push_back(n_.advertise<sensor_msgs::Image>(mapName(DEPTH, r, s, static_cast<Stg::Model*>(new_robot->positionmodel)), 10));
+                new_robot->camera_pubs.push_back(n_.advertise<sensor_msgs::CameraInfo>(mapName(CAMERA_INFO, r, s, static_cast<Stg::Model*>(new_robot->positionmodel)), 10));
+            }
+        }
+
+        this->robotmodels_.push_back(new_robot);
+    }
+    clock_pub_ = n_.advertise<rosgraph_msgs::Clock>("/clock", 10);
+
+    // advertising reset service
+    reset_srv_ = n_.advertiseService("reset_positions", &StageNode::cb_reset_srv, this);
+
+    return(0);
+}
+
+StageNode::~StageNode()
+{    
+    for (std::vector<StageRobot const*>::iterator r = this->robotmodels_.begin(); r != this->robotmodels_.end(); ++r)
+        delete *r;
+}
+
+bool
+StageNode::UpdateWorld()
+{
+    return this->world->UpdateAll();
+}
+
+void
+StageNode::WorldCallback()
+{
+  if( ! ros::ok() ) {
+    ROS_INFO( "ros::ok() is false. Quitting." );
+    this->world->QuitAll();
+    return;
+  }
+  
+    boost::mutex::scoped_lock lock(msg_lock);
+
+    this->sim_time.fromSec(world->SimTimeNow() / 1e6);
+    // We're not allowed to publish clock==0, because it used as a special
+    // value in parts of ROS, #4027.
+    if(this->sim_time.sec == 0 && this->sim_time.nsec == 0)
+    {
+        ROS_DEBUG("Skipping initial simulation step, to avoid publishing clock==0");
+        return;
+    }
+
+    // TODO make this only affect one robot if necessary
+    if((this->base_watchdog_timeout.toSec() > 0.0) &&
+            ((this->sim_time - this->base_last_cmd) >= this->base_watchdog_timeout))
+    {
+        for (size_t r = 0; r < this->positionmodels.size(); r++)
+            this->positionmodels[r]->SetSpeed(0.0, 0.0, 0.0);
+    }
+
+    //loop on the robot models
+    for (size_t r = 0; r < this->robotmodels_.size(); ++r)
+    {
+        StageRobot const * robotmodel = this->robotmodels_[r];
+
+        //loop on the laser devices for the current robot
+        for (size_t s = 0; s < robotmodel->lasermodels.size(); ++s)
+        {
+            Stg::ModelRanger const* lasermodel = robotmodel->lasermodels[s];
+            const std::vector<Stg::ModelRanger::Sensor>& sensors = lasermodel->GetSensors();
+
+            if( sensors.size() > 1 )
+                ROS_WARN( "ROS Stage currently supports rangers with 1 sensor only." );
+
+            // for now we access only the zeroth sensor of the ranger - good
+            // enough for most laser models that have a single beam origin
+            const Stg::ModelRanger::Sensor& sensor = sensors[0];
+
+            if( sensor.ranges.size() )
+            {
+                // Translate into ROS message format and publish
+                sensor_msgs::LaserScan msg;
+                msg.angle_min = -sensor.fov/2.0;
+                msg.angle_max = +sensor.fov/2.0;
+                msg.angle_increment = sensor.fov/(double)(sensor.sample_count-1);
+                msg.range_min = sensor.range.min;
+                msg.range_max = sensor.range.max;
+                msg.ranges.resize(sensor.ranges.size());
+                msg.intensities.resize(sensor.intensities.size());
+
+                for(unsigned int i = 0; i < sensor.ranges.size(); i++)
+                {
+                    msg.ranges[i] = sensor.ranges[i];
+                    msg.intensities[i] = sensor.intensities[i];
+                }
+
+                if (robotmodel->lasermodels.size() > 1)
+                    msg.header.frame_id = mapName("base_laser_link", r, s, static_cast<Stg::Model*>(robotmodel->positionmodel));
+                else
+                    msg.header.frame_id = mapName("base_laser_link", r, static_cast<Stg::Model*>(robotmodel->positionmodel));
+
+                msg.header.stamp = sim_time;
+                robotmodel->laser_pubs[s].publish(msg);
+            }
+
+            // Also publish the base->base_laser_link Tx.  This could eventually move
+            // into being retrieved from the param server as a static Tx.
+            Stg::Pose lp = lasermodel->GetPose();
+            tf::Quaternion laserQ;
+            laserQ.setRPY(0.0, 0.0, lp.a);
+            tf::Transform txLaser =  tf::Transform(laserQ, tf::Point(lp.x, lp.y, robotmodel->positionmodel->GetGeom().size.z + lp.z));
+
+            if (robotmodel->lasermodels.size() > 1)
+                tf.sendTransform(tf::StampedTransform(txLaser, sim_time,
+                                                      mapName("base_link", r, static_cast<Stg::Model*>(robotmodel->positionmodel)),
+                                                      mapName("base_laser_link", r, s, static_cast<Stg::Model*>(robotmodel->positionmodel))));
+            else
+                tf.sendTransform(tf::StampedTransform(txLaser, sim_time,
+                                                      mapName("base_link", r, static_cast<Stg::Model*>(robotmodel->positionmodel)),
+                                                      mapName("base_laser_link", r, static_cast<Stg::Model*>(robotmodel->positionmodel))));
+        }
+
+        //the position of the robot
+        tf.sendTransform(tf::StampedTransform(tf::Transform::getIdentity(),
+                                              sim_time,
+                                              mapName("base_footprint", r, static_cast<Stg::Model*>(robotmodel->positionmodel)),
+                                              mapName("base_link", r, static_cast<Stg::Model*>(robotmodel->positionmodel))));
+
+        // Get latest odometry data
+        // Translate into ROS message format and publish
+        nav_msgs::Odometry odom_msg;
+        odom_msg.pose.pose.position.x = robotmodel->positionmodel->est_pose.x;
+        odom_msg.pose.pose.position.y = robotmodel->positionmodel->est_pose.y;
+        odom_msg.pose.pose.orientation = tf::createQuaternionMsgFromYaw(robotmodel->positionmodel->est_pose.a);
+        Stg::Velocity v = robotmodel->positionmodel->GetVelocity();
+        odom_msg.twist.twist.linear.x = v.x;
+        odom_msg.twist.twist.linear.y = v.y;
+        odom_msg.twist.twist.angular.z = v.a;
+
+        //@todo Publish stall on a separate topic when one becomes available
+        //this->odomMsgs[r].stall = this->positionmodels[r]->Stall();
+        //
+        odom_msg.header.frame_id = mapName("odom", r, static_cast<Stg::Model*>(robotmodel->positionmodel));
+        odom_msg.header.stamp = sim_time;
+
+        robotmodel->odom_pub.publish(odom_msg);
+
+        // broadcast odometry transform
+        tf::Quaternion odomQ;
+        tf::quaternionMsgToTF(odom_msg.pose.pose.orientation, odomQ);
+        tf::Transform txOdom(odomQ, tf::Point(odom_msg.pose.pose.position.x, odom_msg.pose.pose.position.y, 0.0));
+        tf.sendTransform(tf::StampedTransform(txOdom, sim_time,
+                                              mapName("odom", r, static_cast<Stg::Model*>(robotmodel->positionmodel)),
+                                              mapName("base_footprint", r, static_cast<Stg::Model*>(robotmodel->positionmodel))));
+
+        // Also publish the ground truth pose and velocity
+        Stg::Pose gpose = robotmodel->positionmodel->GetGlobalPose();
+        tf::Quaternion q_gpose;
+        q_gpose.setRPY(0.0, 0.0, gpose.a);
+        tf::Transform gt(q_gpose, tf::Point(gpose.x, gpose.y, 0.0));
+        // Velocity is 0 by default and will be set only if there is previous pose and time delta>0
+        Stg::Velocity gvel(0,0,0,0);
+        if (this->base_last_globalpos.size()>r){
+            Stg::Pose prevpose = this->base_last_globalpos.at(r);
+            double dT = (this->sim_time-this->base_last_globalpos_time).toSec();
+            if (dT>0)
+                gvel = Stg::Velocity(
+                            (gpose.x - prevpose.x)/dT,
+                            (gpose.y - prevpose.y)/dT,
+                            (gpose.z - prevpose.z)/dT,
+                            Stg::normalize(gpose.a - prevpose.a)/dT
+                            );
+            this->base_last_globalpos.at(r) = gpose;
+        }else //There are no previous readings, adding current pose...
+            this->base_last_globalpos.push_back(gpose);
+
+        nav_msgs::Odometry ground_truth_msg;
+        ground_truth_msg.pose.pose.position.x     = gt.getOrigin().x();
+        ground_truth_msg.pose.pose.position.y     = gt.getOrigin().y();
+        ground_truth_msg.pose.pose.position.z     = gt.getOrigin().z();
+        ground_truth_msg.pose.pose.orientation.x  = gt.getRotation().x();
+        ground_truth_msg.pose.pose.orientation.y  = gt.getRotation().y();
+        ground_truth_msg.pose.pose.orientation.z  = gt.getRotation().z();
+        ground_truth_msg.pose.pose.orientation.w  = gt.getRotation().w();
+        ground_truth_msg.twist.twist.linear.x = gvel.x;
+        ground_truth_msg.twist.twist.linear.y = gvel.y;
+        ground_truth_msg.twist.twist.linear.z = gvel.z;
+        ground_truth_msg.twist.twist.angular.z = gvel.a;
+
+        ground_truth_msg.header.frame_id = mapName("odom", r, static_cast<Stg::Model*>(robotmodel->positionmodel));
+        ground_truth_msg.header.stamp = sim_time;
+
+        robotmodel->ground_truth_pub.publish(ground_truth_msg);
+
+        //cameras
+        for (size_t s = 0; s < robotmodel->cameramodels.size(); ++s)
+        {
+            Stg::ModelCamera* cameramodel = robotmodel->cameramodels[s];
+            // Get latest image data
+            // Translate into ROS message format and publish
+            if (robotmodel->image_pubs[s].getNumSubscribers() > 0 && cameramodel->FrameColor())
+            {
+                sensor_msgs::Image image_msg;
+
+                image_msg.height = cameramodel->getHeight();
+                image_msg.width = cameramodel->getWidth();
+                image_msg.encoding = "rgba8";
+                //this->imageMsgs[r].is_bigendian="";
+                image_msg.step = image_msg.width*4;
+                image_msg.data.resize(image_msg.width * image_msg.height * 4);
+
+                memcpy(&(image_msg.data[0]), cameramodel->FrameColor(), image_msg.width * image_msg.height * 4);
+
+                //invert the opengl weirdness
+                int height = image_msg.height - 1;
+                int linewidth = image_msg.width*4;
+
+                char* temp = new char[linewidth];
+                for (int y = 0; y < (height+1)/2; y++)
+                {
+                    memcpy(temp,&image_msg.data[y*linewidth],linewidth);
+                    memcpy(&(image_msg.data[y*linewidth]),&(image_msg.data[(height-y)*linewidth]),linewidth);
+                    memcpy(&(image_msg.data[(height-y)*linewidth]),temp,linewidth);
+                }
+
+                if (robotmodel->cameramodels.size() > 1)
+                    image_msg.header.frame_id = mapName("camera", r, s, static_cast<Stg::Model*>(robotmodel->positionmodel));
+                else
+                    image_msg.header.frame_id = mapName("camera", r,static_cast<Stg::Model*>(robotmodel->positionmodel));
+                image_msg.header.stamp = sim_time;
+
+                robotmodel->image_pubs[s].publish(image_msg);
+            }
+
+            //Get latest depth data
+            //Translate into ROS message format and publish
+            //Skip if there are no subscribers
+            if (robotmodel->depth_pubs[s].getNumSubscribers()>0 && cameramodel->FrameDepth())
+            {
+                sensor_msgs::Image depth_msg;
+                depth_msg.height = cameramodel->getHeight();
+                depth_msg.width = cameramodel->getWidth();
+                depth_msg.encoding = this->isDepthCanonical?sensor_msgs::image_encodings::TYPE_32FC1:sensor_msgs::image_encodings::TYPE_16UC1;
+                //this->depthMsgs[r].is_bigendian="";
+                int sz = this->isDepthCanonical?sizeof(float):sizeof(uint16_t);
+                size_t len = depth_msg.width * depth_msg.height;
+                depth_msg.step = depth_msg.width * sz;
+                depth_msg.data.resize(len*sz);
+
+                //processing data according to REP118
+                if (this->isDepthCanonical){
+                    double nearClip = cameramodel->getCamera().nearClip();
+                    double farClip = cameramodel->getCamera().farClip();
+                    memcpy(&(depth_msg.data[0]),cameramodel->FrameDepth(),len*sz);
+                    float * data = (float*)&(depth_msg.data[0]);
+                    for (size_t i=0;i<len;++i)
+                        if(data[i]<=nearClip)
+                            data[i] = -INFINITY;
+                        else if(data[i]>=farClip)
+                            data[i] = INFINITY;
+                }
+                else{
+                    int nearClip = (int)(cameramodel->getCamera().nearClip() * 1000);
+                    int farClip = (int)(cameramodel->getCamera().farClip() * 1000);
+                    for (size_t i=0;i<len;++i){
+                        int v = (int)(cameramodel->FrameDepth()[i]*1000);
+                        if (v<=nearClip || v>=farClip) v = 0;
+                        ((uint16_t*)&(depth_msg.data[0]))[i] = (uint16_t) ((v<=nearClip || v>=farClip) ? 0 : v );
+                    }
+                }
+
+                //invert the opengl weirdness
+                int height = depth_msg.height - 1;
+                int linewidth = depth_msg.width*sz;
+
+                char* temp = new char[linewidth];
+                for (int y = 0; y < (height+1)/2; y++)
+                {
+                    memcpy(temp,&depth_msg.data[y*linewidth],linewidth);
+                    memcpy(&(depth_msg.data[y*linewidth]),&(depth_msg.data[(height-y)*linewidth]),linewidth);
+                    memcpy(&(depth_msg.data[(height-y)*linewidth]),temp,linewidth);
+                }
+
+                if (robotmodel->cameramodels.size() > 1)
+                    depth_msg.header.frame_id = mapName("camera", r, s, static_cast<Stg::Model*>(robotmodel->positionmodel));
+                else
+                    depth_msg.header.frame_id = mapName("camera", r, static_cast<Stg::Model*>(robotmodel->positionmodel));
+                depth_msg.header.stamp = sim_time;
+                robotmodel->depth_pubs[s].publish(depth_msg);
+            }
+
+            //sending camera's tf and info only if image or depth topics are subscribed to
+            if ((robotmodel->image_pubs[s].getNumSubscribers()>0 && cameramodel->FrameColor())
+                    || (robotmodel->depth_pubs[s].getNumSubscribers()>0 && cameramodel->FrameDepth()))
+            {
+
+                Stg::Pose lp = cameramodel->GetPose();
+                tf::Quaternion Q; Q.setRPY(
+                            (cameramodel->getCamera().pitch()*M_PI/180.0)-M_PI,
+                            0.0,
+                            lp.a+(cameramodel->getCamera().yaw()*M_PI/180.0) - robotmodel->positionmodel->GetPose().a
+                            );
+
+                tf::Transform tr =  tf::Transform(Q, tf::Point(lp.x, lp.y, robotmodel->positionmodel->GetGeom().size.z+lp.z));
+
+                if (robotmodel->cameramodels.size() > 1)
+                    tf.sendTransform(tf::StampedTransform(tr, sim_time,
+                                                          mapName("base_link", r, static_cast<Stg::Model*>(robotmodel->positionmodel)),
+                                                          mapName("camera", r, s, static_cast<Stg::Model*>(robotmodel->positionmodel))));
+                else
+                    tf.sendTransform(tf::StampedTransform(tr, sim_time,
+                                                          mapName("base_link", r, static_cast<Stg::Model*>(robotmodel->positionmodel)),
+                                                          mapName("camera", r, static_cast<Stg::Model*>(robotmodel->positionmodel))));
+
+                sensor_msgs::CameraInfo camera_msg;
+                if (robotmodel->cameramodels.size() > 1)
+                    camera_msg.header.frame_id = mapName("camera", r, s, static_cast<Stg::Model*>(robotmodel->positionmodel));
+                else
+                    camera_msg.header.frame_id = mapName("camera", r, static_cast<Stg::Model*>(robotmodel->positionmodel));
+                camera_msg.header.stamp = sim_time;
+                camera_msg.height = cameramodel->getHeight();
+                camera_msg.width = cameramodel->getWidth();
+
+                double fx,fy,cx,cy;
+                cx = camera_msg.width / 2.0;
+                cy = camera_msg.height / 2.0;
+                double fovh = cameramodel->getCamera().horizFov()*M_PI/180.0;
+                double fovv = cameramodel->getCamera().vertFov()*M_PI/180.0;
+                //double fx_ = 1.43266615300557*this->cameramodels[r]->getWidth()/tan(fovh);
+                //double fy_ = 1.43266615300557*this->cameramodels[r]->getHeight()/tan(fovv);
+                fx = cameramodel->getWidth()/(2*tan(fovh/2));
+                fy = cameramodel->getHeight()/(2*tan(fovv/2));
+
+                //ROS_INFO("fx=%.4f,%.4f; fy=%.4f,%.4f", fx, fx_, fy, fy_);
+
+
+                camera_msg.D.resize(4, 0.0);
+
+                camera_msg.K[0] = fx;
+                camera_msg.K[2] = cx;
+                camera_msg.K[4] = fy;
+                camera_msg.K[5] = cy;
+                camera_msg.K[8] = 1.0;
+
+                camera_msg.R[0] = 1.0;
+                camera_msg.R[4] = 1.0;
+                camera_msg.R[8] = 1.0;
+
+                camera_msg.P[0] = fx;
+                camera_msg.P[2] = cx;
+                camera_msg.P[5] = fy;
+                camera_msg.P[6] = cy;
+                camera_msg.P[10] = 1.0;
+
+                robotmodel->camera_pubs[s].publish(camera_msg);
+
+            }
+
+        }
+    }
+
+    this->base_last_globalpos_time = this->sim_time;
+    rosgraph_msgs::Clock clock_msg;
+    clock_msg.clock = sim_time;
+    this->clock_pub_.publish(clock_msg);
+}
+
+int 
+main(int argc, char** argv)
+{
+    if( argc < 2 )
+    {
+        puts(USAGE);
+        exit(-1);
+    }
+
+    ros::init(argc, argv, "stageros");
+
+    bool gui = true;
+    bool use_model_names = false;
+    for(int i=0;i<(argc-1);i++)
+    {
+        if(!strcmp(argv[i], "-g"))
+            gui = false;
+        if(!strcmp(argv[i], "-u"))
+            use_model_names = true;
+    }
+
+    StageNode sn(argc-1,argv,gui,argv[argc-1], use_model_names);
+
+    if(sn.SubscribeModels() != 0)
+        exit(-1);
+
+    boost::thread t = boost::thread(boost::bind(&ros::spin));
+
+    sn.world->Start();
+
+    Stg::World::Run();
+    
+    t.join();
+
+    exit(0);
+}
+
--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/test/hztest.xml
@@ -0,0 +1,44 @@
+<launch>
+  <param name="/use_sim_time" value="true"/>
+  <!-- Bring up the node we want to test. -->
+  <node pkg="stage_ros" name="stageros" type="stageros" args="-g $(find stage_ros)/world/willow-erratic.world"/>
+
+  <!-- Test for publication of 'scan' topic -->
+  <!-- Run hztest -->
+  <test test-name="hztest_test_scan" pkg="rostest" type="hztest" name="scan_test">
+    <!-- The topic to listen for -->
+    <param name="topic" value="base_scan" />  
+    <!-- 
+      The expected publication rate [Hz].  Set to 0.0 to only check that
+      at least one message is received. -->
+    <param name="hz" value="10.0" />
+    <!--
+      Acceptable error in the publication rate [Hz].  Ignored if hz is set
+      to 0.0. -->
+    <param name="hzerror" value="2.0" />
+    <!-- Time to listen for [seconds] -->
+    <param name="test_duration" value="2.0" />
+    
+    <!-- 
+      Whether each inter-message time interval should be checked
+      against the expected publication rate and error bound [boolean].
+      If true, then the test will fail if the time elapsed between
+      *any* two consecutive messages exceeded the specified limits.
+      If false, then we only check the average publication rate over
+      the entire test.  Default: false. -->
+    <param name="check_intervals" value="false" />    
+  </test>
+
+  <!-- Test for publication of 'odom' topic. -->
+  
+  <!-- Note how we use a different node name for this test (odom_test
+       vs. scan_test). -->
+  <test test-name="hztest_test_odom" pkg="rostest" type="hztest" name="odom_test">
+    <param name="topic" value="odom" />  
+    <param name="hz" value="10.0" />
+    <param name="hzerror" value="2.0" />
+    <param name="test_duration" value="2.0" />    
+    <param name="check_intervals" value="false" />    
+  </test>
+  
+</launch>
--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/test/intensity_test.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python
+
+import unittest
+import rospy
+import time
+import Queue as queue
+from sensor_msgs.msg import LaserScan
+
+PKG = "stage_ros"
+
+
+class RangerIntensityTests(unittest.TestCase):
+    def setUp(self):
+        """Called before every test. Set up a LaserScan subscriber
+        """
+        rospy.init_node('ranger_intensity_test', anonymous=True)
+        self._scan_q = queue.Queue()
+        self._scan_topic = rospy.get_param("scan_topic", "base_scan")
+        self._subscriber = rospy.Subscriber(self._scan_topic,
+                                            LaserScan, self._scan_callback)
+
+    def tearDown(self):
+        """Called after every test. Cancel the scan subscription
+        """
+        self._subscriber.unregister()
+        self._scan_q = None
+        self._subscriber = None
+
+    def _scan_callback(self, scan_msg):
+        """Called every time a scan is received
+        """
+        self._scan_q.put(scan_msg)
+
+    def _wait_for_scan(self, timeout=1.0):
+        """Wait for a laser scan to be received
+        """
+        # Use wall clock time for timeout
+        end_time = time.time() + timeout
+        while time.time() < end_time:
+            try:
+                return self._scan_q.get(True, 0.1)
+            except queue.Empty:
+                pass
+        return None
+
+    def test_intensity_greater_than_256(self):
+        """Make sure stage_ros returns intensity values higher than 256
+        """
+        scan = self._wait_for_scan()
+        self.assertIsNotNone(scan)
+        self.assertGreater(max(scan.intensities), 256.9)
+
+
+if __name__ == '__main__':
+    import rosunit
+    rosunit.unitrun(PKG, 'test_intensity', RangerIntensityTests)
--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/test/intensity_test.xml
@@ -0,0 +1,8 @@
+<launch>
+    <param name="/use_sim_time" value="true"/>
+    <node pkg="stage_ros" name="stageros" type="stageros" args="-g $(find stage_ros)/world/intense.world"/>
+
+    <test test-name="intensity_check" pkg="stage_ros" type="intensity_test.py" name="scan_intensity_test">
+        <param name="scan_topic" value="base_scan" />
+    </test>
+</launch>
--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/world/erratic-inc.world
@@ -0,0 +1,26 @@
+# A simple robot for inclusion in other world files
+
+define topurg ranger
+(
+    sensor
+    (
+        range [ 0.0  30.0 ]
+        fov 270.25
+        samples 1081
+    )
+    # generic model properties
+    color "black"
+    size [ 0.05 0.05 0.1 ]
+)
+
+define erratic position
+(
+    size [ 0.35 0.35 0.25 ]
+    origin [ -0.05 0 0 0 ]
+    gui_nose 1
+    drive "diff"
+    topurg
+    (
+        pose [ 0 0 0 0 ]
+    )
+)
--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/world/intense.world
@@ -0,0 +1,63 @@
+# A world containing objects with varying ranger insensity values
+
+include "erratic-inc.world"
+
+resolution 0.02
+interval_sim 100
+
+define block model
+(
+    size [0.5 0.5 0.5]
+    gui_nose 0
+)
+
+erratic
+(
+    pose [ 0 0 0 0 ]
+    name "era"
+    color "blue"
+)
+
+# Insert blocks with different intensity values
+block
+(
+    pose [ 1.0 -3 0 0 ]
+    ranger_return 0
+    color "gray0"
+)
+block
+(
+    pose [ 1.0 -2 0 0 ]
+    ranger_return 50
+    color "gray5"
+)
+block
+(
+    pose [ 1.0 -1 0 0 ]
+    ranger_return 100
+    color "gray10"
+)
+block
+(
+    pose [ 1.0 0 0 0 ]
+    ranger_return 250
+    color "gray25"
+)
+block
+(
+    pose [ 1.0 1 0 0 ]
+    ranger_return 4000
+    color "gray40"
+)
+block
+(
+    pose [ 1.0 2 0 0 ]
+    ranger_return 80000
+    color "gray80"
+)
+block
+(
+    pose [ 1.0 3 0 0 ]
+    ranger_return 1000000
+    color "gray100"
+)
--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/world/willow-erratic.world
@@ -0,0 +1,83 @@
+window
+(
+  size [ 635 666 ] # in pixels
+  scale 22.971   # pixels per meter
+  center [ -20.306  21.679 ]
+  rotate [ 0.000  0.000 ]
+  			
+  show_data 1              # 1=on 0=off
+)
+
+
+define block model
+(
+  size [0.500 0.500 0.500]
+  gui_nose 0
+)
+
+define topurg ranger
+(
+	sensor( 			
+    range [ 0.0  30.0 ]
+    fov 270.25
+   samples 1081
+  )
+
+  # generic model properties
+  color "black"
+  size [ 0.050 0.050 0.100 ]
+)
+
+define erratic position
+(
+  #size [0.415 0.392 0.25]
+  size [0.350 0.350 0.250]
+  origin [-0.050 0.000 0.000 0.000]
+  gui_nose 1
+  drive "diff"
+  topurg(pose [ 0.050 0.000 0.000 0.000 ])
+)
+
+define floorplan model
+(
+  # sombre, sensible, artistic
+  color "gray30"
+
+  # most maps will need a bounding box
+  boundary 1
+
+  gui_nose 0
+  gui_grid 0
+
+  gui_outline 0
+  gripper_return 0
+  fiducial_return 0
+  ranger_return 1.000
+)
+
+# set the resolution of the underlying raytrace model in meters
+resolution 0.02
+
+interval_sim 100  # simulation timestep in milliseconds
+
+
+window
+( 
+  size [ 745 448 ] 
+
+  rotate [ 0.000 -1.560 ]
+  scale 28.806 
+)
+
+# load an environment bitmap
+floorplan
+( 
+  name "willow"
+  bitmap "willow-full.pgm"
+  size [54.000 58.700 0.500]
+  pose [ -29.350 27.000 0.000 90.000 ]
+)
+
+# throw in a robot
+erratic( pose [ -11.277 23.266 0.000 180.000 ] name "era" color "blue")
+block( pose [ -13.924 25.020 0.000 180.000 ] color "red")
--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/world/willow-four-erratics-multisensor.world
@@ -0,0 +1,87 @@
+define block model
+(
+  size [0.5 0.5 0.5]
+  gui_nose 0
+)
+
+define topurg ranger
+(
+	sensor( 			
+    range [ 0.0  30.0 ]
+    fov 270.25
+   samples 1081
+  )
+
+  # generic model properties
+  color "black"
+  size [ 0.05 0.05 0.1 ]
+)
+
+define mycamera camera
+(
+	range [ 0.2 8.0 ]
+	resolution [ 100 100 ]
+	fov [ 70 40 ]
+	pantilt [ 0 0 ]
+	alwayson 1
+)
+
+define erratic position
+(
+  #size [0.415 0.392 0.25]
+  size [0.35 0.35 0.25]
+  origin [-0.05 0 0 0]
+  gui_nose 1
+  drive "diff"
+  topurg(pose [ 0.050 0.000 0 0.000 ])
+  topurg(pose [ -0.050 0.000 0 180.000 ])
+  mycamera(pose [ 0 0 0 90.0 ])
+  mycamera(pose [ 0 0 0 -90.0 ])
+)
+
+define floorplan model
+(
+  # sombre, sensible, artistic
+  color "gray30"
+
+  # most maps will need a bounding box
+  boundary 1
+
+  gui_nose 0
+  gui_grid 0
+
+  gui_outline 0
+  gripper_return 0
+  fiducial_return 0
+  laser_return 1
+)
+
+# set the resolution of the underlying raytrace model in meters
+resolution 0.02
+
+interval_sim 100  # simulation timestep in milliseconds
+
+
+window
+( 
+  size [ 745.000 448.000 ] 
+
+  rotate [ 0.000 -1.560 ]
+  scale 28.806 
+)
+
+# load an environment bitmap
+floorplan
+( 
+  name "willow"
+  bitmap "willow-full.pgm"
+  size [54.0 58.7 0.5]
+  pose [ -29.350 27.000 0 90.000 ]
+)
+
+# throw in two robots
+erratic( pose [ -11.277 23.266 0 180.000 ] name "era" color "blue")
+erratic( pose [ -13.277 22.266 0 180.000 ] name "era2" color "blue")
+erratic( pose [ -13.277 23.266 0 180.000 ] name "era3" color "blue")
+erratic( pose [ -11.277 22.266 0 180.000 ] name "era4" color "blue")
+block( pose [ -13.924 25.020 0 180.000 ] color "red")
--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/world/willow-four-erratics.world
@@ -0,0 +1,75 @@
+define block model
+(
+  size [0.5 0.5 0.5]
+  gui_nose 0
+)
+
+define topurg ranger
+(
+	sensor( 			
+    range [ 0.0  30.0 ]
+    fov 270.25
+   samples 1081
+  )
+
+  # generic model properties
+  color "black"
+  size [ 0.05 0.05 0.1 ]
+)
+
+define erratic position
+(
+  #size [0.415 0.392 0.25]
+  size [0.35 0.35 0.25]
+  origin [-0.05 0 0 0]
+  gui_nose 1
+  drive "diff"
+  topurg(pose [ 0.050 0.000 0 0.000 ])
+)
+
+define floorplan model
+(
+  # sombre, sensible, artistic
+  color "gray30"
+
+  # most maps will need a bounding box
+  boundary 1
+
+  gui_nose 0
+  gui_grid 0
+
+  gui_outline 0
+  gripper_return 0
+  fiducial_return 0
+  laser_return 1
+)
+
+# set the resolution of the underlying raytrace model in meters
+resolution 0.02
+
+interval_sim 100  # simulation timestep in milliseconds
+
+
+window
+( 
+  size [ 745.000 448.000 ] 
+
+  rotate [ 0.000 -1.560 ]
+  scale 28.806 
+)
+
+# load an environment bitmap
+floorplan
+( 
+  name "willow"
+  bitmap "willow-full.pgm"
+  size [54.0 58.7 0.5]
+  pose [ -29.350 27.000 0 90.000 ]
+)
+
+# throw in two robots
+erratic( pose [ -11.277 23.266 0 180.000 ] name "era" color "blue")
+erratic( pose [ -13.277 22.266 0 180.000 ] name "era2" color "blue")
+erratic( pose [ -13.277 23.266 0 180.000 ] name "era3" color "blue")
+erratic( pose [ -11.277 22.266 0 180.000 ] name "era4" color "blue")
+block( pose [ -13.924 25.020 0 180.000 ] color "red")
--- /dev/null
+++ ros-noetic-stage-ros-1.8.0/world/willow-full.pgm
@@ -0,0 +1,11 @@
+P5
+#Created with The GIMP
+540 587
+255
+   3 U 99 -+3 U      ΀΀ŒےU                         @΀          %U   +             Ϊ@UD3 U  ̀ @ K fU c9 f f  x@ @3 f9%  Ϊ 7UkM   Ι /3@U  @     `@-(  Ι7M  Հ3`%    n@kF  %U"F U  ǝۀ;fr @0+/+ n   @+ư       Ur1Un %U DcU U   ` @Gl +9  Fc  M fn   9 np  @ UUU3    ` k 3+    3 3+@U    p    ΀v   Ut  f@Ϊf  f U(  @Ϊb  @_  U\΀c  K3 Y ΀ Up΀%  U@U2       3UUf33ffU  f  ̀t  EzooUlPk|ofHj|]lPY^^PIOXU9.HXH     	    @nlvűغI  ̷\  f@ \ 39doNfPUSrZeer˹Ǻf     `+  UU     +bIfybslUU۪љǳ1Rp=  En         (f3@+     +Uj{Y{pz{sawk{wscwkӵU  `ǎǷ MfUUUU  f]UFrrf]`؎ْǱ^aۣI  UnnU+Q̪àwc\r 3wҴժo{wU0ʱ  ؤݹժ3  U   U       UUr@           U        U    ΀ @I`         %  0 +F]yFvO\O@U+  I{                  ۀ IC   f UfN   @̀   rY  ΀U  p  I̻yz  @fbyRiNE>/Ufr`@    t    㧀]nYUUZ=N-)"-'"0                    + ΀@3      3cnUUP<t``Or񠱱fK)I%P -@3+-   @ U                   ΀%|        3rU@ UnۅҼwlysprzU -  " +  ΀Հ  nU   'n  33frt UfZZ@DnwU@U;3nUU@3/(;(`+33  UՀ3fnI+3n+@f3I`IU @ 3@  @ffՀ` @ (         fŸ  U Uf Uf ̪IR  3U   ΀  rZ۷@U  3p f  Ι U3ǀ   ΀|   ΀ t@n    %tI  It+@   ΀ % w̪r檕 % f tf  ۪r   U+M                           U   U U3  y     U]+`rpv]   r ΀ Ux   ΀΀ &  3 1@   @ f   Ù uIn  F  n    U  <  ΀U Ϊ f <   Ό( f  @n ηf /ΙI ΒU  /  w+@c   ; x\U   M^ f Uck % /  /U    ]ǒ  3    χfФѱ UIF  3MFffw%   9IMtkUrffM+      P7i9 ̙U  ݖf n̙    U`M9`kF@rf\O      s7 P fr̙rP)sDp\wwwDU    +O v   k'cPvU]UlU3  U΀ 9)n3U   U;%     +3     f̙yU      f   ;   U  UbMU   f  I @           UM   Њ ΀ ;  F   @@@  F   ] -%@    33@ fӜ "I\OU``  @;`  c@U      Z+ ZIIk  rQ@΀ O ۷  Q@f t @F  D3U 3 ՙЎU > k @ UU  U U fe tU U  c F  @ Uc   ΀3 ;tf@`K @U U ˙pwk||Ì`                       UM              %    @3 UUUfU 7 3   +f  U3     U  )  ΀U  )   U@ @  Hn f Ϊ  ۻ̐vwpsffl`Kc%-II      7/ࠊr3;@@3@@@9@ If @ U 3       MIcf    Հ  @@@@@@ 3      U     %I   nժU̒تŒ	               9UfU@շ      K        %Z3  @    U# U Ι̪   ΀U@@  %s  U U΀ ΀  r        Un  3tfU Ύ  3    I    \I  f f΀ 1 v̪IU  3E ]  ΀ r  I  F  @9 U1   3@U 0                     w     @f   n   (+        nn  U9  3 `f  9U  q̊۝(  7虪   UtG ]  UO7]Uݪ(3 ΀3  ]K 3  `n /UӊdPRts  @  ID    ٲ + I I@@ @ UմI   /(   +/@   rffn3@@ %  ]]3D  - @         +F  M     %c Ϊ ;  Ϊ Ű  \U U/   ΪU@7 7 3n      3  FrU     U 9           Ui% F9 UI3     |l3  t  UU   @ U3 cɌc@M    (t  IIU ̪   UU    @;   U@  ΀\  f %3  U;9         @`  @Us   ΀ ΀ U9  U %  ΀  U  U@U nΆU9  3΀`  Հ+  +   P"n  ΀ @UU@/  Ǫ ;@  @΀`  fn+ Ţ@  ،   \9  `΀+  r3  ;   %΀ݙ  n DI  3 f  ̀D9  @3   UU 9 n@   U (% `rѱ΀ e@UUUvn@   @c 9 ΀r%U@I%MU` f   +UIf ΀r@   U@  3%% +        l   /΀ U    UnIUI@  \Ґ67M``fM  3     @n̷f`r_ZϛP\sk @rUf Uvt f     t  f ΀   % ΀U۠U 9  9     %  +̪̒U ت/      ΀΀Un IU      ۀ΀I U UU      M \   9   9΀  wv   3 n I  @ zZ 3]     3U @   M    r 3 n  @       ` ՀU I   ΀   I UU  ̀  ` I U  0  U@ c   "  ΀  O 3 Ǫf   Df +\   +    Ui  3@ U  @3nfU     UKΪn @]@  U@U   U ZU  9`    U     `U ΪU @  ΀  U ΀n  @  +%΀UՀ  ̝@ Ϊr    @@U U]   ΀ U   U]3 U     ̊p΀       ΀cr  U @ f    U  kn     I   U            @                             % @  U`  Ϊ               \n@           @ @3     3@  U@  tf  ΀   \΀U n       Ur   UU ΀U ΀I`      ΀  @     `       r;    f̻       ΀f0     U        U      iǀ   k(       `Հf  t7    f Z@     ΀F                 ΀    ΀   U   @t]      n % 3+%%     (  %       iUf  Fr   ΀  ౪Ίf Ut r   ŎU3U    ΀   t   ۣ       f @UU       ] `΀ vUUUU         ̪fUG8)I(-'# 1+ )+3"7Ic@ffMfrՙU   U     /Ǚf+33                 ̪U3U    ^Հ  Or   n ot  /ю`3             @@     U  ̷ cUzY             /Հ  I%+        Ut     fi U cۀ +@UrǪ3       M`  v @p Ϊ3f@@                    @تۺ%   w  η]`9 ΀΀3I̪U U Uf nр3΀  ;|U  ] 3(M3`f΀pUPKMRp  Fr     nw7-ΪUnP΀      bf9%   t<3F @ f΀UU@  36qnn|Un@n f  @ f93  @  `@ + ;/U  U  @D     + +f  ΪU   UU (U <   ú    xw{ۖṯժ̀U @΀9f  tW@  rï    @+           TEK9I@UUttFU@ffIf     UKUn  fcՀF@               ]`    UU"Mn@Ί  ;zzujjrdtU`@              fD @΀M;U z+  %̤ U@
+P3ξv  cK  UI=I  fkI9U\I<OU+ %       UU "336]sv  `΀ @kU+  II ++ UI%+f@Ur̙ՀCU  f f@9]IP  ̈ `%  @  i Uۺ3+ ΀    nk̪3/U%.9\`U ΀+  ɠ ΀̀̈ Յ@   f`rUU  @  ݠ Ιti۪ D솀   @  ێ Und`UOf   գ Ud  U̙f f@	, 9  ݌  p ꙀxbNI3":      Ւ U   f  Mf ;n  ΀c   f 0ұ @  f񊠀 n  n   c l  n   +n U U9  k U DU  溪I9 :  U3U Œ @	' `+U U  t ΀U +   I r`U ѷ   fn@ Ƿ  9  O x tt`  M%(    #壪    U U ̀ǀUUUI9f UyK f  Ύ     Ί nyn Βd % U/ Up In´@%   +U<  bvcĎft w  fڪU3 f vێ   @΀կ `r 朸i΀fwrڞf fU% U(K"\] 9  `   f̙ z܀M    "3nO kUI  ΀Ŏ tI@Q    @̌U3΀U  v Ϲ΀U  F n O @@ +Β@  @UU ix U Π33U  ud         @΀3UfU d                    c ؀r ΀O   ztU3r` v/v@fM̑ v UUpQ   OUη @+if  U@U f U@fU%%        M n3% I x@Ϊ 9  r   U+@      % It    v+9 tZ3 Ur UU@ @f U   d@ (k    wzn  Uηf9Z  3۪cs "3 U΀\  ntnk      @Uշ̀II+fΙ   @@ ݌ +     @U3Dr| ] +Ȼ    M`@   c @eloin U   UUv \  հf + ΀ f΀  DΪct @  Β  @+f `+  U f nΪ局`    ΢G O      /@     F >@  ·G  U xU\f0"6f ɀίܢ +Ut6G9II@U Mrrk]]UU U rI   @%  UKX xR   +@@M6 U@;C    0a  3MM U3x@ nG  %U f9cx `Mf  3Z3f`R U`Ur  ]UUID     9@  M@%Ix0 9@\ Fr Mn``@rU  U`@@3;t̡U  ̷MU" %5C`@  9TC9@nFF   r Ї %UrG` U  f   3v ] vov  ]n@ ]vaw  v "tO Owrvn k @ %n Տx If U;z O c /  ;I( MFU nI@M " #v+Ir ΀wݤ @l ΪU 93Ǆ[9 \fnΪk   @@ 9 M (Q<U:>    K΀\   ++ tvkr+3+U     +-@] + ΀t'         Uf 3rR @IYxv   d++@  Ύ</+NJ    @            f %@zs Uc    pxrnU%0(((     Ϊ5              @% @    Un@iu   3w    v%           ΀ ΀Co΀%Ϊ@@ @Fiߍ         eU@ΪUky{   %d Ւ  M γ7U   t ΀U7` %     ]    `Du @Z  U7 ΀۪   %U dU̒RU` I U"+ t
+   ̀+iDsd `   YU[F Ι7w6 e  @΀   f Pc̕c 3΀{r@Un) O       +t K  @ wfΙvM  3CU @+΀U3 r U FUll n M  ΀jr d0U      3 UUmwΪ`  Kzrr <U    @iG          xF :3:+ ; O+  UZ3  ;cU`UIU@U@3 Uf3@ U     F k  @ 9 FNkf   ]tUUF       U@ D3 3@  nwtIIU3+ U΀K@  @ 3 @9qi8    OP@  Ϊ@ri f+/\  Dn ̎eq   @ ΀I +| Uw+@   ZX U   /Phfm U @Ι\e  Uk %΀@3f i" f  UU      c U+    r U_/  \M  Ϊ΀k  ΀R3X( \OY @I] K3 U;UΌ p+Y  \ ΀@ ΀c#  I7_Rs   ΀U΀P3 lc z3OD \uuU       rI΀rvU f\n     ۙ3 t b       ΌZ Us Un+fٽ` %U ZIf  fkk  F2 @ v n@3   U  rf                      ΀c03+ %Z dU    n33I(@IvdnI    @ r%U Dc c U@   `%#--]lnI3     ff 3 I;I s΀f  f8@"0 Ǒer ·.     v N   @          U{^U  wI΀ 3 fę @U ΀U UU@   ldU  %Ιy< U n  Uf9`Uŝ KU  U 9iU K U  ff\  UՒ̪    +@U%  Z"    s dٝ@   Cp  o83ηs+[I       "  "99QU^0PUr`i`w ΀  fn     KI@H'@Βu fB 3tpú f U`ktUUtr۠sUrzb j}v U     /+ D  `ժ ΪpO0i    t nU ZP"          O+P U]XK] U3Q  3OU3F<i IO/7x   @     3%k  qd@xd1z+kxZnI f%I  U 3 ] sb afvwۙ3    ΀ #  %6 ]+  cH1΀ 3 9WG`]@ p %    +rQs% ΀/;vM@     t  ̙kۺ  3    3  M %r Ϊr   9@d  3UUU 3z@   +IUs>@@@3UUU    M+  o0+    +rw    +U  뵻rIU3@U  UIt ΀F; U /`sx3`Uے%p홖]M@      9ck ΀ <ÀU     dUt        U\\U    Rǀf +ݭ  yt]+   nwsU   3)ǀ3f` w  IUǊ9nU3U  @UnM      k U 
+  äfrv  rnǎUrf@M\Or  @U]  'i̙U  挱nfUIUU̎n  C>% @3R3 c=Yf3 @ %     3f+3@@U@ U\@   "ڷU# (n   f@ UI̠@  ΀FU    UU ΀Mpv| @   w 췷UU @ ΀f Ҥ{    {Uժ+%39+U + (+I    % GΪ +] +۱   l6\9+    UU+ @       UfU Ϊ@zx΀   3  OU{c    ΀_uR     rŌI UU` U co Ϊ  " 
+I +@ 3OΪU                 ΀  o           ^CI Ϊ     @I@3 n i         r     /01I\F ΀   ΀6ɻǪ@            r <tf      G 3fn  θ9 @@ r  3:          0     λ̪3@ @  F3te    ++UF   w3΀   +3 rc   U  E1xP`n  U 3 @ UU  M cf0	   . U@U     U@33+F   nMnn  F 3:U      0U ;@    %  cE`3s      3۰O  +` %U`ۣ]_      ̀ +̀fU@  U+3qѪnY3    y  ۠   ΪkFf/3 UUr    @ f  @+ 3i3`II+  ] `   @UQ+ nR   f@U  U @F @ Uf`U@H   <  ΀wr  ׉]IY 9  99O33   ۪U 3t  f+3`@耀 슀+   `rUU  3 UFO;/3   @9۪   d z9  FzfOi UuIU M 3r y   GzU+M KЯUd݀U fGF9 (fi%Հ`F9IUI@3II U    U++      / % -9w3UIkwF                U̒       U3cClkf    Uw           @3  Ϊ @;     `/@h r3 љU k   IM3^ ۀt/̠3   I  ;I   @+U7 ΀ U I%3 Uۀ 3΀U΀3;f  +U΀ ̀΀9      +               3   f޴  U Uyw\Uf3   U U3 U@   U`  @̷U   3Ϊf   Mv`nUU% U   c̺֞U@           ++n  ΀@ |ikU`trnU       UʙfU   mKҤUU/          Uێ  UU3U΀ ̪3  @@9<fUUU  +      U̪U3U3e^fn        (+;+"QPF fI  U     37;    U                         @@   ẒR  ILu +FOFM]F +   U    9@   U        @3@f  ݸI @ @U+ @ @3U   f  ;sU+nl      fr̷@r@;ΪFk@+9 U UUU  @  ΀ D؀URnU̙  %  FU /@UU  U         FI  + ՀZOI; nU 3       +3U   M   %  yP    r ΀Un@      Ff    U̴̪f`tII` U+rni%n      f۪  @@ `Ū`nr`Dfzν_ If I@+  U %/r] ΀U@3%+@+ 3%f                    ΀rMf +zḭ̌ɱ|UI     InvǷ+@                 %U+IfUn     UUUU w @unfZ 3@3     UU   ΀Dr Un@      ΀ 0#/Œ U`n  ^f     U]%p 3     fUcǺ f R R3 ΀   @  @3  @%   Fؙ"F   @  ۷t@M U_؆\  U   `I U UUKd I% 3%΀ ۠ 
+ywRz ]FM ΀f@ c%w, UfU+% ηZUf   fU ;+b nՙfI @ f  3IfU ( ` 7m22<8HU  LG +F/97")'/Mt3n Uk  Ϊ@c  Yol cE#U@@Uǋ+      rUUQ nҮ㻸   {% Ѻ   p iջn]@3 >  yI w   UΪ 9;dIwfGQ3O`U@@xU    ̴@+i  ΀p  @f  Ϊ       ̙f:swU      ΀z(f@ Ϊy 2  v U΀ +f"~h    b@@΀ t U  M UU ǙU  U f@k  `;  ΀bt3\U  M  9tU    U @  UU\  fc  R  UUq/%KժΪ쳀Fr  c<UU f    Nf 39ZC> @ ɪ@  +ݮ D       UU  3Uf @3R    0% ՀF 9fU -  I   UG?UK     U΀U+  ̷D Mf΀( +     c   @3 +l c I rM΀ GU  @ +U't̀         U``  f"  M΀  \      3  @  U U  nI ]  I   ౒U      @     3      tD O@ +     m @ + Ս% @ + @       ` @  3 +̴ U3  D   +   UU  3-fe  ۪   ΀ v:  UF   @ UUv̙  ΀(d@9 3 w    \(I v ΀%3 3GK<M3       Ut  f %Ǳ+     7    U pe M ˥UUU@@  U  U f    `   s -rvU U `U  U + 9@r  η @U3     @%     Ir`  I@Ϊ  f @  \3     Mt 3 w@U]  U  nI0  ۜ  +3       Ut5@ ΀U  U<  l3    @ n @   @t]UUG*3Zt   ;U     Ι +   3M 9  er   3  Հ3D   3@,   U  U\0   ՙ U  d   3f΀  @   nZ `@  Π`U    U  `i% i  ΀ +  UUUUvйiv< Z  +  3    UktrUFP  n+   3@f    %  DDU3 \   f r n   Uf fff f΀ik Uf @ 9]OUInZp% ff ΀@+ ΀ 33f3 \ Ϊ̒   ՠՀ   UuHN$><  
+  D3 3K  ΀Ϊ` U f  U -#ɻ         "Ui)  պ ΪUr@       "&   dvf3%   +++ U3  v      ΀   @+ ̪tF        3+Lc 3   U  U`Uf @   @U ̪ \/            33fUU  fIf΀I @3U@  IU @U    U΀ n@          3f`UU ΀ U+      f         ժ+   Ϊ    ΀   /vU           /@ +    U  @f           Ϊ U  U ȣr9   % I       U      U     k{U             ǵoID@cRKaU  `  ̙΀Ϊ         cFUrrf  y f U   UnU -  %Ð   UUU 93 3    ΀UU 9+  k@ݰ  @@ `U%(   U  U    F9 M@^   `+fU+U  U            ΀ OfǷD ΀Uvx              U      U PD ΪI`     U `/Z+ "c@U         k@3   p    ΀Ϊ   ΀΀U K@ )pU  U   < U`Z  6dPUUU+]F;F@bf    U 3  ΙU pZ   UI1΀v@@f  =             3  7 f   NU  k   3   U f<3   @ fI\ ΀vn  +   Ϊf@@  շ3K      f   U  ̀n3 fU  @;ժ@ @ `  `U    r    ΀   U P ΀@ZU 3Ìr À9@ ΀@U`c         U@Fd<   U      I  +rU9 ՝I UU3f   f U  K    Ό@ 3+  U@ 7 M U < / Ǚn    fI  ۊ    c  ΪѺ    U f +   %^nUt@@U/ ΀%ۙ Df     k  3n Ϊ   +   @%  U%% @  @@  +@     3f   3 3ժշ  t`+U3+n%U@U    xrr   I  3f                 n(                         fU@ U    ΀w  U     r U           ΀     ΀    Ϊ Ϊ         
\ No newline at end of file
