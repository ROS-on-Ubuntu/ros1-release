Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ros-noetic-xmlrpcpp (1.16.0-0jammy) jammy; urgency=high
Author: Michael Carroll <michael@openrobotics.org>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2024-08-18

--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/CHANGELOG.rst
@@ -0,0 +1,281 @@
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Changelog for package xmlrpcpp
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+1.16.0 (2023-02-15)
+-------------------
+
+1.15.15 (2022-11-23)
+--------------------
+* Move @jacobperron from maintainer to author (`#2302 <https://github.com/ros/ros_comm/issues/2302>`_)
+* Contributors: Shane Loretz
+
+1.15.14 (2022-01-06)
+--------------------
+* Keep the persistent connection only if rosmaster supports http1.1 (`#2208 <https://github.com/ros/ros_comm/issues/2208>`_)
+* Contributors: Chen Lihui
+
+1.15.13 (2021-09-22)
+--------------------
+
+1.15.12 (2021-09-21)
+--------------------
+* Fix XMLRPC endless loop (`#2185 <https://github.com/ros/ros_comm/issues/2185>`_)
+* Fix build when gtest is not available (`#2177 <https://github.com/ros/ros_comm/issues/2177>`_)
+* Contributors: Chris Lalancette, Wolfgang Merkt
+
+1.15.11 (2021-04-06)
+--------------------
+
+1.15.10 (2021-03-18)
+--------------------
+* Portable fix to recent Windows build breaks (`#2110 <https://github.com/ros/ros_comm/issues/2110>`_)
+* Contributors: Sean Yen
+
+1.15.9 (2020-10-16)
+-------------------
+* Update maintainers (`#2075 <https://github.com/ros/ros_comm/issues/2075>`_)
+* Fix to address CVE-2020-16124 (`#2065 <https://github.com/ros/ros_comm/issues/2065>`_)
+* Fix spelling (`#2066 <https://github.com/ros/ros_comm/issues/2066>`_)
+* Fix XmlRpcValue::_doubleFormat being unused (`#2003 <https://github.com/ros/ros_comm/issues/2003>`_)
+* Contributors: Shane Loretz, Sid Faber, tomoya
+
+1.15.8 (2020-07-23)
+-------------------
+* add const versions of XmlRpcValue converting operators (`#1978 <https://github.com/ros/ros_comm/issues/1978>`_)
+
+1.15.7 (2020-05-28)
+-------------------
+
+1.15.6 (2020-05-21)
+-------------------
+
+1.15.5 (2020-05-15)
+-------------------
+* check if enough FDs are free, instead counting the total free FDs (`#1929 <https://github.com/ros/ros_comm/issues/1929>`_)
+
+1.15.4 (2020-03-19)
+-------------------
+* restrict boost dependencies to components used (`#1871 <https://github.com/ros/ros_comm/issues/1871>`_)
+
+1.15.3 (2020-02-28)
+-------------------
+
+1.15.2 (2020-02-25)
+-------------------
+
+1.15.1 (2020-02-24)
+-------------------
+
+1.15.0 (2020-02-21)
+-------------------
+
+1.14.4 (2020-02-20)
+-------------------
+* bump CMake minimum version to avoid CMP0048 warning (`#1869 <https://github.com/ros/ros_comm/issues/1869>`_)
+* [Windows] workaround WSAPoll doesn't report failed connections (`#1816 <https://github.com/ros/ros_comm/issues/1816>`_)
+* fix base64 decode error on ARM platforms (`#1853 <https://github.com/ros/ros_comm/issues/1853>`_)
+* use c++11 std::snprintf (`#1820 <https://github.com/ros/ros_comm/issues/1820>`_)
+* fix dead loop if accept connection error in XmlRpcServer (`#1791 <https://github.com/ros/ros_comm/issues/1791>`_)
+* fix test build errors (`#1723 <https://github.com/ros/ros_comm/issues/1723>`_)
+* fix base64 encode error (`#1769 <https://github.com/ros/ros_comm/issues/1769>`_)
+* XmlRpcValue added bool assignment operator (`#1709 <https://github.com/ros/ros_comm/issues/1709>`_)
+* add const indexer for xmlrpc (`#1759 <https://github.com/ros/ros_comm/issues/1759>`_)
+* xmlrpcpp: fixed invalid zero index (`#1631 <https://github.com/ros/ros_comm/issues/1631>`_)
+* avoid calling memcpy on NULL pointer with size 0 (`#1546 <https://github.com/ros/ros_comm/issues/1546>`_)
+* revert "Revert "move the winsock2.h into cpp."" (`#1588 <https://github.com/ros/ros_comm/issues/1588>`_)
+* visibility macros update (`#1591 <https://github.com/ros/ros_comm/issues/1591>`_)
+* remove explicit -std=c++11, default to 14
+* fix test code build issues on Windows (`#1479 <https://github.com/ros/ros_comm/issues/1479>`_)
+* fix issues when built or run on Windows (`#1466 <https://github.com/ros/ros_comm/issues/1466>`_)
+
+1.14.3 (2018-08-06)
+-------------------
+
+1.14.2 (2018-06-06)
+-------------------
+
+1.14.1 (2018-05-21)
+-------------------
+
+1.14.0 (2018-05-21)
+-------------------
+* fixes for OSX (`#1402 <https://github.com/ros/ros_comm/issues/1402>`_)
+* take XmlRpcValue by *const* ref. in operator<< (`#1350 <https://github.com/ros/ros_comm/issues/1350>`_)
+* fix various compiler warnings on bionic (`#1325 <https://github.com/ros/ros_comm/issues/1325>`_)
+
+1.13.6 (2018-02-05)
+-------------------
+* fix xmlrpc timeout using monotonic clock (`#1249 <https://github.com/ros/ros_comm/issues/1249>`_)
+* add tests and bug fixes for XmlRpcServer (`#1243 <https://github.com/ros/ros_comm/issues/1243>`_)
+* add test and fix uninitialized data in XmlRpcClient (`#1244 <https://github.com/ros/ros_comm/issues/1244>`_)
+* make xmlrpcpp specific include directory work in devel space (`#1261 <https://github.com/ros/ros_comm/issues/1261>`_)
+* add base64 tests (`#1242 <https://github.com/ros/ros_comm/issues/1242>`_)
+* add unit tests for XmlRpcDispatch (`#1232 <https://github.com/ros/ros_comm/issues/1232>`_)
+* add unit tests and bug fixes for XmlRpcClient (`#1221 <https://github.com/ros/ros_comm/issues/1221>`_)
+
+1.13.5 (2017-11-09)
+-------------------
+* add unit tests and bug fixes for XmlRpcSocket (`#1218 <https://github.com/ros/ros_comm/issues/1218>`_)
+* add tests for XmlRpcValue and XML conversion (`#1216 <https://github.com/ros/ros_comm/issues/1216>`_)
+
+1.13.4 (2017-11-02)
+-------------------
+
+1.13.3 (2017-10-25)
+-------------------
+* fix problem when configuring tests without gtest being available (`#1197 <https://github.com/ros/ros_comm/issues/1197>`_)
+
+1.13.2 (2017-08-15)
+-------------------
+* use poll() in favor of select() in the XmlRPCDispatcher (`#833 <https://github.com/ros/ros_comm/issues/833>`_)
+* fix fall through warnings with g++ 7 (`#1139 <https://github.com/ros/ros_comm/issues/1139>`_)
+
+1.13.1 (2017-07-27)
+-------------------
+* switch to libb64 for base64 encoding/decoding (`#1046 <https://github.com/ros/ros_comm/issues/1046>`_)
+
+1.13.0 (2017-02-22)
+-------------------
+
+1.12.7 (2017-02-17)
+-------------------
+* move headers to include/xmlrpcpp (`#962 <https://github.com/ros/ros_comm/issues/962>`_)
+
+1.12.6 (2016-10-26)
+-------------------
+
+1.12.5 (2016-09-30)
+-------------------
+
+1.12.4 (2016-09-19)
+-------------------
+
+1.12.3 (2016-09-17)
+-------------------
+
+1.12.2 (2016-06-03)
+-------------------
+
+1.12.1 (2016-04-18)
+-------------------
+* use directory specific compiler flags (`#785 <https://github.com/ros/ros_comm/pull/785>`_)
+
+1.12.0 (2016-03-18)
+-------------------
+
+1.11.18 (2016-03-17)
+--------------------
+
+1.11.17 (2016-03-11)
+--------------------
+
+1.11.16 (2015-11-09)
+--------------------
+
+1.11.15 (2015-10-13)
+--------------------
+
+1.11.14 (2015-09-19)
+--------------------
+
+1.11.13 (2015-04-28)
+--------------------
+
+1.11.12 (2015-04-27)
+--------------------
+
+1.11.11 (2015-04-16)
+--------------------
+
+1.11.10 (2014-12-22)
+--------------------
+* improve Android support (`#537 <https://github.com/ros/ros_comm/pull/537>`_)
+* fix various defects reported by coverity
+
+1.11.9 (2014-08-18)
+-------------------
+
+1.11.8 (2014-08-04)
+-------------------
+
+1.11.7 (2014-07-18)
+-------------------
+
+1.11.6 (2014-07-10)
+-------------------
+
+1.11.5 (2014-06-24)
+-------------------
+
+1.11.4 (2014-06-16)
+-------------------
+
+1.11.3 (2014-05-21)
+-------------------
+
+1.11.2 (2014-05-08)
+-------------------
+
+1.11.1 (2014-05-07)
+-------------------
+* fix day comparison for rpc value of type timestamp (`#395 <https://github.com/ros/ros_comm/issues/395>`_)
+
+1.11.0 (2014-03-04)
+-------------------
+* output error message when hostname lookup fails (`#364 <https://github.com/ros/ros_comm/issues/364>`_)
+
+1.10.0 (2014-02-11)
+-------------------
+
+1.9.54 (2014-01-27)
+-------------------
+
+1.9.53 (2014-01-14)
+-------------------
+
+1.9.52 (2014-01-08)
+-------------------
+
+1.9.51 (2014-01-07)
+-------------------
+* fix compilation and warnings with clang (`#291 <https://github.com/ros/ros_comm/issues/291>`_)
+
+1.9.50 (2013-10-04)
+-------------------
+
+1.9.49 (2013-09-16)
+-------------------
+
+1.9.48 (2013-08-21)
+-------------------
+
+1.9.47 (2013-07-03)
+-------------------
+
+1.9.46 (2013-06-18)
+-------------------
+
+1.9.45 (2013-06-06)
+-------------------
+
+1.9.44 (2013-03-21)
+-------------------
+* fix install destination for dll's under Windows
+
+1.9.43 (2013-03-13)
+-------------------
+
+1.9.42 (2013-03-08)
+-------------------
+* refine license description to LGPL-2.1
+
+1.9.41 (2013-01-24)
+-------------------
+
+1.9.40 (2013-01-13)
+-------------------
+
+1.9.39 (2012-12-29)
+-------------------
+* first public release for Groovy
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/CMakeLists.txt
@@ -0,0 +1,59 @@
+cmake_minimum_required(VERSION 3.0.2)
+project(xmlrpcpp)
+
+if(NOT WIN32)
+  set_directory_properties(PROPERTIES COMPILE_OPTIONS "-Wall;-Wextra")
+endif()
+
+find_package(catkin REQUIRED COMPONENTS cpp_common rostime)
+
+# The CFG_EXTRAS is only for compatibility, to be removed in Lunar.
+catkin_package(
+  INCLUDE_DIRS include
+  LIBRARIES xmlrpcpp
+  CATKIN_DEPENDS cpp_common rostime
+  CFG_EXTRAS xmlrpcpp-extras.cmake
+)
+
+include_directories(
+  include
+  libb64/include
+  ${catkin_INCLUDE_DIRS}
+)
+link_directories(${catkin_LIBRARY_DIRS})
+
+if(WIN32)
+  add_definitions(-D_WINDOWS)
+endif()
+
+add_library(xmlrpcpp
+  src/XmlRpcClient.cpp
+  src/XmlRpcDispatch.cpp
+  src/XmlRpcServer.cpp
+  src/XmlRpcServerConnection.cpp
+  src/XmlRpcServerMethod.cpp
+  src/XmlRpcSocket.cpp
+  src/XmlRpcSource.cpp
+  src/XmlRpcUtil.cpp
+  src/XmlRpcValue.cpp
+  libb64/src/cdecode.c
+  libb64/src/cencode.c
+)
+
+target_link_libraries(xmlrpcpp ${catkin_LIBRARIES})
+if(WIN32)
+  target_link_libraries(xmlrpcpp ws2_32)
+endif()
+
+install(DIRECTORY include/${PROJECT_NAME}
+  DESTINATION ${CATKIN_GLOBAL_INCLUDE_DESTINATION}
+  FILES_MATCHING PATTERN "*.h")
+
+install(TARGETS xmlrpcpp
+  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION})
+
+if (CATKIN_ENABLE_TESTING)
+  add_subdirectory(test)
+endif()
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/COPYING
@@ -0,0 +1,504 @@
+		  GNU LESSER GENERAL PUBLIC LICENSE
+		       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+		  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/README.html
@@ -0,0 +1,109 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+	<head>
+		<title>XmlRpc++ Library</title>
+		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+		<meta http-equiv="Content-language" content="en-US">
+		<meta name="author" content="Chris Morley">
+		<meta name="copyright" content="Copyright © 2003 by Chris Morley">
+	</head>
+	<body>
+		<H3>XmlRpc++ Library</H3>
+		<P>This is version 0.7 of XmlRpc++, an implementation of the <A HREF="http://www.xmlrpc.org">
+				XmlRpc protocol</A> written in C++, based upon Shilad Sen's excellent <A HREF="http://py-xmlrpc.sourceforge.net">
+				py-xmlrpc library</A>. XmlRpc++ is designed to make it easy to incorporate 
+			XmlRpc client and server support into C++ applications. Or use both client and 
+			server objects in your app for easy peer-to-peer support.
+		</P>
+		<H3>Features</H3>
+		<UL>
+			<li>
+				<STRONG>Easy</STRONG> &nbsp; This library is easy to incorporate into C++ 
+				applications. No other libraries are required, other than your system's socket 
+				libraries. Simple XML parsing and HTTP support are built in.<br>
+			<li>
+				<STRONG>Fast</STRONG> &nbsp; All IO is non-blocking, so a slow client or 
+				network will not slow down the server.<br>
+			<li>
+				<STRONG>Portable</STRONG> Written in standard C++ to the POSIX and Windows 
+				sockets APIs. You do need a fairly recent compiler (g++ 3.1 or MSVC++ .Net or 
+				MSVC++ 6 with the <A href="http://www.dinkumware.com/vc_fixes.html">STL patches</A>.)
+			</li>
+			<li>
+				<STRONG>Free</STRONG> &nbsp; This library is released under the <a href="http://www.gnu.org/">
+					GNU</a> <a href="http://www.gnu.org/copyleft/lesser.html">LGPL</a>.<br>
+				<br>
+			</li>
+		</UL>
+		<P>&nbsp;</P>
+		<h3>Changes</h3>
+		<UL>
+			<li>
+				Better handling of fault responses: server methods can throw an 
+				XmlRpcException to return a fault and XmlRpcClient has a new method to 
+				test whether the last response was a fault.</li>
+			<li>
+				Support for system.listMethods and system.methodHelp from the introspection 
+				API.</li>
+			<li>
+				Support for system.multicall to process multiple requests in a single transaction.</li>
+			<li>
+				Fixed a problem in the XmlRpcServer destructor (it should not have been deleting the methods).</li>
+			<li>
+				The server ensures a valid result value is returned even if the method does not
+				set the result. The default result is an empty string.</li>
+			<li>
+				Doxygen comments in header files and a doc target in the makefile.</li>
+		</UL>
+		<P>
+		<P>&nbsp;</P>
+		<h3>Installation</h3>
+		<P>
+			There are VC++ 6 and VC++ .Net project files building on Windows. If you are 
+			using VC++ 6, you should apply SP3 and the fixes at <A href="http://www.dinkumware.com/vc_fixes.html">
+				http://www.dinkumware.com/vc_fixes.html</A>. Be sure to set the appropriate 
+			code generation switches. In particular, ensure that the runtime library 
+			(single/multi-threaded, static library/DLL) used is the same for the XmlRpc++ 
+			code and whatever application it will be linked to.</P>
+		<P>
+			For Linux, Solaris, and other Unix-like platforms there is a GNU Makefile which 
+			can be edited to suit your system. Specify your C++ compiler, compiler flags, 
+			and your system's socket libraries.
+		</P>
+		<p>In the test directory there are various test programs that are built by default. 
+			To verify that the library built correctly, you can start the HelloServer 
+			example:<br>
+			<pre>HelloServer 8000
+			</pre>
+			and the HelloClient example in another terminal window:<br>
+			<pre>HelloClient localhost 8000
+			</pre>
+		<P>
+			You should see two Hello messages and a sum displayed (amongst a bunch of debug 
+			output). You can also try the XML server validator program (eg, "Validator 80") 
+			and then attempt to connect to it from <A href="http://validator.xmlrpc.com">http://validator.xmlrpc.com</A>
+			(if you have access to the internet and are not behind a firewall etc).
+		</P>
+		<H3>Author</H3>
+		<P><A href="mailto:cmorley@users.sourceforge.net">Chris Morley</A>
+		</P>
+		<P>Although no code was re-used, the design and structure of the library is based 
+			upon the py-xmlrpc library implementation.<BR>
+			The base64 decoder/encoder is by <A href="mailto:lostd@ukr.net">Konstantin 
+				Pilipchuk</A>.</P>
+		<P></P>
+		<H3>License</H3>
+		<p>A full copy of the LGPL license is included in the file COPYING. The source code 
+			is Copyright (c) 2002-2003 by Chris Morley. This library is free software; you 
+			can redistribute it and/or modify it under the terms of the GNU Lesser General 
+			Public License as published by the Free Software Foundation; either version 2.1 
+			of the License, or (at your option) any later version. This library is 
+			distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
+			without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
+			PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. 
+			You should have received a copy of the GNU Lesser General Public License along 
+			with this library; if not, write to the Free Software Foundation, Inc., 59 
+			Temple Place, Suite 330, Boston, MA 02111-1307 USA
+		</p>
+	</body>
+</html>
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/cmake/xmlrpcpp-extras.cmake.develspace.in
@@ -0,0 +1 @@
+list(APPEND @PROJECT_NAME@_INCLUDE_DIRS "@xmlrpcpp_SOURCE_DIR@/include/xmlrpcpp")
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/cmake/xmlrpcpp-extras.cmake.installspace.in
@@ -0,0 +1 @@
+list(APPEND @PROJECT_NAME@_INCLUDE_DIRS "${@PROJECT_NAME@_DIR}/../../../@CATKIN_GLOBAL_INCLUDE_DESTINATION@/xmlrpcpp")
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/include/xmlrpcpp/XmlRpc.h
@@ -0,0 +1,39 @@
+// this file modified by Morgan Quigley on 22 April 2008 to add 
+// a std::exception-derived class
+#ifndef _XMLRPC_H_
+#define _XMLRPC_H_
+//
+// XmlRpc++ Copyright (c) 2002-2003 by Chris Morley
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+// 
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+// 
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+// 
+
+#if defined(_MSC_VER)
+# pragma warning(disable:4786)    // identifier was truncated in debug info
+#endif
+
+#ifndef MAKEDEPEND
+# include <string>
+#endif
+
+#include "xmlrpcpp/XmlRpcClient.h"
+#include "xmlrpcpp/XmlRpcException.h"
+#include "xmlrpcpp/XmlRpcServer.h"
+#include "xmlrpcpp/XmlRpcServerMethod.h"
+#include "xmlrpcpp/XmlRpcValue.h"
+#include "xmlrpcpp/XmlRpcUtil.h"
+
+#include <stdexcept>
+
+#endif // _XMLRPC_H_
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/include/xmlrpcpp/XmlRpcClient.h
@@ -0,0 +1,137 @@
+
+#ifndef _XMLRPCCLIENT_H_
+#define _XMLRPCCLIENT_H_
+//
+// XmlRpc++ Copyright (c) 2002-2003 by Chris Morley
+//
+#if defined(_MSC_VER)
+# pragma warning(disable:4786)    // identifier was truncated in debug info
+#endif
+
+
+#ifndef MAKEDEPEND
+# include <string>
+#endif
+
+#include "xmlrpcpp/XmlRpcDispatch.h"
+#include "xmlrpcpp/XmlRpcSource.h"
+#include "xmlrpcpp/XmlRpcDecl.h"
+
+namespace XmlRpc {
+
+  // Arguments and results are represented by XmlRpcValues
+  class XmlRpcValue;
+
+  //! A class to send XML RPC requests to a server and return the results.
+  class XMLRPCPP_DECL XmlRpcClient : public XmlRpcSource {
+  public:
+    // Static data
+    static const char REQUEST_BEGIN[];
+    static const char REQUEST_END_METHODNAME[];
+    static const char PARAMS_TAG[];
+    static const char PARAMS_ETAG[];
+    static const char PARAM_TAG[];
+    static const char PARAM_ETAG[];
+    static const char REQUEST_END[];
+    // Result tags
+    static const char METHODRESPONSE_TAG[];
+    static const char FAULT_TAG[];
+
+    //! Construct a client to connect to the server at the specified host:port address
+    //!  @param host The name of the remote machine hosting the server
+    //!  @param port The port on the remote machine where the server is listening
+    //!  @param uri  An optional string to be sent as the URI in the HTTP GET header
+    XmlRpcClient(const char* host, int port, const char* uri=0);
+
+    //! Destructor
+    virtual ~XmlRpcClient();
+
+    //! Execute the named procedure on the remote server.
+    //!  @param method The name of the remote procedure to execute
+    //!  @param params An array of the arguments for the method
+    //!  @param result The result value to be returned to the client
+    //!  @return true if the request was sent and a result received 
+    //!   (although the result might be a fault).
+    //!
+    //! Currently this is a synchronous (blocking) implementation (execute
+    //! does not return until it receives a response or an error). Use isFault()
+    //! to determine whether the result is a fault response.
+    bool execute(const char* method, XmlRpcValue const& params, XmlRpcValue& result);
+
+    bool executeNonBlock(const char* method, XmlRpcValue const& params);
+    bool executeCheckDone(XmlRpcValue& result);
+
+    //! Returns true if the result of the last execute() was a fault response.
+    bool isFault() const { return _isFault; }
+
+
+    // XmlRpcSource interface implementation
+    //! Close the connection
+    virtual void close();
+
+    //! Handle server responses. Called by the event dispatcher during execute.
+    //!  @param eventType The type of event that occurred. 
+    //!  @see XmlRpcDispatch::EventType
+    virtual unsigned handleEvent(unsigned eventType);
+
+  protected:
+    // Execution processing helpers
+    virtual bool doConnect();
+    virtual bool setupConnection();
+
+    virtual bool generateRequest(const char* method, XmlRpcValue const& params);
+    virtual std::string generateHeader(size_t length) const;
+    virtual bool writeRequest();
+    virtual bool readHeader();
+    virtual bool readResponse();
+    virtual bool parseResponse(XmlRpcValue& result);
+
+    // Possible IO states for the connection
+    enum ClientConnectionState { NO_CONNECTION, CONNECTING, WRITE_REQUEST, READ_HEADER, READ_RESPONSE, IDLE };
+    ClientConnectionState _connectionState;
+
+    static const char * connectionStateStr(ClientConnectionState state);
+
+    // Server location
+    std::string _host;
+    std::string _uri;
+    int _port;
+  public:
+    const std::string &getHost() { return _host; }
+    const std::string &getUri()  { return _uri; }
+    int getPort() const { return _port; }
+    
+    // The xml-encoded request, http header of response, and response xml
+    std::string _request;
+    std::string _header;
+    std::string _response;
+
+    // Number of times the client has attempted to send the request
+    int _sendAttempts;
+
+    // NOTE(austin): Having multiple variables that imply that the fd is valid
+    //               smells funny.
+    // Number of bytes of the request that have been written to the socket so far
+    int _bytesWritten;
+
+    // True if we are currently executing a request. If you want to multithread,
+    // each thread should have its own client.
+    bool _executing;
+
+    // True if the server closed the connection
+    bool _eof;
+
+    // True if a fault response was returned by the server
+    bool _isFault;
+
+    // Number of bytes expected in the response body (parsed from response header)
+    int _contentLength;
+
+    // Event dispatcher
+    XmlRpcDispatch _disp;
+
+  };	// class XmlRpcClient
+
+}	// namespace XmlRpc
+
+#endif	// _XMLRPCCLIENT_H_
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/include/xmlrpcpp/XmlRpcDecl.h
@@ -0,0 +1,55 @@
+/*********************************************************************
+*
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2009, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*
+*********************************************************************/
+/*
+ * Cross platform macros.
+ *
+ */
+#ifndef XMLRPCPP_DECL_H_INCLUDED
+#define XMLRPCPP_DECL_H_INCLUDED
+
+#include <ros/macros.h>
+
+#ifdef ROS_BUILD_SHARED_LIBS // ros is being built around shared libraries
+  #ifdef xmlrpcpp_EXPORTS // we are building a shared lib/dll
+    #define XMLRPCPP_DECL ROS_HELPER_EXPORT
+  #else // we are using shared lib/dll
+    #define XMLRPCPP_DECL ROS_HELPER_IMPORT
+  #endif
+#else // ros is being built around static libraries
+  #define XMLRPCPP_DECL
+#endif
+
+#endif /* XMLRPCPP_DECL_H_INCLUDED */
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/include/xmlrpcpp/XmlRpcDispatch.h
@@ -0,0 +1,90 @@
+
+#ifndef _XMLRPCDISPATCH_H_
+#define _XMLRPCDISPATCH_H_
+//
+// XmlRpc++ Copyright (c) 2002-2003 by Chris Morley
+//
+#if defined(_MSC_VER)
+# pragma warning(disable:4786)    // identifier was truncated in debug info
+#endif
+
+#include "xmlrpcpp/XmlRpcDecl.h"
+
+#ifndef MAKEDEPEND
+# include <list>
+# include <vector>
+#endif
+
+namespace XmlRpc {
+
+  // An RPC source represents a file descriptor to monitor
+  class XmlRpcSource;
+
+  //! An object which monitors file descriptors for events and performs
+  //! callbacks when interesting events happen.
+  class XMLRPCPP_DECL XmlRpcDispatch {
+  public:
+    //! Constructor
+    XmlRpcDispatch();
+    ~XmlRpcDispatch();
+
+    //! Values indicating the type of events a source is interested in
+    enum EventType {
+      ReadableEvent = 1,    //!< data available to read
+      WritableEvent = 2,    //!< connected/data can be written without blocking
+      Exception     = 4     //!< out-of-band data has arrived
+    };
+    
+    //! Monitor this source for the event types specified by the event mask
+    //! and call its event handler when any of the events occur.
+    //!  @param source The source to monitor
+    //!  @param eventMask Which event types to watch for. \see EventType
+    void addSource(XmlRpcSource* source, unsigned eventMask);
+
+    //! Stop monitoring this source.
+    //!  @param source The source to stop monitoring
+    void removeSource(XmlRpcSource* source);
+
+    //! Modify the types of events to watch for on this source
+    void setSourceEvents(XmlRpcSource* source, unsigned eventMask);
+
+
+    //! Watch current set of sources and process events for the specified
+    //! duration (in ms, -1 implies wait forever, or until exit is called)
+    void work(double msTime);
+
+    //! Exit from work routine
+    void exit();
+
+    //! Clear all sources from the monitored sources list. Sources are closed.
+    void clear();
+
+    // helper returning current steady/monotonic time
+    double getTime();
+
+    // A source to monitor and what to monitor it for
+    struct MonitoredSource {
+      MonitoredSource(XmlRpcSource* src, unsigned mask) : _src(src), _mask(mask) {}
+      XmlRpcSource* getSource() const { return _src; }
+      unsigned& getMask() { return _mask; }
+      XmlRpcSource* _src;
+      unsigned _mask;
+    };
+
+    // A list of sources to monitor
+    typedef std::list< MonitoredSource > SourceList; 
+
+    // Sources being monitored
+    SourceList _sources;
+  protected:
+
+    // When work should stop (-1 implies wait forever, or until exit is called)
+    double _endTime;
+
+    bool _doClear;
+    bool _inWork;
+
+  };
+} // namespace XmlRpc
+
+#endif  // _XMLRPCDISPATCH_H_
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/include/xmlrpcpp/XmlRpcException.h
@@ -0,0 +1,44 @@
+
+#ifndef _XMLRPCEXCEPTION_H_
+#define _XMLRPCEXCEPTION_H_
+//
+// XmlRpc++ Copyright (c) 2002-2003 by Chris Morley
+//
+#if defined(_MSC_VER)
+# pragma warning(disable:4786)    // identifier was truncated in debug info
+#endif
+
+#ifndef MAKEDEPEND
+# include <string>
+#endif
+
+#include "xmlrpcpp/XmlRpcDecl.h"
+
+
+namespace XmlRpc {
+
+  //! A class representing an error.
+  //! If server methods throw this exception, a fault response is returned
+  //! to the client.
+  class XMLRPCPP_DECL XmlRpcException {
+  public:
+    //! Constructor
+    //!   @param message  A descriptive error message
+    //!   @param code     An integer error code
+    XmlRpcException(const std::string& message, int code=-1) :
+        _message(message), _code(code) {}
+
+    //! Return the error message.
+    const std::string& getMessage() const { return _message; }
+
+    //! Return the error code.
+    int getCode() const { return _code; }
+
+  private:
+    std::string _message;
+    int _code;
+  };
+
+}
+
+#endif	// _XMLRPCEXCEPTION_H_
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/include/xmlrpcpp/XmlRpcServer.h
@@ -0,0 +1,135 @@
+// this file modified by Morgan Quigley on 22 Apr 2008.
+// added features: server can be opened on port 0 and you can read back
+// what port the OS gave you
+
+#ifndef _XMLRPCSERVER_H_
+#define _XMLRPCSERVER_H_
+//
+// XmlRpc++ Copyright (c) 2002-2003 by Chris Morley
+//
+#if defined(_MSC_VER)
+# pragma warning(disable:4786)    // identifier was truncated in debug info
+#endif
+
+#ifndef MAKEDEPEND
+# include <map>
+# include <string>
+# include <vector>
+# ifndef _WINDOWS
+#  include <poll.h>
+# endif
+#endif
+
+#include "xmlrpcpp/XmlRpcDispatch.h"
+#include "xmlrpcpp/XmlRpcSource.h"
+#include "xmlrpcpp/XmlRpcDecl.h"
+
+namespace XmlRpc {
+
+
+  // An abstract class supporting XML RPC methods
+  class XmlRpcServerMethod;
+
+  // Class representing connections to specific clients
+  class XmlRpcServerConnection;
+
+  // Class representing argument and result values
+  class XmlRpcValue;
+
+
+  //! A class to handle XML RPC requests
+  class XMLRPCPP_DECL XmlRpcServer : public XmlRpcSource {
+  public:
+    //! Create a server object.
+    XmlRpcServer();
+    //! Destructor.
+    virtual ~XmlRpcServer();
+
+    //! Specify whether introspection is enabled or not. Default is not enabled.
+    void enableIntrospection(bool enabled=true);
+
+    //! Add a command to the RPC server
+    void addMethod(XmlRpcServerMethod* method);
+
+    //! Remove a command from the RPC server
+    void removeMethod(XmlRpcServerMethod* method);
+
+    //! Remove a command from the RPC server by name
+    void removeMethod(const std::string& methodName);
+
+    //! Look up a method by name
+    XmlRpcServerMethod* findMethod(const std::string& name) const;
+
+    //! Create a socket, bind to the specified port, and
+    //! set it in listen mode to make it available for clients.
+    bool bindAndListen(int port, int backlog = 5);
+
+    //! Process client requests for the specified time
+    void work(double msTime);
+
+    //! Temporarily stop processing client requests and exit the work() method.
+    void exit();
+
+    //! Close all connections with clients and the socket file descriptor
+    void shutdown();
+
+    //! Introspection support
+    void listMethods(XmlRpcValue& result);
+
+    // XmlRpcSource interface implementation
+
+    //! Handle client connection requests
+    virtual unsigned handleEvent(unsigned eventType);
+
+    //! Remove a connection from the dispatcher
+    virtual void removeConnection(XmlRpcServerConnection*);
+
+    inline int get_port() { return _port; }
+
+    XmlRpcDispatch *get_dispatch() { return &_disp; }
+
+  protected:
+
+    //! Accept a client connection request
+    virtual unsigned acceptConnection();
+
+    //! Create a new connection object for processing requests from a specific client.
+    virtual XmlRpcServerConnection* createConnection(int socket);
+
+    //! Check if enough number of free file descriptors
+    bool enoughFreeFDs();
+
+    // Whether the introspection API is supported by this server
+    bool _introspectionEnabled;
+
+    // Event dispatcher
+    XmlRpcDispatch _disp;
+
+    // Collection of methods. This could be a set keyed on method name if we wanted...
+    typedef std::map< std::string, XmlRpcServerMethod* > MethodMap;
+    MethodMap _methods;
+
+    // system methods
+    XmlRpcServerMethod* _listMethods;
+    XmlRpcServerMethod* _methodHelp;
+
+    int _port;
+
+    // Flag indicating that accept had an error and needs to be retried.
+    bool _accept_error;
+    // If we cannot accept(), retry after this many seconds. Hopefully there
+    // will be more free file descriptors later.
+    static const double ACCEPT_RETRY_INTERVAL_SEC;
+    // Retry time for accept.
+    double _accept_retry_time_sec;
+
+    // Minimum number of free file descriptors before rejecting clients.
+    static const int FREE_FD_BUFFER;
+#ifndef _WINDOWS
+    // List of all file descriptors, used for counting open files.
+    std::vector<struct pollfd> pollfds;
+#endif
+  };
+} // namespace XmlRpc
+
+#endif //_XMLRPCSERVER_H_
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/include/xmlrpcpp/XmlRpcServerConnection.h
@@ -0,0 +1,103 @@
+#ifndef _XMLRPCSERVERCONNECTION_H_
+#define _XMLRPCSERVERCONNECTION_H_
+//
+// XmlRpc++ Copyright (c) 2002-2003 by Chris Morley
+//
+#if defined(_MSC_VER)
+# pragma warning(disable:4786)    // identifier was truncated in debug info
+#endif
+
+#ifndef MAKEDEPEND
+# include <string>
+#endif
+
+#include "xmlrpcpp/XmlRpcValue.h"
+#include "xmlrpcpp/XmlRpcSource.h"
+#include "xmlrpcpp/XmlRpcDecl.h"
+
+namespace XmlRpc {
+
+
+  // The server waits for client connections and provides methods
+  class XmlRpcServer;
+  class XmlRpcServerMethod;
+
+  //! A class to handle XML RPC requests from a particular client
+  class XMLRPCPP_DECL XmlRpcServerConnection : public XmlRpcSource {
+  public:
+    // Static data
+    static const char METHODNAME_TAG[];
+    static const char PARAMS_TAG[];
+    static const char PARAMS_ETAG[];
+    static const char PARAM_TAG[];
+    static const char PARAM_ETAG[];
+
+    static const std::string SYSTEM_MULTICALL;
+    static const std::string METHODNAME;
+    static const std::string PARAMS;
+
+    static const std::string FAULTCODE;
+    static const std::string FAULTSTRING;
+
+    //! Constructor
+    XmlRpcServerConnection(int fd, XmlRpcServer* server, bool deleteOnClose = false);
+    //! Destructor
+    virtual ~XmlRpcServerConnection();
+
+    // XmlRpcSource interface implementation
+    //! Handle IO on the client connection socket.
+    //!   @param eventType Type of IO event that occurred. @see XmlRpcDispatch::EventType.
+    virtual unsigned handleEvent(unsigned eventType);
+
+  protected:
+
+    bool readHeader();
+    bool readRequest();
+    bool writeResponse();
+
+    // Parses the request, runs the method, generates the response xml.
+    virtual void executeRequest();
+
+    // Parse the methodName and parameters from the request.
+    std::string parseRequest(XmlRpcValue& params);
+
+    // Execute a named method with the specified params.
+    bool executeMethod(const std::string& methodName, XmlRpcValue& params, XmlRpcValue& result);
+
+    // Execute multiple calls and return the results in an array.
+    bool executeMulticall(const std::string& methodName, XmlRpcValue& params, XmlRpcValue& result);
+
+    // Construct a response from the result XML.
+    void generateResponse(std::string const& resultXml);
+    void generateFaultResponse(std::string const& msg, int errorCode = -1);
+    std::string generateHeader(std::string const& body);
+
+
+    // The XmlRpc server that accepted this connection
+    XmlRpcServer* _server;
+
+    // Possible IO states for the connection
+    enum ServerConnectionState { READ_HEADER, READ_REQUEST, WRITE_RESPONSE };
+    ServerConnectionState _connectionState;
+
+    // Request headers
+    std::string _header;
+
+    // Number of bytes expected in the request body (parsed from header)
+    int _contentLength;
+
+    // Request body
+    std::string _request;
+
+    // Response
+    std::string _response;
+
+    // Number of bytes of the response written so far
+    int _bytesWritten;
+
+    // Whether to keep the current client connection open for further requests
+    bool _keepAlive;
+  };
+} // namespace XmlRpc
+
+#endif // _XMLRPCSERVERCONNECTION_H_
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/include/xmlrpcpp/XmlRpcServerMethod.h
@@ -0,0 +1,49 @@
+
+#ifndef _XMLRPCSERVERMETHOD_H_
+#define _XMLRPCSERVERMETHOD_H_
+//
+// XmlRpc++ Copyright (c) 2002-2003 by Chris Morley
+//
+#if defined(_MSC_VER)
+# pragma warning(disable:4786)    // identifier was truncated in debug info
+#endif
+
+#include "xmlrpcpp/XmlRpcDecl.h"
+
+#ifndef MAKEDEPEND
+# include <string>
+#endif
+
+namespace XmlRpc {
+
+  // Representation of a parameter or result value
+  class XmlRpcValue;
+
+  // The XmlRpcServer processes client requests to call RPCs
+  class XmlRpcServer;
+
+  //! Abstract class representing a single RPC method
+  class XMLRPCPP_DECL XmlRpcServerMethod {
+  public:
+    //! Constructor
+    XmlRpcServerMethod(std::string const& name, XmlRpcServer* server = 0);
+    //! Destructor
+    virtual ~XmlRpcServerMethod();
+
+    //! Returns the name of the method
+    std::string& name() { return _name; }
+
+    //! Execute the method. Subclasses must provide a definition for this method.
+    virtual void execute(XmlRpcValue& params, XmlRpcValue& result) = 0;
+
+    //! Returns a help string for the method.
+    //! Subclasses should define this method if introspection is being used.
+    virtual std::string help() { return std::string(); }
+
+  protected:
+    std::string _name;
+    XmlRpcServer* _server;
+  };
+} // namespace XmlRpc
+
+#endif // _XMLRPCSERVERMETHOD_H_
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/include/xmlrpcpp/XmlRpcSocket.h
@@ -0,0 +1,80 @@
+// this file modified by Morgan Quigley on 22 Apr 2008.
+// added features: server can be opened on port 0 and you can read back
+// what port the OS gave you
+
+#ifndef _XMLRPCSOCKET_H_
+#define _XMLRPCSOCKET_H_
+//
+// XmlRpc++ Copyright (c) 2002-2003 by Chris Morley
+//
+#if defined(_MSC_VER)
+# pragma warning(disable:4786)    // identifier was truncated in debug info
+#endif
+
+#ifndef MAKEDEPEND
+# include <string>
+#endif
+
+#include "xmlrpcpp/XmlRpcDecl.h"
+
+namespace XmlRpc {
+
+  //! A platform-independent socket API.
+  class XMLRPCPP_DECL XmlRpcSocket {
+  public:
+
+    static bool s_use_ipv6_;
+
+    //! Creates a stream (TCP) socket. Returns -1 on failure.
+    static int socket();
+
+    //! Closes a socket.
+    static void close(int socket);
+
+
+    //! Sets a stream (TCP) socket to perform non-blocking IO. Returns false on failure.
+    static bool setNonBlocking(int socket);
+
+    //! Read text from the specified socket. Returns false on error.
+    static bool nbRead(int socket, std::string& s, bool *eof);
+
+    //! Write text to the specified socket. Returns false on error.
+    static bool nbWrite(int socket, const std::string& s, int *bytesSoFar);
+
+
+    // The next four methods are appropriate for servers.
+
+    //! Allow the port the specified socket is bound to to be re-bound immediately so 
+    //! server re-starts are not delayed. Returns false on failure.
+    static bool setReuseAddr(int socket);
+
+    //! Bind to a specified port
+    static bool bind(int socket, int port);
+    
+    static int get_port(int socket);
+
+    //! Set socket in listen mode
+    static bool listen(int socket, int backlog);
+
+    //! Accept a client connection request
+    static int accept(int socket);
+
+
+
+    //! Connect a socket to a server (from a client)
+    static bool connect(int socket, const std::string& host, int port);
+
+
+    //! Returns last errno
+    static int getError();
+
+    //! Returns message corresponding to last error
+    static std::string getErrorMsg();
+
+    //! Returns message corresponding to error
+    static std::string getErrorMsg(int error);
+  };
+
+} // namespace XmlRpc
+
+#endif
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/include/xmlrpcpp/XmlRpcSource.h
@@ -0,0 +1,57 @@
+
+#ifndef _XMLRPCSOURCE_H_
+#define _XMLRPCSOURCE_H_
+//
+// XmlRpc++ Copyright (c) 2002-2003 by Chris Morley
+//
+#if defined(_MSC_VER)
+# pragma warning(disable:4786)    // identifier was truncated in debug info
+#endif
+
+#include "xmlrpcpp/XmlRpcDecl.h"
+
+namespace XmlRpc {
+
+  //! An RPC source represents a file descriptor to monitor
+  class XMLRPCPP_DECL XmlRpcSource {
+  public:
+    //! Constructor
+    //!  @param fd The socket file descriptor to monitor.
+    //!  @param deleteOnClose If true, the object deletes itself when close is called.
+    XmlRpcSource(int fd = -1, bool deleteOnClose = false);
+
+    //! Destructor
+    virtual ~XmlRpcSource();
+
+    //! Return the file descriptor being monitored.
+    int getfd() const { return _fd; }
+    //! Specify the file descriptor to monitor.
+    void setfd(int fd) { _fd = fd; }
+
+    //! Return whether the file descriptor should be kept open if it is no longer monitored.
+    bool getKeepOpen() const { return _keepOpen; }
+    //! Specify whether the file descriptor should be kept open if it is no longer monitored.
+    void setKeepOpen(bool b=true) { _keepOpen = b; }
+
+    //! Close the owned fd. If deleteOnClose was specified at construction, the object is deleted.
+    virtual void close();
+
+    //! Return true to continue monitoring this source
+    virtual unsigned handleEvent(unsigned eventType) = 0;
+
+  private:
+
+    // Socket. This should really be a SOCKET (an alias for unsigned int*) on windows...
+    int _fd;
+
+    // In the server, a new source (XmlRpcServerConnection) is created
+    // for each connected client. When each connection is closed, the
+    // corresponding source object is deleted.
+    bool _deleteOnClose;
+
+    // In the client, keep connections open if you intend to make multiple calls.
+    bool _keepOpen;
+  };
+} // namespace XmlRpc
+
+#endif //_XMLRPCSOURCE_H_
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/include/xmlrpcpp/XmlRpcUtil.h
@@ -0,0 +1,123 @@
+#ifndef _XMLRPCUTIL_H_
+#define _XMLRPCUTIL_H_
+//
+// XmlRpc++ Copyright (c) 2002-2003 by Chris Morley
+//
+#if defined(_MSC_VER)
+# pragma warning(disable:4786)    // identifier was truncated in debug info
+#endif
+
+#ifndef MAKEDEPEND
+# include <string>
+#endif
+
+#include "xmlrpcpp/XmlRpcDecl.h"
+
+#if defined(_MSC_VER)
+# define strcasecmp	  _stricmp
+# define strncasecmp	_strnicmp
+#elif defined(__BORLANDC__)
+# define strcasecmp stricmp
+# define strncasecmp strnicmp
+#endif
+
+namespace XmlRpc {
+
+  //! An interface allowing custom handling of error message reporting.
+  class XmlRpcErrorHandler {
+  public:
+    virtual ~XmlRpcErrorHandler() { }
+
+    //! Returns a pointer to the currently installed error handling object.
+    static XmlRpcErrorHandler* getErrorHandler()
+    { return _errorHandler; }
+
+    //! Specifies the error handler.
+    static void setErrorHandler(XmlRpcErrorHandler* eh)
+    { _errorHandler = eh; }
+
+    //! Report an error. Custom error handlers should define this method.
+    virtual void error(const char* msg) = 0;
+
+  protected:
+    static XMLRPCPP_DECL XmlRpcErrorHandler* _errorHandler;
+  };
+
+  //! An interface allowing custom handling of informational message reporting.
+  class XmlRpcLogHandler {
+  public:
+    virtual ~XmlRpcLogHandler() { }
+
+    //! Returns a pointer to the currently installed message reporting object.
+    static XmlRpcLogHandler* getLogHandler()
+    { return _logHandler; }
+
+    //! Specifies the message handler.
+    static void setLogHandler(XmlRpcLogHandler* lh)
+    { _logHandler = lh; }
+
+    //! Returns the level of verbosity of informational messages. 0 is no output, 5 is very verbose.
+    static int getVerbosity()
+    { return _verbosity; }
+
+    //! Specify the level of verbosity of informational messages. 0 is no output, 5 is very verbose.
+    static void setVerbosity(int v)
+    { _verbosity = v; }
+
+    //! Output a message. Custom error handlers should define this method.
+    virtual void log(int level, const char* msg) = 0;
+
+  protected:
+    static XMLRPCPP_DECL XmlRpcLogHandler* _logHandler;
+    static XMLRPCPP_DECL int _verbosity;
+  };
+
+  //! Returns log message verbosity. This is short for XmlRpcLogHandler::getVerbosity()
+  XMLRPCPP_DECL int getVerbosity();
+  //! Sets log message verbosity. This is short for XmlRpcLogHandler::setVerbosity(level)
+  XMLRPCPP_DECL void setVerbosity(int level);
+
+  //! Version identifier
+  extern XMLRPCPP_DECL const char XMLRPC_VERSION[];
+
+  //! Utilities for XML parsing, encoding, and decoding and message handlers.
+  class XMLRPCPP_DECL XmlRpcUtil {
+  public:
+    // hokey xml parsing
+    //! Returns contents between <tag> and </tag>, updates offset to char after </tag>.
+    //! This method will skip *any* intermediate string to find the tag; as such, it is
+    //! unsafe to use in general, and `nextTagData` should be used instead.
+    static std::string parseTag(const char* tag, std::string const& xml, int* offset);
+
+    //! Returns true if the tag is found and updates offset to the char after the tag
+    static bool findTag(const char* tag, std::string const& xml, int* offset);
+
+    //! Returns the next tag and updates offset to the char after the tag, or empty string
+    //! if the next non-whitespace character is not '<'
+    static std::string getNextTag(std::string const& xml, int* offset);
+
+    //! Returns true if the tag is found at the specified offset (modulo any whitespace)
+    //! and updates offset to the char after the tag
+    static bool nextTagIs(const char* tag, std::string const& xml, int* offset);
+
+    //! Returns contents between <tag> and </tag> at the specified offset (modulo any whitespace),
+    //! and updates offset to char after </tag>
+    static std::string nextTagData(const char* tag, std::string const& xml, int* offset);
+
+    //! Convert raw text to encoded xml.
+    static std::string xmlEncode(const std::string& raw);
+
+    //! Convert encoded xml to raw text
+    static std::string xmlDecode(const std::string& encoded);
+
+
+    //! Dump messages somewhere
+    static void log(int level, const char* fmt, ...);
+
+    //! Dump error messages somewhere
+    static void error(const char* fmt, ...);
+
+  };
+} // namespace XmlRpc
+
+#endif // _XMLRPCUTIL_H_
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/include/xmlrpcpp/XmlRpcValue.h
@@ -0,0 +1,210 @@
+
+#ifndef _XMLRPCVALUE_H_
+#define _XMLRPCVALUE_H_
+//
+// XmlRpc++ Copyright (c) 2002-2003 by Chris Morley
+//
+#if defined(_MSC_VER)
+# pragma warning(disable:4786)    // identifier was truncated in debug info
+#endif
+
+#include "xmlrpcpp/XmlRpcDecl.h"
+
+#ifndef MAKEDEPEND
+# include <map>
+# include <string>
+# include <vector>
+# include <time.h>
+#endif
+
+namespace XmlRpc {
+
+  //! RPC method arguments and results are represented by Values
+  //   should probably refcount them...
+  class XMLRPCPP_DECL XmlRpcValue {
+  public:
+
+
+    enum Type {
+      TypeInvalid,
+      TypeBoolean,
+      TypeInt,
+      TypeDouble,
+      TypeString,
+      TypeDateTime,
+      TypeBase64,
+      TypeArray,
+      TypeStruct
+    };
+
+    // Non-primitive types
+    typedef std::vector<char> BinaryData;
+    typedef std::vector<XmlRpcValue> ValueArray;
+    typedef std::map<std::string, XmlRpcValue> ValueStruct;
+    typedef ValueStruct::iterator iterator;
+    typedef ValueStruct::const_iterator const_iterator;
+
+    //! Constructors
+    XmlRpcValue() : _type(TypeInvalid) { _value.asBinary = 0; }
+    XmlRpcValue(bool value) : _type(TypeBoolean) { _value.asBool = value; }
+    XmlRpcValue(int value)  : _type(TypeInt) { _value.asInt = value; }
+    XmlRpcValue(double value)  : _type(TypeDouble) { _value.asDouble = value; }
+
+    XmlRpcValue(std::string const& value) : _type(TypeString) 
+    { _value.asString = new std::string(value); }
+
+    XmlRpcValue(const char* value)  : _type(TypeString)
+    { _value.asString = new std::string(value); }
+
+    XmlRpcValue(struct tm* value)  : _type(TypeDateTime) 
+    { _value.asTime = new struct tm(*value); }
+
+
+    XmlRpcValue(void* value, int nBytes)  : _type(TypeBase64)
+    {
+      _value.asBinary = new BinaryData((char*)value, ((char*)value)+nBytes);
+    }
+
+    //! Construct from xml, beginning at *offset chars into the string, updates offset
+    XmlRpcValue(std::string const& xml, int* offset) : _type(TypeInvalid)
+    { if ( ! fromXml(xml,offset)) _type = TypeInvalid; }
+
+    //! Copy
+    XmlRpcValue(XmlRpcValue const& rhs) : _type(TypeInvalid) { *this = rhs; }
+
+    //! Destructor (make virtual if you want to subclass)
+    /*virtual*/ ~XmlRpcValue() { invalidate(); }
+
+    //! Erase the current value
+    void clear() { invalidate(); }
+
+    // Operators
+    XmlRpcValue& operator=(XmlRpcValue const& rhs);
+    XmlRpcValue& operator=(bool const& rhs) { return operator=(XmlRpcValue(rhs)); }
+    XmlRpcValue& operator=(int const& rhs) { return operator=(XmlRpcValue(rhs)); }
+    XmlRpcValue& operator=(double const& rhs) { return operator=(XmlRpcValue(rhs)); }
+    XmlRpcValue& operator=(const char* rhs) { return operator=(XmlRpcValue(std::string(rhs))); }
+
+    bool operator==(XmlRpcValue const& other) const;
+    bool operator!=(XmlRpcValue const& other) const;
+
+    operator bool&()          { assertTypeOrInvalid(TypeBoolean); return _value.asBool; }
+    operator int&()           { assertTypeOrInvalid(TypeInt); return _value.asInt; }
+    operator double&()        { assertTypeOrInvalid(TypeDouble); return _value.asDouble; }
+    operator std::string&()   { assertTypeOrInvalid(TypeString); return *_value.asString; }
+    operator BinaryData&()    { assertTypeOrInvalid(TypeBase64); return *_value.asBinary; }
+    operator struct tm&()     { assertTypeOrInvalid(TypeDateTime); return *_value.asTime; }
+
+    operator const bool&() const          { assertTypeOrInvalid(TypeBoolean); return _value.asBool; }
+    operator const int&() const           { assertTypeOrInvalid(TypeInt); return _value.asInt; }
+    operator const double&() const        { assertTypeOrInvalid(TypeDouble); return _value.asDouble; }
+    operator const std::string&() const   { assertTypeOrInvalid(TypeString); return *_value.asString; }
+    operator const BinaryData&() const    { assertTypeOrInvalid(TypeBase64); return *_value.asBinary; }
+    operator const struct tm&() const     { assertTypeOrInvalid(TypeDateTime); return *_value.asTime; }
+
+    XmlRpcValue const& operator[](int i) const { assertArray(i+1); return _value.asArray->at(i); }
+    XmlRpcValue& operator[](int i)             { assertArray(i+1); return _value.asArray->at(i); }
+
+    XmlRpcValue& operator[](std::string const& k) const { assertStruct(); return (*_value.asStruct)[k]; }
+    XmlRpcValue& operator[](std::string const& k) { assertStruct(); return (*_value.asStruct)[k]; }
+    XmlRpcValue& operator[](const char* k) const { assertStruct(); std::string s(k); return (*_value.asStruct)[s]; }
+    XmlRpcValue& operator[](const char* k) { assertStruct(); std::string s(k); return (*_value.asStruct)[s]; }
+
+    iterator begin() {assertStruct(); return (*_value.asStruct).begin(); }
+    iterator end() {assertStruct(); return (*_value.asStruct).end(); }
+
+    const_iterator begin() const {assertStruct(); return (*_value.asStruct).begin(); }
+    const_iterator end() const {assertStruct(); return (*_value.asStruct).end(); }
+
+    // Accessors
+    //! Return true if the value has been set to something.
+    bool valid() const { return _type != TypeInvalid; }
+
+    //! Return the type of the value stored. \see Type.
+    Type const &getType() const { return _type; }
+
+    //! Return the size for string, base64, array, and struct values.
+    int size() const;
+
+    //! Specify the size for array values. Array values will grow beyond this size if needed.
+    void setSize(int size)    { assertArray(size); }
+
+    //! Check for the existence of a struct member by name.
+    bool hasMember(const std::string& name) const;
+
+    //! Decode xml. Destroys any existing value.
+    bool fromXml(std::string const& valueXml, int* offset);
+
+    //! Encode the Value in xml
+    std::string toXml() const;
+
+    //! Write the value (no xml encoding)
+    std::ostream& write(std::ostream& os) const;
+
+    // Formatting
+    //! Return the format used to write double values.
+    static std::string const& getDoubleFormat() { return _doubleFormat; }
+
+    //! Specify the format used to write double values.
+    static void setDoubleFormat(const char* f) { _doubleFormat = f; }
+
+
+  protected:
+    // Clean up
+    void invalidate();
+
+    // Type checking
+    void assertTypeOrInvalid(Type t) const;
+    void assertTypeOrInvalid(Type t);
+    void assertArray(int size) const;
+    void assertArray(int size);
+    void assertStruct() const;
+    void assertStruct();
+
+    // XML decoding
+    bool boolFromXml(std::string const& valueXml, int* offset);
+    bool intFromXml(std::string const& valueXml, int* offset);
+    bool doubleFromXml(std::string const& valueXml, int* offset);
+    bool stringFromXml(std::string const& valueXml, int* offset);
+    bool timeFromXml(std::string const& valueXml, int* offset);
+    bool binaryFromXml(std::string const& valueXml, int* offset);
+    bool arrayFromXml(std::string const& valueXml, int* offset);
+    bool structFromXml(std::string const& valueXml, int* offset);
+
+    // XML encoding
+    std::string boolToXml() const;
+    std::string intToXml() const;
+    std::string doubleToXml() const;
+    std::string stringToXml() const;
+    std::string timeToXml() const;
+    std::string binaryToXml() const;
+    std::string arrayToXml() const;
+    std::string structToXml() const;
+
+    // Format strings
+    static std::string _doubleFormat;
+
+    // Type tag and values
+    Type _type;
+
+    // At some point I will split off Arrays and Structs into
+    // separate ref-counted objects for more efficient copying.
+    union {
+      bool          asBool;
+      int           asInt;
+      double        asDouble;
+      struct tm*    asTime;
+      std::string*  asString;
+      BinaryData*   asBinary;
+      ValueArray*   asArray;
+      ValueStruct*  asStruct;
+    } _value;
+    
+  };
+} // namespace XmlRpc
+
+
+XMLRPCPP_DECL std::ostream& operator<<(std::ostream& os, const XmlRpc::XmlRpcValue& v);
+
+
+#endif // _XMLRPCVALUE_H_
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/include/xmlrpcpp/base64.h
@@ -0,0 +1,3 @@
+#error This header was removed due to licensing issues. \
+Please use a dedicated base64 library if you need one for your own project. \
+See https://github.com/ros/ros_comm/pull/1046 for more details.
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/libb64/AUTHORS
@@ -0,0 +1,15 @@
+libb64: Base64 Encoding/Decoding Routines
+======================================
+
+Authors:
+-------
+
+Chris Venter	chris.venter@gmail.com	http://controlaltfire.com
+
+Contributors:
+------------
+
+Mario Rugiero
+Shlok Datye
+Peter K. Lee
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/libb64/BENCHMARKS
@@ -0,0 +1,85 @@
+-- Intro
+
+Some people have expressed opinions about how
+fast libb64's encoding and decoding routines
+are, as compared to some other BASE64 packages
+out there.
+
+This document shows the result of a short and sweet 
+benchmark, which takes a large-ish file and 
+encodes/decodes it a number of times.
+The winner is the executable that does this task the quickest.
+
+-- Platform
+
+The tests were all run on a Fujitsu-Siemens laptop,
+with a Pentium M processor running at 2GHz, with
+1GB of RAM, running Ubuntu 10.4.
+
+-- Packages
+
+The following BASE64 packages were used in this benchmark:
+
+- libb64-1.2 (libb64-base64)
+  From libb64.sourceforge.net
+  Size of executable: 18808 bytes
+  Compiled with:
+    CFLAGS += -O3
+    BUFFERSIZE = 16777216
+
+- base64-1.5 (fourmilab-base64)
+  From http://www.fourmilab.ch/webtools/base64/
+  Size of executable: 20261 bytes
+  Compiled with Default package settings
+
+- coreutils 7.4-2ubuntu2 (coreutils-base64)
+  From http://www.gnu.org/software/coreutils/
+  Size of executable: 38488 bytes
+  Default binary distributed with Ubuntu 10.4
+
+-- Input File
+
+Using blender-2.49b-linux-glibc236-py25-i386.tar.bz2
+from http://www.blender.org/download/get-blender/
+Size: 18285329 bytes
+(approx. 18MB)
+
+-- Method
+
+Encode and Decode the Input file 50 times in a loop,
+using a simple shell script, and get the running time.
+
+-- Results
+
+$ time ./benchmark-libb64.sh 
+real	0m28.389s
+user	0m14.077s
+sys	0m12.309s
+
+$ time ./benchmark-fourmilab.sh 
+real	1m43.160s
+user	1m23.769s
+sys	0m8.737s
+
+$ time ./benchmark-coreutils.sh 
+real	0m36.288s
+user	0m24.746s
+sys	0m8.181s
+
+28.389 for 18MB * 50
+= 28.389 for 900
+
+-- Conclusion
+
+libb64 is the fastest encoder/decoder, and 
+has the smallest executable size.
+
+On average it will encode and decode at roughly 31.7MB/second.
+
+The closest "competitor" is base64 from GNU coreutils, which
+reaches only 24.8MB/second.
+
+--
+14/06/2010
+chris.venter@gmail.com
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/libb64/CHANGELOG
@@ -0,0 +1,33 @@
+libb64: Base64 Encoding/Decoding Routines
+======================================
+
+## Changelog ##
+
+Version 1.2.1 Release
+---------------------
+Fixed a long-standing bug in src/cdecode.c where value_in was not correctly
+checked against the bounds [0..decoding_size)
+Thanks to both Mario Rugiero and Shlok Datye for pointing this out.
+Added some simple example code to answer some of the most common misconceptions
+people have about the library usage.
+
+Version 1.2 Release
+-------------------
+Removed the b64dec, b64enc, encoder and decoder programs in favour of
+a better example, called base64, which encodes and decodes 
+depending on its arguments.
+
+Created a solution for Microsoft Visual Studio C++ Express 2010
+edition, which simply builds the base64 example as a console application.
+
+Version 1.1 Release
+-------------------
+Modified encode.h to (correctly) read from the iostream argument,
+instead of std::cin.
+Thanks to Peter K. Lee for the heads-up.
+
+No API changes.
+
+Version 1.0 Release
+-------------------
+The current content is the changeset.
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/libb64/INSTALL
@@ -0,0 +1,44 @@
+libb64: Base64 Encoding/Decoding Routines
+======================================
+
+Requirements:
+------------
+This piece of software has minimal requirements.
+
+I have tested it on the following systems:
+
+- a Linux machine, with the following specs:
+(this was the original development machine)
+	* FedoraCore 4
+	* kernel v. 2.6.11 (stock FC4 kernel)
+	* gcc version 4.0.1 20050727 (Red Hat 4.0.1-5)
+	* glibc-2.3.5-10
+	* make v. 3.80
+	* some arb version of makedepend
+
+- Windows XP machine
+	* MSYS 1.0
+	* MinGW 5.1.4
+	* gcc version 3.4.5 (mingw-vista special r3)
+
+- Windows XP machine (same as above)
+	* Microsoft Visual Studio 2010, Version 10.0.30319.1 RTMRel
+	
+Barring any serious screwups on my part, this code should compile and run sweetly
+under Cygwin and other systems too. If you DO get it running under some weird arch/os setup,
+send me a mail, please.
+
+Compiling:
+---------
+There is no configure. It would be overkill for something so simple...
+Run make in the root directory.
+
+Installing:
+----------
+Since the current targets are a standalone executable and a static library
+(fancy name for archive) with some headers, an install script has not been implemented yet.
+Simply copy the executable into your path, and use it.
+
+--
+peace out
+Chris
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/libb64/LICENSE
@@ -0,0 +1,29 @@
+Copyright-Only Dedication (based on United States law) 
+or Public Domain Certification
+
+The person or persons who have associated work with this document (the
+"Dedicator" or "Certifier") hereby either (a) certifies that, to the best of
+his knowledge, the work of authorship identified is in the public domain of the
+country from which the work is published, or (b) hereby dedicates whatever
+copyright the dedicators holds in the work of authorship identified below (the
+"Work") to the public domain. A certifier, moreover, dedicates any copyright
+interest he may have in the associated work, and for these purposes, is
+described as a "dedicator" below.
+
+A certifier has taken reasonable steps to verify the copyright status of this
+work. Certifier recognizes that his good faith efforts may not shield him from
+liability if in fact the work certified is not in the public domain.
+
+Dedicator makes this dedication for the benefit of the public at large and to
+the detriment of the Dedicator's heirs and successors. Dedicator intends this
+dedication to be an overt act of relinquishment in perpetuity of all present
+and future rights under copyright law, whether vested or contingent, in the
+Work. Dedicator understands that such relinquishment of all rights includes
+the relinquishment of all rights to enforce (by lawsuit or otherwise) those
+copyrights in the Work.
+
+Dedicator recognizes that, once placed in the public domain, the Work may be
+freely reproduced, distributed, transmitted, used, modified, built upon, or
+otherwise exploited by anyone for any purpose, commercial or non-commercial,
+and in any way, including by methods that have not yet been invented or
+conceived.
\ No newline at end of file
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/libb64/Makefile
@@ -0,0 +1,31 @@
+all: all_src all_base64 all_examples
+
+all_src:
+	$(MAKE) -C src
+all_base64: all_src
+	$(MAKE) -C base64
+all_examples:
+	$(MAKE) -C examples
+	
+clean: clean_src clean_base64 clean_include clean_examples
+	rm -f *~ *.bak
+
+clean_include:
+	rm -f include/b64/*~
+
+clean_src:
+	$(MAKE) -C src clean;
+clean_base64:
+	$(MAKE) -C base64 clean;
+clean_examples:
+	$(MAKE) -C examples clean;
+		
+distclean: clean distclean_src distclean_base64 distclean_examples
+
+distclean_src:
+	$(MAKE) -C src distclean;
+distclean_base64:
+	$(MAKE) -C base64 distclean;
+distclean_examples:
+	$(MAKE) -C examples distclean;
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/libb64/README
@@ -0,0 +1,143 @@
+b64: Base64 Encoding/Decoding Routines
+======================================
+
+Overview:
+--------
+libb64 is a library of ANSI C routines for fast encoding/decoding data into and
+from a base64-encoded format. C++ wrappers are included, as well as the source
+code for standalone encoding and decoding executables.
+
+base64 consists of ASCII text, and is therefore a useful encoding for storing 
+binary data in a text file, such as xml, or sending binary data over text-only
+email.
+
+References:
+----------
+* Wikipedia article:
+	http://en.wikipedia.org/wiki/Base64
+* base64, another implementation of a commandline en/decoder:
+	http://www.fourmilab.ch/webtools/base64/
+
+Why?
+---
+I did this because I need an implementation of base64 encoding and decoding,
+without any licensing problems. Most OS implementations are released under
+either the GNU/GPL, or a BSD-variant, which is not what I require.
+
+Also, the chance to actually use the co-routine implementation in code is rare,
+and its use here is fitting. I couldn't pass up the chance.
+For more information on this technique, see "Coroutines in C", by Simon Tatham,
+which can be found online here: 
+http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html
+
+So then, under which license do I release this code? On to the next section...
+
+License:
+-------
+This work is released under into the Public Domain.
+It basically boils down to this: I put this work in the public domain, and you
+can take it and do whatever you want with it.
+
+An example of this "license" is the Creative Commons Public Domain License, a
+copy of which can be found in the LICENSE file, and also online at
+http://creativecommons.org/licenses/publicdomain/
+
+Commandline Use:
+---------------
+There is a new executable available, it is simply called base64.
+It can encode and decode files, as instructed by the user.
+
+To encode a file:
+$ ./base64 -e filea fileb
+fileb will now be the base64-encoded version of filea.
+
+To decode a file:
+$ ./base64 -d fileb filec
+filec will now be identical to filea.
+
+Programming:
+-----------
+Some C++ wrappers are provided as well, so you don't have to get your hands
+dirty. Encoding from standard input to standard output is as simple as
+
+	#include <b64/encode.h>
+	#include <iostream>
+	int main()
+	{
+		base64::encoder E;
+		E.encode(std::cin, std::cout);
+		return 0;
+	}
+
+Both standalone executables and a static library is provided in the package,
+
+Example code:
+------------
+The 'examples' directory contains some simple example C code, that demonstrates
+how to use the C interface of the library.
+
+Implementation:
+--------------
+It is DAMN fast, if I may say so myself. The C code uses a little trick which
+has been used to implement coroutines, of which one can say that this
+implementation is an example.
+
+(To see how the libb64 codebase compares with some other BASE64 implementations
+available, see the BENCHMARKS file)
+
+The trick involves the fact that a switch-statement may legally cross into
+sub-blocks. A very thorough and enlightening essay on co-routines in C, using
+this method, can be found in the above mentioned "Coroutines in C", by Simon
+Tatham: http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html
+
+For example, an RLE decompressing routine, adapted from the article:
+1	static int STATE = 0;
+2	static int len, c;
+3	switch (STATE)
+4	{
+5		while (1)
+6		{
+7			c = getchar();
+8			if (c == EOF) return EOF;
+9			if (c == 0xFF) {
+10				len = getchar();
+11				c = getchar();
+12				while (len--)
+13				{
+14					STATE = 0;
+15					return c;
+16	case 0:
+17				}
+18			} else
+19				STATE = 1;
+20				return c;
+21	case 1:
+22			}
+23		}
+24	}
+
+As can be seen from this example, a coroutine depends on a state variable,
+which it sets directly before exiting (lines 14 and 119). The next time the
+routine is entered, the switch moves control to the specific point directly
+after the previous exit (lines 16 and 21).hands
+
+(As an aside, in the mentioned article the combination of the top-level switch,
+the various setting of the state, the return of a value, and the labelling of
+the exit point is wrapped in #define macros, making the structure of the
+routine even clearer.)
+
+The obvious problem with any such routine is the static keyword.
+Any static variables in a function spell doom for multithreaded applications.
+Also, in situations where this coroutine is used by more than one other
+coroutines, the consistency is disturbed.
+
+What is needed is a structure for storing these variabled, which is passed to
+the routine seperately. This obviously breaks the modularity of the function,
+since now the caller has to worry about and care for the internal state of the
+routine (the callee). This allows for a fast, multithreading-enabled
+implementation, which may (obviously) be wrapped in a C++ object for ease of
+use.
+
+The base64 encoding and decoding functionality in this package is implemented
+in exactly this way, providing both a high-speed high-maintanence C interface,
+and a wrapped C++ which is low-maintanence and only slightly less performant.
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/libb64/include/b64/cdecode.h
@@ -0,0 +1,29 @@
+/*
+cdecode.h - c header for a base64 decoding algorithm
+
+This is part of the libb64 project, and has been placed in the public domain.
+For details, see http://sourceforge.net/projects/libb64
+*/
+
+#ifndef BASE64_CDECODE_H
+#define BASE64_CDECODE_H
+
+typedef enum
+{
+	step_a, step_b, step_c, step_d
+} base64_decodestep;
+
+typedef struct
+{
+	base64_decodestep step;
+	char plainchar;
+} base64_decodestate;
+
+void base64_init_decodestate(base64_decodestate* state_in);
+
+int base64_decode_value(char value_in);
+
+int base64_decode_block(const char* code_in, const int length_in, char* plaintext_out, base64_decodestate* state_in);
+
+#endif /* BASE64_CDECODE_H */
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/libb64/include/b64/cencode.h
@@ -0,0 +1,32 @@
+/*
+cencode.h - c header for a base64 encoding algorithm
+
+This is part of the libb64 project, and has been placed in the public domain.
+For details, see http://sourceforge.net/projects/libb64
+*/
+
+#ifndef BASE64_CENCODE_H
+#define BASE64_CENCODE_H
+
+typedef enum
+{
+	step_A, step_B, step_C
+} base64_encodestep;
+
+typedef struct
+{
+	base64_encodestep step;
+	char result;
+	int stepcount;
+} base64_encodestate;
+
+void base64_init_encodestate(base64_encodestate* state_in);
+
+char base64_encode_value(char value_in);
+
+int base64_encode_block(const char* plaintext_in, int length_in, char* code_out, base64_encodestate* state_in);
+
+int base64_encode_blockend(char* code_out, base64_encodestate* state_in);
+
+#endif /* BASE64_CENCODE_H */
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/libb64/include/b64/decode.h
@@ -0,0 +1,74 @@
+// :mode=c++:
+/*
+decode.h - c++ wrapper for a base64 decoding algorithm
+
+This is part of the libb64 project, and has been placed in the public domain.
+For details, see http://sourceforge.net/projects/libb64
+*/
+#ifndef BASE64_DECODE_H
+#define BASE64_DECODE_H
+
+#include "xmlrpcpp/XmlRpcDecl.h"
+
+#include <iostream>
+
+namespace base64
+{
+	extern "C"
+	{
+		#include "cdecode.h"
+	}
+
+	struct XMLRPCPP_DECL decoder
+	{
+		base64_decodestate _state;
+		int _buffersize;
+
+		decoder(int buffersize_in = 512)
+		: _buffersize(buffersize_in)
+		{
+			base64_init_decodestate(&_state);
+		}
+
+		int decode(char value_in)
+		{
+			return base64_decode_value(value_in);
+		}
+
+		int decode(const char* code_in, const int length_in, char* plaintext_out)
+		{
+			return base64_decode_block(code_in, length_in, plaintext_out, &_state);
+		}
+
+		void decode(std::istream& istream_in, std::ostream& ostream_in)
+		{
+			base64_init_decodestate(&_state);
+			//
+			const int N = _buffersize;
+			char* code = new char[N];
+			char* plaintext = new char[N];
+			int codelength;
+			int plainlength;
+
+			do
+			{
+				istream_in.read((char*)code, N);
+				codelength = istream_in.gcount();
+				plainlength = decode(code, codelength, plaintext);
+				ostream_in.write((const char*)plaintext, plainlength);
+			}
+			while (istream_in.good() && codelength > 0);
+			//
+			base64_init_decodestate(&_state);
+
+			delete [] code;
+			delete [] plaintext;
+		}
+	};
+
+} // namespace base64
+
+
+
+#endif // BASE64_DECODE_H
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/libb64/include/b64/encode.h
@@ -0,0 +1,81 @@
+// :mode=c++:
+/*
+encode.h - c++ wrapper for a base64 encoding algorithm
+
+This is part of the libb64 project, and has been placed in the public domain.
+For details, see http://sourceforge.net/projects/libb64
+*/
+#ifndef BASE64_ENCODE_H
+#define BASE64_ENCODE_H
+
+#include "xmlrpcpp/XmlRpcDecl.h"
+
+#include <iostream>
+
+namespace base64
+{
+	extern "C" 
+	{
+		#include "cencode.h"
+	}
+
+	struct XMLRPCPP_DECL encoder
+	{
+		base64_encodestate _state;
+		int _buffersize;
+
+		encoder(int buffersize_in = 512)
+		: _buffersize(buffersize_in)
+		{
+			base64_init_encodestate(&_state);
+		}
+
+		int encode(char value_in)
+		{
+			return base64_encode_value(value_in);
+		}
+
+		int encode(const char* code_in, const int length_in, char* plaintext_out)
+		{
+			return base64_encode_block(code_in, length_in, plaintext_out, &_state);
+		}
+
+		int encode_end(char* plaintext_out)
+		{
+			return base64_encode_blockend(plaintext_out, &_state);
+		}
+
+		void encode(std::istream& istream_in, std::ostream& ostream_in)
+		{
+			base64_init_encodestate(&_state);
+			//
+			const int N = _buffersize;
+			char* plaintext = new char[N];
+			char* code = new char[2*N];
+			int plainlength;
+			int codelength;
+
+			do
+			{
+				istream_in.read(plaintext, N);
+				plainlength = istream_in.gcount();
+				//
+				codelength = encode(plaintext, plainlength, code);
+				ostream_in.write(code, codelength);
+			}
+			while (istream_in.good() && plainlength > 0);
+
+			codelength = encode_end(code);
+			ostream_in.write(code, codelength);
+			//
+			base64_init_encodestate(&_state);
+
+			delete [] code;
+			delete [] plaintext;
+		}
+	};
+
+} // namespace base64
+
+#endif // BASE64_ENCODE_H
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/libb64/src/Makefile
@@ -0,0 +1,43 @@
+LIBRARIES = libb64.a
+
+# Build flags (uncomment one)
+#############################
+# Release build flags
+CFLAGS += -O3
+#############################
+# Debug build flags
+#CFLAGS += -g
+#############################
+
+SOURCES = cdecode.c  cencode.c
+
+TARGETS = $(LIBRARIES)
+
+LINK.o = gcc
+
+CFLAGS += -Werror -pedantic
+CFLAGS += -I../include
+
+vpath %.h ../include/b64
+
+.PHONY : clean
+
+all: $(TARGETS) #strip
+
+libb64.a: cencode.o cdecode.o
+	$(AR) $(ARFLAGS) $@ $^
+
+strip:
+	strip $(BINARIES) *.exe
+
+clean:
+	rm -f *.exe* *.o $(TARGETS) *.bak *~
+
+distclean: clean
+	rm -f depend
+
+depend: $(SOURCES)
+	makedepend -f- $(CFLAGS) $(SOURCES) 2> /dev/null 1> depend
+
+-include depend
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/libb64/src/cdecode.c
@@ -0,0 +1,96 @@
+/*
+cdecoder.c - c source to a base64 decoding algorithm implementation
+
+This is part of the libb64 project, and has been placed in the public domain.
+For details, see http://sourceforge.net/projects/libb64
+*/
+
+#include <b64/cdecode.h>
+
+int base64_decode_value(char value_in)
+{
+	static const signed char decoding[] = {62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-2,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51};
+	static const char decoding_size = sizeof(decoding);
+	if (value_in < 43) return -1;
+	value_in -= 43;
+	if (value_in >= decoding_size) return -1;
+	return decoding[(int)value_in];
+}
+
+void base64_init_decodestate(base64_decodestate* state_in)
+{
+	state_in->step = step_a;
+	state_in->plainchar = 0;
+}
+
+int base64_decode_block(const char* code_in, const int length_in, char* plaintext_out, base64_decodestate* state_in)
+{
+	const char* codechar = code_in;
+	char* plainchar = plaintext_out;
+	int fragment;
+	
+	if(length_in == 0) {
+    return 0;
+  }
+
+	*plainchar = state_in->plainchar;
+	
+	switch (state_in->step)
+	{
+		while (1)
+		{
+	case step_a:
+			do {
+				if (codechar == code_in+length_in)
+				{
+					state_in->step = step_a;
+					state_in->plainchar = 0; // no state to save; use default value
+					return plainchar - plaintext_out;
+				}
+				fragment = base64_decode_value(*codechar++);
+			} while (fragment < 0);
+			*plainchar    = (fragment & 0x03f) << 2;
+			//lint -fallthrough
+	case step_b:
+			do {
+				if (codechar == code_in+length_in)
+				{
+					state_in->step = step_b;
+					state_in->plainchar = *plainchar;
+					return plainchar - plaintext_out;
+				}
+				fragment = base64_decode_value(*codechar++);
+			} while (fragment < 0);
+			*plainchar++ |= (fragment & 0x030) >> 4;
+			*plainchar    = (fragment & 0x00f) << 4;
+			//lint -fallthrough
+	case step_c:
+			do {
+				if (codechar == code_in+length_in)
+				{
+					state_in->step = step_c;
+					state_in->plainchar = *plainchar;
+					return plainchar - plaintext_out;
+				}
+				fragment = base64_decode_value(*codechar++);
+			} while (fragment < 0);
+			*plainchar++ |= (fragment & 0x03c) >> 2;
+			*plainchar    = (fragment & 0x003) << 6;
+			//lint -fallthrough
+	case step_d:
+			do {
+				if (codechar == code_in+length_in)
+				{
+					state_in->step = step_d;
+					state_in->plainchar = *plainchar;
+					return plainchar - plaintext_out;
+				}
+				fragment = base64_decode_value(*codechar++);
+			} while (fragment < 0);
+			*plainchar++   |= (fragment & 0x03f);
+		}
+	}
+	/* control should not reach here */
+	return plainchar - plaintext_out;
+}
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/libb64/src/cencode.c
@@ -0,0 +1,111 @@
+/*
+cencoder.c - c source to a base64 encoding algorithm implementation
+
+This is part of the libb64 project, and has been placed in the public domain.
+For details, see http://sourceforge.net/projects/libb64
+*/
+
+#include <b64/cencode.h>
+
+const int CHARS_PER_LINE = 72;
+
+void base64_init_encodestate(base64_encodestate* state_in)
+{
+	state_in->step = step_A;
+	state_in->result = 0;
+	state_in->stepcount = 0;
+}
+
+char base64_encode_value(char value_in)
+{
+	static const char* encoding = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+	if (value_in > 63) return '=';
+	return encoding[(int)value_in];
+}
+
+int base64_encode_block(const char* plaintext_in, int length_in, char* code_out, base64_encodestate* state_in)
+{
+	const char* plainchar = plaintext_in;
+	const char* const plaintextend = plaintext_in + length_in;
+	char* codechar = code_out;
+	char result;
+	char fragment;
+	
+	result = state_in->result;
+	
+	switch (state_in->step)
+	{
+		while (1)
+		{
+	case step_A:
+			if (plainchar == plaintextend)
+			{
+				state_in->result = result;
+				state_in->step = step_A;
+				return codechar - code_out;
+			}
+			fragment = *plainchar++;
+			result = (fragment & 0x0fc) >> 2;
+			*codechar++ = base64_encode_value(result);
+			result = (fragment & 0x003) << 4;
+			//lint -fallthrough
+	case step_B:
+			if (plainchar == plaintextend)
+			{
+				state_in->result = result;
+				state_in->step = step_B;
+				return codechar - code_out;
+			}
+			fragment = *plainchar++;
+			result |= (fragment & 0x0f0) >> 4;
+			*codechar++ = base64_encode_value(result);
+			result = (fragment & 0x00f) << 2;
+			//lint -fallthrough
+	case step_C:
+			if (plainchar == plaintextend)
+			{
+				state_in->result = result;
+				state_in->step = step_C;
+				return codechar - code_out;
+			}
+			fragment = *plainchar++;
+			result |= (fragment & 0x0c0) >> 6;
+			*codechar++ = base64_encode_value(result);
+			result  = (fragment & 0x03f) >> 0;
+			*codechar++ = base64_encode_value(result);
+			
+			++(state_in->stepcount);
+			if (state_in->stepcount == CHARS_PER_LINE/4)
+			{
+				*codechar++ = '\n';
+				state_in->stepcount = 0;
+			}
+		}
+	}
+	/* control should not reach here */
+	return codechar - code_out;
+}
+
+int base64_encode_blockend(char* code_out, base64_encodestate* state_in)
+{
+	char* codechar = code_out;
+	
+	switch (state_in->step)
+	{
+	case step_B:
+		*codechar++ = base64_encode_value(state_in->result);
+		*codechar++ = '=';
+		*codechar++ = '=';
+		break;
+	case step_C:
+		*codechar++ = base64_encode_value(state_in->result);
+		*codechar++ = '=';
+		break;
+	case step_A:
+		break;
+	}
+	*codechar++ = '\n';
+	
+	return codechar - code_out;
+}
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/package.xml
@@ -0,0 +1,32 @@
+<package format="2">
+  <name>xmlrpcpp</name>
+  <version>1.16.0</version>
+  <description>
+    XmlRpc++ is a C++ implementation of the XML-RPC protocol. This version is
+    heavily modified from the package available on SourceForge in order to
+    support roscpp's threading model. As such, we are maintaining our
+    own fork.
+  </description>
+  <maintainer email="michael@openrobotics.org">Michael Carroll</maintainer>
+  <maintainer email="sloretz@openrobotics.org">Shane Loretz</maintainer>
+  <license>LGPL-2.1</license>
+
+  <url>http://xmlrpcpp.sourceforge.net</url>
+  <author>Chris Morley</author>
+  <author>Konstantin Pilipchuk</author>
+  <author>Morgan Quigley</author>
+  <author>Austin Hendrix</author>
+  <author email="dthomas@osrfoundation.org">Dirk Thomas</author>
+  <author email="jacob@openrobotics.org">Jacob Perron</author>
+
+  <buildtool_depend>catkin</buildtool_depend>
+
+  <depend>cpp_common</depend>
+  <depend version_gte="0.6.9">rostime</depend>
+
+  <test_depend>libboost-thread-dev</test_depend>
+
+  <export>
+    <rosdoc external="http://xmlrpcpp.sourceforge.net/doc/hierarchy.html"/>
+  </export>
+</package>
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/src/Doxyfile
@@ -0,0 +1,1041 @@
+# Doxyfile 1.3-rc3
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# General configuration options
+#---------------------------------------------------------------------------
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
+# by quotes) that should identify the project.
+
+PROJECT_NAME           = XmlRpc++
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
+# This could be handy for archiving the generated documentation or 
+# if some version control system is used.
+
+PROJECT_NUMBER         = 0.7
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
+# base path where the generated documentation will be put. 
+# If a relative path is entered, it will be relative to the location 
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = ../doc
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
+# documentation generated by doxygen is written. Doxygen will use this 
+# information to generate all constant output in the proper language. 
+# The default language is English, other supported languages are: 
+# Brazilian, Catalan, Chinese, Chinese-Traditional, Croatian, Czech, Danish, Dutch, 
+# Finnish, French, German, Greek, Hungarian, Italian, Japanese, Japanese-en 
+# (Japanese with english messages), Korean, Norwegian, Polish, Portuguese, 
+# Romanian, Russian, Serbian, Slovak, Slovene, Spanish, Swedish and Ukrainian.
+
+OUTPUT_LANGUAGE        = English
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
+# documentation are documented, even if no documentation was available. 
+# Private class members and static file members will be hidden unless 
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file 
+# will be included in the documentation.
+
+EXTRACT_STATIC         = NO
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
+# defined locally in source files will be included in the documentation. 
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
+# undocumented members of documented classes, files or namespaces. 
+# If set to NO (the default) these members will be included in the 
+# various overviews, but no documentation section is generated. 
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
+# undocumented classes that are normally visible in the class hierarchy. 
+# If set to NO (the default) these class will be included in the various 
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = YES
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
+# friend (class|struct|union) declarations. 
+# If set to NO (the default) these declarations will be included in the 
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
+# documentation blocks found inside the body of a function. 
+# If set to NO (the default) these blocks will be appended to the 
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
+# include brief member descriptions after the members that are listed in 
+# the file and class documentation (similar to JavaDoc). 
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
+# the brief description of a member or function before the detailed description. 
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
+# Doxygen will generate a detailed section even if there is only a brief 
+# description.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all inherited 
+# members of a class in the documentation of that class as if those members were 
+# ordinary class members. Constructors, destructors and assignment operators of 
+# the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
+# path before files name in the file list and in the header files. If set 
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
+# can be used to strip a user defined part of the path. Stripping is 
+# only done if one of the specified strings matches the left-hand part of 
+# the path. It is allowed to use relative paths in the argument list.
+
+STRIP_FROM_PATH        = 
+
+# The INTERNAL_DOCS tag determines if documentation 
+# that is typed after a \internal command is included. If the tag is set 
+# to NO (the default) then the documentation will be excluded. 
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
+# file names in lower case letters. If set to YES upper case letters are also 
+# allowed. This is useful if you have classes or files whose names only differ 
+# in case and if your file system supports case sensitive file names. Windows 
+# users are adviced to set this option to NO.
+
+CASE_SENSE_NAMES       = YES
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
+# (but less readable) file names. This can be useful is your file systems 
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
+# will show members with their full class and namespace scopes in the 
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
+# will generate a verbatim copy of the header file for each class for 
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = YES
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
+# will put list of the files that are included by a file in the documentation 
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
+# will interpret the first line (until the first dot) of a JavaDoc-style 
+# comment as the brief description. If set to NO, the JavaDoc 
+# comments  will behave just like the Qt-style comments (thus requiring an 
+# explict @brief command for a brief description.
+
+JAVADOC_AUTOBRIEF      = YES
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
+# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
+# comments) as a brief description. This used to be the default behaviour. 
+# The new default is to treat a multi-line C++ comment block as a detailed 
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the DETAILS_AT_TOP tag is set to YES then Doxygen 
+# will output the detailed description near the top, like JavaDoc.
+# If set to NO, the detailed description appears after the member 
+# documentation.
+
+DETAILS_AT_TOP         = NO
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
+# member inherits the documentation from any documented member that it 
+# reimplements.
+
+INHERIT_DOCS           = YES
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
+# will sort the (detailed) documentation of file and class members 
+# alphabetically by member name. If set to NO the members will appear in 
+# declaration order.
+
+SORT_MEMBER_DOCS       = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
+# tag is set to YES, then doxygen will reuse the documentation of the first 
+# member in the group (if any) for the other members of the group. By default 
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 8
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or 
+# disable (NO) the todo list. This list is created by putting \todo 
+# commands in the documentation.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or 
+# disable (NO) the test list. This list is created by putting \test 
+# commands in the documentation.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or 
+# disable (NO) the bug list. This list is created by putting \bug 
+# commands in the documentation.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
+# disable (NO) the deprecated list. This list is created by putting 
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# This tag can be used to specify a number of aliases that acts 
+# as commands in the documentation. An alias has the form "name=value". 
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
+# put the command \sideeffect (or @sideeffect) in the documentation, which 
+# will result in a user defined paragraph with heading "Side Effects:". 
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                = 
+
+# The ENABLED_SECTIONS tag can be used to enable conditional 
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS       = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
+# the initial value of a variable or define consist of for it to appear in 
+# the documentation. If the initializer consists of more lines than specified 
+# here it will be hidden. Use a value of 0 to hide initializers completely. 
+# The appearance of the initializer of individual variables and defines in the 
+# documentation can be controlled using \showinitializer or \hideinitializer 
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources 
+# only. Doxygen will then generate output that is more tailored for C. 
+# For instance some of the names that are used will be different. The list 
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = NO
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java sources 
+# only. Doxygen will then generate output that is more tailored for Java. 
+# For instance namespaces will be presented as packages, qualified scopes 
+# will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
+# at the bottom of the documentation of classes and structs. If set to YES the 
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated 
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are 
+# generated by doxygen. Possible values are YES and NO. If left blank 
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
+# potential errors in the documentation, such as not documenting some 
+# parameters in a documented function, or documenting parameters that 
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# The WARN_FORMAT tag determines the format of the warning messages that 
+# doxygen can produce. The string should contain the $file, $line, and $text 
+# tags, which will be replaced by the file and line number from which the 
+# warning originated and the warning text.
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning 
+# and error messages should be written. If left blank the output is written 
+# to stderr.
+
+WARN_LOGFILE           = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain 
+# documented source files. You may enter file names like "myfile.cpp" or 
+# directories like "/usr/src/myproject". Separate the files or directories 
+# with spaces.
+
+INPUT                  = 
+
+# If the value of the INPUT tag contains directories, you can use the 
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank the following patterns are tested: 
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx *.hpp 
+# *.h++ *.idl *.odl
+
+FILE_PATTERNS          = 
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
+# should be searched for input files as well. Possible values are YES and NO. 
+# If left blank NO is used.
+
+RECURSIVE              = NO
+
+# The EXCLUDE tag can be used to specify files and/or directories that should 
+# excluded from the INPUT source files. This way you can easily exclude a 
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE                = base64.h
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or directories 
+# that are symbolic links (a Unix filesystem feature) are excluded from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the 
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
+# certain files from those directories.
+
+EXCLUDE_PATTERNS       = 
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or 
+# directories that contain example code fragments that are included (see 
+# the \include command).
+
+EXAMPLE_PATH           = 
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank all files are included.
+
+EXAMPLE_PATTERNS       = 
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
+# searched for input files to be used with the \include or \dontinclude 
+# commands irrespective of the value of the RECURSIVE tag. 
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or 
+# directories that contain image that are included in the documentation (see 
+# the \image command).
+
+IMAGE_PATH             = 
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should 
+# invoke to filter for each input file. Doxygen will invoke the filter program 
+# by executing (via popen()) the command <filter> <input-file>, where <filter> 
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
+# input file. Doxygen will then use the output that the filter program writes 
+# to standard output.
+
+INPUT_FILTER           = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
+# INPUT_FILTER) will be used to filter the input files when producing source 
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
+# be generated. Documented entities will be cross-referenced with these sources.
+
+SOURCE_BROWSER         = NO
+
+# Setting the INLINE_SOURCES tag to YES will include the body 
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
+# doxygen to hide any special comment blocks from generated source code 
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES (the default) 
+# then for each documented function all documented 
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = YES
+
+# If the REFERENCES_RELATION tag is set to YES (the default) 
+# then for each documented function all documented entities 
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index 
+# of all compounds will be generated. Enable this if the project 
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX     = NO
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all 
+# classes will be put under the same header in the alphabetical index. 
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard header.
+
+HTML_HEADER            = 
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard footer.
+
+HTML_FOOTER            = 
+
+# The HTML_STYLESHEET tag can be used to specify a user defined cascading 
+# style sheet that is used by each HTML page. It can be used to 
+# fine-tune the look of the HTML output. If the tag is left blank doxygen 
+# will generate a default style sheet
+
+HTML_STYLESHEET        = 
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
+# files or namespaces will be aligned in HTML using tables. If set to 
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS     = YES
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
+# will be generated that can be used as input for tools like the 
+# Microsoft HTML help workshop to generate a compressed HTML help file (.chm) 
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
+# be used to specify the file name of the resulting .chm file. You 
+# can add a path in front of the file if the result should not be 
+# written to the html output dir.
+
+CHM_FILE               = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
+# be used to specify the location (absolute path including file name) of 
+# the HTML help compiler (hhc.exe). If non empty doxygen will try to run 
+# the html help compiler on the generated index.hhp.
+
+HHC_LOCATION           = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
+# controls if a separate .chi index file is generated (YES) or that 
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
+# controls whether a binary table of contents is generated (YES) or a 
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members 
+# to the contents of the Html help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
+# top of each HTML page. The value NO (the default) enables the index and 
+# the value YES disables it.
+
+DISABLE_INDEX          = NO
+
+# This tag can be used to set the number of enum values (range [1..20]) 
+# that doxygen will group on one line in the generated HTML documentation.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the GENERATE_TREEVIEW tag is set to YES, a side panel will be
+# generated containing a tree-like index structure (just like the one that 
+# is generated for HTML Help). For this to work a browser that supports 
+# JavaScript, DHTML, CSS and frames is required (for instance Mozilla, 
+# Netscape 6.0+, Internet explorer 5.0+, or Konqueror). Windows users are 
+# probably better off using the HTML help feature.
+
+GENERATE_TREEVIEW      = NO
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
+# used to set the initial width (in pixels) of the frame in which the tree 
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
+# generate Latex output.
+
+GENERATE_LATEX         = NO
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
+# invoked. If left blank `latex' will be used as the default command name.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
+# generate index for LaTeX. If left blank `makeindex' will be used as the 
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
+# LaTeX documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used 
+# by the printer. Possible values are: a4, a4wide, letter, legal and 
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = a4wide
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
+# the generated latex document. The header should contain everything until 
+# the first chapter. If it is left blank doxygen will generate a 
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
+# contain links (just like the HTML output) instead of page references 
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = NO
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
+# plain latex in the generated Makefile. Set this option to YES to get a 
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = NO
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
+# command to the generated LaTeX files. This will instruct LaTeX to keep 
+# running if errors occur, instead of asking the user for help. 
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
+# The RTF output is optimised for Word 97 and may not look very pretty with 
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
+# RTF documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
+# will contain hyperlink fields. The RTF file will 
+# contain links (just like the HTML output) instead of page references. 
+# This makes the output suitable for online browsing using WORD or other 
+# programs which support those fields. 
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's 
+# config file, i.e. a series of assigments. You only have to provide 
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    = 
+
+# Set optional variables used in the generation of an rtf document. 
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to 
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
+# then it will generate one additional man file for each entity 
+# documented in the real man page(s). These additional files 
+# only source the real man page, but without them the man command 
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will 
+# generate an XML file that captures the structure of 
+# the code including all documentation. Note that this 
+# feature is still experimental and incomplete at the 
+# moment.
+
+GENERATE_XML           = NO
+
+# The XML_SCHEMA tag can be used to specify an XML schema, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_SCHEMA             = 
+
+# The XML_DTD tag can be used to specify an XML DTD, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_DTD                = 
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
+# generate an AutoGen Definitions (see autogen.sf.net) file 
+# that captures the structure of the code including all 
+# documentation. Note that this feature is still experimental 
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
+# generate a Perl module file that captures the structure of 
+# the code including all documentation. Note that this 
+# feature is still experimental and incomplete at the 
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
+# nicely formatted so it can be parsed by a human reader.  This is useful 
+# if you want to understand what is going on.  On the other hand, if this 
+# tag is set to NO the size of the Perl module output will be much smaller 
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file 
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
+# This is useful so different doxyrules.make files included by the same 
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
+# evaluate all C-preprocessor directives found in the sources and include 
+# files.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
+# names in the source code. If set to NO (the default) only conditional 
+# compilation will be performed. Macro expansion can be done in a controlled 
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
+# then the macro expansion is limited to the macros specified with the 
+# PREDEFINED and EXPAND_AS_PREDEFINED tags.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that 
+# contain include files that are not input files but should be processed by 
+# the preprocessor.
+
+INCLUDE_PATH           = 
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
+# patterns (like *.h and *.hpp) to filter out the header-files in the 
+# directories. If left blank, the patterns specified with FILE_PATTERNS will 
+# be used.
+
+INCLUDE_FILE_PATTERNS  = 
+
+# The PREDEFINED tag can be used to specify one or more macro names that 
+# are defined before the preprocessor is started (similar to the -D option of 
+# gcc). The argument of the tag is a list of macros of the form: name 
+# or name=definition (no spaces). If the definition and the = are 
+# omitted =1 is assumed.
+
+PREDEFINED             = 
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
+# this tag can be used to specify a list of macro names that should be expanded. 
+# The macro definition that is found in the sources will be used. 
+# Use the PREDEFINED tag if you want to use a different macro definition.
+
+EXPAND_AS_DEFINED      = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
+# doxygen's preprocessor will remove all function-like macros that are alone 
+# on a line, have an all uppercase name, and do not end with a semicolon. Such 
+# function macros are typically used for boiler-plate code, and will confuse the 
+# parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::addtions related to external references   
+#---------------------------------------------------------------------------
+
+# The TAGFILES tag can be used to specify one or more tagfiles.
+
+TAGFILES               = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       = 
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
+# in the class index. If set to NO only the inherited external classes 
+# will be listed.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
+# in the modules index. If set to NO, only the current project's groups will 
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script 
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
+# generate a inheritance diagram (in Html, RTF and LaTeX) for classes with base or 
+# super classes. Setting the tag to NO turns the diagrams off. Note that this 
+# option is superceded by the HAVE_DOT option below. This is only a fallback. It is 
+# recommended to install and use dot, since it yield more powerful graphs.
+
+CLASS_DIAGRAMS         = YES
+
+# If set to YES, the inheritance and collaboration graphs will hide 
+# inheritance and usage relations if the target is undocumented 
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
+# available from the path. This tool is part of Graphviz, a graph visualization 
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = NO
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect inheritance relations. Setting this tag to YES will force the 
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect implementation dependencies (inheritance, containment, and 
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = YES
+
+# If set to YES, the inheritance and collaboration graphs will show the 
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
+# tags are set to YES then doxygen will generate a graph for each documented 
+# file showing the direct and indirect include dependencies of the file with 
+# other documented files.
+
+INCLUDE_GRAPH          = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
+# documented header file showing the documented files that directly or 
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
+# will graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
+# generated by dot. Possible values are png, jpg, or gif
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT       = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be 
+# found. If left blank, it is assumed the dot tool can be found on the path.
+
+DOT_PATH               = 
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that 
+# contain dot files that are included in the documentation (see the 
+# \dotfile command).
+
+DOTFILE_DIRS           = 
+
+# The MAX_DOT_GRAPH_WIDTH tag can be used to set the maximum allowed width 
+# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
+# this value, doxygen will try to truncate the graph, so that it fits within 
+# the specified constraint. Beware that most browsers cannot cope with very 
+# large images.
+
+MAX_DOT_GRAPH_WIDTH    = 1024
+
+# The MAX_DOT_GRAPH_HEIGHT tag can be used to set the maximum allows height 
+# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
+# this value, doxygen will try to truncate the graph, so that it fits within 
+# the specified constraint. Beware that most browsers cannot cope with very 
+# large images.
+
+MAX_DOT_GRAPH_HEIGHT   = 1024
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
+# generate a legend page explaining the meaning of the various boxes and 
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
+# remove the intermedate dot files that are used to generate 
+# the various graphs.
+
+DOT_CLEANUP            = YES
+
+#---------------------------------------------------------------------------
+# Configuration::addtions related to the search engine   
+#---------------------------------------------------------------------------
+
+# The SEARCHENGINE tag specifies whether or not a search engine should be 
+# used. If set to NO the values of all tags below this one will be ignored.
+
+SEARCHENGINE           = NO
+
+# The CGI_NAME tag should be the name of the CGI script that 
+# starts the search engine (doxysearch) with the correct parameters. 
+# A script with this name will be generated by doxygen.
+
+CGI_NAME               = search.cgi
+
+# The CGI_URL tag should be the absolute URL to the directory where the 
+# cgi binaries are located. See the documentation of your http daemon for 
+# details.
+
+CGI_URL                = 
+
+# The DOC_URL tag should be the absolute URL to the directory where the 
+# documentation is located. If left blank the absolute path to the 
+# documentation, with file:// prepended to it, will be used.
+
+DOC_URL                = 
+
+# The DOC_ABSPATH tag should be the absolute path to the directory where the 
+# documentation is located. If left blank the directory on the local machine 
+# will be used.
+
+DOC_ABSPATH            = 
+
+# The BIN_ABSPATH tag must point to the directory where the doxysearch binary 
+# is installed.
+
+BIN_ABSPATH            = /usr/local/bin/
+
+# The EXT_DOC_PATHS tag can be used to specify one or more paths to 
+# documentation generated for other projects. This allows doxysearch to search 
+# the documentation for these projects as well.
+
+EXT_DOC_PATHS          = 
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/src/XmlRpcClient.cpp
@@ -0,0 +1,548 @@
+
+#include "xmlrpcpp/XmlRpcClient.h"
+
+#include "xmlrpcpp/XmlRpcSocket.h"
+#include "xmlrpcpp/XmlRpcUtil.h"
+#include "xmlrpcpp/XmlRpcValue.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#ifndef _WINDOWS
+	# include <strings.h>
+#endif
+#include <string.h>
+#include <climits>
+
+
+using namespace XmlRpc;
+
+// Static data
+const char XmlRpcClient::REQUEST_BEGIN[] = 
+  "<?xml version=\"1.0\"?>\r\n"
+  "<methodCall><methodName>";
+const char XmlRpcClient::REQUEST_END_METHODNAME[] = "</methodName>\r\n";
+const char XmlRpcClient::PARAMS_TAG[] = "<params>";
+const char XmlRpcClient::PARAMS_ETAG[] = "</params>";
+const char XmlRpcClient::PARAM_TAG[] = "<param>";
+const char XmlRpcClient::PARAM_ETAG[] =  "</param>";
+const char XmlRpcClient::REQUEST_END[] = "</methodCall>\r\n";
+const char XmlRpcClient::METHODRESPONSE_TAG[] = "<methodResponse>";
+const char XmlRpcClient::FAULT_TAG[] = "<fault>";
+
+
+const char * XmlRpcClient::connectionStateStr(ClientConnectionState state) {
+  switch(state) {
+    case NO_CONNECTION:
+      return "NO_CONNECTION";
+    case CONNECTING:
+      return "CONNECTING";
+    case WRITE_REQUEST:
+      return "WRITE_REQUEST";
+    case READ_HEADER:
+      return "READ_HEADER";
+    case READ_RESPONSE:
+      return "READ_RESPONSE";
+    case IDLE:
+      return "IDLE";
+    default:
+      return "UNKNOWN";
+  }
+}
+
+XmlRpcClient::XmlRpcClient(const char* host, int port, const char* uri/*=0*/)
+  : _connectionState(NO_CONNECTION),
+  _host(host),
+  _port(port),
+  _sendAttempts(0),
+  _bytesWritten(0),
+  _executing(false),
+  _eof(false),
+  _isFault(false),
+  _contentLength(0)
+{
+  XmlRpcUtil::log(1, "XmlRpcClient new client: host %s, port %d.", host, port);
+
+  if (uri)
+    _uri = uri;
+  else
+    _uri = "/RPC2";
+
+  // Default to keeping the connection open until an explicit close is done
+  setKeepOpen();
+}
+
+
+XmlRpcClient::~XmlRpcClient()
+{
+  this->close();
+}
+
+// Close the owned fd
+void
+XmlRpcClient::close()
+{
+  XmlRpcUtil::log(4, "XmlRpcClient::close: fd %d.", getfd());
+  _connectionState = NO_CONNECTION;
+  _disp.exit();
+  _disp.removeSource(this);
+  XmlRpcSource::close();
+}
+
+
+// Clear the referenced flag even if exceptions or errors occur.
+struct ClearFlagOnExit {
+  ClearFlagOnExit(bool& flag) : _flag(flag) {}
+  ~ClearFlagOnExit() { _flag = false; }
+  bool& _flag;
+};
+
+// Execute the named procedure on the remote server.
+// Params should be an array of the arguments for the method.
+// Returns true if the request was sent and a result received (although the result
+// might be a fault).
+bool
+XmlRpcClient::execute(const char* method, XmlRpcValue const& params, XmlRpcValue& result)
+{
+  XmlRpcUtil::log(1, "XmlRpcClient::execute: method %s (_connectionState %s).", method, connectionStateStr(_connectionState));
+
+  // This is not a thread-safe operation, if you want to do multithreading, use separate
+  // clients for each thread. If you want to protect yourself from multiple threads
+  // accessing the same client, replace this code with a real mutex.
+  if (_executing)
+    return false;
+
+  _executing = true;
+  ClearFlagOnExit cf(_executing);
+
+  _sendAttempts = 0;
+  _isFault = false;
+
+  if ( ! setupConnection())
+    return false;
+
+  if ( ! generateRequest(method, params))
+    return false;
+
+  result.clear();
+  double msTime = -1.0;   // Process until exit is called
+  _disp.work(msTime);
+
+  if (_connectionState != IDLE || ! parseResponse(result)) {
+    _header = "";
+    return false;
+  }
+
+  // close() if server does not supports HTTP1.1
+  // otherwise, reusing the socket to write leads to a SIGPIPE because
+  // the remote server could shut down the corresponding socket.
+  if (_header.find("HTTP/1.1 200 OK", 0, 15) != 0) {
+    close();
+  }
+
+  XmlRpcUtil::log(1, "XmlRpcClient::execute: method %s completed.", method);
+  _header = "";
+  _response = "";
+  return true;
+}
+
+// Execute the named procedure on the remote server, non-blocking.
+// Params should be an array of the arguments for the method.
+// Returns true if the request was sent and a result received (although the result
+// might be a fault).
+bool
+XmlRpcClient::executeNonBlock(const char* method, XmlRpcValue const& params)
+{
+  XmlRpcUtil::log(1, "XmlRpcClient::executeNonBlock: method %s (_connectionState %s).", method, connectionStateStr(_connectionState));
+
+  // This is not a thread-safe operation, if you want to do multithreading, use separate
+  // clients for each thread. If you want to protect yourself from multiple threads
+  // accessing the same client, replace this code with a real mutex.
+  if (_executing)
+    return false;
+
+  _executing = true;
+  ClearFlagOnExit cf(_executing);
+
+  _sendAttempts = 0;
+  _isFault = false;
+
+  if ( ! setupConnection())
+    return false;
+
+  if ( ! generateRequest(method, params))
+    return false;
+
+  return true;
+}
+
+bool
+XmlRpcClient::executeCheckDone(XmlRpcValue& result)
+{
+  result.clear();
+  // Are we done yet?
+  // If we lost connection, the call failed.
+  if (_connectionState == NO_CONNECTION) {
+    return true;
+  }
+
+  // Otherwise, assume the call is still in progress.
+  if (_connectionState != IDLE) {
+    return false;
+  }
+
+  if (! parseResponse(result))
+  {
+    // Hopefully the caller can determine that parsing failed.
+  }
+  //XmlRpcUtil::log(1, "XmlRpcClient::execute: method %s completed.", method);
+  _response = "";
+  return true;
+}
+
+// XmlRpcSource interface implementation
+// Handle server responses. Called by the event dispatcher during execute.
+unsigned
+XmlRpcClient::handleEvent(unsigned eventType)
+{
+  if (eventType == XmlRpcDispatch::Exception)
+  {
+    if (_connectionState == WRITE_REQUEST && _bytesWritten == 0)
+      XmlRpcUtil::error("Error in XmlRpcClient::handleEvent: could not connect to server (%s).", 
+                       XmlRpcSocket::getErrorMsg().c_str());
+    else
+      XmlRpcUtil::error("Error in XmlRpcClient::handleEvent (state %s): %s.", 
+                        connectionStateStr(_connectionState),
+                        XmlRpcSocket::getErrorMsg().c_str());
+    return 0;
+  }
+
+  if (_connectionState == WRITE_REQUEST)
+    if ( ! writeRequest()) return 0;
+
+  if (_connectionState == READ_HEADER)
+    if ( ! readHeader()) return 0;
+
+  if (_connectionState == READ_RESPONSE)
+    if ( ! readResponse()) return 0;
+
+  // This should probably always ask for Exception events too
+  return (_connectionState == WRITE_REQUEST) 
+        ? XmlRpcDispatch::WritableEvent : XmlRpcDispatch::ReadableEvent;
+}
+
+
+// Create the socket connection to the server if necessary
+bool
+XmlRpcClient::setupConnection()
+{
+  // If an error occurred last time through, or if the server closed the connection, close our end
+  if ((_connectionState != NO_CONNECTION && _connectionState != IDLE) || _eof)
+    close();
+
+  _eof = false;
+  if (_connectionState == NO_CONNECTION)
+    if (! doConnect()) 
+      return false;
+
+  // Prepare to write the request
+  _connectionState = WRITE_REQUEST;
+  _bytesWritten = 0;
+
+  // Notify the dispatcher to listen on this source (calls handleEvent when the socket is writable)
+  _disp.removeSource(this);       // Make sure nothing is left over
+  _disp.addSource(this, XmlRpcDispatch::WritableEvent | XmlRpcDispatch::Exception);
+
+  return true;
+}
+
+
+// Connect to the xmlrpc server
+bool
+XmlRpcClient::doConnect()
+{
+  int fd = XmlRpcSocket::socket();
+  if (fd < 0)
+  {
+    XmlRpcUtil::error("Error in XmlRpcClient::doConnect: Could not create socket (%s).", XmlRpcSocket::getErrorMsg().c_str());
+    return false;
+  }
+
+  XmlRpcUtil::log(3, "XmlRpcClient::doConnect: fd %d.", fd);
+  this->setfd(fd);
+
+  // Don't block on connect/reads/writes
+  if ( ! XmlRpcSocket::setNonBlocking(fd))
+  {
+    this->close();
+    XmlRpcUtil::error("Error in XmlRpcClient::doConnect: Could not set socket to non-blocking IO mode (%s).", XmlRpcSocket::getErrorMsg().c_str());
+    return false;
+  }
+
+  if ( ! XmlRpcSocket::connect(fd, _host, _port))
+  {
+    this->close();
+    XmlRpcUtil::error("Error in XmlRpcClient::doConnect: Could not connect to server (%s).", XmlRpcSocket::getErrorMsg().c_str());
+    return false;
+  }
+
+  return true;
+}
+
+// Encode the request to call the specified method with the specified parameters into xml
+bool
+XmlRpcClient::generateRequest(const char* methodName, XmlRpcValue const& params)
+{
+  std::string body = REQUEST_BEGIN;
+  body += methodName;
+  body += REQUEST_END_METHODNAME;
+
+  // If params is an array, each element is a separate parameter
+  if (params.valid()) {
+    body += PARAMS_TAG;
+    if (params.getType() == XmlRpcValue::TypeArray)
+    {
+      for (int i=0; i<params.size(); ++i) {
+        body += PARAM_TAG;
+        body += params[i].toXml();
+        body += PARAM_ETAG;
+      }
+    }
+    else
+    {
+      body += PARAM_TAG;
+      body += params.toXml();
+      body += PARAM_ETAG;
+    }
+      
+    body += PARAMS_ETAG;
+  }
+  body += REQUEST_END;
+
+  std::string header = generateHeader(body.length());
+  XmlRpcUtil::log(4, "XmlRpcClient::generateRequest: header is %d bytes, content-length is %d.", 
+                  header.length(), body.length());
+
+  _request = header + body;
+  // Limit the size of the request to avoid integer overruns
+  if (_request.length() > size_t(INT_MAX)) {
+    XmlRpcUtil::error("XmlRpcClient::generateRequest: request length (%u) exceeds maximum allowed size (%u).",
+                      _request.length(), INT_MAX);
+    _request.clear();
+    return false;
+  }
+  return true;
+}
+
+// Prepend http headers
+std::string
+XmlRpcClient::generateHeader(size_t length) const
+{
+  std::string header = 
+    "POST " + _uri + " HTTP/1.1\r\n"
+    "User-Agent: ";
+  header += XMLRPC_VERSION;
+  header += "\r\nHost: ";
+  header += _host;
+
+  char buff[40];
+  std::snprintf(buff,40,":%d\r\n", _port);
+
+  header += buff;
+  header += "Content-Type: text/xml\r\nContent-length: ";
+
+  std::snprintf(buff,40,"%zu\r\n\r\n", length);
+
+  return header + buff;
+}
+
+bool
+XmlRpcClient::writeRequest()
+{
+  if (_bytesWritten == 0)
+    XmlRpcUtil::log(5, "XmlRpcClient::writeRequest (attempt %d):\n%s\n", _sendAttempts+1, _request.c_str());
+
+  // Try to write the request
+  if ( ! XmlRpcSocket::nbWrite(this->getfd(), _request, &_bytesWritten)) {
+    XmlRpcUtil::error("Error in XmlRpcClient::writeRequest: write error (%s).",XmlRpcSocket::getErrorMsg().c_str());
+    // If the write fails, we had an unrecoverable error. Close the socket.
+    close();
+    return false;
+  }
+    
+  XmlRpcUtil::log(3, "XmlRpcClient::writeRequest: wrote %d of %d bytes.", _bytesWritten, _request.length());
+
+  // Wait for the result
+  if (_bytesWritten == int(_request.length())) {
+    _header = "";
+    _response = "";
+    _connectionState = READ_HEADER;
+  } else {
+    // On partial write, remove the portion of the output that was written from
+    // the request buffer.
+    _request = _request.substr(_bytesWritten);
+    _bytesWritten = 0;
+  }
+  return true;
+}
+
+
+// Read the header from the response
+bool
+XmlRpcClient::readHeader()
+{
+  // Read available data
+  if ( ! XmlRpcSocket::nbRead(this->getfd(), _header, &_eof) ||
+       (_eof && _header.length() == 0)) {
+
+    // If we haven't read any data yet and this is a keep-alive connection, the server may
+    // have timed out, so we try one more time.
+    if (getKeepOpen() && _header.length() == 0 && _sendAttempts++ == 0) {
+      XmlRpcUtil::log(4, "XmlRpcClient::readHeader: re-trying connection");
+      XmlRpcSource::close();
+      _connectionState = NO_CONNECTION;
+      _eof = false;
+      return setupConnection();
+    }
+
+    XmlRpcUtil::error("Error in XmlRpcClient::readHeader: error while reading "
+                      "header (%s) on fd %d.",
+                      XmlRpcSocket::getErrorMsg().c_str(), getfd());
+    // Read failed; this means the socket is in an unrecoverable state.
+    // Close the socket.
+    close();
+    return false;
+  }
+
+  XmlRpcUtil::log(4, "XmlRpcClient::readHeader: client has read %d bytes", _header.length());
+
+  char *hp = (char*)_header.c_str();  // Start of header
+  char *ep = hp + _header.length();   // End of string
+  char *bp = 0;                       // Start of body
+  char *lp = 0;                       // Start of content-length value
+
+  for (char *cp = hp; (bp == 0) && (cp < ep); ++cp) {
+    if ((ep - cp > 16) && (strncasecmp(cp, "Content-length: ", 16) == 0))
+      lp = cp + 16;
+    else if ((ep - cp > 4) && (strncmp(cp, "\r\n\r\n", 4) == 0))
+      bp = cp + 4;
+    else if ((ep - cp > 2) && (strncmp(cp, "\n\n", 2) == 0))
+      bp = cp + 2;
+  }
+
+  // If we haven't gotten the entire header yet, return (keep reading)
+  if (bp == 0) {
+    if (_eof)          // EOF in the middle of a response is an error
+    {
+      XmlRpcUtil::error("Error in XmlRpcClient::readHeader: EOF while reading header");
+      close();
+      return false;   // Close the connection
+    }
+    
+    return true;  // Keep reading
+  }
+
+  // Decode content length
+  if (lp == 0) {
+    XmlRpcUtil::error("Error XmlRpcClient::readHeader: No Content-length specified");
+    // Close the socket because we can't make further use of it.
+    close();
+    return false;   // We could try to figure it out by parsing as we read, but for now...
+  }
+
+  // avoid overly large or improperly formatted content-length
+  long int clength = 0;
+  clength = strtol(lp, nullptr, 10);
+  if ((clength <= 0) || (clength > INT_MAX)) {
+    XmlRpcUtil::error("Error in XmlRpcClient::readHeader: Invalid Content-length specified.");
+    // Close the socket because we can't make further use of it.
+    close();
+    return false;
+  }
+  _contentLength = int(clength);
+  	
+  XmlRpcUtil::log(4, "client read content length: %d", _contentLength);
+
+  // Otherwise copy non-header data to response buffer and set state to read response.
+  _response = bp;
+  _connectionState = READ_RESPONSE;
+  return true;    // Continue monitoring this source
+}
+
+    
+bool
+XmlRpcClient::readResponse()
+{
+  // If we dont have the entire response yet, read available data
+  if (int(_response.length()) < _contentLength) {
+    std::string buff;
+    if ( ! XmlRpcSocket::nbRead(this->getfd(), buff, &_eof)) {
+      XmlRpcUtil::error("Error in XmlRpcClient::readResponse: read error (%s).",XmlRpcSocket::getErrorMsg().c_str());
+      // nbRead returned an error, indicating that the socket is in a bad state.
+      // close it and stop monitoring this client.
+      close();
+      return false;
+    }
+    _response += buff;
+
+    // Avoid an overly large response
+    if (_response.length() > size_t(INT_MAX)) {
+      XmlRpcUtil::error("XmlRpcClient::readResponse: response length (%u) exceeds the maximum allowed size (%u).",
+                        _response.length(), INT_MAX);
+      _response.clear();
+      close();
+      return false;
+    }
+    // If we haven't gotten the entire _response yet, return (keep reading)
+    if (int(_response.length()) < _contentLength) {
+      if (_eof) {
+        XmlRpcUtil::error("Error in XmlRpcClient::readResponse: EOF while reading response");
+        // nbRead returned an eof, indicating that the socket is disconnected.
+        // close it and stop monitoring this client.
+        close();
+        return false;
+      }
+      return true;
+    }
+  }
+
+  // Otherwise, parse and return the result
+  XmlRpcUtil::log(3, "XmlRpcClient::readResponse (read %d bytes)", _response.length());
+  XmlRpcUtil::log(5, "response:\n%s", _response.c_str());
+
+  _connectionState = IDLE;
+
+  return false;    // Stop monitoring this source (causes return from work)
+}
+
+
+// Convert the response xml into a result value
+bool
+XmlRpcClient::parseResponse(XmlRpcValue& result)
+{
+  // Parse response xml into result
+  int offset = 0;
+  if ( ! XmlRpcUtil::findTag(METHODRESPONSE_TAG,_response,&offset)) {
+    XmlRpcUtil::error("Error in XmlRpcClient::parseResponse: Invalid response - no methodResponse. Response:\n%s", _response.c_str());
+    return false;
+  }
+
+  // Expect either <params><param>... or <fault>...
+  if ((XmlRpcUtil::nextTagIs(PARAMS_TAG,_response,&offset) &&
+       XmlRpcUtil::nextTagIs(PARAM_TAG,_response,&offset)) ||
+      (XmlRpcUtil::nextTagIs(FAULT_TAG,_response,&offset) && (_isFault = true)))
+  {
+    if ( ! result.fromXml(_response, &offset)) {
+      XmlRpcUtil::error("Error in XmlRpcClient::parseResponse: Invalid response value. Response:\n%s", _response.c_str());
+      _response = "";
+      return false;
+    }
+  } else {
+    XmlRpcUtil::error("Error in XmlRpcClient::parseResponse: Invalid response - no param or fault tag. Response:\n%s", _response.c_str());
+    _response = "";
+    return false;
+  }
+      
+  _response = "";
+  return result.valid();
+}
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/src/XmlRpcDispatch.cpp
@@ -0,0 +1,291 @@
+
+#include "xmlrpcpp/XmlRpcDispatch.h"
+#include "xmlrpcpp/XmlRpcSource.h"
+#include "xmlrpcpp/XmlRpcUtil.h"
+
+#include "ros/time.h"
+
+#include <math.h>
+#include <errno.h>
+#include <sys/timeb.h>
+
+#if defined(_WINDOWS)
+# include <winsock2.h>
+static int poll( struct pollfd *pfd, int nfds, int timeout)
+{
+  // workaround: "Windows 8 Bugs 309411 â WSAPoll does not report failed connections"
+  // https://curl.haxx.se/mail/lib-2012-10/0038.html
+  // the following logic is to use select() to check all writable socket connnection status.
+  // if all the sockets to be checked are not connected, it reports SOCKET_ERROR to
+  // error out, instead of going to WSAPoll() which causes infinitely wait situation.
+  FD_SET writable;
+  FD_SET error;
+  FD_ZERO(&writable);
+  FD_ZERO(&error);
+  for (int i = 0; i < nfds; ++i)
+  {
+    if (pfd[i].events & POLLOUT)
+    {
+      FD_SET(pfd[i].fd, &writable);
+      FD_SET(pfd[i].fd, &error);
+    }
+  }
+
+  int connectionError = 0;
+  if (writable.fd_count > 0)
+  {
+    int result = select(0, nullptr, &writable, &error, nullptr);
+    if (SOCKET_ERROR == result)
+    {
+      return SOCKET_ERROR;
+    }
+
+    if (0 != result)
+    {
+      for (int i = 0; i < nfds; ++i)
+      {
+        if ((pfd[i].events & POLLOUT) &&
+            (FD_ISSET(pfd[i].fd, &error)))
+        {
+          connectionError++;
+        }
+      }
+    }
+  }
+
+  if (connectionError == nfds)
+  {
+    // error out if all sockets are failed to connect.
+    return SOCKET_ERROR;
+  }
+  else
+  {
+    return WSAPoll(pfd, nfds, timeout);
+  }
+}
+
+# define USE_FTIME
+# if defined(_MSC_VER)
+#  define timeb _timeb
+#  define ftime _ftime_s
+# endif
+#else
+# include <sys/poll.h>
+# include <sys/time.h>
+#endif  // _WINDOWS
+
+
+using namespace XmlRpc;
+
+
+XmlRpcDispatch::XmlRpcDispatch()
+{
+  _endTime = -1.0;
+  _doClear = false;
+  _inWork = false;
+}
+
+
+XmlRpcDispatch::~XmlRpcDispatch()
+{
+}
+
+// Monitor this source for the specified events and call its event handler
+// when the event occurs
+void
+XmlRpcDispatch::addSource(XmlRpcSource* source, unsigned mask)
+{
+  _sources.push_back(MonitoredSource(source, mask));
+}
+
+// Stop monitoring this source. Does not close the source.
+void
+XmlRpcDispatch::removeSource(XmlRpcSource* source)
+{
+  for (SourceList::iterator it=_sources.begin(); it!=_sources.end(); ++it)
+    if (it->getSource() == source)
+    {
+      _sources.erase(it);
+      break;
+    }
+}
+
+
+// Modify the types of events to watch for on this source
+void
+XmlRpcDispatch::setSourceEvents(XmlRpcSource* source, unsigned eventMask)
+{
+  for (SourceList::iterator it=_sources.begin(); it!=_sources.end(); ++it)
+    if (it->getSource() == source)
+    {
+      it->getMask() = eventMask;
+      break;
+    }
+}
+
+
+
+// Watch current set of sources and process events
+void
+XmlRpcDispatch::work(double timeout)
+{
+  // Loosely based on `man select` > Correspondence between select() and poll() notifications
+  // and cloudius-systems/osv#35, cloudius-systems/osv@b53d39a using poll to emulate select
+  const unsigned POLLIN_REQ = POLLIN; // Request read
+  const unsigned POLLIN_CHK = (POLLIN | POLLHUP | POLLERR); // Readable or connection lost
+  const unsigned POLLOUT_REQ = POLLOUT; // Request write
+  const unsigned POLLOUT_CHK = (POLLOUT | POLLERR); // Writable or connection lost
+#if !defined(_WINDOWS)
+  const unsigned POLLEX_REQ = POLLPRI; // Out-of-band data received
+  const unsigned POLLEX_CHK = (POLLPRI | POLLNVAL); // Out-of-band data or invalid fd
+#else
+  const unsigned POLLEX_REQ = POLLRDBAND; // Out-of-band data received
+  const unsigned POLLEX_CHK = (POLLRDBAND | POLLNVAL); // Out-of-band data or invalid fd
+#endif
+
+  // Compute end time
+  _endTime = (timeout < 0.0) ? -1.0 : (getTime() + timeout);
+  _doClear = false;
+  _inWork = true;
+  int timeout_ms = static_cast<int>(floor(timeout * 1000.));
+
+  // Only work while there is something to monitor
+  while (_sources.size() > 0) {
+
+    // Construct the sets of descriptors we are interested in
+    const unsigned source_cnt = _sources.size();
+    std::vector<pollfd> fds(source_cnt);
+    std::vector<XmlRpcSource *> sources(source_cnt);
+
+    SourceList::iterator it;
+    std::size_t i = 0;
+    for (it=_sources.begin(); it!=_sources.end(); ++it, ++i) {
+      sources[i] = it->getSource();
+      fds[i].fd = sources[i]->getfd();
+      fds[i].revents = 0; // some platforms may not clear this in poll()
+      fds[i].events = 0;
+      if (it->getMask() & ReadableEvent) fds[i].events |= POLLIN_REQ;
+      if (it->getMask() & WritableEvent) fds[i].events |= POLLOUT_REQ;
+      if (it->getMask() & Exception) fds[i].events |= POLLEX_REQ;
+    }
+
+    // Check for events
+    int nEvents = poll(&fds[0], source_cnt, (timeout_ms < 0) ? -1 : timeout_ms);
+
+    if (nEvents < 0)
+    {
+#if defined(_WINDOWS)
+      XmlRpcUtil::error("Error in XmlRpcDispatch::work: error in poll (%d).", WSAGetLastError());
+#else
+      if(errno != EINTR)
+        XmlRpcUtil::error("Error in XmlRpcDispatch::work: error in poll (%d).", nEvents);
+#endif
+      _inWork = false;
+      return;
+    }
+
+    // Process events
+    for (i=0; i < source_cnt; ++i)
+    {
+      XmlRpcSource* src = sources[i];
+      pollfd & pfd = fds[i];
+      unsigned newMask = (unsigned) -1;
+      // Only handle requested events to avoid being prematurely removed from dispatch
+      bool readable = (pfd.events & POLLIN_REQ) == POLLIN_REQ;
+      bool writable = (pfd.events & POLLOUT_REQ) == POLLOUT_REQ;
+      bool oob = (pfd.events & POLLEX_REQ) == POLLEX_REQ;
+      if (readable && (pfd.revents & POLLIN_CHK))
+        newMask &= src->handleEvent(ReadableEvent);
+      if (writable && (pfd.revents & POLLOUT_CHK))
+        newMask &= src->handleEvent(WritableEvent);
+      if (oob && (pfd.revents & POLLEX_CHK))
+        newMask &= src->handleEvent(Exception);
+
+      // Find the source iterator. It may have moved as a result of the way
+      // that sources are removed and added in the call stack starting
+      // from the handleEvent() calls above.
+      SourceList::iterator thisIt;
+      for (thisIt = _sources.begin(); thisIt != _sources.end(); thisIt++)
+      {
+        if(thisIt->getSource() == src)
+          break;
+      }
+      if(thisIt == _sources.end())
+      {
+        XmlRpcUtil::error("Error in XmlRpcDispatch::work: couldn't find source iterator");
+        continue;
+      }
+
+      if ( ! newMask) {
+        _sources.erase(thisIt);  // Stop monitoring this one
+        if ( ! src->getKeepOpen())
+          src->close();
+      } else if (newMask != (unsigned) -1) {
+        thisIt->getMask() = newMask;
+      }
+    }
+
+    // Check whether to clear all sources
+    if (_doClear)
+    {
+      SourceList closeList = _sources;
+      _sources.clear();
+      for (SourceList::iterator it=closeList.begin(); it!=closeList.end(); ++it) {
+	XmlRpcSource *src = it->getSource();
+        src->close();
+      }
+
+      _doClear = false;
+    }
+
+    // Check whether end time has passed
+    if (0 <= _endTime && getTime() > _endTime)
+      break;
+  }
+
+  _inWork = false;
+}
+
+
+// Exit from work routine. Presumably this will be called from
+// one of the source event handlers.
+void
+XmlRpcDispatch::exit()
+{
+  _endTime = 0.0;   // Return from work asap
+}
+
+// Clear all sources from the monitored sources list
+void
+XmlRpcDispatch::clear()
+{
+  if (_inWork)
+    _doClear = true;  // Finish reporting current events before clearing
+  else
+  {
+    SourceList closeList = _sources;
+    _sources.clear();
+    for (SourceList::iterator it=closeList.begin(); it!=closeList.end(); ++it)
+      it->getSource()->close();
+  }
+}
+
+
+double
+XmlRpcDispatch::getTime()
+{
+#ifdef USE_FTIME
+  struct timeb	tbuff;
+
+  ftime(&tbuff);
+  return ((double) tbuff.time + ((double)tbuff.millitm / 1000.0) +
+	  ((double) tbuff.timezone * 60));
+#else
+  uint32_t sec, nsec;
+
+  ros::ros_steadytime(sec, nsec);
+  return ((double)sec + (double)nsec / 1e9);
+#endif /* USE_FTIME */
+}
+
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/src/XmlRpcServer.cpp
@@ -0,0 +1,390 @@
+// this file modified by Morgan Quigley on 22 Apr 2008.
+// added features: server can be opened on port 0 and you can read back
+// what port the OS gave you
+
+#include "xmlrpcpp/XmlRpcServer.h"
+#include "xmlrpcpp/XmlRpcServerConnection.h"
+#include "xmlrpcpp/XmlRpcServerMethod.h"
+#include "xmlrpcpp/XmlRpcSocket.h"
+#include "xmlrpcpp/XmlRpcUtil.h"
+#include "xmlrpcpp/XmlRpcException.h"
+
+#include <errno.h>
+#include <string.h>
+#if !defined(_WINDOWS)
+# include <sys/resource.h>
+#else
+# include <winsock2.h>
+#endif
+
+using namespace XmlRpc;
+
+const int XmlRpcServer::FREE_FD_BUFFER = 32;
+const double XmlRpcServer::ACCEPT_RETRY_INTERVAL_SEC = 1.0;
+
+XmlRpcServer::XmlRpcServer()
+  : _introspectionEnabled(false),
+    _listMethods(0),
+    _methodHelp(0),
+    _port(0),
+    _accept_error(false),
+    _accept_retry_time_sec(0.0)
+{
+#if !defined(_WINDOWS)
+  struct rlimit limit = { .rlim_cur = 0, .rlim_max = 0 };
+  unsigned int max_files = 1024;
+
+  if(getrlimit(RLIMIT_NOFILE, &limit) == 0) {
+    max_files = limit.rlim_max;
+    if( limit.rlim_max == RLIM_INFINITY ) {
+      max_files = 0;
+    }
+  } else {
+    XmlRpcUtil::error("Could not get open file limit: %s", strerror(errno));
+  }
+  pollfds.resize(max_files);
+  for(unsigned int i=0; i<max_files; i++) {
+    // Set up file descriptor query for all events.
+    pollfds[i].fd = i;
+    pollfds[i].events = POLLIN | POLLPRI | POLLOUT;
+  }
+#endif
+
+  // Ask dispatch not to close this socket if it becomes unreadable.
+  setKeepOpen(true);
+}
+
+
+XmlRpcServer::~XmlRpcServer()
+{
+  this->shutdown();
+  _methods.clear();
+  delete _listMethods;
+  delete _methodHelp;
+}
+
+
+// Add a command to the RPC server
+void 
+XmlRpcServer::addMethod(XmlRpcServerMethod* method)
+{
+  _methods[method->name()] = method;
+}
+
+// Remove a command from the RPC server
+void 
+XmlRpcServer::removeMethod(XmlRpcServerMethod* method)
+{
+  MethodMap::iterator i = _methods.find(method->name());
+  if (i != _methods.end())
+    _methods.erase(i);
+}
+
+// Remove a command from the RPC server by name
+void 
+XmlRpcServer::removeMethod(const std::string& methodName)
+{
+  MethodMap::iterator i = _methods.find(methodName);
+  if (i != _methods.end())
+    _methods.erase(i);
+}
+
+
+// Look up a method by name
+XmlRpcServerMethod* 
+XmlRpcServer::findMethod(const std::string& name) const
+{
+  MethodMap::const_iterator i = _methods.find(name);
+  if (i == _methods.end())
+    return 0;
+  return i->second;
+}
+
+
+// Create a socket, bind to the specified port, and
+// set it in listen mode to make it available for clients.
+bool 
+XmlRpcServer::bindAndListen(int port, int backlog /*= 5*/)
+{
+  int fd = XmlRpcSocket::socket();
+  if (fd < 0)
+  {
+    XmlRpcUtil::error("XmlRpcServer::bindAndListen: Could not create socket (%s).", XmlRpcSocket::getErrorMsg().c_str());
+    return false;
+  }
+
+  this->setfd(fd);
+
+  // Don't block on reads/writes
+  if ( ! XmlRpcSocket::setNonBlocking(fd))
+  {
+    this->close();
+    XmlRpcUtil::error("XmlRpcServer::bindAndListen: Could not set socket to non-blocking input mode (%s).", XmlRpcSocket::getErrorMsg().c_str());
+    return false;
+  }
+
+  // Allow this port to be re-bound immediately so server re-starts are not delayed
+  if ( ! XmlRpcSocket::setReuseAddr(fd))
+  {
+    this->close();
+    XmlRpcUtil::error("XmlRpcServer::bindAndListen: Could not set SO_REUSEADDR socket option (%s).", XmlRpcSocket::getErrorMsg().c_str());
+    return false;
+  }
+
+  // Bind to the specified port on the default interface
+  if ( ! XmlRpcSocket::bind(fd, port))
+  {
+    this->close();
+    XmlRpcUtil::error("XmlRpcServer::bindAndListen: Could not bind to specified port (%s).", XmlRpcSocket::getErrorMsg().c_str());
+    return false;
+  }
+
+  // Set in listening mode
+  if ( ! XmlRpcSocket::listen(fd, backlog))
+  {
+    this->close();
+    XmlRpcUtil::error("XmlRpcServer::bindAndListen: Could not set socket in listening mode (%s).", XmlRpcSocket::getErrorMsg().c_str());
+    return false;
+  }
+
+  _port = XmlRpcSocket::get_port(fd);
+
+  XmlRpcUtil::log(2, "XmlRpcServer::bindAndListen: server listening on port %d fd %d", _port, fd);
+
+  // Notify the dispatcher to listen on this source when we are in work()
+  _disp.addSource(this, XmlRpcDispatch::ReadableEvent);
+
+  return true;
+}
+
+
+// Process client requests for the specified time
+void 
+XmlRpcServer::work(double msTime)
+{
+  XmlRpcUtil::log(2, "XmlRpcServer::work: waiting for a connection");
+  if(_accept_error && _disp.getTime() > _accept_retry_time_sec) {
+    _disp.addSource(this, XmlRpcDispatch::ReadableEvent);
+  }
+  _disp.work(msTime);
+}
+
+
+
+// Handle input on the server socket by accepting the connection
+// and reading the rpc request.
+unsigned
+XmlRpcServer::handleEvent(unsigned)
+{
+  return acceptConnection();
+}
+
+
+// Accept a client connection request and create a connection to
+// handle method calls from the client.
+unsigned
+XmlRpcServer::acceptConnection()
+{
+  int s = XmlRpcSocket::accept(this->getfd());
+  XmlRpcUtil::log(2, "XmlRpcServer::acceptConnection: socket %d", s);
+  if (s < 0)
+  {
+    //this->close();
+    XmlRpcUtil::error("XmlRpcServer::acceptConnection: Could not accept connection (%s).", XmlRpcSocket::getErrorMsg().c_str());
+
+    // Note that there was an accept error; retry in 1 second
+    _accept_error = true;
+    _accept_retry_time_sec = _disp.getTime() + ACCEPT_RETRY_INTERVAL_SEC;
+    return 0; // Stop monitoring this FD
+  }
+  else if ( !enoughFreeFDs() )
+  {
+    XmlRpcSocket::close(s);
+    XmlRpcUtil::error("XmlRpcServer::acceptConnection: Rejecting client, not enough free file descriptors");
+  }
+  else if ( ! XmlRpcSocket::setNonBlocking(s))
+  {
+    XmlRpcSocket::close(s);
+    XmlRpcUtil::error("XmlRpcServer::acceptConnection: Could not set socket to non-blocking input mode (%s).", XmlRpcSocket::getErrorMsg().c_str());
+  }
+  else  // Notify the dispatcher to listen for input on this source when we are in work()
+  {
+    _accept_error = false;
+    XmlRpcUtil::log(2, "XmlRpcServer::acceptConnection: creating a connection");
+    _disp.addSource(this->createConnection(s), XmlRpcDispatch::ReadableEvent);
+  }
+  return XmlRpcDispatch::ReadableEvent; // Continue to monitor this fd
+}
+
+bool XmlRpcServer::enoughFreeFDs() {
+  // This function is just to check if enough FDs are there.
+  //
+  // If the underlying system calls here fail, this will print an error and
+  // return false
+
+#if !defined(_WINDOWS)
+  int free_fds = 0;
+
+  struct rlimit limit = { .rlim_cur = 0, .rlim_max = 0 };
+
+  // Get the current soft limit on the number of file descriptors.
+  if(getrlimit(RLIMIT_NOFILE, &limit) == 0) {
+    // If we have infinite file descriptors, always return true.
+    if( limit.rlim_max == RLIM_INFINITY ) {
+      return true;
+    }
+
+    // Poll the available file descriptors.
+    // The POSIX specification guarantees that rlim_cur will always be less or
+    // equal to the process's initial rlim_max, so we don't need an additional
+    // bounds check here.
+    if(poll(&pollfds[0], limit.rlim_cur, 1) >= 0) {
+      for(rlim_t i=0; i<limit.rlim_cur; i++) {
+        if(pollfds[i].revents & POLLNVAL) {
+          free_fds++;
+        }
+        if (free_fds >= FREE_FD_BUFFER) {
+          // Checked enough FDs are not opened.
+          return true;
+        }
+      }
+    } else {
+      // poll() may fail if interrupted, if the pollfds array is a bad pointer,
+      // if nfds exceeds RLIMIT_NOFILE, or if the system is out of memory.
+      XmlRpcUtil::error("XmlRpcServer::enoughFreeFDs: poll() failed: %s",
+                        strerror(errno));
+    }
+  } else {
+    // The man page for getrlimit says that it can fail if the requested
+    // resource is invalid or the second argument is invalid. I'm not sure
+    // either of these can actually fail in this code, but it's better to
+    // check.
+    XmlRpcUtil::error("XmlRpcServer::enoughFreeFDs: Could not get open file "
+                      "limit, getrlimit() failed: %s", strerror(errno));
+  }
+
+  return false;
+#else
+  return true;
+#endif
+}
+
+
+// Create a new connection object for processing requests from a specific client.
+XmlRpcServerConnection*
+XmlRpcServer::createConnection(int s)
+{
+  // Specify that the connection object be deleted when it is closed
+  return new XmlRpcServerConnection(s, this, true);
+}
+
+
+void 
+XmlRpcServer::removeConnection(XmlRpcServerConnection* sc)
+{
+  _disp.removeSource(sc);
+}
+
+
+// Stop processing client requests
+void 
+XmlRpcServer::exit()
+{
+  _disp.exit();
+}
+
+
+// Close the server socket file descriptor and stop monitoring connections
+void 
+XmlRpcServer::shutdown()
+{
+  // This closes and destroys all connections as well as closing this socket
+  _disp.clear();
+}
+
+
+// Introspection support
+static const std::string LIST_METHODS("system.listMethods");
+static const std::string METHOD_HELP("system.methodHelp");
+static const std::string MULTICALL("system.multicall");
+
+
+// List all methods available on a server
+class ListMethods : public XmlRpcServerMethod
+{
+public:
+  ListMethods(XmlRpcServer* s) : XmlRpcServerMethod(LIST_METHODS, s) {}
+
+  void execute(XmlRpcValue&, XmlRpcValue& result)
+  {
+    _server->listMethods(result);
+  }
+
+  std::string help() { return std::string("List all methods available on a server as an array of strings"); }
+};
+
+
+// Retrieve the help string for a named method
+class MethodHelp : public XmlRpcServerMethod
+{
+public:
+  MethodHelp(XmlRpcServer* s) : XmlRpcServerMethod(METHOD_HELP, s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    if (params[0].getType() != XmlRpcValue::TypeString)
+      throw XmlRpcException(METHOD_HELP + ": Invalid argument type");
+
+    XmlRpcServerMethod* m = _server->findMethod(params[0]);
+    if ( ! m)
+      throw XmlRpcException(METHOD_HELP + ": Unknown method name");
+
+    result = m->help();
+  }
+
+  std::string help() { return std::string("Retrieve the help string for a named method"); }
+};
+
+    
+// Specify whether introspection is enabled or not. Default is enabled.
+void 
+XmlRpcServer::enableIntrospection(bool enabled)
+{
+  if (_introspectionEnabled == enabled)
+    return;
+
+  _introspectionEnabled = enabled;
+
+  if (enabled)
+  {
+    if ( ! _listMethods)
+    {
+      _listMethods = new ListMethods(this);
+      _methodHelp = new MethodHelp(this);
+    } else {
+      addMethod(_listMethods);
+      addMethod(_methodHelp);
+    }
+  }
+  else
+  {
+    removeMethod(LIST_METHODS);
+    removeMethod(METHOD_HELP);
+  }
+}
+
+
+void
+XmlRpcServer::listMethods(XmlRpcValue& result)
+{
+  int i = 0;
+  result.setSize(_methods.size()+1);
+  for (MethodMap::iterator it=_methods.begin(); it != _methods.end(); ++it)
+    result[i++] = it->first;
+
+  // Multicall support is built into XmlRpcServerConnection
+  result[i] = MULTICALL;
+}
+
+
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/src/XmlRpcServerConnection.cpp
@@ -0,0 +1,400 @@
+
+#include "xmlrpcpp/XmlRpcServerConnection.h"
+
+#include "xmlrpcpp/XmlRpcSocket.h"
+#include "xmlrpcpp/XmlRpc.h"
+#ifndef MAKEDEPEND
+# include <stdio.h>
+# include <stdlib.h>
+#ifndef _WINDOWS
+	# include <strings.h>
+#endif
+# include <string.h>
+#endif
+#include <climits>
+
+using namespace XmlRpc;
+
+// Static data
+const char XmlRpcServerConnection::METHODNAME_TAG[] = "<methodName>";
+const char XmlRpcServerConnection::PARAMS_TAG[] = "<params>";
+const char XmlRpcServerConnection::PARAMS_ETAG[] = "</params>";
+const char XmlRpcServerConnection::PARAM_TAG[] = "<param>";
+const char XmlRpcServerConnection::PARAM_ETAG[] = "</param>";
+
+const std::string XmlRpcServerConnection::SYSTEM_MULTICALL = "system.multicall";
+const std::string XmlRpcServerConnection::METHODNAME = "methodName";
+const std::string XmlRpcServerConnection::PARAMS = "params";
+
+const std::string XmlRpcServerConnection::FAULTCODE = "faultCode";
+const std::string XmlRpcServerConnection::FAULTSTRING = "faultString";
+
+
+
+// The server delegates handling client requests to a serverConnection object.
+XmlRpcServerConnection::XmlRpcServerConnection(int fd, XmlRpcServer* server, bool deleteOnClose /*= false*/) :
+  XmlRpcSource(fd, deleteOnClose)
+{
+  XmlRpcUtil::log(2,"XmlRpcServerConnection: new socket %d.", fd);
+  _server = server;
+  _connectionState = READ_HEADER;
+  _contentLength = 0;
+  _bytesWritten = 0;
+  _keepAlive = true;
+}
+
+
+XmlRpcServerConnection::~XmlRpcServerConnection()
+{
+  XmlRpcUtil::log(4,"XmlRpcServerConnection dtor.");
+  _server->removeConnection(this);
+}
+
+
+// Handle input on the server socket by accepting the connection
+// and reading the rpc request. Return true to continue to monitor
+// the socket for events, false to remove it from the dispatcher.
+unsigned
+XmlRpcServerConnection::handleEvent(unsigned /*eventType*/)
+{
+  if (_connectionState == READ_HEADER)
+    if ( ! readHeader()) return 0;
+
+  if (_connectionState == READ_REQUEST)
+    if ( ! readRequest()) return 0;
+
+  if (_connectionState == WRITE_RESPONSE)
+    if ( ! writeResponse()) return 0;
+
+  return (_connectionState == WRITE_RESPONSE) 
+        ? XmlRpcDispatch::WritableEvent : XmlRpcDispatch::ReadableEvent;
+}
+
+
+bool
+XmlRpcServerConnection::readHeader()
+{
+  // Read available data
+  bool eof;
+  if ( ! XmlRpcSocket::nbRead(this->getfd(), _header, &eof)) {
+    // Its only an error if we already have read some data
+    if (_header.length() > 0)
+      XmlRpcUtil::error("XmlRpcServerConnection::readHeader: error while reading header (%s).",XmlRpcSocket::getErrorMsg().c_str());
+    return false;
+  }
+
+  XmlRpcUtil::log(4, "XmlRpcServerConnection::readHeader: read %d bytes.", _header.length());
+  char *hp = (char*)_header.c_str();  // Start of header
+  char *ep = hp + _header.length();   // End of string
+  char *bp = 0;                       // Start of body
+  char *lp = 0;                       // Start of content-length value
+  char *kp = 0;                       // Start of connection value
+
+  for (char *cp = hp; (bp == 0) && (cp < ep); ++cp) {
+	if ((ep - cp > 16) && (strncasecmp(cp, "Content-length: ", 16) == 0))
+	  lp = cp + 16;
+	else if ((ep - cp > 12) && (strncasecmp(cp, "Connection: ", 12) == 0))
+	  kp = cp + 12;
+	else if ((ep - cp > 4) && (strncmp(cp, "\r\n\r\n", 4) == 0))
+	  bp = cp + 4;
+	else if ((ep - cp > 2) && (strncmp(cp, "\n\n", 2) == 0))
+	  bp = cp + 2;
+  }
+
+  // If we haven't gotten the entire header yet, return (keep reading)
+  if (bp == 0) {
+    // EOF in the middle of a request is an error, otherwise its ok
+    if (eof) {
+      XmlRpcUtil::log(4, "XmlRpcServerConnection::readHeader: EOF");
+      if (_header.length() > 0)
+        XmlRpcUtil::error("XmlRpcServerConnection::readHeader: EOF while reading header");
+      return false;   // Either way we close the connection
+    }
+    
+    return true;  // Keep reading
+  }
+
+  // Decode content length
+  if (lp == 0) {
+    XmlRpcUtil::error("XmlRpcServerConnection::readHeader: No Content-length specified");
+    return false;   // We could try to figure it out by parsing as we read, but for now...
+  }
+
+  // avoid overly large or improperly formatted content-length
+  long int clength = 0;
+  clength = strtol(lp, nullptr, 10);
+  if ((clength < 0) || (clength > INT_MAX)) {
+    XmlRpcUtil::error("XmlRpcServerConnection::readHeader: Invalid Content-length specified.");
+    return false;
+  }
+  _contentLength = int(clength);
+  	
+  XmlRpcUtil::log(3, "XmlRpcServerConnection::readHeader: specified content length is %d.", _contentLength);
+
+  // Otherwise copy non-header data to request buffer and set state to read request.
+  _request = bp;
+
+  // Parse out any interesting bits from the header (HTTP version, connection)
+  _keepAlive = true;
+  if (_header.find("HTTP/1.0") != std::string::npos) {
+    if (kp == 0 || strncasecmp(kp, "keep-alive", 10) != 0)
+      _keepAlive = false;           // Default for HTTP 1.0 is to close the connection
+  } else {
+    if (kp != 0 && strncasecmp(kp, "close", 5) == 0)
+      _keepAlive = false;
+  }
+  XmlRpcUtil::log(3, "KeepAlive: %d", _keepAlive);
+
+
+  _header = ""; 
+  _connectionState = READ_REQUEST;
+  return true;    // Continue monitoring this source
+}
+
+bool
+XmlRpcServerConnection::readRequest()
+{
+  // If we dont have the entire request yet, read available data
+  if (int(_request.length()) < _contentLength) {
+    bool eof;
+    if ( ! XmlRpcSocket::nbRead(this->getfd(), _request, &eof)) {
+      XmlRpcUtil::error("XmlRpcServerConnection::readRequest: read error (%s).",XmlRpcSocket::getErrorMsg().c_str());
+      return false;
+    }
+    // Avoid an overly large request
+    if (_request.length() > size_t(INT_MAX)) {
+      XmlRpcUtil::error("XmlRpcServerConnection::readRequest: request length (%u) exceeds the maximum allowed size (%u)",
+                        _request.length(), INT_MAX);
+      _request.resize(INT_MAX);
+      return false;
+    }
+
+    // If we haven't gotten the entire request yet, return (keep reading)
+    if (int(_request.length()) < _contentLength) {
+      if (eof) {
+        XmlRpcUtil::error("XmlRpcServerConnection::readRequest: EOF while reading request");
+        return false;   // Either way we close the connection
+      }
+      return true;
+    }
+  }
+
+  // Otherwise, parse and dispatch the request
+  XmlRpcUtil::log(3, "XmlRpcServerConnection::readRequest read %d bytes.", _request.length());
+  //XmlRpcUtil::log(5, "XmlRpcServerConnection::readRequest:\n%s\n", _request.c_str());
+
+  _connectionState = WRITE_RESPONSE;
+
+  return true;    // Continue monitoring this source
+}
+
+
+bool
+XmlRpcServerConnection::writeResponse()
+{
+  if (_response.length() == 0) {
+    executeRequest();
+    _bytesWritten = 0;
+    if (_response.length() == 0) {
+      XmlRpcUtil::error("XmlRpcServerConnection::writeResponse: empty response.");
+      return false;
+    }
+  }
+
+  // Try to write the response
+  if ( ! XmlRpcSocket::nbWrite(this->getfd(), _response, &_bytesWritten)) {
+    XmlRpcUtil::error("XmlRpcServerConnection::writeResponse: write error (%s).",XmlRpcSocket::getErrorMsg().c_str());
+    return false;
+  }
+  XmlRpcUtil::log(3, "XmlRpcServerConnection::writeResponse: wrote %d of %d bytes.", _bytesWritten, _response.length());
+
+  // Prepare to read the next request
+  if (_bytesWritten == int(_response.length())) {
+    _header = "";
+    _request = "";
+    _response = "";
+    _connectionState = READ_HEADER;
+  }
+
+  return _keepAlive;    // Continue monitoring this source if true
+}
+
+// Run the method, generate _response string
+void
+XmlRpcServerConnection::executeRequest()
+{
+  XmlRpcValue params, resultValue;
+  std::string methodName = parseRequest(params);
+  XmlRpcUtil::log(2, "XmlRpcServerConnection::executeRequest: server calling method '%s'", 
+                    methodName.c_str());
+
+  try {
+
+    if ( ! executeMethod(methodName, params, resultValue) &&
+         ! executeMulticall(methodName, params, resultValue))
+      generateFaultResponse(methodName + ": unknown method name");
+    else
+      generateResponse(resultValue.toXml());
+
+  } catch (const XmlRpcException& fault) {
+    XmlRpcUtil::log(2, "XmlRpcServerConnection::executeRequest: fault %s.",
+                    fault.getMessage().c_str()); 
+    generateFaultResponse(fault.getMessage(), fault.getCode());
+  }
+}
+
+// Parse the method name and the argument values from the request.
+std::string
+XmlRpcServerConnection::parseRequest(XmlRpcValue& params)
+{
+  int offset = 0;   // Number of chars parsed from the request
+
+  std::string methodName = XmlRpcUtil::parseTag(METHODNAME_TAG, _request, &offset);
+
+  if (methodName.size() > 0 && XmlRpcUtil::findTag(PARAMS_TAG, _request, &offset))
+  {
+    int nArgs = 0;
+    while (XmlRpcUtil::nextTagIs(PARAM_TAG, _request, &offset)) {
+      params[nArgs++] = XmlRpcValue(_request, &offset);
+      (void) XmlRpcUtil::nextTagIs(PARAM_ETAG, _request, &offset);
+    }
+
+    (void) XmlRpcUtil::nextTagIs(PARAMS_ETAG, _request, &offset);
+  }
+
+  return methodName;
+}
+
+// Execute a named method with the specified params.
+bool
+XmlRpcServerConnection::executeMethod(const std::string& methodName, 
+                                      XmlRpcValue& params, XmlRpcValue& result)
+{
+  XmlRpcServerMethod* method = _server->findMethod(methodName);
+
+  if ( ! method) return false;
+
+  method->execute(params, result);
+
+  // Ensure a valid result value
+  if ( ! result.valid())
+      result = std::string();
+
+  return true;
+}
+
+// Execute multiple calls and return the results in an array.
+bool
+XmlRpcServerConnection::executeMulticall(const std::string& methodName, 
+                                         XmlRpcValue& params, XmlRpcValue& result)
+{
+  if (methodName != SYSTEM_MULTICALL) return false;
+
+  // There ought to be 1 parameter, an array of structs
+  if (params.size() != 1 || params[0].getType() != XmlRpcValue::TypeArray)
+    throw XmlRpcException(SYSTEM_MULTICALL + ": Invalid argument (expected an array)");
+
+  int nc = params[0].size();
+  result.setSize(nc);
+
+  for (int i=0; i<nc; ++i) {
+
+    if ( ! params[0][i].hasMember(METHODNAME) ||
+         ! params[0][i].hasMember(PARAMS)) {
+      result[i][FAULTCODE] = -1;
+      result[i][FAULTSTRING] = SYSTEM_MULTICALL +
+              ": Invalid argument (expected a struct with members methodName and params)";
+      continue;
+    }
+
+    const std::string& methodName = params[0][i][METHODNAME];
+    XmlRpcValue& methodParams = params[0][i][PARAMS];
+
+    XmlRpcValue resultValue;
+    resultValue.setSize(1);
+    try {
+      if ( ! executeMethod(methodName, methodParams, resultValue[0]) &&
+           ! executeMulticall(methodName, params, resultValue[0]))
+      {
+        result[i][FAULTCODE] = -1;
+        result[i][FAULTSTRING] = methodName + ": unknown method name";
+      }
+      else
+        result[i] = resultValue;
+
+    } catch (const XmlRpcException& fault) {
+        result[i][FAULTCODE] = fault.getCode();
+        result[i][FAULTSTRING] = fault.getMessage();
+    }
+  }
+
+  return true;
+}
+
+
+// Create a response from results xml
+void
+XmlRpcServerConnection::generateResponse(std::string const& resultXml)
+{
+  const char RESPONSE_1[] = 
+    "<?xml version=\"1.0\"?>\r\n"
+    "<methodResponse><params><param>\r\n\t";
+  const char RESPONSE_2[] =
+    "\r\n</param></params></methodResponse>\r\n";
+
+  std::string body = RESPONSE_1 + resultXml + RESPONSE_2;
+  std::string header = generateHeader(body);
+
+  // Avoid an overly large response
+  if ((header.length() + body.length()) > size_t(INT_MAX)) {
+    XmlRpcUtil::error("XmlRpcServerConnection::generateResponse: response length (%u) exceeds the maximum allowed size (%u).",
+                      _response.length(), INT_MAX);
+    _response = "";
+  }
+  else {
+    _response = header + body;
+    XmlRpcUtil::log(5, "XmlRpcServerConnection::generateResponse:\n%s\n", _response.c_str());
+  }
+}
+
+// Prepend http headers
+std::string
+XmlRpcServerConnection::generateHeader(std::string const& body)
+{
+  std::string header = 
+    "HTTP/1.1 200 OK\r\n"
+    "Server: ";
+  header += XMLRPC_VERSION;
+  header += "\r\n"
+    "Content-Type: text/xml\r\n"
+    "Content-length: ";
+
+  char buffLen[40];
+#ifdef _MSC_VER
+  sprintf_s(buffLen,40,"%d\r\n\r\n", (int)body.size());
+#else
+  sprintf(buffLen,"%d\r\n\r\n", (int)body.size());
+#endif
+
+  return header + buffLen;
+}
+
+
+void
+XmlRpcServerConnection::generateFaultResponse(std::string const& errorMsg, int errorCode)
+{
+  const char RESPONSE_1[] = 
+    "<?xml version=\"1.0\"?>\r\n"
+    "<methodResponse><fault>\r\n\t";
+  const char RESPONSE_2[] =
+    "\r\n</fault></methodResponse>\r\n";
+
+  XmlRpcValue faultStruct;
+  faultStruct[FAULTCODE] = errorCode;
+  faultStruct[FAULTSTRING] = errorMsg;
+  std::string body = RESPONSE_1 + faultStruct.toXml() + RESPONSE_2;
+  std::string header = generateHeader(body);
+
+  _response = header + body;
+}
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/src/XmlRpcServerMethod.cpp
@@ -0,0 +1,21 @@
+
+#include "xmlrpcpp/XmlRpcServerMethod.h"
+#include "xmlrpcpp/XmlRpcServer.h"
+
+namespace XmlRpc {
+
+
+  XmlRpcServerMethod::XmlRpcServerMethod(std::string const& name, XmlRpcServer* server)
+  {
+    _name = name;
+    _server = server;
+    if (_server) _server->addMethod(this);
+  }
+
+  XmlRpcServerMethod::~XmlRpcServerMethod()
+  {
+    if (_server) _server->removeMethod(this);
+  }
+
+
+} // namespace XmlRpc
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/src/XmlRpcSocket.cpp
@@ -0,0 +1,415 @@
+// this file modified by Morgan Quigley on 22 Apr 2008.
+// added features: server can be opened on port 0 and you can read back
+// what port the OS gave you
+
+#include "xmlrpcpp/XmlRpcSocket.h"
+#include "xmlrpcpp/XmlRpcUtil.h"
+
+#ifndef MAKEDEPEND
+
+#if defined(_WINDOWS)
+# include <stdio.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+//# pragma lib(WS2_32.lib)
+
+// MS VS10 actually has these definitions (as opposed to earlier versions),
+// so if present, temporarily disable them and reset to WSA codes for this file only.
+#ifdef EAGAIN
+  #undef EAGAIN
+#endif
+#ifdef EINTR
+  #undef EINTR
+#endif
+#ifdef EINPROGRESS
+  #undef EINPROGRESS
+#endif
+#ifdef  EWOULDBLOCK
+  #undef EWOULDBLOCK
+#endif
+#ifdef ETIMEDOUT
+  #undef ETIMEDOUT
+#endif
+# define EAGAIN		WSATRY_AGAIN
+# define EINTR			WSAEINTR
+# define EINPROGRESS	WSAEINPROGRESS
+# define EWOULDBLOCK	WSAEWOULDBLOCK
+# define ETIMEDOUT	    WSAETIMEDOUT
+#else
+extern "C" {
+# include <unistd.h>
+# include <stdio.h>
+# include <sys/types.h>
+# include <sys/socket.h>
+# include <netinet/in.h>
+# include <netdb.h>
+# include <errno.h>
+# include <fcntl.h>
+# include <string.h>
+# include <stdlib.h>
+# include <arpa/inet.h>
+}
+#endif  // _WINDOWS
+
+#include <climits>
+
+#endif // MAKEDEPEND
+
+// MSG_NOSIGNAL does not exists on OS X
+#if defined(__APPLE__) || defined(__MACH__)
+# ifndef MSG_NOSIGNAL
+#   define MSG_NOSIGNAL SO_NOSIGPIPE
+# endif
+#endif
+
+
+using namespace XmlRpc;
+
+
+bool XmlRpcSocket::s_use_ipv6_ = false;
+
+#if defined(_WINDOWS)
+
+static void initWinSock()
+{
+  static bool wsInit = false;
+  if (! wsInit)
+  {
+    WORD wVersionRequested = MAKEWORD( 2, 0 );
+    WSADATA wsaData;
+    WSAStartup(wVersionRequested, &wsaData);
+    wsInit = true;
+  }
+}
+
+#else
+
+#define initWinSock()
+
+#endif // _WINDOWS
+
+
+// These errors are not considered fatal for an IO operation; the operation will be re-tried.
+static inline bool
+nonFatalError()
+{
+  int err = XmlRpcSocket::getError();
+  return (err == EINPROGRESS || err == EAGAIN || err == EWOULDBLOCK || err == EINTR);
+}
+
+int
+XmlRpcSocket::socket()
+{
+  initWinSock();
+  return (int) ::socket(s_use_ipv6_ ? AF_INET6 : AF_INET, SOCK_STREAM, 0);
+}
+
+
+void
+XmlRpcSocket::close(int fd)
+{
+  XmlRpcUtil::log(4, "XmlRpcSocket::close: fd %d.", fd);
+#if defined(_WINDOWS)
+  closesocket(fd);
+#else
+  ::close(fd);
+#endif // _WINDOWS
+}
+
+
+
+
+bool
+XmlRpcSocket::setNonBlocking(int fd)
+{
+#if defined(_WINDOWS)
+  unsigned long flag = 1;
+  return (ioctlsocket((SOCKET)fd, FIONBIO, &flag) == 0);
+#else
+  return (fcntl(fd, F_SETFL, O_NONBLOCK) == 0);
+#endif // _WINDOWS
+}
+
+
+bool
+XmlRpcSocket::setReuseAddr(int fd)
+{
+  // Allow this port to be re-bound immediately so server re-starts are not delayed
+  int sflag = 1;
+  return (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (const char *)&sflag, sizeof(sflag)) == 0);
+}
+
+
+// Bind to a specified port
+bool
+XmlRpcSocket::bind(int fd, int port)
+{
+  sockaddr_storage ss;
+  socklen_t ss_len;
+  memset(&ss, 0, sizeof(ss));
+
+  if (s_use_ipv6_)
+  {
+    sockaddr_in6 *address = (sockaddr_in6 *)&ss;
+    ss_len = sizeof(sockaddr_in6);
+
+    address->sin6_family = AF_INET6;
+    address->sin6_addr = in6addr_any;
+    address->sin6_port = htons((u_short) port);
+  }
+  else
+  {
+    sockaddr_in *address = (sockaddr_in *)&ss;
+    ss_len = sizeof(sockaddr_in);
+
+    address->sin_family = AF_INET;
+    address->sin_addr.s_addr = htonl(INADDR_ANY);
+    address->sin_port = htons((u_short) port);
+  }
+
+  return (::bind(fd, (sockaddr*)&ss, ss_len) == 0);
+}
+
+
+// Set socket in listen mode
+bool
+XmlRpcSocket::listen(int fd, int backlog)
+{
+  return (::listen(fd, backlog) == 0);
+}
+
+
+int
+XmlRpcSocket::accept(int fd)
+{
+  struct sockaddr_in addr;
+#if defined(_WINDOWS)
+  int
+#else
+  socklen_t
+#endif
+    addrlen = sizeof(addr);
+  // accept will truncate the address if the buffer is too small.
+  // As we are not using it, no special case for IPv6
+  // has to be made.
+  return (int) ::accept(fd, (struct sockaddr*)&addr, &addrlen);
+}
+
+
+
+// Connect a socket to a server (from a client)
+bool
+XmlRpcSocket::connect(int fd, const std::string& host, int port)
+{
+  sockaddr_storage ss;
+  socklen_t ss_len;
+  memset(&ss, 0, sizeof(ss));
+
+  struct addrinfo* addr;
+  struct addrinfo hints;
+  memset(&hints, 0, sizeof(hints));
+  hints.ai_family = AF_UNSPEC;
+  int getaddr_err = getaddrinfo(host.c_str(), NULL, &hints, &addr);
+  if (0 != getaddr_err) {
+#if !defined(_WINDOWS)
+    if(getaddr_err == EAI_SYSTEM) {
+      XmlRpcUtil::error("Couldn't find an %s address for [%s]: %s\n", s_use_ipv6_ ? "AF_INET6" : "AF_INET", host.c_str(), XmlRpcSocket::getErrorMsg().c_str());
+    } else {
+#else
+    {
+#endif
+      XmlRpcUtil::error("Couldn't find an %s address for [%s]: %s\n", s_use_ipv6_ ? "AF_INET6" : "AF_INET", host.c_str(), gai_strerror(getaddr_err));
+    }
+    return false;
+  }
+
+  bool found = false;
+  struct addrinfo* it = addr;
+
+  for (; it; it = it->ai_next)
+  {
+    if (!s_use_ipv6_ && it->ai_family == AF_INET)
+    {
+      sockaddr_in *address = (sockaddr_in *)&ss;
+      ss_len = sizeof(sockaddr_in);
+
+      memcpy(address, it->ai_addr, it->ai_addrlen);
+      address->sin_family = it->ai_family;
+      address->sin_port = htons((u_short) port);
+
+      XmlRpcUtil::log(5, "found host as %s\n", inet_ntoa(address->sin_addr));
+      found = true;
+      break;
+    }
+    if (s_use_ipv6_ && it->ai_family == AF_INET6)
+    {
+      sockaddr_in6 *address = (sockaddr_in6 *)&ss;
+      ss_len = sizeof(sockaddr_in6);
+
+      memcpy(address, it->ai_addr, it->ai_addrlen);
+      address->sin6_family = it->ai_family;
+      address->sin6_port = htons((u_short) port);
+
+      char buf[128];
+      // TODO IPV6: check if this also works under Windows
+      XmlRpcUtil::log(5, "found ipv6 host as %s\n", inet_ntop(AF_INET6, (void*)&(address->sin6_addr), buf, sizeof(buf)));
+      found = true;
+      break;
+    }
+
+  }
+
+  if (!found)
+  {
+    XmlRpcUtil::error("Couldn't find an %s address for [%s]\n", s_use_ipv6_ ? "AF_INET6" : "AF_INET", host.c_str());
+    freeaddrinfo(addr);
+    return false;
+  }
+
+  // For asynch operation, this will return EWOULDBLOCK (windows) or
+  // EINPROGRESS (linux) and we just need to wait for the socket to be writable...
+  int result = ::connect(fd, (sockaddr*)&ss, ss_len);
+  bool success = true;
+  if (result != 0 ) {
+    int error = getError();
+    // platform check here, EWOULDBLOCK on WIN32 and EINPROGRESS otherwise
+#if defined(_WINDOWS)
+    if (error != EWOULDBLOCK) {
+#else
+    if (error != EINPROGRESS) {
+#endif
+      XmlRpcUtil::error("::connect error = %s\n", getErrorMsg(error).c_str());
+      success = false;
+    }
+  }
+
+  freeaddrinfo(addr);
+
+  return success;
+}
+
+
+
+// Read available text from the specified socket. Returns false on error.
+bool
+XmlRpcSocket::nbRead(int fd, std::string& s, bool *eof)
+{
+  const int READ_SIZE = 4096;   // Number of bytes to attempt to read at a time
+  char readBuf[READ_SIZE];
+
+  bool wouldBlock = false;
+  *eof = false;
+
+  while ( ! wouldBlock && ! *eof) {
+#if defined(_WINDOWS)
+    int n = recv(fd, readBuf, READ_SIZE-1, 0);
+#else
+    int n = read(fd, readBuf, READ_SIZE-1);
+#endif
+    XmlRpcUtil::log(5, "XmlRpcSocket::nbRead: read/recv returned %d.", n);
+
+    if (n > 0) {
+      readBuf[n] = 0;
+      s.append(readBuf, n);
+    } else if (n == 0) {
+      *eof = true;
+    } else if (nonFatalError()) {
+      wouldBlock = true;
+    } else {
+      return false;   // Error
+    }
+  }
+  // Watch for integer overrun
+  if (s.length() > size_t(INT_MAX)) {
+    XmlRpcUtil::error("XmlRpcSocket::nbRead: text size (%u) exceeds the maximum allowed size (%s).",
+                      s.length(), INT_MAX);
+    s.clear();
+    return false;
+  }
+  return true;
+}
+
+
+// Write text to the specified socket. Returns false on error.
+bool
+XmlRpcSocket::nbWrite(int fd, const std::string& s, int *bytesSoFar)
+{
+  // Watch for integer overrun
+  if (s.length() > size_t(INT_MAX)) {
+    XmlRpcUtil::error("XmlRpcSocket::nbWrite: text size (%u) exceeds the maximum allowed size(%s)",
+                      s.length(), INT_MAX);
+    return false;
+  }
+  int nToWrite = int(s.length()) - *bytesSoFar;
+  char *sp = const_cast<char*>(s.c_str()) + *bytesSoFar;
+  bool wouldBlock = false;
+
+  while ( nToWrite > 0 && ! wouldBlock ) {
+#if defined(_WINDOWS)
+    int n = send(fd, sp, nToWrite, 0);
+#else
+    int n = write(fd, sp, nToWrite);
+#endif
+    XmlRpcUtil::log(5, "XmlRpcSocket::nbWrite: send/write returned %d.", n);
+
+    if (n > 0) {
+      sp += n;
+      *bytesSoFar += n;
+      nToWrite -= n;
+    } else if (nonFatalError()) {
+      wouldBlock = true;
+    } else {
+      return false;   // Error
+    }
+  }
+  return true;
+}
+
+
+// Returns last errno
+int
+XmlRpcSocket::getError()
+{
+#if defined(_WINDOWS)
+  return WSAGetLastError();
+#else
+  return errno;
+#endif
+}
+
+
+// Returns message corresponding to last errno
+std::string
+XmlRpcSocket::getErrorMsg()
+{
+  return getErrorMsg(getError());
+}
+
+// Returns message corresponding to errno... well, it should anyway
+std::string
+XmlRpcSocket::getErrorMsg(int error)
+{
+  char err[60];
+  std::snprintf(err,sizeof(err),"%s",strerror(error));
+  return std::string(err);
+}
+
+int XmlRpcSocket::get_port(int socket)
+{
+  sockaddr_storage ss;
+  socklen_t ss_len = sizeof(ss);
+  if(getsockname(socket, (sockaddr *)&ss, &ss_len) == 0) {
+    sockaddr_in *sin = (sockaddr_in *)&ss;
+    sockaddr_in6 *sin6 = (sockaddr_in6 *)&ss;
+
+    switch (ss.ss_family)
+    {
+      case AF_INET:
+        return ntohs(sin->sin_port);
+      case AF_INET6:
+        return ntohs(sin6->sin6_port);
+    }
+  }
+  return 0;
+}
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/src/XmlRpcSource.cpp
@@ -0,0 +1,35 @@
+
+#include "xmlrpcpp/XmlRpcSource.h"
+#include "xmlrpcpp/XmlRpcSocket.h"
+#include "xmlrpcpp/XmlRpcUtil.h"
+
+namespace XmlRpc {
+
+
+  XmlRpcSource::XmlRpcSource(int fd /*= -1*/, bool deleteOnClose /*= false*/) 
+    : _fd(fd), _deleteOnClose(deleteOnClose), _keepOpen(false)
+  {
+  }
+
+  XmlRpcSource::~XmlRpcSource()
+  {
+  }
+
+
+  void
+  XmlRpcSource::close()
+  {
+    if (_fd != -1) {
+      XmlRpcUtil::log(2,"XmlRpcSource::close: closing socket %d.", _fd);
+      XmlRpcSocket::close(_fd);
+      XmlRpcUtil::log(2,"XmlRpcSource::close: done closing socket %d.", _fd);
+      _fd = -1;
+    }
+    if (_deleteOnClose) {
+      XmlRpcUtil::log(2,"XmlRpcSource::close: deleting this");
+      _deleteOnClose = false;
+      delete this;
+    }
+  }
+
+} // namespace XmlRpc
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/src/XmlRpcUtil.cpp
@@ -0,0 +1,325 @@
+
+#include "xmlrpcpp/XmlRpcUtil.h"
+
+#ifndef MAKEDEPEND
+# include <ctype.h>
+# include <iostream>
+# include <stdarg.h>
+# include <stdio.h>
+# include <string.h>
+# include <climits>
+#endif
+
+#include "xmlrpcpp/XmlRpc.h"
+
+using namespace XmlRpc;
+
+
+//#define USE_WINDOWS_DEBUG // To make the error and log messages go to VC++ debug output
+#ifdef USE_WINDOWS_DEBUG
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#endif
+
+// Version id
+const char XmlRpc::XMLRPC_VERSION[] = "XMLRPC++ 0.7";
+
+// Default log verbosity: 0 for no messages through 5 (writes everything)
+int XmlRpcLogHandler::_verbosity = 0;
+
+// Default log handler
+static class DefaultLogHandler : public XmlRpcLogHandler {
+public:
+
+  void log(int level, const char* msg) { 
+#ifdef USE_WINDOWS_DEBUG
+    if (level <= _verbosity) { OutputDebugString(msg); OutputDebugString("\n"); }
+#else
+    if (level <= _verbosity) std::cout << msg << std::endl; 
+#endif  
+  }
+
+} defaultLogHandler;
+
+// Message log singleton
+XmlRpcLogHandler* XmlRpcLogHandler::_logHandler = &defaultLogHandler;
+
+
+// Default error handler
+static class DefaultErrorHandler : public XmlRpcErrorHandler {
+public:
+
+#ifdef USE_WINDOWS_DEBUG
+  void error(const char* msg) {
+    OutputDebugString(msg); OutputDebugString("\n");
+#else
+  void error(const char*) {
+#endif  
+    // As far as I can tell, throwing an exception here is a bug, unless
+    // the intention is that the program should exit.  Throughout the code,
+    // calls to error() are followed by cleanup code that does things like
+    // closing a failed socket.  Thus it would seem that it should be
+    // possible to continue execution.  But if the user just catches the
+    // exception that's thrown here, the library ends up in a bogus state.
+    // So I'm commenting out the throw.  - BPG
+    //
+    //throw std::runtime_error(msg);
+  }
+} defaultErrorHandler;
+
+
+// Error handler singleton
+XmlRpcErrorHandler* XmlRpcErrorHandler::_errorHandler = &defaultErrorHandler;
+
+
+// Easy API for log verbosity
+int XmlRpc::getVerbosity() { return XmlRpcLogHandler::getVerbosity(); }
+void XmlRpc::setVerbosity(int level) { XmlRpcLogHandler::setVerbosity(level); }
+
+ 
+
+void XmlRpcUtil::log(int level, const char* fmt, ...)
+{
+  if (level <= XmlRpcLogHandler::getVerbosity())
+  {
+    va_list va;
+    char buf[1024];
+    va_start( va, fmt);
+    std::vsnprintf(buf,sizeof(buf)-1,fmt,va);
+    va_end(va);
+    buf[sizeof(buf)-1] = 0;
+    XmlRpcLogHandler::getLogHandler()->log(level, buf);
+  }
+}
+
+
+void XmlRpcUtil::error(const char* fmt, ...)
+{
+  va_list va;
+  va_start(va, fmt);
+  char buf[1024];
+  std::vsnprintf(buf,sizeof(buf)-1,fmt,va);
+  va_end(va);
+  buf[sizeof(buf)-1] = 0;
+  XmlRpcErrorHandler::getErrorHandler()->error(buf);
+}
+
+
+// Returns contents between <tag> and </tag>, updates offset to char after </tag>
+// This method will skip *any* intermediate string to find the tag; as such, it is
+// unsafe to use in general, and `nextTagData` should be used instead.
+std::string 
+XmlRpcUtil::parseTag(const char* tag, std::string const& xml, int* offset)
+{
+  if (offset == NULL) return std::string();
+  // avoid attempting to parse overly long xml input
+  if (xml.length() > size_t(INT_MAX)) return std::string();
+  if (*offset >= int(xml.length())) return std::string();
+  size_t istart = xml.find(tag, *offset);
+  if (istart == std::string::npos) return std::string();
+  istart += strlen(tag);
+  std::string etag = "</";
+  etag += tag + 1;
+  size_t iend = xml.find(etag, istart);
+  if (iend == std::string::npos) return std::string();
+
+  *offset = int(iend + etag.length());
+  return xml.substr(istart, iend-istart);
+}
+
+
+// Returns true if the tag is found and updates offset to the char after the tag
+bool 
+XmlRpcUtil::findTag(const char* tag, std::string const& xml, int* offset)
+{
+  if (offset == NULL) return false;
+  if (xml.length() > size_t(INT_MAX)) return false;
+  if (*offset >= int(xml.length())) return false;
+  size_t istart = xml.find(tag, *offset);
+  if (istart == std::string::npos)
+    return false;
+
+  *offset = int(istart + strlen(tag));
+  return true;
+}
+
+
+// Returns true if the tag is found at the specified offset (modulo any whitespace)
+// and updates offset to the char after the tag
+bool 
+XmlRpcUtil::nextTagIs(const char* tag, std::string const& xml, int* offset)
+{
+  if (offset == NULL) return false;
+  if (xml.length() > size_t(INT_MAX)) return false;
+  if (*offset >= int(xml.length())) return false;
+  const char* cp = xml.c_str() + *offset;
+  int nc = 0;
+  while (*cp && isspace(*cp)) {
+    ++cp;
+    ++nc;
+  }
+
+  int len = int(strlen(tag));
+  if  (*cp && (strncmp(cp, tag, len) == 0)) {
+    *offset += nc + len;
+    return true;
+  }
+  return false;
+}
+
+// Returns contents between <tag> and </tag> at the specified offset (modulo any whitespace),
+// and updates offset to char after </tag>
+std::string
+XmlRpcUtil::nextTagData(const char* tag, std::string const& xml, int* offset)
+{
+  if (offset == NULL) return std::string();
+  if (xml.length() > size_t(INT_MAX)) return std::string();
+  if (*offset >= int(xml.length())) return std::string();
+
+  const char* start_cp = xml.c_str() + *offset;
+  const char* cp = start_cp;
+  while (*cp && isspace(*cp)) {
+    ++cp;
+  }
+
+  const int len = int(strnlen(tag, xml.length()));
+  // Check if the tag is next; if not, we'll get out of here
+  if (!(*cp) || (strncmp(cp, tag, len) != 0)) {
+    return std::string();
+  }
+
+  cp += len;
+
+  // Now collect all of the data up to the next tag
+  std::string ret;
+  while (*cp) {
+    if (*cp == '<') {
+      break;
+    }
+    ret += *cp;
+    cp++;
+  }
+
+  if (!(*cp)) {
+    return std::string();
+  }
+
+  // Now find the end tag
+  std::string etag = "</";
+  etag += tag + 1;
+
+  if (strncmp(cp, etag.c_str(), etag.length()) != 0) {
+    return std::string();
+  }
+
+  cp += etag.length();
+
+  *offset += (cp - start_cp);
+
+  return ret;
+}
+
+// Returns the next tag and updates offset to the char after the tag, or empty string
+// if the next non-whitespace character is not '<'
+std::string 
+XmlRpcUtil::getNextTag(std::string const& xml, int* offset)
+{
+  if (offset == NULL) return std::string();
+  if (xml.length() > size_t(INT_MAX)) return std::string();
+  if (*offset >= int(xml.length())) return std::string();
+
+  size_t pos = *offset;
+  const char* cp = xml.c_str() + pos;
+  while (*cp && isspace(*cp)) {
+    ++cp;
+    ++pos;
+  }
+
+  if (*cp != '<') return std::string();
+
+  std::string s;
+  do {
+    s += *cp;
+    ++pos;
+  } while (*cp++ != '>' && *cp != 0);
+
+  *offset = int(pos);
+  return s;
+}
+
+
+
+// xml encodings (xml-encoded entities are preceded with '&')
+static const char  AMP = '&';
+static const char  rawEntity[] = { '<',   '>',   '&',    '\'',    '\"',    0 };
+static const char* xmlEntity[] = { "lt;", "gt;", "amp;", "apos;", "quot;", 0 };
+static const int   xmlEntLen[] = { 3,     3,     4,      5,       5 };
+
+
+// Replace xml-encoded entities with the raw text equivalents.
+
+std::string 
+XmlRpcUtil::xmlDecode(const std::string& encoded)
+{
+  std::string::size_type iAmp = encoded.find(AMP);
+  if (iAmp == std::string::npos)
+    return encoded;
+
+  std::string decoded(encoded, 0, iAmp);
+  std::string::size_type iSize = encoded.size();
+  decoded.reserve(iSize);
+
+  const char* ens = encoded.c_str();
+  while (iAmp != iSize) {
+    if (encoded[iAmp] == AMP && iAmp+1 < iSize) {
+      int iEntity;
+      for (iEntity=0; xmlEntity[iEntity] != 0; ++iEntity)
+	//if (encoded.compare(iAmp+1, xmlEntLen[iEntity], xmlEntity[iEntity]) == 0)
+	if (strncmp(ens+iAmp+1, xmlEntity[iEntity], xmlEntLen[iEntity]) == 0)
+        {
+          decoded += rawEntity[iEntity];
+          iAmp += xmlEntLen[iEntity]+1;
+          break;
+        }
+      if (xmlEntity[iEntity] == 0)    // unrecognized sequence
+        decoded += encoded[iAmp++];
+
+    } else {
+      decoded += encoded[iAmp++];
+    }
+  }
+    
+  return decoded;
+}
+
+
+// Replace raw text with xml-encoded entities.
+
+std::string 
+XmlRpcUtil::xmlEncode(const std::string& raw)
+{
+  std::string::size_type iRep = raw.find_first_of(rawEntity);
+  if (iRep == std::string::npos)
+    return raw;
+
+  std::string encoded(raw, 0, iRep);
+  std::string::size_type iSize = raw.size();
+
+  while (iRep != iSize) {
+    int iEntity;
+    for (iEntity=0; rawEntity[iEntity] != 0; ++iEntity)
+      if (raw[iRep] == rawEntity[iEntity])
+      {
+        encoded += AMP;
+        encoded += xmlEntity[iEntity];
+        break;
+      }
+    if (rawEntity[iEntity] == 0)
+      encoded += raw[iRep];
+    ++iRep;
+  }
+  return encoded;
+}
+
+
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/src/XmlRpcValue.cpp
@@ -0,0 +1,699 @@
+
+#include "xmlrpcpp/XmlRpcValue.h"
+#include "xmlrpcpp/XmlRpcException.h"
+#include "xmlrpcpp/XmlRpcUtil.h"
+
+#include <b64/encode.h>
+#include <b64/decode.h>
+
+#ifndef MAKEDEPEND
+# include <iostream>
+# include <ostream>
+# include <stdlib.h>
+# include <stdio.h>
+#endif
+
+#include <sstream>
+#include <mutex>
+#include <vector>
+
+namespace XmlRpc {
+
+
+  static const char VALUE_TAG[]     = "<value>";
+  static const char VALUE_ETAG[]    = "</value>";
+
+  static const char BOOLEAN_TAG[]   = "<boolean>";
+  static const char BOOLEAN_ETAG[]  = "</boolean>";
+  static const char DOUBLE_TAG[]    = "<double>";
+  static const char DOUBLE_ETAG[]   = "</double>";
+  static const char INT_TAG[]       = "<int>";
+  static const char I4_TAG[]        = "<i4>";
+  static const char I4_ETAG[]       = "</i4>";
+  static const char STRING_TAG[]    = "<string>";
+  static const char DATETIME_TAG[]  = "<dateTime.iso8601>";
+  static const char DATETIME_ETAG[] = "</dateTime.iso8601>";
+  static const char BASE64_TAG[]    = "<base64>";
+  static const char BASE64_ETAG[]   = "</base64>";
+
+  static const char ARRAY_TAG[]     = "<array>";
+  static const char DATA_TAG[]      = "<data>";
+  static const char DATA_ETAG[]     = "</data>";
+  static const char ARRAY_ETAG[]    = "</array>";
+
+  static const char STRUCT_TAG[]    = "<struct>";
+  static const char MEMBER_TAG[]    = "<member>";
+  static const char NAME_TAG[]      = "<name>";
+  static const char NAME_ETAG[]     = "</name>";
+  static const char MEMBER_ETAG[]   = "</member>";
+  static const char STRUCT_ETAG[]   = "</struct>";
+
+
+      
+  // Format strings
+  std::string XmlRpcValue::_doubleFormat("%.16g");
+
+
+
+  // Clean up
+  void XmlRpcValue::invalidate()
+  {
+    switch (_type) {
+      case TypeString:    delete _value.asString; break;
+      case TypeDateTime:  delete _value.asTime;   break;
+      case TypeBase64:    delete _value.asBinary; break;
+      case TypeArray:     delete _value.asArray;  break;
+      case TypeStruct:    delete _value.asStruct; break;
+      default: break;
+    }
+    _type = TypeInvalid;
+    _value.asBinary = 0;
+  }
+
+  
+  // Type checking
+  void XmlRpcValue::assertTypeOrInvalid(Type t) const
+  {
+    if (_type != t)
+      throw XmlRpcException("type error");
+  }
+
+  void XmlRpcValue::assertTypeOrInvalid(Type t)
+  {
+    if (_type == TypeInvalid)
+    {
+      _type = t;
+      switch (_type) {    // Ensure there is a valid value for the type
+        case TypeString:   _value.asString = new std::string(); break;
+        case TypeDateTime: _value.asTime = new struct tm();     break;
+        case TypeBase64:   _value.asBinary = new BinaryData();  break;
+        case TypeArray:    _value.asArray = new ValueArray();   break;
+        case TypeStruct:   _value.asStruct = new ValueStruct(); break;
+        default:           _value.asBinary = 0; break;
+      }
+    }
+    else if (_type != t)
+      throw XmlRpcException("type error");
+  }
+
+  void XmlRpcValue::assertArray(int size) const
+  {
+    if (_type != TypeArray)
+      throw XmlRpcException("type error: expected an array");
+    else if (int(_value.asArray->size()) < size)
+      throw XmlRpcException("range error: array index too large");
+  }
+
+
+  void XmlRpcValue::assertArray(int size)
+  {
+    if (_type == TypeInvalid) {
+      _type = TypeArray;
+      _value.asArray = new ValueArray(size);
+    } else if (_type == TypeArray) {
+      if (int(_value.asArray->size()) < size)
+        _value.asArray->resize(size);
+    } else
+      throw XmlRpcException("type error: expected an array");
+  }
+
+  void XmlRpcValue::assertStruct() const
+  {
+    if (_type != TypeStruct)
+      throw XmlRpcException("type error: expected a struct");
+  }
+
+  void XmlRpcValue::assertStruct()
+  {
+    if (_type == TypeInvalid) {
+      _type = TypeStruct;
+      _value.asStruct = new ValueStruct();
+    } else if (_type != TypeStruct)
+      throw XmlRpcException("type error: expected a struct");
+  }
+
+
+  // Operators
+  XmlRpcValue& XmlRpcValue::operator=(XmlRpcValue const& rhs)
+  {
+    if (this != &rhs)
+    {
+      invalidate();
+      _type = rhs._type;
+      switch (_type) {
+        case TypeBoolean:  _value.asBool = rhs._value.asBool; break;
+        case TypeInt:      _value.asInt = rhs._value.asInt; break;
+        case TypeDouble:   _value.asDouble = rhs._value.asDouble; break;
+        case TypeDateTime: _value.asTime = new struct tm(*rhs._value.asTime); break;
+        case TypeString:   _value.asString = new std::string(*rhs._value.asString); break;
+        case TypeBase64:   _value.asBinary = new BinaryData(*rhs._value.asBinary); break;
+        case TypeArray:    _value.asArray = new ValueArray(*rhs._value.asArray); break;
+        case TypeStruct:   _value.asStruct = new ValueStruct(*rhs._value.asStruct); break;
+        default:           _value.asBinary = 0; break;
+      }
+    }
+    return *this;
+  }
+
+
+  // Predicate for tm equality
+  static bool tmEq(struct tm const& t1, struct tm const& t2) {
+    return t1.tm_sec == t2.tm_sec && t1.tm_min == t2.tm_min &&
+            t1.tm_hour == t2.tm_hour && t1.tm_mday == t2.tm_mday &&
+            t1.tm_mon == t2.tm_mon && t1.tm_year == t2.tm_year;
+  }
+
+  bool XmlRpcValue::operator==(XmlRpcValue const& other) const
+  {
+    if (_type != other._type)
+      return false;
+
+    switch (_type) {
+      case TypeBoolean:  return ( !_value.asBool && !other._value.asBool) ||
+                                ( _value.asBool && other._value.asBool);
+      case TypeInt:      return _value.asInt == other._value.asInt;
+      case TypeDouble:   return _value.asDouble == other._value.asDouble;
+      case TypeDateTime: return tmEq(*_value.asTime, *other._value.asTime);
+      case TypeString:   return *_value.asString == *other._value.asString;
+      case TypeBase64:   return *_value.asBinary == *other._value.asBinary;
+      case TypeArray:    return *_value.asArray == *other._value.asArray;
+
+      // The map<>::operator== requires the definition of value< for kcc
+      case TypeStruct:   //return *_value.asStruct == *other._value.asStruct;
+        {
+          if (_value.asStruct->size() != other._value.asStruct->size())
+            return false;
+          
+          ValueStruct::const_iterator it1=_value.asStruct->begin();
+          ValueStruct::const_iterator it2=other._value.asStruct->begin();
+          while (it1 != _value.asStruct->end()) {
+            const XmlRpcValue& v1 = it1->second;
+            const XmlRpcValue& v2 = it2->second;
+            if ( ! (v1 == v2))
+              return false;
+            it1++;
+            it2++;
+          }
+          return true;
+        }
+      default: break;
+    }
+    return true;    // Both invalid values ...
+  }
+
+  bool XmlRpcValue::operator!=(XmlRpcValue const& other) const
+  {
+    return !(*this == other);
+  }
+
+
+  // Works for strings, binary data, arrays, and structs.
+  int XmlRpcValue::size() const
+  {
+    switch (_type) {
+      case TypeString: return int(_value.asString->size());
+      case TypeBase64: return int(_value.asBinary->size());
+      case TypeArray:  return int(_value.asArray->size());
+      case TypeStruct: return int(_value.asStruct->size());
+      default: break;
+    }
+
+    throw XmlRpcException("type error");
+  }
+
+  // Checks for existence of struct member
+  bool XmlRpcValue::hasMember(const std::string& name) const
+  {
+    return _type == TypeStruct && _value.asStruct->find(name) != _value.asStruct->end();
+  }
+
+  // Set the value from xml. The chars at *offset into valueXml 
+  // should be the start of a <value> tag. Destroys any existing value.
+  bool XmlRpcValue::fromXml(std::string const& valueXml, int* offset)
+  {
+    if (offset == NULL) return false;
+
+    int savedOffset = *offset;
+
+    invalidate();
+    if ( ! XmlRpcUtil::nextTagIs(VALUE_TAG, valueXml, offset))
+      return false;       // Not a value, offset not updated
+
+	int afterValueOffset = *offset;
+    std::string typeTag = XmlRpcUtil::getNextTag(valueXml, offset);
+    bool result = false;
+    if (typeTag == BOOLEAN_TAG)
+      result = boolFromXml(valueXml, offset);
+    else if (typeTag == I4_TAG || typeTag == INT_TAG)
+      result = intFromXml(valueXml, offset);
+    else if (typeTag == DOUBLE_TAG)
+      result = doubleFromXml(valueXml, offset);
+    else if (typeTag.empty() || typeTag == STRING_TAG)
+      result = stringFromXml(valueXml, offset);
+    else if (typeTag == DATETIME_TAG)
+      result = timeFromXml(valueXml, offset);
+    else if (typeTag == BASE64_TAG)
+      result = binaryFromXml(valueXml, offset);
+    else if (typeTag == ARRAY_TAG)
+      result = arrayFromXml(valueXml, offset);
+    else if (typeTag == STRUCT_TAG)
+      result = structFromXml(valueXml, offset);
+    // Watch for empty/blank strings with no <string>tag
+    else if (typeTag == VALUE_ETAG)
+    {
+      *offset = afterValueOffset;   // back up & try again
+      result = stringFromXml(valueXml, offset);
+    }
+
+    if (result)  // Skip over the </value> tag
+      XmlRpcUtil::findTag(VALUE_ETAG, valueXml, offset);
+    else        // Unrecognized tag after <value>
+      *offset = savedOffset;
+
+    return result;
+  }
+
+  // Encode the Value in xml
+  std::string XmlRpcValue::toXml() const
+  {
+    switch (_type) {
+      case TypeBoolean:  return boolToXml();
+      case TypeInt:      return intToXml();
+      case TypeDouble:   return doubleToXml();
+      case TypeString:   return stringToXml();
+      case TypeDateTime: return timeToXml();
+      case TypeBase64:   return binaryToXml();
+      case TypeArray:    return arrayToXml();
+      case TypeStruct:   return structToXml();
+      default: break;
+    }
+    return std::string();   // Invalid value
+  }
+
+
+  // Boolean
+  bool XmlRpcValue::boolFromXml(std::string const& valueXml, int* offset)
+  {
+    const char* valueStart = valueXml.c_str() + *offset;
+    char* valueEnd;
+    long ivalue = strtol(valueStart, &valueEnd, 10);
+    if (valueEnd == valueStart || (ivalue != 0 && ivalue != 1))
+      return false;
+
+    _type = TypeBoolean;
+    _value.asBool = (ivalue == 1);
+    *offset += int(valueEnd - valueStart);
+    return true;
+  }
+
+  std::string XmlRpcValue::boolToXml() const
+  {
+    std::string xml = VALUE_TAG;
+    xml += BOOLEAN_TAG;
+    xml += (_value.asBool ? "1" : "0");
+    xml += BOOLEAN_ETAG;
+    xml += VALUE_ETAG;
+    return xml;
+  }
+
+  // Int
+  bool XmlRpcValue::intFromXml(std::string const& valueXml, int* offset)
+  {
+    const char* valueStart = valueXml.c_str() + *offset;
+    char* valueEnd;
+    long ivalue = strtol(valueStart, &valueEnd, 10);
+    if (valueEnd == valueStart)
+      return false;
+
+    _type = TypeInt;
+    _value.asInt = int(ivalue);
+    *offset += int(valueEnd - valueStart);
+    return true;
+  }
+
+  std::string XmlRpcValue::intToXml() const
+  {
+    char buf[256];
+    std::snprintf(buf, sizeof(buf)-1, "%d", _value.asInt);
+    buf[sizeof(buf)-1] = 0;
+    std::string xml = VALUE_TAG;
+    xml += I4_TAG;
+    xml += buf;
+    xml += I4_ETAG;
+    xml += VALUE_ETAG;
+    return xml;
+  }
+
+  // Double
+  bool XmlRpcValue::doubleFromXml(std::string const& valueXml, int* offset)
+  {
+    const char* valueStart = valueXml.c_str() + *offset;
+    char* valueEnd;
+
+    // ticket #2438
+    // push/pop the locale here. Value 123.45 can get read by strtod
+    // as '123', if the locale expects a comma instead of dot.
+    // if there are locale problems, silently continue.
+    std::string tmplocale;
+    char* locale_cstr = setlocale(LC_NUMERIC, 0);
+    if (locale_cstr)
+      {
+        tmplocale = locale_cstr;
+        setlocale(LC_NUMERIC, "POSIX");
+      }
+
+    double dvalue = strtod(valueStart, &valueEnd);
+
+    if (tmplocale.size() > 0) {
+      setlocale(LC_NUMERIC, tmplocale.c_str());
+    }
+
+    if (valueEnd == valueStart)
+      return false;
+
+    _type = TypeDouble;
+    _value.asDouble = dvalue;
+    *offset += int(valueEnd - valueStart);
+    return true;
+  }
+
+  std::string XmlRpcValue::doubleToXml() const
+  {
+    // ticket #2438
+    std::stringstream ss;
+    ss.imbue(std::locale::classic()); // ensure we're using "C" locale for formatting floating-point (1.4 vs. 1,4, etc.)
+    ss.precision(17);
+    ss << _value.asDouble;
+
+    std::string xml = VALUE_TAG;
+    xml += DOUBLE_TAG;
+    xml += ss.str();
+    xml += DOUBLE_ETAG;
+    xml += VALUE_ETAG;
+    return xml;
+  }
+
+  // String
+  bool XmlRpcValue::stringFromXml(std::string const& valueXml, int* offset)
+  {
+    size_t valueEnd = valueXml.find('<', *offset);
+    if (valueEnd == std::string::npos)
+      return false;     // No end tag;
+
+    _type = TypeString;
+    _value.asString = new std::string(XmlRpcUtil::xmlDecode(valueXml.substr(*offset, valueEnd-*offset)));
+    *offset += int(_value.asString->length());
+    return true;
+  }
+
+  std::string XmlRpcValue::stringToXml() const
+  {
+    std::string xml = VALUE_TAG;
+    //xml += STRING_TAG; optional
+    xml += XmlRpcUtil::xmlEncode(*_value.asString);
+    //xml += STRING_ETAG;
+    xml += VALUE_ETAG;
+    return xml;
+  }
+
+  // DateTime (stored as a struct tm)
+  bool XmlRpcValue::timeFromXml(std::string const& valueXml, int* offset)
+  {
+    size_t valueEnd = valueXml.find('<', *offset);
+    if (valueEnd == std::string::npos)
+      return false;     // No end tag;
+
+    std::string stime = valueXml.substr(*offset, valueEnd-*offset);
+
+    struct tm t;
+#ifdef _MSC_VER
+    if (sscanf_s(stime.c_str(),"%4d%2d%2dT%2d:%2d:%2d",&t.tm_year,&t.tm_mon,&t.tm_mday,&t.tm_hour,&t.tm_min,&t.tm_sec) != 6)
+#else
+    if (sscanf(stime.c_str(),"%4d%2d%2dT%2d:%2d:%2d",&t.tm_year,&t.tm_mon,&t.tm_mday,&t.tm_hour,&t.tm_min,&t.tm_sec) != 6)
+#endif
+      return false;
+
+    t.tm_isdst = -1;
+    _type = TypeDateTime;
+    _value.asTime = new struct tm(t);
+    *offset += int(stime.length());
+    return true;
+  }
+
+  std::string XmlRpcValue::timeToXml() const
+  {
+    struct tm* t = _value.asTime;
+    char buf[20];
+    std::snprintf(buf, sizeof(buf)-1, "%4d%02d%02dT%02d:%02d:%02d", 
+      t->tm_year,t->tm_mon,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);
+    buf[sizeof(buf)-1] = 0;
+
+    std::string xml = VALUE_TAG;
+    xml += DATETIME_TAG;
+    xml += buf;
+    xml += DATETIME_ETAG;
+    xml += VALUE_ETAG;
+    return xml;
+  }
+
+  namespace {
+    std::size_t base64EncodedSize(std::size_t raw_size)
+    {
+      // encoder will still write to output buffer for empty input.
+      if (raw_size == 0) return 1;
+
+      // 4 encoded character per 3 input bytes, rounded up,
+      // plus a newline character per 72 output characters, rounded up.
+      std::size_t encoded = (raw_size + 2) / 3 * 4;
+      encoded += (encoded + 71) / 72;
+      return encoded;
+    }
+
+    std::size_t base64DecodedSize(std::size_t encoded_size)
+    {
+      // decoded will still write to output buffer for empty input.
+      if (encoded_size == 0) return 1;
+
+      // 3 decoded bytes per 4 encoded characters, rounded up just to be sure.
+      return (encoded_size + 3) / 4 * 3;
+    }
+
+  }
+
+  // Base64
+  bool XmlRpcValue::binaryFromXml(std::string const& valueXml, int* offset)
+  {
+    size_t valueEnd = valueXml.find('<', *offset);
+    if (valueEnd == std::string::npos)
+      return false;     // No end tag;
+
+    std::size_t encoded_size = valueEnd - *offset;
+
+
+    _type = TypeBase64;
+    // might reserve too much, we'll shrink later
+    _value.asBinary = new BinaryData(base64DecodedSize(encoded_size), '\0');
+
+    base64::decoder decoder;
+    std::size_t size = decoder.decode(&valueXml[*offset], encoded_size, &(*_value.asBinary)[0]);
+    _value.asBinary->resize(size);
+
+    *offset += encoded_size;
+    return true;
+  }
+
+  std::string XmlRpcValue::binaryToXml() const
+  {
+    // Wrap with xml
+    std::string xml = VALUE_TAG;
+    xml += BASE64_TAG;
+
+    std::size_t offset = xml.size();
+    // might reserve too much, we'll shrink later
+    xml.resize(xml.size() + base64EncodedSize(_value.asBinary->size()));
+
+    base64::encoder encoder;
+    offset += encoder.encode(_value.asBinary->data(), _value.asBinary->size(), &xml[offset]);
+    offset += encoder.encode_end(&xml[offset]);
+    xml.resize(offset);
+
+    xml += BASE64_ETAG;
+    xml += VALUE_ETAG;
+    return xml;
+  }
+
+
+  // Array
+  bool XmlRpcValue::arrayFromXml(std::string const& valueXml, int* offset)
+  {
+    if ( ! XmlRpcUtil::nextTagIs(DATA_TAG, valueXml, offset))
+      return false;
+
+    _type = TypeArray;
+    _value.asArray = new ValueArray;
+    XmlRpcValue v;
+    while (v.fromXml(valueXml, offset))
+      _value.asArray->push_back(v);       // copy...
+
+    // Skip the trailing </data>
+    (void) XmlRpcUtil::nextTagIs(DATA_ETAG, valueXml, offset);
+    return true;
+  }
+
+
+  // In general, its preferable to generate the xml of each element of the
+  // array as it is needed rather than glomming up one big string.
+  std::string XmlRpcValue::arrayToXml() const
+  {
+    std::string xml = VALUE_TAG;
+    xml += ARRAY_TAG;
+    xml += DATA_TAG;
+
+    int s = int(_value.asArray->size());
+    for (int i=0; i<s; ++i)
+       xml += _value.asArray->at(i).toXml();
+
+    xml += DATA_ETAG;
+    xml += ARRAY_ETAG;
+    xml += VALUE_ETAG;
+    return xml;
+  }
+
+
+  // Struct
+  bool XmlRpcValue::structFromXml(std::string const& valueXml, int* offset)
+  {
+    _type = TypeStruct;
+    _value.asStruct = new ValueStruct;
+
+    while (XmlRpcUtil::nextTagIs(MEMBER_TAG, valueXml, offset)) {
+      // name
+      const std::string name = XmlRpcUtil::nextTagData(NAME_TAG, valueXml, offset);
+      // value
+      XmlRpcValue val(valueXml, offset);
+      if ( ! val.valid()) {
+        invalidate();
+        return false;
+      }
+      const std::pair<const std::string, XmlRpcValue> p(name, val);
+      _value.asStruct->insert(p);
+
+      (void) XmlRpcUtil::nextTagIs(MEMBER_ETAG, valueXml, offset);
+    }
+    return true;
+  }
+
+
+  // In general, its preferable to generate the xml of each element
+  // as it is needed rather than glomming up one big string.
+  std::string XmlRpcValue::structToXml() const
+  {
+    std::string xml = VALUE_TAG;
+    xml += STRUCT_TAG;
+
+    ValueStruct::const_iterator it;
+    for (it=_value.asStruct->begin(); it!=_value.asStruct->end(); ++it) {
+      xml += MEMBER_TAG;
+      xml += NAME_TAG;
+      xml += XmlRpcUtil::xmlEncode(it->first);
+      xml += NAME_ETAG;
+      xml += it->second.toXml();
+      xml += MEMBER_ETAG;
+    }
+
+    xml += STRUCT_ETAG;
+    xml += VALUE_ETAG;
+    return xml;
+  }
+
+
+
+  // Write the value without xml encoding it
+  std::ostream& XmlRpcValue::write(std::ostream& os) const {
+    switch (_type) {
+      default:           break;
+      case TypeBoolean:  os << _value.asBool; break;
+      case TypeInt:      os << _value.asInt; break;
+      case TypeDouble:
+        {
+          static std::once_flag once;
+          char buf[128]; // Should be long enough
+          int required_size = std::snprintf(buf, sizeof(buf)-1,
+                                getDoubleFormat().c_str(), _value.asDouble);
+          if (required_size < 0) {
+            std::call_once(once,
+              [](){XmlRpcUtil::error("Failed to format with %s", getDoubleFormat().c_str());});
+            os << _value.asDouble;
+          } else if (required_size < static_cast<int>(sizeof(buf))) {
+            buf[sizeof(buf)-1] = 0;
+            os << buf;
+          } else { // required_size >= static_cast<int>(sizeof(buf)
+            std::vector<char> required_buf(required_size+1);
+            std::snprintf(required_buf.data(), required_size,
+              getDoubleFormat().c_str(), _value.asDouble);
+            required_buf[required_size] = 0;
+            os << required_buf.data();
+          }
+          break;
+        }
+      case TypeString:   os << *_value.asString; break;
+      case TypeDateTime:
+        {
+          struct tm* t = _value.asTime;
+          char buf[20];
+          std::snprintf(buf, sizeof(buf)-1, "%4d%02d%02dT%02d:%02d:%02d", 
+            t->tm_year,t->tm_mon,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);
+          buf[sizeof(buf)-1] = 0;
+          os << buf;
+          break;
+        }
+      case TypeBase64:
+        {
+          std::stringstream buffer;
+          buffer.write(_value.asBinary->data(), _value.asBinary->size());
+          base64::encoder encoder;
+          encoder.encode(buffer, os);
+          break;
+        }
+      case TypeArray:
+        {
+          int s = int(_value.asArray->size());
+          os << '{';
+          for (int i=0; i<s; ++i)
+          {
+            if (i > 0) os << ',';
+            _value.asArray->at(i).write(os);
+          }
+          os << '}';
+          break;
+        }
+      case TypeStruct:
+        {
+          os << '[';
+          ValueStruct::const_iterator it;
+          for (it=_value.asStruct->begin(); it!=_value.asStruct->end(); ++it)
+          {
+            if (it!=_value.asStruct->begin()) os << ',';
+            os << it->first << ':';
+            it->second.write(os);
+          }
+          os << ']';
+          break;
+        }
+      
+    }
+    
+    return os;
+  }
+
+} // namespace XmlRpc
+
+
+// ostream
+std::ostream& operator<<(std::ostream& os, const XmlRpc::XmlRpcValue& v)
+{
+  // If you want to output in xml format:
+  //return os << v.toXml();
+  return v.write(os);
+}
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/FileClient.cpp
@@ -0,0 +1,108 @@
+// FileClient.cpp : A simple xmlrpc client. Usage: FileClient serverHost serverPort xmlfile
+// Reads an xmlrpc request from the specified xmlfile and calls the method on the server.
+// 
+// Link against xmlrpc lib and whatever socket libs your system needs (ws2_32.lib on windows)
+
+#include "xmlrpcpp/XmlRpc.h"
+#include <iostream>
+#include <fstream>
+#include <stdlib.h>
+
+using namespace XmlRpc;
+
+std::string parseRequest(std::string const& xml, XmlRpcValue& params);
+
+
+int main(int argc, char* argv[])
+{
+  if (argc != 4) {
+    std::cerr << "Usage: FileClient serverHost serverPort requestXmlFile\n";
+    return -1;
+  }
+  int port = atoi(argv[2]);
+
+  XmlRpc::setVerbosity(5);
+  XmlRpcClient c(argv[1], port);
+
+  //
+  std::ifstream infile(argv[3]);
+  if (infile.fail()) {
+    std::cerr << "Could not open file '" << argv[3] << "'.\n";
+    return -1;
+  }
+
+  // Suck in the file. This is a one-liner in good compilers (which vc++ 6 is not)...
+  infile.seekg(0L, std::ios::end);
+  long nb = infile.tellg();
+  infile.clear();
+  infile.seekg(0L);
+  char* b = new char[nb+1];
+  infile.read(b, nb);
+  b[nb] = 0;
+
+  std::cout << "Read file.\n";
+
+  // Find the methodName and parse the params
+  std::string s(b);
+  XmlRpcValue params;
+  std::string name = parseRequest(s, params);
+
+  if (name.empty()) {
+    std::cerr << "Could not parse file\n";
+    return -1;
+  }
+
+  for (;;) {
+    XmlRpcValue result;
+    std::cout << "Calling " << name << std::endl;
+    if (c.execute(name.c_str(), params, result))
+      std::cout << result << "\n\n";
+    else
+      std::cout << "Error calling '" << name << "'\n\n";
+    std::cout << "Again? [y]: ";
+    std::string ans;
+    std::cin >> ans;
+    if (ans != "" && ans != "y") break;
+  }
+
+  return 0;
+}
+
+
+// 
+std::string
+parseRequest(std::string const& xml, XmlRpcValue& params)
+{
+  const char METHODNAME_TAG[] = "<methodName>";
+  const char PARAMS_TAG[] = "<params>";
+  const char PARAMS_ETAG[] = "</params>";
+  const char PARAM_TAG[] = "<param>";
+  const char PARAM_ETAG[] = "</param>";
+
+  int offset = 0;   // Number of chars parsed from the request
+
+  std::string methodName = XmlRpcUtil::parseTag(METHODNAME_TAG, xml, &offset);
+  XmlRpcUtil::log(3, "XmlRpcServerConnection::parseRequest: parsed methodName %s.", methodName.c_str()); 
+
+  if (! methodName.empty() && XmlRpcUtil::findTag(PARAMS_TAG, xml, &offset))
+  {
+    int nArgs = 0;
+    while (XmlRpcUtil::nextTagIs(PARAM_TAG, xml, &offset)) {
+      std::cout << "Parsing arg " << nArgs+1 << std::endl;
+      XmlRpcValue arg(xml, &offset);
+      if ( ! arg.valid()) {
+        std::cerr << "Invalid argument\n";
+        return std::string();
+      }
+      std::cout << "Adding arg " << nArgs+1 << " to params array." << std::endl;
+      params[nArgs++] = arg;
+      (void) XmlRpcUtil::nextTagIs(PARAM_ETAG, xml, &offset);
+    }
+
+    XmlRpcUtil::log(3, "XmlRpcServerConnection::parseRequest: parsed %d params.", nArgs); 
+
+    (void) XmlRpcUtil::nextTagIs(PARAMS_ETAG, xml, &offset);
+  }
+
+  return methodName;
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/FileClient.dsp
@@ -0,0 +1,96 @@
+# Microsoft Developer Studio Project File - Name="FileClient" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=FileClient - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "FileClient.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "FileClient.mak" CFG="FileClient - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "FileClient - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "FileClient - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "FileClient - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /I "..\src" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /FD /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 xmlrpc.lib Ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /libpath:"..\release"
+
+!ELSEIF  "$(CFG)" == "FileClient - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /ZI /Od /I "..\src" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /FD /GZ /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 xmlrpc.lib Ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\Debug"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "FileClient - Win32 Release"
+# Name "FileClient - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\FileClient.cpp
+# End Source File
+# End Group
+# End Target
+# End Project
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/FileClient.vcproj
@@ -0,0 +1,158 @@
+<?xml version="1.0" encoding = "Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.00"
+	Name="FileClient"
+	ProjectGUID="{C3B49855-CD45-448E-991E-3E4C9B02F465}"
+	SccProjectName=""
+	SccLocalPath="">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\src"
+				PreprocessorDefinitions="WIN32,NDEBUG,_CONSOLE,_WINDOWS"
+				StringPooling="TRUE"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="TRUE"
+				PrecompiledHeaderFile=".\Release/FileClient.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				CompileAs="0">
+				<IntelOptions
+					Optimization="2"
+					InlineFuncExpansion="1"
+					OmitFramePtrs="1"
+					StringPooling="1"
+					RuntimeLibrary="2"
+					BufferSecurityCheck="1"
+					FunctionLevelLinking="1"
+					AllOptions="/c  /I &quot;..\src&quot; /nologo /W3 /O2 /Ob1 /Oy /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /GF /FD /EHsc /MD /GS /Gy /Fp&quot;.\Release/FileClient.pch&quot; /Fo&quot;.\Release/&quot; /Fd&quot;.\Release/&quot; /Gd"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\Release/FileClient.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="..\release"
+				ProgramDatabaseFile=".\Release/FileClient.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Release/FileClient.exe&quot; /INCREMENTAL:NO /LIBPATH:&quot;..\release&quot; xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib /PDB:&quot;.\Release/FileClient.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/FileClient.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\src"
+				PreprocessorDefinitions="WIN32,_DEBUG,_CONSOLE,_WINDOWS"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				PrecompiledHeaderFile=".\Debug/FileClient.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0">
+				<IntelOptions
+					Optimization="0"
+					MinimalRebuild="1"
+					BasicRuntimeChecks="3"
+					RuntimeLibrary="3"
+					AllOptions="/c  /I &quot;..\src&quot; /ZI /nologo /W3 /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /Gm /EHsc /RTC1 /MDd /Fp&quot;.\Debug/FileClient.pch&quot; /Fo&quot;.\Debug/&quot; /Fd&quot;.\Debug/&quot; /Gd"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\Debug/FileClient.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="..\Debug"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile=".\Debug/FileClient.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Debug/FileClient.exe&quot; /INCREMENTAL /LIBPATH:&quot;..\Debug&quot; xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib /DEBUG /PDB:&quot;.\Debug/FileClient.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/FileClient.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+	</Configurations>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
+			<File
+				RelativePath=".\FileClient.cpp"/>
+		</Filter>
+	</Files>
+	<Globals/>
+</VisualStudioProject>
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/HelloClient.cpp
@@ -0,0 +1,88 @@
+// HelloClient.cpp : A simple xmlrpc client. Usage: HelloClient serverHost serverPort
+// Link against xmlrpc lib and whatever socket libs your system needs (ws2_32.lib 
+// on windows)
+#include "xmlrpcpp/XmlRpc.h"
+#include <iostream>
+using namespace XmlRpc;
+
+int main(int argc, char* argv[])
+{
+  if (argc != 3) {
+    std::cerr << "Usage: HelloClient serverHost serverPort\n";
+    return -1;
+  }
+  int port = atoi(argv[2]);
+  //XmlRpc::setVerbosity(5);
+
+  // Use introspection API to look up the supported methods
+  XmlRpcClient c(argv[1], port);
+  XmlRpcValue noArgs, result;
+  for (int i = 0; i < 2000; i++)
+  {
+    if (c.execute("system.listMethods", noArgs, result))
+      std::cout << "\nMethods:\n " << result << "\n\n";
+    else
+      std::cout << "Error calling 'listMethods'\n\n";
+  }
+
+  // Use introspection API to get the help string for the Hello method
+  XmlRpcValue oneArg;
+  oneArg[0] = "Hello";
+  if (c.execute("system.methodHelp", oneArg, result))
+    std::cout << "Help for 'Hello' method: " << result << "\n\n";
+  else
+    std::cout << "Error calling 'methodHelp'\n\n";
+
+  // Call the Hello method
+  if (c.execute("Hello", noArgs, result))
+    std::cout << result << "\n\n";
+  else
+    std::cout << "Error calling 'Hello'\n\n";
+
+  // Call the HelloName method
+  oneArg[0] = "Chris";
+  if (c.execute("HelloName", oneArg, result))
+    std::cout << result << "\n\n";
+  else
+    std::cout << "Error calling 'HelloName'\n\n";
+
+  // Add up an array of numbers
+  XmlRpcValue numbers;
+  numbers[0] = 33.33;
+  numbers[1] = 112.57;
+  numbers[2] = 76.1;
+  std::cout << "numbers.size() is " << numbers.size() << std::endl;
+  if (c.execute("Sum", numbers, result))
+    std::cout << "Sum = " << double(result) << "\n\n";
+  else
+    std::cout << "Error calling 'Sum'\n\n";
+
+  // Test the "no such method" fault
+  if (c.execute("NoSuchMethod", numbers, result))
+    std::cout << "NoSuchMethod call: fault: " << c.isFault() << ", result = " << result << std::endl;
+  else
+    std::cout << "Error calling 'Sum'\n";
+
+  // Test the multicall method. It accepts one arg, an array of structs
+  XmlRpcValue multicall;
+  multicall[0][0]["methodName"] = "Sum";
+  multicall[0][0]["params"][0] = 5.0;
+  multicall[0][0]["params"][1] = 9.0;
+
+  multicall[0][1]["methodName"] = "NoSuchMethod";
+  multicall[0][1]["params"][0] = "";
+
+  multicall[0][2]["methodName"] = "Sum";
+  // Missing params
+
+  multicall[0][3]["methodName"] = "Sum";
+  multicall[0][3]["params"][0] = 10.5;
+  multicall[0][3]["params"][1] = 12.5;
+
+  if (c.execute("system.multicall", multicall, result))
+    std::cout << "\nmulticall  result = " << result << std::endl;
+  else
+    std::cout << "\nError calling 'system.multicall'\n";
+
+  return 0;
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/HelloClient.dsp
@@ -0,0 +1,96 @@
+# Microsoft Developer Studio Project File - Name="HelloClient" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=HelloClient - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "HelloClient.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "HelloClient.mak" CFG="HelloClient - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "HelloClient - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "HelloClient - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "HelloClient - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /I "..\src" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /FD /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 xmlrpc.lib Ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /libpath:"..\release"
+
+!ELSEIF  "$(CFG)" == "HelloClient - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /ZI /Od /I "..\src" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /FD /GZ /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 xmlrpc.lib Ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\Debug"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "HelloClient - Win32 Release"
+# Name "HelloClient - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\HelloClient.cpp
+# End Source File
+# End Group
+# End Target
+# End Project
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/HelloClient.vcproj
@@ -0,0 +1,158 @@
+<?xml version="1.0" encoding = "Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.00"
+	Name="HelloClient"
+	ProjectGUID="{F6860B2F-0F3B-445E-92F2-6DF3D36C90F0}"
+	SccProjectName=""
+	SccLocalPath="">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\src"
+				PreprocessorDefinitions="WIN32,NDEBUG,_CONSOLE"
+				StringPooling="TRUE"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="TRUE"
+				PrecompiledHeaderFile=".\Release/HelloClient.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				CompileAs="0">
+				<IntelOptions
+					Optimization="2"
+					InlineFuncExpansion="1"
+					OmitFramePtrs="1"
+					StringPooling="1"
+					RuntimeLibrary="2"
+					BufferSecurityCheck="1"
+					FunctionLevelLinking="1"
+					AllOptions="/c  /I &quot;..\src&quot; /nologo /W3 /O2 /Ob1 /Oy /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /GF /FD /EHsc /MD /GS /Gy /Fp&quot;.\Release/HelloClient.pch&quot; /Fo&quot;.\Release/&quot; /Fd&quot;.\Release/&quot; /Gd"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\Release/HelloClient.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="..\release"
+				ProgramDatabaseFile=".\Release/HelloClient.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Release/HelloClient.exe&quot; /INCREMENTAL:NO /LIBPATH:&quot;..\release&quot; xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib /PDB:&quot;.\Release/HelloClient.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/HelloClient.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\src"
+				PreprocessorDefinitions="WIN32,_DEBUG,_CONSOLE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				PrecompiledHeaderFile=".\Debug/HelloClient.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0">
+				<IntelOptions
+					Optimization="0"
+					MinimalRebuild="1"
+					BasicRuntimeChecks="3"
+					RuntimeLibrary="3"
+					AllOptions="/c  /I &quot;..\src&quot; /ZI /nologo /W3 /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /Gm /EHsc /RTC1 /MDd /Fp&quot;.\Debug/HelloClient.pch&quot; /Fo&quot;.\Debug/&quot; /Fd&quot;.\Debug/&quot; /Gd"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386 &quot;c:\home\cmm\dev\sourceforge\xmlrpc++\Debug\xmlrpc.lib&quot;"
+				AdditionalDependencies="xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\Debug/HelloClient.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="..\Debug"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile=".\Debug/HelloClient.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Debug/HelloClient.exe&quot; /INCREMENTAL /LIBPATH:&quot;..\Debug&quot; xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib /DEBUG /PDB:&quot;.\Debug/HelloClient.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/HelloClient.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+	</Configurations>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
+			<File
+				RelativePath=".\HelloClient.cpp"/>
+		</Filter>
+	</Files>
+	<Globals/>
+</VisualStudioProject>
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/HelloServer.cpp
@@ -0,0 +1,82 @@
+// HelloServer.cpp : Simple XMLRPC server example. Usage: HelloServer serverPort
+//
+#include "xmlrpcpp/XmlRpc.h"
+
+#include <iostream>
+#include <stdlib.h>
+
+using namespace XmlRpc;
+
+// The server
+XmlRpcServer s;
+
+// No arguments, result is "Hello".
+class Hello : public XmlRpcServerMethod
+{
+public:
+  Hello(XmlRpcServer* s) : XmlRpcServerMethod("Hello", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    result = "Hello";
+  }
+
+  std::string help() { return std::string("Say hello"); }
+
+} hello(&s);    // This constructor registers the method with the server
+
+
+// One argument is passed, result is "Hello, " + arg.
+class HelloName : public XmlRpcServerMethod
+{
+public:
+  HelloName(XmlRpcServer* s) : XmlRpcServerMethod("HelloName", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    std::string resultString = "Hello, ";
+    resultString += std::string(params[0]);
+    result = resultString;
+  }
+} helloName(&s);
+
+
+// A variable number of arguments are passed, all doubles, result is their sum.
+class Sum : public XmlRpcServerMethod
+{
+public:
+  Sum(XmlRpcServer* s) : XmlRpcServerMethod("Sum", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    int nArgs = params.size();
+    double sum = 0.0;
+    for (int i=0; i<nArgs; ++i)
+      sum += double(params[i]);
+    result = sum;
+  }
+} sum(&s);
+
+
+int main(int argc, char* argv[])
+{
+  if (argc != 2) {
+    std::cerr << "Usage: HelloServer serverPort\n";
+    return -1;
+  }
+  int port = atoi(argv[1]);
+
+  XmlRpc::setVerbosity(5);
+
+  // Create the server socket on the specified port
+  s.bindAndListen(port);
+
+  // Enable introspection
+  s.enableIntrospection(true);
+
+  // Wait for requests indefinitely
+  s.work(-1.0);
+
+  return 0;
+}
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/HelloServer.dsp
@@ -0,0 +1,96 @@
+# Microsoft Developer Studio Project File - Name="HelloServer" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=HelloServer - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "HelloServer.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "HelloServer.mak" CFG="HelloServer - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "HelloServer - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "HelloServer - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "HelloServer - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /I "..\src" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /FD /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 xmlrpc.lib Ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /libpath:"..\release"
+
+!ELSEIF  "$(CFG)" == "HelloServer - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /ZI /Od /I "..\src" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /FD /GZ /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 xmlrpc.lib Ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\Debug"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "HelloServer - Win32 Release"
+# Name "HelloServer - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\HelloServer.cpp
+# End Source File
+# End Group
+# End Target
+# End Project
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/HelloServer.vcproj
@@ -0,0 +1,158 @@
+<?xml version="1.0" encoding = "Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.00"
+	Name="HelloServer"
+	ProjectGUID="{08C4FFA8-A9E5-4EEA-9703-53C293C2F724}"
+	SccProjectName=""
+	SccLocalPath="">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\src"
+				PreprocessorDefinitions="WIN32,NDEBUG,_CONSOLE"
+				StringPooling="TRUE"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="TRUE"
+				PrecompiledHeaderFile=".\Release/HelloServer.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				CompileAs="0">
+				<IntelOptions
+					Optimization="2"
+					InlineFuncExpansion="1"
+					OmitFramePtrs="1"
+					StringPooling="1"
+					RuntimeLibrary="2"
+					BufferSecurityCheck="1"
+					FunctionLevelLinking="1"
+					AllOptions="/c  /I &quot;..\src&quot; /nologo /W3 /O2 /Ob1 /Oy /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /GF /FD /EHsc /MD /GS /Gy /Fp&quot;.\Release/HelloServer.pch&quot; /Fo&quot;.\Release/&quot; /Fd&quot;.\Release/&quot; /Gd"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\Release/HelloServer.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="..\release"
+				ProgramDatabaseFile=".\Release/HelloServer.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Release/HelloServer.exe&quot; /INCREMENTAL:NO /LIBPATH:&quot;..\release&quot; xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib /PDB:&quot;.\Release/HelloServer.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/HelloServer.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\src"
+				PreprocessorDefinitions="WIN32,_DEBUG,_CONSOLE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				PrecompiledHeaderFile=".\Debug/HelloServer.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0">
+				<IntelOptions
+					Optimization="0"
+					MinimalRebuild="1"
+					BasicRuntimeChecks="3"
+					RuntimeLibrary="3"
+					AllOptions="/c  /I &quot;..\src&quot; /ZI /nologo /W3 /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /Gm /EHsc /RTC1 /MDd /Fp&quot;.\Debug/HelloServer.pch&quot; /Fo&quot;.\Debug/&quot; /Fd&quot;.\Debug/&quot; /Gd"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\Debug/HelloServer.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="..\Debug"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile=".\Debug/HelloServer.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Debug/HelloServer.exe&quot; /INCREMENTAL /LIBPATH:&quot;..\Debug&quot; xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib /DEBUG /PDB:&quot;.\Debug/HelloServer.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/HelloServer.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+	</Configurations>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
+			<File
+				RelativePath=".\HelloServer.cpp"/>
+		</Filter>
+	</Files>
+	<Globals/>
+</VisualStudioProject>
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/Makefile
@@ -0,0 +1,26 @@
+# makefile written for gnu make
+CXX		= g++
+SRC		= ../src
+CPPFLAGS	= -I$(SRC)
+DEBUG		= -g
+#OPTIMIZE	= -O2
+GCCWARN		= -Wall
+CXXFLAGS	= $(DEBUG) $(GCCWARN) $(OPTIMIZE) $(INCLUDES)
+
+LIB		= ../libXmlRpc.a
+
+# Add your system-dependent network libs here
+# Solaris: -lsocket -lnsl
+SYSTEMLIBS	=
+
+LDLIBS		= $(SYSTEMLIBS) $(LIB)
+
+TESTS		= HelloClient HelloServer TestBase64Client TestBase64Server TestValues TestXml Validator port_zero_server bool_test
+
+all:		$(TESTS)
+
+$(TESTS):	$(LIB)
+
+clean:
+		rm -f *.o
+		rm -f $(TESTS)
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/TestBase64Client.cpp
@@ -0,0 +1,45 @@
+// TestBase64Client.cpp : A simple xmlrpc client that returns a png file
+// encoded as base64 data to the client.
+//
+// Usage: TestBase64Client serverHost serverPort outputfile
+// Requests a png file from the specified server and saves it in outputfile.
+// Link against xmlrpc lib and whatever socket libs your system needs (ws2_32.lib on windows)
+
+#include "xmlrpcpp/XmlRpc.h"
+#include <iostream>
+#include <fstream>
+#include <stdlib.h>
+
+using namespace XmlRpc;
+
+int main(int argc, char* argv[])
+{
+  if (argc != 4) {
+    std::cerr << "Usage: TestBase64Client serverHost serverPort outputFile\n";
+    return -1;
+  }
+  int port = atoi(argv[2]);
+
+  //XmlRpc::setVerbosity(5);
+  XmlRpcClient c(argv[1], port);
+
+  XmlRpcValue noArgs, result;
+  if (c.execute("TestBase64", noArgs, result))
+  {
+    const XmlRpcValue::BinaryData& data = result;
+    std::ofstream outfile(argv[3], std::ios::binary | std::ios::trunc);
+    if (outfile.fail())
+      std::cerr << "Error opening " << argv[3] << " for output.\n";
+    else
+    {
+      int n = int(data.size());
+      for (int i=0; i<n; ++i)
+        outfile << data[i];
+    }
+  }
+  else
+    std::cout << "Error calling 'TestBase64'\n\n";
+
+  return 0;
+}
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/TestBase64Client.dsp
@@ -0,0 +1,96 @@
+# Microsoft Developer Studio Project File - Name="TestBase64Client" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=TestBase64Client - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "TestBase64Client.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "TestBase64Client.mak" CFG="TestBase64Client - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "TestBase64Client - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "TestBase64Client - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "TestBase64Client - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /I "..\src" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /FD /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 xmlrpc.lib Ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /libpath:"..\release"
+
+!ELSEIF  "$(CFG)" == "TestBase64Client - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /ZI /Od /I "..\src" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /FD /GZ /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 xmlrpc.lib Ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\Debug"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "TestBase64Client - Win32 Release"
+# Name "TestBase64Client - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\TestBase64Client.cpp
+# End Source File
+# End Group
+# End Target
+# End Project
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/TestBase64Client.vcproj
@@ -0,0 +1,158 @@
+<?xml version="1.0" encoding = "Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.00"
+	Name="TestBase64Client"
+	ProjectGUID="{1E8B725B-E898-494C-84C6-DB77EF38E6CB}"
+	SccProjectName=""
+	SccLocalPath="">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\src"
+				PreprocessorDefinitions="WIN32,_DEBUG,_CONSOLE,_WINDOWS"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				PrecompiledHeaderFile=".\Debug/TestBase64Client.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0">
+				<IntelOptions
+					Optimization="0"
+					MinimalRebuild="1"
+					BasicRuntimeChecks="3"
+					RuntimeLibrary="3"
+					AllOptions="/c  /I &quot;..\src&quot; /ZI /nologo /W3 /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /Gm /EHsc /RTC1 /MDd /Fp&quot;.\Debug/TestBase64Client.pch&quot; /Fo&quot;.\Debug/&quot; /Fd&quot;.\Debug/&quot; /Gd"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\Debug/TestBase64Client.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="..\Debug"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile=".\Debug/TestBase64Client.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Debug/TestBase64Client.exe&quot; /INCREMENTAL /LIBPATH:&quot;..\Debug&quot; xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib /DEBUG /PDB:&quot;.\Debug/TestBase64Client.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/TestBase64Client.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\src"
+				PreprocessorDefinitions="WIN32,NDEBUG,_CONSOLE,_WINDOWS"
+				StringPooling="TRUE"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="TRUE"
+				PrecompiledHeaderFile=".\Release/TestBase64Client.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				CompileAs="0">
+				<IntelOptions
+					Optimization="2"
+					InlineFuncExpansion="1"
+					OmitFramePtrs="1"
+					StringPooling="1"
+					RuntimeLibrary="2"
+					BufferSecurityCheck="1"
+					FunctionLevelLinking="1"
+					AllOptions="/c  /I &quot;..\src&quot; /nologo /W3 /O2 /Ob1 /Oy /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /GF /FD /EHsc /MD /GS /Gy /Fp&quot;.\Release/TestBase64Client.pch&quot; /Fo&quot;.\Release/&quot; /Fd&quot;.\Release/&quot; /Gd"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\Release/TestBase64Client.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="..\release"
+				ProgramDatabaseFile=".\Release/TestBase64Client.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Release/TestBase64Client.exe&quot; /INCREMENTAL:NO /LIBPATH:&quot;..\release&quot; xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib /PDB:&quot;.\Release/TestBase64Client.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/TestBase64Client.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+	</Configurations>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
+			<File
+				RelativePath=".\TestBase64Client.cpp"/>
+		</Filter>
+	</Files>
+	<Globals/>
+</VisualStudioProject>
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/TestBase64Server.cpp
@@ -0,0 +1,68 @@
+// TestBase64Server.cpp : Simple XMLRPC server example. Usage: TestBase64Server serverPort
+//
+#if defined(_MSC_VER)
+# pragma warning(disable:4786)    // identifier was truncated in debug info
+#endif
+
+
+#include <iostream>
+#include <fstream>
+#include <algorithm>
+#include <stdlib.h>
+
+
+#include "xmlrpcpp/XmlRpc.h"
+using namespace XmlRpc;
+
+
+// The server
+XmlRpcServer s;
+
+// No arguments, result is Base64-encoded pngnow.png data.
+class TestBase64 : public XmlRpcServerMethod
+{
+public:
+  TestBase64(XmlRpcServer* s) : XmlRpcServerMethod("TestBase64", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    std::ifstream infile("pngnow.png", std::ios::binary);
+    if (infile.fail())
+      infile.open("../pngnow.png", std::ios::binary);
+    if (infile.fail())
+      result = "Could not open file pngnow.png";
+    else {
+
+      XmlRpcValue::BinaryData& data = result;
+      int n = 0;
+      for (;; ++n) {
+        char c = infile.get();
+        if (infile.eof()) break;
+        data.push_back(c);
+      }
+      std::cerr << "Read " << n << " bytes from pngnow.png\n";
+    }
+  }
+} TestBase64(&s);    // This constructor registers the method with the server
+
+
+
+int main(int argc, char* argv[])
+{
+  if (argc != 2) {
+    std::cerr << "Usage: TestBase64Server serverPort\n";
+    return -1;
+  }
+  int port = atoi(argv[1]);
+
+  //XmlRpc::setVerbosity(5);
+
+  // Create the server socket on the specified port
+  s.bindAndListen(port);
+
+  // Wait for requests indefinitely
+  s.work(-1.0);
+
+  return 0;
+}
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/TestBase64Server.dsp
@@ -0,0 +1,96 @@
+# Microsoft Developer Studio Project File - Name="TestBase64Server" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=TestBase64Server - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "TestBase64Server.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "TestBase64Server.mak" CFG="TestBase64Server - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "TestBase64Server - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "TestBase64Server - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "TestBase64Server - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /I "..\src" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /FD /c
+# SUBTRACT CPP /Fr /YX /Yc /Yu
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 xmlrpc.lib Ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /libpath:"..\release"
+
+!ELSEIF  "$(CFG)" == "TestBase64Server - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /ZI /Od /I "..\src" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /FD /GZ /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 xmlrpc.lib Ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\Debug"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "TestBase64Server - Win32 Release"
+# Name "TestBase64Server - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\TestBase64Server.cpp
+# End Source File
+# End Group
+# End Target
+# End Project
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/TestBase64Server.vcproj
@@ -0,0 +1,158 @@
+<?xml version="1.0" encoding = "Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.00"
+	Name="TestBase64Server"
+	ProjectGUID="{D3107CC6-6300-47DE-B183-255B75CFE85A}"
+	SccProjectName=""
+	SccLocalPath="">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\src"
+				PreprocessorDefinitions="WIN32,NDEBUG,_CONSOLE,_WINDOWS"
+				StringPooling="TRUE"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="TRUE"
+				PrecompiledHeaderFile=".\Release/TestBase64Server.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				CompileAs="0">
+				<IntelOptions
+					Optimization="2"
+					InlineFuncExpansion="1"
+					OmitFramePtrs="1"
+					StringPooling="1"
+					RuntimeLibrary="2"
+					BufferSecurityCheck="1"
+					FunctionLevelLinking="1"
+					AllOptions="/c  /I &quot;..\src&quot; /nologo /W3 /O2 /Ob1 /Oy /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /GF /FD /EHsc /MD /GS /Gy /Fp&quot;.\Release/TestBase64Server.pch&quot; /Fo&quot;.\Release/&quot; /Fd&quot;.\Release/&quot; /Gd"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\Release/TestBase64Server.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="..\release"
+				ProgramDatabaseFile=".\Release/TestBase64Server.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Release/TestBase64Server.exe&quot; /INCREMENTAL:NO /LIBPATH:&quot;..\release&quot; xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib /PDB:&quot;.\Release/TestBase64Server.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/TestBase64Server.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\src"
+				PreprocessorDefinitions="WIN32,_DEBUG,_CONSOLE,_WINDOWS"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				PrecompiledHeaderFile=".\Debug/TestBase64Server.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0">
+				<IntelOptions
+					Optimization="0"
+					MinimalRebuild="1"
+					BasicRuntimeChecks="3"
+					RuntimeLibrary="3"
+					AllOptions="/c  /I &quot;..\src&quot; /ZI /nologo /W3 /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /Gm /EHsc /RTC1 /MDd /Fp&quot;.\Debug/TestBase64Server.pch&quot; /Fo&quot;.\Debug/&quot; /Fd&quot;.\Debug/&quot; /Gd"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\Debug/TestBase64Server.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="..\Debug"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile=".\Debug/TestBase64Server.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Debug/TestBase64Server.exe&quot; /INCREMENTAL /LIBPATH:&quot;..\Debug&quot; xmlrpc.lib Ws2_32.lib odbc32.lib odbccp32.lib /DEBUG /PDB:&quot;.\Debug/TestBase64Server.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/TestBase64Server.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+	</Configurations>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
+			<File
+				RelativePath=".\TestBase64Server.cpp"/>
+		</Filter>
+	</Files>
+	<Globals/>
+</VisualStudioProject>
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/TestValues.cpp
@@ -0,0 +1,233 @@
+// TestValues.cpp : Test XML encoding and decoding of XmlRpcValues.
+
+#include <stdlib.h>
+
+#include "xmlrpcpp/XmlRpcValue.h"
+
+
+#include <assert.h>
+#include <iostream>
+
+
+using namespace XmlRpc;
+
+
+void testBoolean()
+{
+  XmlRpcValue booleanFalse(false);
+  XmlRpcValue booleanTrue(true);
+  int offset = 0;
+  XmlRpcValue booleanFalseXml("<value><boolean>0</boolean></value>", &offset);
+  offset = 0;
+  XmlRpcValue booleanTrueXml("<value><boolean>1</boolean></value>", &offset);
+  assert(booleanFalse != booleanTrue);
+  assert(booleanFalse == booleanFalseXml);
+  assert(booleanFalse != booleanTrueXml);
+
+  if (bool(booleanFalse))
+    assert(false);
+
+  if ( ! bool(booleanTrue))
+    assert(false);
+}
+
+// Int
+void testInt()
+{
+  XmlRpcValue int0(0);
+  XmlRpcValue int1(1);
+  XmlRpcValue int10(10);
+  XmlRpcValue int_1(-1);
+  int offset = 0;
+  XmlRpcValue int0Xml("<value><int>0</int></value>", &offset);
+  offset = 0;
+  XmlRpcValue int9Xml("<value><i4>9</i4></value>", &offset);
+  assert(int0 == int0Xml);
+  assert(int(int10) - int(int1) == int(int9Xml));
+  assert(9 == int(int9Xml));
+  assert(int(int10) + int(int_1) == int(int9Xml));
+}
+
+void testDouble()
+{
+  // Double
+  XmlRpcValue d(43.7);
+  int offset = 0;
+  XmlRpcValue dXml("<value><double>56.3</double></value>", &offset);
+  assert(double(d) + double(dXml) == 100.0);  // questionable practice...
+}
+
+void testString()
+{
+  // String
+  XmlRpcValue s("Now is the time <&");
+  char csxml[] = "<value><string>Now is the time &lt;&amp;</string></value>";
+  std::string ssxml = csxml;
+  int offset = 0;
+  XmlRpcValue vscXml(csxml, &offset);
+  offset = 0;
+  XmlRpcValue vssXml(ssxml, &offset);
+  assert(s == vscXml);
+  assert(s == vssXml);
+  offset = 0;
+  XmlRpcValue fromXml(vssXml.toXml(), &offset);
+  assert(s == fromXml);
+
+  // Empty or blank strings with no <string> tags
+  std::string emptyStringXml("<value></value>");
+  offset = 0;
+  XmlRpcValue emptyStringVal1(emptyStringXml, &offset);
+  XmlRpcValue emptyStringVal2("");
+  assert(emptyStringVal1 == emptyStringVal2);
+
+  emptyStringXml = "<value>  </value>";
+  offset = 0;
+  XmlRpcValue blankStringVal(emptyStringXml, &offset);
+  assert(std::string(blankStringVal) == "  ");
+}
+
+
+void testDateTime()
+{
+  // DateTime
+  int offset = 0;
+  XmlRpcValue dateTime("<value><dateTime.iso8601>19040101T03:12:35</dateTime.iso8601></value>", &offset);
+  struct tm &t = dateTime;
+  assert(t.tm_year == 1904 && t.tm_min == 12);
+}
+
+
+void testArray(XmlRpcValue const& d)
+{
+  // Array
+  XmlRpcValue a;
+  a.setSize(4);
+  a[0] = 1;
+  a[1] = std::string("two");
+  a[2] = 43.7;
+  a[3] = "four";
+  assert(int(a[0]) == 1);
+  assert(a[2] == d);
+
+  char csaXml[] =
+    "<value><array>\n"
+    "  <data>\n"
+    "    <value><i4>1</i4></value> \n"
+    "    <value> <string>two</string></value>\n"
+    "    <value><double>43.7</double></value>\n"
+    "    <value>four</value>\n"
+    "  </data>\n"
+    "</array></value>";
+    
+  int offset = 0;
+  XmlRpcValue aXml(csaXml, &offset);
+  assert(a == aXml);
+}
+
+void testStruct()
+{
+  // Struct
+  XmlRpcValue struct1;
+  struct1["i4"] = 1;
+  struct1["str"] = "two";
+  struct1["d"] = 43.7;
+
+  XmlRpcValue a;
+  a.setSize(4);
+  a[0] = 1;
+  a[1] = std::string("two");
+  a[2] = 43.7;
+  a[3] = "four";
+
+  assert(struct1["d"] == a[2]);
+
+  char csStructXml[] =
+    "<value><struct>\n"
+    "  <member>\n"
+    "    <name>i4</name> \n"
+    "    <value><i4>1</i4></value> \n"
+    "  </member>\n"
+    "  <member>\n"
+    "    <name>d</name> \n"
+    "    <value><double>43.7</double></value>\n"
+    "  </member>\n"
+    "  <member>\n"
+    "    <name>str</name> \n"
+    "    <value> <string>two</string></value>\n"
+    "  </member>\n"
+    "</struct></value>";
+    
+  int offset = 0;
+  XmlRpcValue structXml(csStructXml, &offset);
+  assert(struct1 == structXml);
+
+  XmlRpcValue astruct;
+  astruct["array"] = a;
+  assert(astruct["array"][2] == struct1["d"]);
+
+  for (int i=0; i<10; i++) {
+    XmlRpcValue Event;
+    Event["Name"] = "string";
+
+    Event.clear();
+
+    const int NELMTS = 100;
+    int ii;
+
+    for (ii=0; ii< NELMTS; ++ii) {
+      char buf[40];
+      sprintf(buf,"%d", ii);
+      Event[std::string(buf)] = buf;
+    }
+
+    Event.clear();
+
+    for (ii=0; ii< NELMTS; ++ii) {
+      char buf[40];
+      sprintf(buf,"%d", ii);
+      if (ii != NELMTS/2)
+        Event[std::string(buf)] = ii;
+      else
+        for (int jj=0; jj< NELMTS; ++jj) {
+          char bufj[40];
+          sprintf(bufj,"%d", jj);
+          Event[std::string(buf)][std::string(bufj)] = bufj;
+        }
+    }
+
+    for (ii=0; ii< NELMTS; ++ii) {
+      char buf[40];
+      sprintf(buf,"%d", ii);
+      if (ii != NELMTS/2)
+        assert(Event[std::string(buf)] == XmlRpcValue(ii));
+      else
+        assert(Event[std::string(buf)].size() == NELMTS);
+    }
+  }
+}
+
+
+
+int main(int argc, char* argv[])
+{
+  testBoolean();
+
+  testInt();
+
+
+  testDouble();
+
+
+  testString();
+
+
+  testDateTime();
+
+
+  testArray(43.7);
+
+
+  testStruct();
+
+  return 0;
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/TestValues.dsp
@@ -0,0 +1,95 @@
+# Microsoft Developer Studio Project File - Name="TestValues" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=TestValues - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "TestValues.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "TestValues.mak" CFG="TestValues - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "TestValues - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "TestValues - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "TestValues - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /I "..\src" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 xmlrpc.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /libpath:"..\Release"
+
+!ELSEIF  "$(CFG)" == "TestValues - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /MDd /W3 /GX /Zi /Od /I "..\src" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /FR /FD /c
+# SUBTRACT CPP /nologo
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 xmlrpc.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\Debug"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "TestValues - Win32 Release"
+# Name "TestValues - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\TestValuesWin32.cpp
+# End Source File
+# End Group
+# End Target
+# End Project
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/TestValues.vcproj
@@ -0,0 +1,156 @@
+<?xml version="1.0" encoding = "Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.00"
+	Name="TestValues"
+	ProjectGUID="{6181BBE3-DA50-4EEE-8D52-1F4245A1D603}"
+	SccProjectName=""
+	SccLocalPath="">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				InlineFunctionExpansion="1"
+				PreprocessorDefinitions="WIN32,NDEBUG,_CONSOLE"
+				StringPooling="TRUE"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="TRUE"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderFile=".\Release/TestValues.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE">
+				<IntelOptions
+					Optimization="2"
+					InlineFuncExpansion="1"
+					OmitFramePtrs="1"
+					StringPooling="1"
+					RuntimeLibrary="2"
+					BufferSecurityCheck="1"
+					FunctionLevelLinking="1"
+					AllOptions="/c  /nologo /W3 /O2 /Ob1 /Oy /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /GF /FD /EHsc /MD /GS /Gy /YX&quot;StdAfx.h&quot; /Fp&quot;.\Release/TestValues.pch&quot; /Fo&quot;.\Release/&quot; /Fd&quot;.\Release/&quot; /Gd /TP"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="odbc32.lib odbccp32.lib"
+				OutputFile=".\Release/TestValues.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				ProgramDatabaseFile=".\Release/TestValues.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Release/TestValues.exe&quot; /INCREMENTAL:NO odbc32.lib odbccp32.lib /PDB:&quot;.\Release/TestValues.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/TestValues.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\src"
+				PreprocessorDefinitions="WIN32,_DEBUG,_CONSOLE,_WINDOWS"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				PrecompiledHeaderFile=".\Debug/TestValues.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0">
+				<IntelOptions
+					Optimization="0"
+					MinimalRebuild="1"
+					BasicRuntimeChecks="3"
+					RuntimeLibrary="3"
+					AllOptions="/c  /I &quot;..\src&quot; /ZI /nologo /W3 /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /Gm /EHsc /RTC1 /MDd /Fp&quot;.\Debug/TestValues.pch&quot; /Fo&quot;.\Debug/&quot; /Fd&quot;.\Debug/&quot; /Gd"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="xmlrpc.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\Debug/TestValues.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="..\Debug"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile=".\Debug/TestValues.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Debug/TestValues.exe&quot; /INCREMENTAL /LIBPATH:&quot;..\Debug&quot; xmlrpc.lib odbc32.lib odbccp32.lib /DEBUG /PDB:&quot;.\Debug/TestValues.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/TestValues.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+	</Configurations>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
+			<File
+				RelativePath=".\TestValues.cpp"/>
+		</Filter>
+	</Files>
+	<Globals/>
+</VisualStudioProject>
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/TestValuesWin32.cpp
@@ -0,0 +1,253 @@
+// TestValues.cpp : Test XML encoding and decoding of XmlRpcValues.
+
+#define _CRTDBG_MAP_ALLOC
+#include <stdlib.h>
+#include <crtdbg.h>
+
+#include "xmlrpcpp/XmlRpcValue.h"
+
+
+#include <assert.h>
+#include <iostream>
+
+
+using namespace XmlRpc;
+
+
+void testBoolean()
+{
+  XmlRpcValue booleanFalse(false);
+  XmlRpcValue booleanTrue(true);
+  int offset = 0;
+  XmlRpcValue booleanFalseXml("<value><boolean>0</boolean></value>", &offset);
+  offset = 0;
+  XmlRpcValue booleanTrueXml("<value><boolean>1</boolean></value>", &offset);
+  assert(booleanFalse != booleanTrue);
+  assert(booleanFalse == booleanFalseXml);
+  assert(booleanFalse == booleanFalseXml);
+  if (booleanFalse)
+    assert(false);
+
+  if (booleanTrue)
+    assert( ! false);
+  else
+    assert(false);
+}
+
+// Int
+void testInt()
+{
+  XmlRpcValue int0(0);
+  XmlRpcValue int1(1);
+  XmlRpcValue int10(10);
+  XmlRpcValue int_1(-1);
+  int offset = 0;
+  XmlRpcValue int0Xml("<value><int>0</int></value>", &offset);
+  offset = 0;
+  XmlRpcValue int9Xml("<value><i4>9</i4></value>", &offset);
+  assert(int0 == int0Xml);
+  assert(int(int10) - int(int1) == int(int9Xml));
+  assert(9 == int(int9Xml));
+  assert(int(int10) + int(int_1) == int(int9Xml));
+}
+
+void testDouble()
+{
+  // Double
+  XmlRpcValue d(43.7);
+  int offset = 0;
+  XmlRpcValue dXml("<value><double>56.3</double></value>", &offset);
+  assert(double(d) + double(dXml) == 100.0);  // questionable practice...
+}
+
+void testString()
+{
+  // String
+  XmlRpcValue s("Now is the time <&");
+  char csxml[] = "<value><string>Now is the time &lt;&amp;</string></value>";
+  std::string ssxml = csxml;
+  int offset = 0;
+  XmlRpcValue vscXml(csxml, &offset);
+  offset = 0;
+  XmlRpcValue vssXml(ssxml, &offset);
+  assert(s == vscXml);
+  assert(s == vssXml);
+  offset = 0;
+  XmlRpcValue fromXml(vssXml.toXml(), &offset);
+  assert(s == fromXml);
+
+  // Empty or blank strings with no <string> tags
+  std::string emptyStringXml("<value></value>");
+  offset = 0;
+  XmlRpcValue emptyStringVal1(emptyStringXml, &offset);
+  XmlRpcValue emptyStringVal2("");
+  assert(emptyStringVal1 == emptyStringVal2);
+
+  emptyStringXml = "<value>  </value>";
+  offset = 0;
+  XmlRpcValue blankStringVal(emptyStringXml, &offset);
+  assert(std::string(blankStringVal) == "  ");
+}
+
+
+void testDateTime()
+{
+  // DateTime
+  int offset = 0;
+  XmlRpcValue dateTime("<value><dateTime.iso8601>19040101T03:12:35</dateTime.iso8601></value>", &offset);
+  struct tm &t = dateTime;
+  assert(t.tm_year == 1904 && t.tm_min == 12);
+}
+
+
+void testArray(XmlRpcValue const& d)
+{
+  // Array
+  XmlRpcValue a;
+  a.setSize(4);
+  a[0] = 1;
+  a[1] = std::string("two");
+  a[2] = 43.7;
+  a[3] = "four";
+  assert(int(a[0]) == 1);
+  assert(a[2] == d);
+
+  char csaXml[] =
+    "<value><array>\n"
+    "  <data>\n"
+    "    <value><i4>1</i4></value> \n"
+    "    <value> <string>two</string></value>\n"
+    "    <value><double>43.7</double></value>\n"
+    "    <value>four</value>\n"
+    "  </data>\n"
+    "</array></value>";
+    
+  int offset = 0;
+  XmlRpcValue aXml(csaXml, &offset);
+  assert(a == aXml);
+}
+
+void testStruct()
+{
+  // Struct
+  XmlRpcValue struct1;
+  struct1["i4"] = 1;
+  struct1["str"] = "two";
+  struct1["d"] = 43.7;
+
+  XmlRpcValue a;
+  a.setSize(4);
+  a[0] = 1;
+  a[1] = std::string("two");
+  a[2] = 43.7;
+  a[3] = "four";
+
+  assert(struct1["d"] == a[2]);
+
+  char csStructXml[] =
+    "<value><struct>\n"
+    "  <member>\n"
+    "    <name>i4</name> \n"
+    "    <value><i4>1</i4></value> \n"
+    "  </member>\n"
+    "  <member>\n"
+    "    <name>d</name> \n"
+    "    <value><double>43.7</double></value>\n"
+    "  </member>\n"
+    "  <member>\n"
+    "    <name>str</name> \n"
+    "    <value> <string>two</string></value>\n"
+    "  </member>\n"
+    "</struct></value>";
+    
+  int offset = 0;
+  XmlRpcValue structXml(csStructXml, &offset);
+  assert(struct1 == structXml);
+
+  XmlRpcValue astruct;
+  astruct["array"] = a;
+  assert(astruct["array"][2] == struct1["d"]);
+
+  for (int i=0; i<10; i++) {
+    XmlRpcValue Event;
+    Event["Name"] = "string";
+
+    Event.clear();
+
+    const int NELMTS = 100;
+    int ii;
+
+    for (ii=0; ii< NELMTS; ++ii) {
+      char buf[40];
+      sprintf(buf,"%d", ii);
+      Event[buf] = buf;
+    }
+
+    Event.clear();
+
+    for (ii=0; ii< NELMTS; ++ii) {
+      char buf[40];
+      sprintf(buf,"%d", ii);
+      if (ii != NELMTS/2)
+        Event[buf] = ii;
+      else
+        for (int jj=0; jj< NELMTS; ++jj) {
+          char bufj[40];
+          sprintf(bufj,"%d", jj);
+          Event[buf][bufj] = bufj;
+        }
+    }
+
+    for (ii=0; ii< NELMTS; ++ii) {
+      char buf[40];
+      sprintf(buf,"%d", ii);
+      if (ii != NELMTS/2)
+        assert(Event[buf] == XmlRpcValue(ii));
+      else
+        assert(Event[buf].size() == NELMTS);
+    }
+  }
+}
+
+
+
+int main(int argc, char* argv[])
+{
+  _CrtDumpMemoryLeaks();
+  _CrtCheckMemory( );
+
+  testBoolean();
+  _CrtDumpMemoryLeaks();
+  _CrtCheckMemory( );
+
+  testInt();
+  _CrtDumpMemoryLeaks();
+  _CrtCheckMemory( );
+
+
+  testDouble();
+  _CrtDumpMemoryLeaks();
+  _CrtCheckMemory( );
+
+
+  testString();
+  _CrtDumpMemoryLeaks();
+  _CrtCheckMemory( );
+
+
+  testDateTime();
+  _CrtDumpMemoryLeaks();
+  _CrtCheckMemory( );
+
+
+  testArray(43.7);
+  _CrtDumpMemoryLeaks();
+  _CrtCheckMemory( );
+
+
+  testStruct();
+  _CrtDumpMemoryLeaks();
+  _CrtCheckMemory( );
+
+  return 0;
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/TestXml.cpp
@@ -0,0 +1,53 @@
+// TestXml.cpp : Test XML encoding and decoding.
+// The characters <>&'" are illegal in xml and must be encoded.
+
+
+#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
+
+#include <iostream>
+// If you are using MSVC++6, you should update <string> to fix
+// BUG: getline Template Function Reads Extra Character
+#include <string>
+#include <assert.h>
+#include <stdlib.h>
+
+#include "xmlrpcpp/XmlRpcUtil.h"
+
+using namespace XmlRpc;
+
+
+int main(int argc, char* argv[])
+{
+  // Basic tests
+  std::string empty;
+  assert(empty == XmlRpcUtil::xmlEncode(empty));
+  assert(empty == XmlRpcUtil::xmlDecode(empty));
+  assert(empty == XmlRpcUtil::xmlEncode(""));
+  assert(empty == XmlRpcUtil::xmlDecode(""));
+
+  std::string raw("<>&'\"");
+  assert(XmlRpcUtil::xmlDecode(XmlRpcUtil::xmlEncode(raw)) == raw);
+  
+  std::cout << "Basic tests passed.\n";
+
+  // Interactive tests
+  std::string s;
+  for (;;) {
+    std::cout << "\nEnter line of raw text to encode:\n";
+    std::getline(std::cin, s);
+    if (s.empty()) break;
+
+    std::cout << XmlRpcUtil::xmlEncode(s) << std::endl;
+  }
+
+  for (;;) {
+    std::cout << "\nEnter line of xml-encoded text to decode:\n";
+    std::getline(std::cin, s);
+    if (s.empty()) break;
+
+    std::cout << XmlRpcUtil::xmlDecode(s) << std::endl;
+  }
+
+  return 0;
+}
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/TestXml.dsp
@@ -0,0 +1,96 @@
+# Microsoft Developer Studio Project File - Name="TestXml" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=TestXml - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "TestXml.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "TestXml.mak" CFG="TestXml - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "TestXml - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "TestXml - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "TestXml - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /I "..\src" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FD /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 xmlrpc.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /libpath:"..\release"
+
+!ELSEIF  "$(CFG)" == "TestXml - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /ZI /Od /I "..\src" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FD /GZ /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 xmlrpc.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\Debug"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "TestXml - Win32 Release"
+# Name "TestXml - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\TestXml.cpp
+# End Source File
+# End Group
+# End Target
+# End Project
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/TestXml.vcproj
@@ -0,0 +1,158 @@
+<?xml version="1.0" encoding = "Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.00"
+	Name="TestXml"
+	ProjectGUID="{6F0C2ADA-0341-4183-8FAA-576668F1788A}"
+	SccProjectName=""
+	SccLocalPath="">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\src"
+				PreprocessorDefinitions="WIN32,NDEBUG,_CONSOLE"
+				StringPooling="TRUE"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="TRUE"
+				PrecompiledHeaderFile=".\Release/TestXml.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				CompileAs="0">
+				<IntelOptions
+					Optimization="2"
+					InlineFuncExpansion="1"
+					OmitFramePtrs="1"
+					StringPooling="1"
+					RuntimeLibrary="2"
+					BufferSecurityCheck="1"
+					FunctionLevelLinking="1"
+					AllOptions="/c  /I &quot;..\src&quot; /nologo /W3 /O2 /Ob1 /Oy /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /GF /FD /EHsc /MD /GS /Gy /Fp&quot;.\Release/TestXml.pch&quot; /Fo&quot;.\Release/&quot; /Fd&quot;.\Release/&quot; /Gd"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="xmlrpc.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\Release/TestXml.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="..\release"
+				ProgramDatabaseFile=".\Release/TestXml.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Release/TestXml.exe&quot; /INCREMENTAL:NO /LIBPATH:&quot;..\release&quot; xmlrpc.lib odbc32.lib odbccp32.lib /PDB:&quot;.\Release/TestXml.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/TestXml.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\src"
+				PreprocessorDefinitions="WIN32,_DEBUG,_CONSOLE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				PrecompiledHeaderFile=".\Debug/TestXml.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0">
+				<IntelOptions
+					Optimization="0"
+					MinimalRebuild="1"
+					BasicRuntimeChecks="3"
+					RuntimeLibrary="3"
+					AllOptions="/c  /I &quot;..\src&quot; /ZI /nologo /W3 /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /Gm /EHsc /RTC1 /MDd /Fp&quot;.\Debug/TestXml.pch&quot; /Fo&quot;.\Debug/&quot; /Fd&quot;.\Debug/&quot; /Gd"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="xmlrpc.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\Debug/TestXml.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="..\Debug"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile=".\Debug/TestXml.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Debug/TestXml.exe&quot; /INCREMENTAL /LIBPATH:&quot;..\Debug&quot; xmlrpc.lib odbc32.lib odbccp32.lib /DEBUG /PDB:&quot;.\Debug/TestXml.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/TestXml.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+	</Configurations>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
+			<File
+				RelativePath=".\TestXml.cpp"/>
+		</Filter>
+	</Files>
+	<Globals/>
+</VisualStudioProject>
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/Validator.cpp
@@ -0,0 +1,207 @@
+// Validator.cpp : XMLRPC server based on the compliancy test at validator.xmlrpc.com.
+//
+#include "xmlrpcpp/XmlRpc.h"
+using namespace XmlRpc;
+
+#include <iostream>
+
+
+XmlRpcServer s;
+
+
+// One argument is passed, an array of structs, each with a member named curly with 
+// an integer value. Return the sum of those values.
+
+class ArrayOfStructsTest : public XmlRpcServerMethod
+{
+public:
+  ArrayOfStructsTest(XmlRpcServer* s) : XmlRpcServerMethod("validator1.arrayOfStructsTest", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    std::cerr << "ArrayOfStructsTest\n";
+    XmlRpcValue& arg1 = params[0];
+    int n = arg1.size(), sum = 0;
+    for (int i=0; i<n; ++i) 
+      sum += int(arg1[i]["curly"]);
+
+    result = sum;
+  }
+} arrayOfStructsTest(&s);
+
+
+// This handler takes a single parameter, a string, that contains any number of predefined 
+// entities, namely <, >, &, ' and ".
+// The handler must return a struct that contains five fields, all numbers: ctLeftAngleBrackets, 
+// ctRightAngleBrackets, ctAmpersands, ctApostrophes, ctQuotes. 
+// To validate, the numbers must be correct.
+
+class CountTheEntities : public XmlRpcServerMethod
+{
+public:
+  CountTheEntities(XmlRpcServer* s) : XmlRpcServerMethod("validator1.countTheEntities", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    std::cerr << "CountTheEntities\n";
+    std::string& arg = params[0];
+    int ctLeftAngleBrackets = 0;
+    int ctRightAngleBrackets = 0;
+    int ctAmpersands = 0;
+    int ctApostrophes = 0;
+    int ctQuotes = 0;
+
+    int n = int(arg.length());
+    for (int i=0; i<n; ++i)
+      switch (arg[i])
+      {
+        case '<': ++ctLeftAngleBrackets; break;
+        case '>': ++ctRightAngleBrackets; break;
+        case '&': ++ctAmpersands; break;
+        case '\'': ++ctApostrophes; break;
+        case '\"': ++ctQuotes; break;
+      }
+
+    result["ctLeftAngleBrackets"] = ctLeftAngleBrackets;
+    result["ctRightAngleBrackets"] = ctRightAngleBrackets;
+    result["ctAmpersands"] = ctAmpersands;
+    result["ctApostrophes"] = ctApostrophes;
+    result["ctQuotes"] = ctQuotes;
+  }
+} countTheEntities(&s);
+
+
+
+// This handler takes a single parameter, a struct, containing at least three elements 
+// named moe, larry and curly, all <i4>s. Your handler must add the three numbers and 
+// return the result.
+
+class EasyStructTest : public XmlRpcServerMethod
+{
+public:
+  EasyStructTest(XmlRpcServer* s) : XmlRpcServerMethod("validator1.easyStructTest", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    std::cerr << "EasyStructTest\n";
+    XmlRpcValue& arg1 = params[0];
+    int sum = int(arg1["moe"]) + int(arg1["larry"]) + int(arg1["curly"]);
+    result = sum;
+  }
+} easyStructTest(&s);
+
+
+// This handler takes a single parameter, a struct. Your handler must return the struct.
+
+class EchoStructTest : public XmlRpcServerMethod
+{
+public:
+  EchoStructTest(XmlRpcServer* s) : XmlRpcServerMethod("validator1.echoStructTest", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    std::cerr << "EchoStructTest\n";
+    result = params[0];
+  }
+} echoStructTest(&s);
+
+
+
+// This handler takes six parameters, and returns an array containing all the parameters.
+
+class ManyTypesTest : public XmlRpcServerMethod
+{
+public:
+  ManyTypesTest(XmlRpcServer* s) : XmlRpcServerMethod("validator1.manyTypesTest", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    std::cerr << "ManyTypesTest\n";
+    result = params;
+  }
+} manyTypesTest(&s);
+
+
+
+// This handler takes a single parameter, which is an array containing between 100 and 
+// 200 elements. Each of the items is a string, your handler must return a string 
+// containing the concatenated text of the first and last elements.
+
+
+class ModerateSizeArrayCheck : public XmlRpcServerMethod
+{
+public:
+  ModerateSizeArrayCheck(XmlRpcServer* s) : XmlRpcServerMethod("validator1.moderateSizeArrayCheck", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    std::cerr << "ModerateSizeArrayCheck\n";
+    std::string s = params[0][0];
+    s += std::string(params[0][params[0].size()-1]);
+    result = s;
+  }
+} moderateSizeArrayCheck(&s);
+
+
+// This handler takes a single parameter, a struct, that models a daily calendar.
+// At the top level, there is one struct for each year. Each year is broken down
+// into months, and months into days. Most of the days are empty in the struct
+// you receive, but the entry for April 1, 2000 contains a least three elements
+// named moe, larry and curly, all <i4>s. Your handler must add the three numbers
+// and return the result.
+
+class NestedStructTest : public XmlRpcServerMethod
+{
+public:
+  NestedStructTest(XmlRpcServer* s) : XmlRpcServerMethod("validator1.nestedStructTest", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    std::cerr << "NestedStructTest\n";
+    XmlRpcValue& dayStruct = params[0]["2000"]["04"]["01"];
+    int sum = int(dayStruct["moe"]) + int(dayStruct["larry"]) + int(dayStruct["curly"]);
+    result = sum;
+  }
+} nestedStructTest(&s);
+
+
+
+// This handler takes one parameter, and returns a struct containing three elements, 
+// times10, times100 and times1000, the result of multiplying the number by 10, 100 and 1000.
+
+class SimpleStructReturnTest : public XmlRpcServerMethod
+{
+public:
+  SimpleStructReturnTest(XmlRpcServer* s) : XmlRpcServerMethod("validator1.simpleStructReturnTest", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    std::cerr << "SimpleStructReturnTest\n";
+    int n = params[0];
+    result["times10"] = n * 10;
+    result["times100"] = n * 100;
+    result["times1000"] = n * 1000;
+  }
+} simpleStructReturnTest(&s);
+
+
+
+int main(int argc, char* argv[])
+{
+  if (argc != 2) {
+    std::cerr << "Usage: Validator port\n";
+    return -1;
+  }
+  int port = atoi(argv[1]);
+
+  XmlRpc::setVerbosity(5);
+
+  // Create the server socket on the specified port
+  s.bindAndListen(port);
+
+  // Wait for requests indefinitely
+  s.work(-1.0);
+
+  return 0;
+}
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/Validator.dsp
@@ -0,0 +1,95 @@
+# Microsoft Developer Studio Project File - Name="Validator" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=Validator - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "Validator.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "Validator.mak" CFG="Validator - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "Validator - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "Validator - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "Validator - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
+# ADD CPP /nologo /MD /W3 /GX /Zd /O2 /I "..\src" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /FD /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 xmlrpc.lib ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /libpath:"..\release"
+
+!ELSEIF  "$(CFG)" == "Validator - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /ZI /Od /I "..\src" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /FD /GZ /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 xmlrpc.lib WS2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\debug"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "Validator - Win32 Release"
+# Name "Validator - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\Validator.cpp
+# End Source File
+# End Group
+# End Target
+# End Project
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/Validator.vcproj
@@ -0,0 +1,157 @@
+<?xml version="1.0" encoding = "Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.00"
+	Name="Validator"
+	ProjectGUID="{E68AB694-4805-43EA-A96E-21B8FE285DE4}"
+	SccProjectName=""
+	SccLocalPath="">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				InlineFunctionExpansion="1"
+				PreprocessorDefinitions="WIN32,NDEBUG,_CONSOLE,_WINDOWS"
+				StringPooling="TRUE"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="TRUE"
+				UsePrecompiledHeader="3"
+				PrecompiledHeaderThrough="stdafx.h"
+				PrecompiledHeaderFile=".\Release/Validator.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE">
+				<IntelOptions
+					Optimization="2"
+					InlineFuncExpansion="1"
+					OmitFramePtrs="1"
+					StringPooling="1"
+					RuntimeLibrary="2"
+					BufferSecurityCheck="1"
+					FunctionLevelLinking="1"
+					AllOptions="/c  /nologo /W3 /O2 /Ob1 /Oy /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /GF /FD /EHsc /MD /GS /Gy /Yu&quot;stdafx.h&quot; /Fp&quot;.\Release/Validator.pch&quot; /Fo&quot;.\Release/&quot; /Fd&quot;.\Release/&quot; /Gd /TP"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="odbc32.lib odbccp32.lib"
+				OutputFile=".\Release/Validator.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				ProgramDatabaseFile=".\Release/Validator.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Release/Validator.exe&quot; /INCREMENTAL:NO odbc32.lib odbccp32.lib /PDB:&quot;.\Release/Validator.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/Validator.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\src"
+				PreprocessorDefinitions="WIN32,_DEBUG,_CONSOLE,_WINDOWS"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				PrecompiledHeaderFile=".\Debug/Validator.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0">
+				<IntelOptions
+					Optimization="0"
+					MinimalRebuild="1"
+					BasicRuntimeChecks="3"
+					RuntimeLibrary="3"
+					AllOptions="/c  /I &quot;..\src&quot; /ZI /nologo /W3 /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /Gm /EHsc /RTC1 /MDd /Fp&quot;.\Debug/Validator.pch&quot; /Fo&quot;.\Debug/&quot; /Fd&quot;.\Debug/&quot; /Gd"/>
+			</Tool>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="xmlrpc.lib WS2_32.lib odbc32.lib odbccp32.lib"
+				OutputFile=".\Debug/Validator.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="..\debug"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile=".\Debug/Validator.pdb"
+				SubSystem="1">
+				<IntelOptions
+					AllOptions="/NOLOGO /OUT:&quot;.\Debug/Validator.exe&quot; /INCREMENTAL /LIBPATH:&quot;..\debug&quot; xmlrpc.lib WS2_32.lib odbc32.lib odbccp32.lib /DEBUG /PDB:&quot;.\Debug/Validator.pdb&quot; /SUBSYSTEM:CONSOLE /TLBID:1 /MACHINE:I386 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib"/>
+			</Tool>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/Validator.tlb"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<IntelOptions
+				CompilerName="1"/>
+		</Configuration>
+	</Configurations>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
+			<File
+				RelativePath=".\Validator.cpp"/>
+		</Filter>
+	</Files>
+	<Globals/>
+</VisualStudioProject>
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/arrayOfStructsTest.xml
@@ -0,0 +1,255 @@
+<?xml version="1.0"?>
+<methodCall>
+	<methodName>validator1.arrayOfStructsTest</methodName>
+	<params>
+		<param>
+			<value><array>
+				<data>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-84</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>87</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>77</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-46</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>27</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>33</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-70</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>89</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>30</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-90</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>42</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>6</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-28</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>96</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>92</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-31</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>81</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>85</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-18</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>62</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>9</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-98</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>79</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>66</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-3</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>59</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>80</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-83</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>27</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>19</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-85</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>4</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>16</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					</data>
+				</array></value>
+			</param>
+		</params>
+	</methodCall>
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/bool_test.cpp
@@ -0,0 +1,21 @@
+// bool_test.cpp : make sure bool variables copy around ok
+#include "xmlrpcpp/XmlRpc.h"
+#include <iostream>
+#include <stdlib.h>
+
+using namespace XmlRpc;
+using namespace std;
+
+int main(int argc, char* argv[])
+{
+  XmlRpcValue v(bool(false));
+  cout << v.toXml() << endl;
+  XmlRpcValue v2;
+  v2[0] = int(1);
+  v2[1] = string();
+  v2[2] = XmlRpcValue(false);
+  cout << v2.toXml() << endl;
+
+  return 0;
+}
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/countTheEntities.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0"?>
+<methodCall>
+	<methodName>validator1.countTheEntities</methodName>
+	<params>
+		<param>
+			<value>&'<p"dgt"&>'<&"'<s>>ehv<j><>iu'<<<y"'>qo>"z"f<l&'"akn<&r'c'wbm&&x''</value>
+			</param>
+		</params>
+	</methodCall>
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/easyStructTest.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0"?>
+<methodCall>
+	<methodName>validator1.easyStructTest</methodName>
+	<params>
+		<param>
+			<value><struct>
+				<member>
+					<name>curly</name>
+					<value>
+						<i4>-78</i4>
+						</value>
+					</member>
+				<member>
+					<name>larry</name>
+					<value>
+						<i4>23</i4>
+						</value>
+					</member>
+				<member>
+					<name>moe</name>
+					<value>
+						<i4>38</i4>
+						</value>
+					</member>
+				</struct></value>
+			</param>
+		</params>
+	</methodCall>
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/echo.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0"?>
+<methodCall>
+	<methodName>echo</methodName>
+	<params>
+		<param><value><string>Hello Chris</string></value></param>
+		<param><value><i4>123</i4></value></param>
+		</params>
+	</methodCall>
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/echoStructTest.xml
@@ -0,0 +1,261 @@
+<?xml version="1.0"?>
+<methodCall>
+	<methodName>validator1.echoStructTest</methodName>
+	<params>
+		<param>
+			<value><struct>
+				<member>
+					<name>substruct0</name>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-76</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>31</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>44</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					</member>
+				<member>
+					<name>substruct1</name>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-9</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>42</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>57</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					</member>
+				<member>
+					<name>substruct2</name>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-15</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>69</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>78</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					</member>
+				<member>
+					<name>substruct3</name>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-91</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>66</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>4</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					</member>
+				<member>
+					<name>substruct4</name>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-47</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>66</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>8</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					</member>
+				<member>
+					<name>substruct5</name>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-68</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>26</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>87</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					</member>
+				<member>
+					<name>substruct6</name>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-59</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>20</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>74</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					</member>
+				<member>
+					<name>substruct7</name>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-57</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>30</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>75</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					</member>
+				<member>
+					<name>substruct8</name>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-34</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>33</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>30</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					</member>
+				<member>
+					<name>substruct9</name>
+					<value>
+						<struct>
+							<member>
+								<name>curly</name>
+								<value>
+									<i4>-64</i4>
+									</value>
+								</member>
+							<member>
+								<name>larry</name>
+								<value>
+									<i4>98</i4>
+									</value>
+								</member>
+							<member>
+								<name>moe</name>
+								<value>
+									<i4>17</i4>
+									</value>
+								</member>
+							</struct>
+						</value>
+					</member>
+				</struct></value>
+			</param>
+		</params>
+	</methodCall>
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/pngnow.png
@@ -0,0 +1 @@
+PNG
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/standalone-tests/port_zero_server.cpp
@@ -0,0 +1,76 @@
+// HelloServer.cpp : Simple XMLRPC server example. Usage: HelloServer serverPort
+//
+#include "xmlrpcpp/XmlRpc.h"
+
+#include <iostream>
+#include <stdlib.h>
+
+using namespace XmlRpc;
+
+// The server
+XmlRpcServer s;
+
+// No arguments, result is "Hello".
+class Hello : public XmlRpcServerMethod
+{
+public:
+  Hello(XmlRpcServer* s) : XmlRpcServerMethod("Hello", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    result = "Hello";
+  }
+
+  std::string help() { return std::string("Say hello"); }
+
+} hello(&s);    // This constructor registers the method with the server
+
+
+// One argument is passed, result is "Hello, " + arg.
+class HelloName : public XmlRpcServerMethod
+{
+public:
+  HelloName(XmlRpcServer* s) : XmlRpcServerMethod("HelloName", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    std::string resultString = "Hello, ";
+    resultString += std::string(params[0]);
+    result = resultString;
+  }
+} helloName(&s);
+
+
+// A variable number of arguments are passed, all doubles, result is their sum.
+class Sum : public XmlRpcServerMethod
+{
+public:
+  Sum(XmlRpcServer* s) : XmlRpcServerMethod("Sum", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    int nArgs = params.size();
+    double sum = 0.0;
+    for (int i=0; i<nArgs; ++i)
+      sum += double(params[i]);
+    result = sum;
+  }
+} sum(&s);
+
+
+int main(int argc, char* argv[])
+{
+  XmlRpc::setVerbosity(5);
+
+  // Create the server socket on the specified port
+  s.bindAndListen(0);
+
+  // Enable introspection
+  s.enableIntrospection(true);
+
+  // Wait for requests indefinitely
+  s.work(-1.0);
+
+  return 0;
+}
+
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/CMakeLists.txt
@@ -0,0 +1,135 @@
+catkin_add_gtest(xmlrpcvalue_base64 xmlrpcvalue_base64.cpp)
+if(TARGET xmlrpcvalue_base64)
+  target_link_libraries(xmlrpcvalue_base64 xmlrpcpp)
+endif()
+
+catkin_add_gtest(test_base64 test_base64.cpp)
+if(TARGET test_base64)
+  target_link_libraries(test_base64 xmlrpcpp)
+endif()
+
+if(WIN32)
+  # On Windows, gtest can be built as shared (dll) or static (lib),
+  # to simplify the problem, here we require to match BUILD_SHARED_LIBS we used
+  if(BUILD_SHARED_LIBS)
+    set_target_properties(test_base64 PROPERTIES COMPILE_DEFINITIONS "GTEST_LINKED_AS_SHARED_LIBRARY=1")
+  endif()
+endif()
+
+# Some of the tests that follow use boost threads.
+find_package(Boost REQUIRED COMPONENTS thread)
+include_directories(${Boost_INCLUDE_DIRS})
+
+add_library(test_fixtures test_fixtures.cpp)
+target_link_libraries(test_fixtures xmlrpcpp ${Boost_LIBRARIES} ${GTEST_LIBRARIES})
+set_target_properties(test_fixtures PROPERTIES EXCLUDE_FROM_ALL TRUE)
+
+catkin_add_gtest(HelloTest HelloTest.cpp)
+if(TARGET HelloTest)
+  target_link_libraries(HelloTest xmlrpcpp ${Boost_LIBRARIES})
+endif()
+
+catkin_add_gtest(test_dispatch_live test_dispatch_live.cpp)
+if(TARGET test_dispatch_live)
+  target_link_libraries(test_dispatch_live xmlrpcpp test_fixtures ${Boost_LIBRARIES})
+endif()
+
+catkin_add_gtest(test_ulimit test_ulimit.cpp)
+if(TARGET test_ulimit)
+  target_link_libraries(test_ulimit xmlrpcpp test_fixtures ${Boost_LIBRARIES})
+endif()
+
+add_library(mock_socket mock_socket.cpp)
+target_link_libraries(mock_socket ${GTEST_LIBRARIES})
+set_target_properties(mock_socket PROPERTIES EXCLUDE_FROM_ALL TRUE)
+
+catkin_add_gtest(test_client
+  test_client.cpp
+  ../src/XmlRpcClient.cpp
+  ../src/XmlRpcValue.cpp
+  ../src/XmlRpcUtil.cpp
+  ../src/XmlRpcDispatch.cpp
+  ../src/XmlRpcSource.cpp
+  ../libb64/src/cdecode.c
+  ../libb64/src/cencode.c
+)
+if(WIN32)
+  # build everything from source, undefine ROS_BUILD_SHARED_LIBS to eliminate the dllimport/dllexport attributes
+  set_target_properties(test_client PROPERTIES COMPILE_FLAGS -UROS_BUILD_SHARED_LIBS)
+endif()
+
+if(TARGET test_client)
+  target_link_libraries(test_client mock_socket ${catkin_LIBRARIES})
+  if(WIN32)
+    target_link_libraries(test_client ws2_32)
+  endif()
+endif()
+
+catkin_add_gtest(test_dispatch
+  test_dispatch.cpp
+  ../src/XmlRpcDispatch.cpp
+  ../src/XmlRpcSource.cpp
+  ../src/XmlRpcUtil.cpp
+  ../libb64/src/cdecode.c
+  ../libb64/src/cencode.c
+)
+if(WIN32)
+  # build everything from source, undefine ROS_BUILD_SHARED_LIBS to eliminate the dllimport/dllexport attributes
+  set_target_properties(test_dispatch PROPERTIES COMPILE_FLAGS -UROS_BUILD_SHARED_LIBS)
+endif()
+
+if(TARGET test_dispatch)
+  target_link_libraries(test_dispatch mock_socket ${catkin_LIBRARIES})
+  if(WIN32)
+    target_link_libraries(test_dispatch ws2_32)
+  endif()
+
+  if(APPLE)
+    set_target_properties(test_dispatch PROPERTIES
+      LINK_FLAGS
+      "-Wl,-alias,___wrap_poll,_poll"
+    )
+  elseif(UNIX)
+    set_target_properties(test_dispatch PROPERTIES
+      LINK_FLAGS
+      "-Wl,--wrap=poll"
+    )
+  endif()
+endif()
+
+if(NOT WIN32)
+  catkin_add_gtest(test_socket
+    test_socket.cpp
+    test_system_mocks.c
+    ../src/XmlRpcSocket.cpp
+    ../src/XmlRpcUtil.cpp
+  )
+  if(TARGET test_socket)
+    if(APPLE)
+      set_target_properties(test_socket PROPERTIES
+        LINK_FLAGS
+        "-Wl,-alias,___wrap_accept,_accept -Wl,-alias,___wrap_bind,_bind -Wl,-alias,___wrap_close,_close -Wl,-alias,___wrap_connect,_connect -Wl,-alias,___wrap_getaddrinfo,_getaddrinfo -Wl,-alias,___wrap_getsockname,_getsockname -Wl,-alias,___wrap_listen,_listen -Wl,-alias,___wrap_read,_read -Wl,-alias,___wrap_setsockopt,_setsockopt -Wl,-alias,___wrap_select,_select -Wl,-alias,___wrap_select,_select$1050 -Wl,-alias,___wrap_socket,_socket -Wl,-alias,___wrap_write,_write -Wl,-alias,___wrap_fcntl,_fcntl -Wl,-alias,___wrap_freeaddrinfo,_freeaddrinfo"
+      )
+    elseif(UNIX)
+      set_target_properties(test_socket PROPERTIES
+        LINK_FLAGS
+        "-Wl,--wrap=accept -Wl,--wrap=bind -Wl,--wrap=close -Wl,--wrap=connect -Wl,--wrap=getaddrinfo -Wl,--wrap=getsockname -Wl,--wrap=listen -Wl,--wrap=read -Wl,--wrap=setsockopt -Wl,--wrap=select -Wl,--wrap=socket -Wl,--wrap=write -Wl,--wrap=fcntl -Wl,--wrap=freeaddrinfo"
+      )
+    endif()
+  endif()
+endif()
+
+catkin_add_gtest(TestValues TestValues.cpp)
+if(TARGET TestValues)
+  target_link_libraries(TestValues xmlrpcpp)
+endif()
+
+catkin_add_gtest(test_util test_util.cpp)
+if(TARGET test_util)
+  target_link_libraries(test_util xmlrpcpp)
+endif()
+
+catkin_add_gtest(TestXml TestXml.cpp)
+if(TARGET TestXml)
+  target_link_libraries(TestXml xmlrpcpp)
+endif()
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/HelloTest.cpp
@@ -0,0 +1,276 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ * Loosely based on HelloServer.cpp and HelloClient.cpp by Chris Morley
+ *
+ */
+
+#include "xmlrpcpp/XmlRpc.h"
+#include "xmlrpcpp/XmlRpcClient.h"
+#include "xmlrpcpp/XmlRpcServer.h"
+#include "xmlrpcpp/XmlRpcServerMethod.h"
+
+#include <iostream>
+#include <stdlib.h>
+#include <boost/thread/thread.hpp>
+#include <boost/thread/mutex.hpp>
+#include <functional>
+
+#include <gtest/gtest.h>
+
+using XmlRpc::XmlRpcServerMethod;
+using XmlRpc::XmlRpcServer;
+using XmlRpc::XmlRpcClient;
+using XmlRpc::XmlRpcValue;
+
+// No arguments, result is "Hello".
+class Hello : public XmlRpcServerMethod
+{
+public:
+  Hello(XmlRpcServer* s) : XmlRpcServerMethod("Hello", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    (void)params;
+    result = "Hello";
+  }
+
+  std::string help()
+  {
+    return std::string("Say hello");
+  }
+};
+
+// One argument is passed, result is "Hello, " + arg.
+class HelloName : public XmlRpcServerMethod
+{
+public:
+  HelloName(XmlRpcServer* s) : XmlRpcServerMethod("HelloName", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    std::string resultString = "Hello, ";
+    resultString += std::string(params[0]);
+    result = resultString;
+  }
+};
+
+// A variable number of arguments are passed, all doubles, result is their sum.
+class Sum : public XmlRpcServerMethod
+{
+public:
+  Sum(XmlRpcServer* s) : XmlRpcServerMethod("Sum", s) {}
+
+  void execute(XmlRpcValue& params, XmlRpcValue& result)
+  {
+    int nArgs = params.size();
+    double sum = 0.0;
+    for (int i = 0; i < nArgs; ++i)
+      sum += double(params[i]);
+    result = sum;
+  }
+};
+
+class XmlRpcTest : public ::testing::Test
+{
+protected:
+  XmlRpcTest() : hello(&s), helloName(&s), sum(&s), port(0), done(false) {}
+
+  void work()
+  {
+    while (!done)
+    {
+      s.work(0.1); // run the worker queue for 100ms
+    }
+  }
+
+  virtual void SetUp()
+  {
+    // XmlRpc::setVerbosity(5);
+
+    // Create the server socket. Passing 0 for the port number requests that
+    // the OS randomly select an available port.
+    s.bindAndListen(0);
+    // Retrieve the assigned port number.
+    port = s.get_port();
+
+    // Enable introspection.
+    s.enableIntrospection(true);
+
+    // Start the worker thread.
+    server_thread = boost::thread(boost::mem_fn(&XmlRpcTest::work), this);
+  }
+
+  virtual void TearDown()
+  {
+    // TODO(austin): determine if we need to do anything here to avoid
+    // leaking resources
+    done = true;
+    server_thread.join();
+    s.shutdown();
+  }
+
+  // The server and its methods
+  XmlRpcServer s;
+  Hello hello;
+  HelloName helloName;
+  Sum sum;
+
+  // Server port number (for clients)
+  int port;
+
+  // Server thread
+  bool done;
+  boost::thread server_thread;
+};
+
+TEST_F(XmlRpcTest, Introspection)
+{
+  XmlRpcClient c("localhost", port);
+
+  // Use introspection API to look up the supported methods
+  XmlRpcValue noArgs, result;
+
+  ASSERT_TRUE(c.execute("system.listMethods", noArgs, result));
+
+  XmlRpcValue methods;
+  methods[0] = "Hello";
+  methods[1] = "HelloName";
+  methods[2] = "Sum";
+  methods[3] = "system.listMethods";
+  methods[4] = "system.methodHelp";
+  methods[5] = "system.multicall";
+  EXPECT_EQ(result, methods);
+
+  // Use introspection API to get the help string for the Hello method
+  XmlRpcValue oneArg;
+  oneArg[0] = "Hello";
+
+  ASSERT_TRUE(c.execute("system.methodHelp", oneArg, result));
+
+  EXPECT_EQ(result, XmlRpcValue("Say hello"));
+
+  // Use introspection API to get the help string for the HelloName method
+  // This should be the default help string, ie empty string.
+  oneArg[0] = "HelloName";
+
+  ASSERT_TRUE(c.execute("system.methodHelp", oneArg, result));
+
+  EXPECT_EQ(result, XmlRpcValue(""));
+}
+
+TEST_F(XmlRpcTest, Hello)
+{
+  XmlRpcClient c("localhost", port);
+  XmlRpcValue noArgs, result;
+
+  // Call the Hello method
+  ASSERT_TRUE(c.execute("Hello", noArgs, result));
+
+  EXPECT_EQ(result, XmlRpcValue("Hello"));
+}
+
+TEST_F(XmlRpcTest, HelloURI)
+{
+  XmlRpcClient c("localhost", port, "/");
+  XmlRpcValue noArgs, result;
+
+  // Call the Hello method
+  ASSERT_TRUE(c.execute("Hello", noArgs, result));
+
+  EXPECT_EQ(result, XmlRpcValue("Hello"));
+}
+
+TEST_F(XmlRpcTest, HelloName)
+{
+  XmlRpcClient c("localhost", port);
+  XmlRpcValue oneArg, result;
+
+  // Call the HelloName method
+  oneArg[0] = "Chris";
+  ASSERT_TRUE(c.execute("HelloName", oneArg, result));
+
+  EXPECT_EQ(result, XmlRpcValue("Hello, Chris"));
+}
+
+TEST_F(XmlRpcTest, Sum)
+{
+  XmlRpcClient c("localhost", port);
+  XmlRpcValue result;
+
+  // Add up an array of numbers
+  XmlRpcValue numbers;
+  numbers[0] = 33.33;
+  numbers[1] = 112.57;
+  numbers[2] = 76.1;
+  EXPECT_EQ(numbers.size(), 3);
+
+  ASSERT_TRUE(c.execute("Sum", numbers, result));
+  EXPECT_DOUBLE_EQ(double(result), 222.0);
+
+  // Test the "no such method" fault
+  ASSERT_TRUE(c.execute("NoSuchMethod", numbers, result));
+  EXPECT_TRUE(c.isFault());
+
+  XmlRpcValue fault;
+  fault["faultCode"] = -1;
+  fault["faultString"] = "NoSuchMethod: unknown method name";
+  EXPECT_EQ(result, fault);
+}
+
+TEST_F(XmlRpcTest, Multicall)
+{
+  XmlRpcClient c("localhost", port);
+  XmlRpcValue result;
+
+  // Test the multicall method. It accepts one arg, an array of structs
+  XmlRpcValue multicall, expected_result;
+  multicall[0][0]["methodName"] = "Sum";
+  multicall[0][0]["params"][0] = 5.0;
+  multicall[0][0]["params"][1] = 9.0;
+  expected_result[0][0] = 14.0;
+
+  multicall[0][1]["methodName"] = "NoSuchMethod";
+  multicall[0][1]["params"][0] = "";
+  expected_result[1]["faultCode"] = -1;
+  expected_result[1]["faultString"] = "NoSuchMethod: unknown method name";
+
+  multicall[0][2]["methodName"] = "Sum";
+  // Missing params
+  expected_result[2]["faultCode"] = -1;
+  expected_result[2]["faultString"] = "system.multicall: Invalid argument "
+                                      "(expected a struct with members "
+                                      "methodName and params)";
+
+  multicall[0][3]["methodName"] = "Sum";
+  multicall[0][3]["params"][0] = 10.5;
+  multicall[0][3]["params"][1] = 12.5;
+  expected_result[3][0] = 23.0;
+
+  ASSERT_TRUE(c.execute("system.multicall", multicall, result));
+  EXPECT_EQ(result, expected_result);
+  EXPECT_EQ(result.toXml(), expected_result.toXml());
+}
+
+int main(int argc, char **argv)
+{
+  ::testing::InitGoogleTest(&argc, argv);
+  return RUN_ALL_TESTS();
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/TestValues.cpp
@@ -0,0 +1,1260 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ * Loosely based on the original TestValues.cpp by Chris Morley
+ *
+ */
+
+// TestValues.cpp : Test XML encoding and decoding of XmlRpcValues.
+
+#include <stdlib.h>
+#include <string>
+#include <climits>
+
+#include "xmlrpcpp/XmlRpcValue.h"
+#include "xmlrpcpp/XmlRpcException.h"
+#include "xmlrpcpp/XmlRpcUtil.h"
+
+#include <gtest/gtest.h>
+
+using namespace XmlRpc;
+
+TEST(XmlRpc, Bool) {
+  XmlRpcValue v(bool(false));
+
+  EXPECT_EQ("<value><boolean>0</boolean></value>", v.toXml());
+
+  XmlRpcValue v2;
+  v2[0] = int(1);
+  v2[1] = std::string();
+  v2[2] = XmlRpcValue(false);
+  EXPECT_EQ("<value><array><data><value><i4>1</i4></value><value></"
+            "value><value><boolean>0</boolean></value></data></array></value>",
+            v2.toXml());
+}
+
+TEST(XmlRpc, testBoolean) {
+  const XmlRpcValue booleanFalse(false);
+  XmlRpcValue booleanTrue(true);
+  int offset = 0;
+  XmlRpcValue booleanFalseXml("<value><boolean>0</boolean></value>", &offset);
+  offset = 0;
+  XmlRpcValue booleanTrueXml("<value><boolean>1</boolean></value>", &offset);
+  EXPECT_NE(booleanFalse, booleanTrue);
+  EXPECT_EQ(booleanFalse, booleanFalseXml);
+  EXPECT_NE(booleanFalse, booleanTrueXml);
+
+  EXPECT_FALSE(bool(booleanFalse));
+
+  EXPECT_TRUE(bool(booleanTrue));
+
+  // Test stream operator.
+  std::stringstream ss;
+  ss << booleanFalse;
+  EXPECT_EQ("0", ss.str());
+
+  std::stringstream ss2;
+  ss2 << booleanTrue;
+  EXPECT_EQ("1", ss2.str());
+}
+
+// Int
+TEST(XmlRpc, testInt) {
+  const XmlRpcValue int0(0);
+  ASSERT_EQ(XmlRpcValue::TypeInt, int0.getType());
+
+  XmlRpcValue int1(1);
+  ASSERT_EQ(XmlRpcValue::TypeInt, int1.getType());
+
+  XmlRpcValue int10(10);
+  ASSERT_EQ(XmlRpcValue::TypeInt, int10.getType());
+
+  XmlRpcValue int_1(-1);
+  ASSERT_EQ(XmlRpcValue::TypeInt, int_1.getType());
+
+  int offset = 0;
+  XmlRpcValue int0Xml("<value><int>0</int></value>", &offset);
+  ASSERT_EQ(XmlRpcValue::TypeInt, int0Xml.getType());
+  EXPECT_EQ(0, int(int0Xml));
+
+  offset = 0;
+  XmlRpcValue int9Xml("<value><i4>9</i4></value>", &offset);
+  ASSERT_EQ(XmlRpcValue::TypeInt, int9Xml.getType());
+  EXPECT_EQ(9, int(int9Xml));
+
+  EXPECT_EQ(int0, int0Xml);
+  EXPECT_EQ(int(int10) - int(int1), int(int9Xml));
+  EXPECT_EQ(9, int(int9Xml));
+  EXPECT_EQ(int(int10) + int(int_1), int(int9Xml));
+
+  // Test stream operator.
+  std::stringstream ss;
+  ss << int9Xml;
+  EXPECT_EQ("9", ss.str());
+}
+
+TEST(XmlRpc, testDouble) {
+  // Double
+  const XmlRpcValue d(43.7);
+  ASSERT_EQ(XmlRpcValue::TypeDouble, d.getType());
+  EXPECT_EQ("<value><double>43.700000000000003</double></value>", d.toXml());
+  EXPECT_DOUBLE_EQ(43.7, double(d));
+
+  int offset = 0;
+  XmlRpcValue dXml("<value><double>56.3</double></value>", &offset);
+  ASSERT_EQ(XmlRpcValue::TypeDouble, dXml.getType());
+  EXPECT_DOUBLE_EQ(56.3, double(dXml));
+
+  EXPECT_DOUBLE_EQ(100.0, double(d) + double(dXml));
+
+  // Test stream operator.
+  std::stringstream ss;
+  ss << d;
+  EXPECT_EQ("43.7", ss.str());
+  ss.str("");
+
+  // Test format
+  const XmlRpc::XmlRpcValue a(2.0);
+  ASSERT_EQ(XmlRpcValue::TypeDouble, d.getType());
+  const std::string save_format = XmlRpc::XmlRpcValue::getDoubleFormat();
+
+  XmlRpc::XmlRpcValue::setDoubleFormat("%32.10f");
+  ss << a;
+  EXPECT_EQ("                    2.0000000000", ss.str());
+  ss.str("");
+
+  XmlRpc::XmlRpcValue::setDoubleFormat("%10.32f");
+  ss << a;
+  EXPECT_EQ("2.00000000000000000000000000000000", ss.str());
+  ss.str("");
+
+  XmlRpc::XmlRpcValue::setDoubleFormat("%128.10f");
+  ss << a;
+  EXPECT_EQ("                                "
+            "                                "
+            "                                "
+            "                    2.000000000", ss.str());
+  ss.str("");
+
+  XmlRpc::XmlRpcValue::setDoubleFormat("%10.128f");
+  ss << a;
+  EXPECT_EQ("2.000000000000000000000000000000"
+            "00000000000000000000000000000000"
+            "00000000000000000000000000000000"
+            "000000000000000000000000000000000", ss.str());
+  ss.str("");
+
+  XmlRpc::XmlRpcValue::setDoubleFormat(save_format.c_str());
+}
+
+TEST(XmlRpc, testString) {
+  // String
+  const XmlRpcValue s("Now is the time <&");
+  ASSERT_EQ(XmlRpcValue::TypeString, s.getType());
+  EXPECT_EQ(18, s.size());
+  EXPECT_EQ("<value>Now is the time &lt;&amp;</value>", s.toXml());
+
+  char csxml[] = "<value><string>Now is the time &lt;&amp;</string></value>";
+  std::string ssxml = csxml;
+
+  int offset = 0;
+  XmlRpcValue vscXml(csxml, &offset);
+  EXPECT_EQ(s, vscXml);
+
+  offset = 0;
+  XmlRpcValue vssXml(ssxml, &offset);
+  EXPECT_EQ(s, vssXml);
+
+  offset = 0;
+  XmlRpcValue fromXml(vssXml.toXml(), &offset);
+  EXPECT_EQ(s, fromXml);
+
+  // Empty or blank strings with no <string> tags
+  std::string emptyStringXml("<value></value>");
+  offset = 0;
+  XmlRpcValue emptyStringVal1(emptyStringXml, &offset);
+  XmlRpcValue emptyStringVal2("");
+  EXPECT_EQ(emptyStringVal1, emptyStringVal2);
+
+  emptyStringXml = "<value>  </value>";
+  offset = 0;
+  XmlRpcValue blankStringVal(emptyStringXml, &offset);
+  EXPECT_EQ(std::string(blankStringVal), "  ");
+
+  // Implicitly initialized string.
+  XmlRpcValue s2;
+  std::string tmp = s2;
+  EXPECT_EQ("", tmp);
+  EXPECT_EQ("", (std::string)s2);
+
+  // Test stream operator.
+  std::stringstream ss;
+  ss << s;
+  EXPECT_EQ("Now is the time <&", ss.str());
+}
+
+//Test decoding of a well-formed but overly large XML input
+TEST(XmlRpc, testOversizeString) {
+  try {
+    std::string xml = "<tag><nexttag>";
+    xml += std::string(INT_MAX, 'a');
+    xml += "a</nexttag></tag>";
+    int offset;
+
+    offset = 0;
+    EXPECT_EQ(XmlRpcUtil::parseTag("<tag>", xml, &offset), std::string());
+    EXPECT_EQ(offset, 0);
+
+    offset = 0;
+    EXPECT_FALSE(XmlRpcUtil::findTag("<tag>", xml, &offset));
+    EXPECT_EQ(offset, 0);
+
+    offset = 0;
+    EXPECT_FALSE(XmlRpcUtil::nextTagIs("<tag>", xml, &offset));
+    EXPECT_EQ(offset, 0);
+
+    offset = 0;
+    EXPECT_EQ(XmlRpcUtil::getNextTag(xml, &offset), std::string());
+    EXPECT_EQ(offset, 0);
+  }
+  catch (std::bad_alloc& err) {
+#ifdef GTEST_SKIP
+    GTEST_SKIP() << "Unable to allocate memory to run test\n";
+#else
+    std::cerr << "[ SKIPPED  ] XmlRpc.testOversizeString Unable to allocate memory to run test\n";
+#endif
+  }
+}
+
+TEST(XmlRpc, testParseTag) {
+  int offset = 0;
+
+  // Test a null tag
+  EXPECT_EQ(XmlRpcUtil::parseTag(NULL, "", &offset), std::string());
+  EXPECT_EQ(offset, 0);
+
+  // Test a null offset
+  EXPECT_EQ(XmlRpcUtil::parseTag("<tag>", "", NULL), std::string());
+  EXPECT_EQ(offset, 0);
+
+  // Test if the offset is beyond the end of the input xml
+  offset = 20;
+  EXPECT_EQ(XmlRpcUtil::parseTag("<tag>", "", &offset), std::string());
+  EXPECT_EQ(offset, 20);
+
+  // Test if the tag is not found in the input xml
+  offset = 0;
+  EXPECT_EQ(XmlRpcUtil::parseTag("<tag>", "<foo></foo>", &offset), std::string());
+  EXPECT_EQ(offset, 0);
+
+  // Test if the tag is found, but the end tag is not
+  EXPECT_EQ(XmlRpcUtil::parseTag("<tag>", "<tag>", &offset), std::string());
+  EXPECT_EQ(offset, 0);
+
+  // Test if the tag is found, the end tag is found, and there is a value in the middle
+  EXPECT_EQ(XmlRpcUtil::parseTag("<tag>", "<tag>foo</tag>", &offset), "foo");
+  EXPECT_EQ(offset, 14);
+}
+
+TEST(XmlRpc, testFindTag) {
+  int offset = 0;
+
+  // Test a null tag
+  EXPECT_FALSE(XmlRpcUtil::findTag(NULL, "", &offset));
+  EXPECT_EQ(offset, 0);
+
+  // Test a null offset
+  EXPECT_FALSE(XmlRpcUtil::findTag("<tag>", "", NULL));
+  EXPECT_EQ(offset, 0);
+
+  // Test if the offset is beyond the end of the input xml
+  offset = 20;
+  EXPECT_FALSE(XmlRpcUtil::findTag("<tag>", "", &offset));
+  EXPECT_EQ(offset, 20);
+
+  // Test that the offset moves when finding a tag
+  offset = 0;
+  EXPECT_TRUE(XmlRpcUtil::findTag("<subtag>", "<tag><subtag></subtag></tag>", &offset));
+  EXPECT_EQ(offset, 13);
+}
+
+TEST(XmlRpc, testNextTagIs) {
+  int offset = 0;
+
+  // Test a null tag
+  EXPECT_FALSE(XmlRpcUtil::nextTagIs(NULL, "", &offset));
+  EXPECT_EQ(offset, 0);
+
+  // Test a null offset
+  EXPECT_FALSE(XmlRpcUtil::nextTagIs("<tag>", "", NULL));
+  EXPECT_EQ(offset, 0);
+
+  // Test if the offset is beyond the end of the input xml
+  offset = 20;
+  EXPECT_FALSE(XmlRpcUtil::nextTagIs("<tag>", "", &offset));
+  EXPECT_EQ(offset, 20);
+
+  // Test that the offset moves when finding a tag with no whitespace
+  offset = 0;
+  EXPECT_TRUE(XmlRpcUtil::nextTagIs("<tag>", "<tag></tag>", &offset));
+  EXPECT_EQ(offset, 5);
+
+  // Test that the offset moves when finding a tag with whitespace
+  offset = 0;
+  EXPECT_TRUE(XmlRpcUtil::nextTagIs("<tag>", "      <tag></tag>", &offset));
+  EXPECT_EQ(offset, 11);
+
+  // Test that the offset doesn't move when the tag is not found
+  offset = 0;
+  EXPECT_FALSE(XmlRpcUtil::nextTagIs("<tag>", "      <footag></footag>", &offset));
+  EXPECT_EQ(offset, 0);
+}
+
+TEST(XmlRpc, testGetNextTag) {
+  int offset = 0;
+
+  // Test a null offset
+  EXPECT_EQ(XmlRpcUtil::getNextTag("", NULL), std::string());
+  EXPECT_EQ(offset, 0);
+
+  // Test if the offset is beyond the end of the input xml
+  offset = 20;
+  EXPECT_EQ(XmlRpcUtil::getNextTag("<tag>", &offset), std::string());
+  EXPECT_EQ(offset, 20);
+
+  // Test that the offset moves when finding a tag with no whitespace
+  offset = 0;
+  EXPECT_EQ(XmlRpcUtil::getNextTag("<tag></tag>", &offset), "<tag>");
+  EXPECT_EQ(offset, 5);
+
+  // Test that the offset moves when finding a tag with whitespace
+  offset = 0;
+  EXPECT_EQ(XmlRpcUtil::getNextTag("      <tag></tag>", &offset), "<tag>");
+  EXPECT_EQ(offset, 11);
+
+  // Test that the offset doesn't move if there are no tags
+  offset = 0;
+  EXPECT_EQ(XmlRpcUtil::getNextTag("      foo", &offset), std::string());
+  EXPECT_EQ(offset, 0);
+
+  // Test that the offset moves if there is a start < but no end >
+  offset = 0;
+  // FIXME: this should fail, but currently does not
+  EXPECT_EQ(XmlRpcUtil::getNextTag("<foo", &offset), "<foo");
+  EXPECT_EQ(offset, 4);
+
+  // Test what happens if there is no data in the tag
+  offset = 0;
+  EXPECT_EQ(XmlRpcUtil::getNextTag("<>", &offset), "<>");
+  EXPECT_EQ(offset, 2);
+}
+
+TEST(XmlRpc, testNextTagData)
+{
+  int offset = 0;
+
+  // Test a null tag
+  EXPECT_EQ(XmlRpcUtil::nextTagData(NULL, "", &offset), std::string());
+  EXPECT_EQ(offset, 0);
+
+  // Test a null offset
+  EXPECT_EQ(XmlRpcUtil::nextTagData("<tag>", "", NULL), std::string());
+  EXPECT_EQ(offset, 0);
+
+  // Test if the offset is beyond the end of the input xml
+  offset = 20;
+  EXPECT_EQ(XmlRpcUtil::nextTagData("<tag>", "", &offset), std::string());
+  EXPECT_EQ(offset, 20);
+
+  // Test that the offset moves when finding a tag with no whitespace
+  offset = 0;
+  EXPECT_EQ(XmlRpcUtil::nextTagData("<tag>", "<tag></tag>", &offset), "");
+  EXPECT_EQ(offset, 11);
+
+  // Test that the offset moves when finding a tag with whitespace
+  offset = 0;
+  EXPECT_EQ(XmlRpcUtil::nextTagData("<tag>", "   <tag></tag>", &offset), "");
+  EXPECT_EQ(offset, 14);
+
+  // Test that the offset moves when finding a tag with whitespace
+  offset = 0;
+  EXPECT_EQ(XmlRpcUtil::nextTagData("<tag>", "   <tag>foo</tag>", &offset), "foo");
+  EXPECT_EQ(offset, 17);
+
+  // Test that the offset doesn't move when missing the tag
+  offset = 0;
+  EXPECT_EQ(XmlRpcUtil::nextTagData("<tag>", "   <foo></foo>", &offset), "");
+  EXPECT_EQ(offset, 0);
+
+  // Test that the offset doesn't move when the close tag is after other tags
+  offset = 0;
+  EXPECT_EQ(XmlRpcUtil::nextTagData("<tag>", "   <tag><foo></tag>", &offset), "");
+  EXPECT_EQ(offset, 0);
+
+  // Test that the offset doesn't move if there is no closing tag
+  offset = 0;
+  EXPECT_EQ(XmlRpcUtil::nextTagData("<tag>", "   <tag>foo", &offset), "");
+  EXPECT_EQ(offset, 0);
+}
+
+TEST(XmlRpc, testDateTime) {
+  // DateTime
+  int offset = 0;
+  // Construct from XML
+  const XmlRpcValue dateTime(
+      "<value><dateTime.iso8601>19040503T03:12:35</dateTime.iso8601></value>",
+      &offset);
+  ASSERT_EQ(XmlRpcValue::TypeDateTime, dateTime.getType());
+  struct tm t = dateTime;
+  EXPECT_EQ(t.tm_year, 1904);
+  EXPECT_EQ(t.tm_min, 12);
+  EXPECT_EQ(t.tm_sec, 35);
+  EXPECT_EQ(t.tm_hour, 3);
+  EXPECT_EQ(t.tm_mday, 3);
+  EXPECT_EQ(t.tm_mon, 5);
+
+  EXPECT_EQ(
+      "<value><dateTime.iso8601>19040503T03:12:35</dateTime.iso8601></value>",
+      dateTime.toXml());
+
+  // Constructor from struct tm.
+  XmlRpcValue dateTime2(&t);
+  ASSERT_EQ(XmlRpcValue::TypeDateTime, dateTime2.getType());
+  t = dateTime2;
+  EXPECT_EQ(t.tm_year, 1904);
+  EXPECT_EQ(t.tm_min, 12);
+
+  // Implicit initialization by cast.
+  XmlRpcValue dateTime3;
+  t = dateTime3;
+  ASSERT_EQ(XmlRpcValue::TypeDateTime, dateTime3.getType());
+  EXPECT_EQ(t.tm_year, 0);
+  EXPECT_EQ(t.tm_min, 0);
+
+  // Test stream operator.
+  std::stringstream ss;
+  ss << dateTime;
+  EXPECT_EQ("19040503T03:12:35", ss.str());
+
+  // Tests for DateTime equality operator
+  EXPECT_EQ(dateTime, dateTime2);
+
+  // Copy operator
+  dateTime3 = dateTime;
+  EXPECT_EQ(dateTime, dateTime3);
+
+  // Explicit mutable reference into dateTime2 so that we can modify it to make
+  // it not equal to dateTime in various ways.
+  t = dateTime;
+  struct tm& tm2 = dateTime2;
+  // Seconds not equal.
+  tm2.tm_sec = 0;
+  EXPECT_NE(dateTime, dateTime2);
+  tm2 = t;
+  ASSERT_EQ(dateTime, dateTime2);
+
+  // Minutes not equal.
+  tm2.tm_min = 0;
+  EXPECT_NE(dateTime, dateTime2);
+  tm2 = t;
+  ASSERT_EQ(dateTime, dateTime2);
+
+  // Hours not equal.
+  tm2.tm_hour = 0;
+  EXPECT_NE(dateTime, dateTime2);
+  tm2 = t;
+  ASSERT_EQ(dateTime, dateTime2);
+
+  // Day not equal.
+  tm2.tm_mday = 1;
+  EXPECT_NE(dateTime, dateTime2);
+  tm2 = t;
+  ASSERT_EQ(dateTime, dateTime2);
+
+  // Month not equal.
+  tm2.tm_mon = 1;
+  EXPECT_NE(dateTime, dateTime2);
+  tm2 = t;
+  ASSERT_EQ(dateTime, dateTime2);
+
+  // Year not equal.
+  tm2.tm_year = 1988;
+  EXPECT_NE(dateTime, dateTime2);
+}
+
+TEST(XmlRpc, testArray) {
+  XmlRpcValue d(43.7);
+  // Array
+  XmlRpcValue a;
+  a.setSize(4);
+  a[0] = 1;
+  a[1] = std::string("two");
+  a[2] = 43.7;
+  a[3] = "four";
+  EXPECT_EQ(XmlRpcValue::TypeArray, a.getType());
+  EXPECT_EQ(int(a[0]), 1);
+  EXPECT_EQ(a[2], d);
+
+  char csaXml[] = "<value><array>\n"
+                  "  <data>\n"
+                  "    <value><i4>1</i4></value> \n"
+                  "    <value> <string>two</string></value>\n"
+                  "    <value><double>43.7</double></value>\n"
+                  "    <value>four</value>\n"
+                  "  </data>\n"
+                  "</array></value>";
+
+  int offset = 0;
+  XmlRpcValue aXml(csaXml, &offset);
+  EXPECT_EQ(a, aXml);
+
+  // Array copy works
+  const XmlRpcValue copy(a);
+  ASSERT_EQ(a.getType(), copy.getType());
+  ASSERT_EQ(a.size(), copy.size());
+  for (int i = 0; i < 3; i++) {
+    EXPECT_EQ(a[i], copy[i]);
+  }
+  // Test that comparison operator works.
+  EXPECT_EQ(a, copy);
+
+  // Test that comparison for unlike types returns false.
+  EXPECT_NE(a, d);
+
+  // Test stream operator.
+  std::stringstream ss;
+  ss << a;
+  EXPECT_EQ("{1,two,43.7,four}", ss.str());
+}
+
+TEST(XmlRpc, testStruct) {
+  // Struct
+  XmlRpcValue struct1;
+  struct1["i4"] = 1;
+  struct1["str"] = "two";
+  struct1["d"] = 43.7;
+  EXPECT_EQ(3, struct1.size());
+  EXPECT_EQ(XmlRpcValue::TypeStruct, struct1.getType());
+  EXPECT_TRUE(struct1.hasMember("i4"));
+  EXPECT_FALSE(struct1.hasMember("nowhere"));
+
+  // Test stream operator.
+  std::stringstream ss;
+  ss << struct1;
+  EXPECT_EQ("[d:43.7,i4:1,str:two]", ss.str());
+
+  XmlRpcValue a;
+  a.setSize(4);
+  a[0] = 1;
+  a[1] = std::string("two");
+  a[2] = 43.7;
+  a[3] = "four";
+
+  EXPECT_EQ(struct1["d"], a[2]);
+
+  char csStructXml[] = "<value><struct>\n"
+                       "  <member>\n"
+                       "    <name>i4</name> \n"
+                       "    <value><i4>1</i4></value> \n"
+                       "  </member>\n"
+                       "  <member>\n"
+                       "    <name>d</name> \n"
+                       "    <value><double>43.7</double></value>\n"
+                       "  </member>\n"
+                       "  <member>\n"
+                       "    <name>str</name> \n"
+                       "    <value> <string>two</string></value>\n"
+                       "  </member>\n"
+                       "</struct></value>";
+
+  int offset = 0;
+  const XmlRpcValue structXml(csStructXml, &offset);
+  EXPECT_EQ(struct1, structXml);
+
+  for (XmlRpcValue::iterator itr = struct1.begin(); itr != struct1.end();
+       itr++) {
+  }
+
+  XmlRpcValue astruct;
+  astruct["array"] = a;
+  EXPECT_EQ(astruct["array"][2], struct1["d"]);
+
+  for (int i = 0; i < 10; i++) {
+    XmlRpcValue Event;
+    Event["Name"] = "string";
+
+    Event.clear();
+
+    const int NELMTS = 100;
+    int ii;
+
+    for (ii = 0; ii < NELMTS; ++ii) {
+      char buf[40];
+      sprintf(buf, "%d", ii);
+      Event[std::string(buf)] = buf;
+    }
+
+    Event.clear();
+
+    for (ii = 0; ii < NELMTS; ++ii) {
+      char buf[40];
+      sprintf(buf, "%d", ii);
+      if (ii != NELMTS / 2)
+        Event[std::string(buf)] = ii;
+      else
+        for (int jj = 0; jj < NELMTS; ++jj) {
+          char bufj[40];
+          sprintf(bufj, "%d", jj);
+          Event[std::string(buf)][std::string(bufj)] = bufj;
+        }
+    }
+
+    for (ii = 0; ii < NELMTS; ++ii) {
+      char buf[40];
+      sprintf(buf, "%d", ii);
+      if (ii != NELMTS / 2)
+        EXPECT_EQ(Event[std::string(buf)], XmlRpcValue(ii));
+      else
+        EXPECT_EQ(Event[std::string(buf)].size(), NELMTS);
+    }
+  }
+}
+
+TEST(XmlRpc, base64) {
+  char data[] = {1, 2};
+  const XmlRpcValue bin(data, 2);
+
+  EXPECT_EQ(XmlRpcValue::TypeBase64, bin.getType());
+  EXPECT_EQ(2, bin.size());
+
+  XmlRpcValue::BinaryData d = bin;
+  EXPECT_EQ(d[0], 1);
+  EXPECT_EQ(d[1], 2);
+
+  EXPECT_EQ("<value><base64>AQI=\n</base64></value>", bin.toXml());
+
+  // Test stream operator.
+  std::stringstream ss;
+  ss << bin;
+  EXPECT_EQ("AQI=\n", ss.str());
+
+  // Constructor from XML
+  int offset = 0;
+  XmlRpcValue bin2("<value><base64>AQI=</base64></value>", &offset);
+  EXPECT_EQ(XmlRpcValue::TypeBase64, bin2.getType());
+  EXPECT_EQ(2, bin2.size());
+
+  d = bin2;
+  EXPECT_EQ(d[0], 1);
+  EXPECT_EQ(d[1], 2);
+
+  EXPECT_EQ(bin, bin2);
+
+  // Implicit initialization.
+  XmlRpcValue bin3;
+  d = bin3;
+  EXPECT_EQ(XmlRpcValue::TypeBase64, bin3.getType());
+  EXPECT_EQ(0, bin3.size());
+  EXPECT_EQ(0u, d.size());
+
+  // Copy operator
+  XmlRpcValue bin4;
+  bin4 = bin;
+
+  EXPECT_EQ(XmlRpcValue::TypeBase64, bin4.getType());
+  EXPECT_EQ(2, bin4.size());
+
+  d = bin4;
+  EXPECT_EQ(d[0], 1);
+  EXPECT_EQ(d[1], 2);
+}
+
+TEST(XmpRpc, errors) {
+  // Value is initially invalid.
+  XmlRpcValue value;
+  EXPECT_FALSE(value.valid());
+  EXPECT_EQ("", value.toXml());
+
+  // Implicit bool initialization.
+  bool v = (bool)value;
+  EXPECT_FALSE(v);
+
+  // Conversions to other types should now throw an XmlRpcException.
+  EXPECT_THROW((void)(int)value, XmlRpcException);
+  EXPECT_THROW(value[0], XmlRpcException);
+  EXPECT_THROW(value["bar"], XmlRpcException);
+
+  // Tests on const objects.
+  const XmlRpcValue& ref = value;
+  EXPECT_THROW(ref[0], XmlRpcException);
+  // TODO(austin): is this really allowed on non-struct objects?
+  EXPECT_FALSE(ref.hasMember("bar"));
+
+  // Check that the exception that is thrown is populated correctly.
+  try {
+    (void)int(value);
+  } catch (XmlRpcException& e) {
+    EXPECT_EQ("type error", e.getMessage());
+    EXPECT_EQ(-1, e.getCode());
+  }
+
+  // size() on bool should throw.
+  EXPECT_THROW(value.size(), XmlRpcException);
+
+  // Clear should result in invalid again.
+  value.clear();
+  EXPECT_FALSE(value.valid());
+}
+
+TEST(XmlRpc, int_errors) {
+  XmlRpcValue value;
+  // Implicit int initialization.
+  int v = (int)value;
+  EXPECT_EQ(0, v);
+  EXPECT_EQ(0, (int)value);
+
+  // Conversion to other types should now thrown an exception.
+  EXPECT_THROW((void)(bool)value, XmlRpcException);
+}
+
+TEST(XmlRpc, array_errors) {
+  XmlRpcValue value;
+  // Implicit array creation.
+  int v = value[0];
+  EXPECT_EQ(0, v);
+  EXPECT_THROW((void)(bool)value, XmlRpcException);
+  EXPECT_EQ(1, value.size());
+
+  // Access on a non-const array should implicitly create another element.
+  EXPECT_EQ(0, (int)value[1]);
+  EXPECT_EQ(2, value.size());
+
+  // Access to a const array should throw an exception if the index is out of
+  // bounds.
+  const XmlRpcValue& ref = value;
+  EXPECT_THROW(ref[2], XmlRpcException);
+}
+
+TEST(XmlRpc, fromXmlInvalid) {
+  int offset = 0;
+  XmlRpcValue val;
+
+  // Test what happens with a null offset
+  val.fromXml("", NULL);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+
+  // Test what happens with an offset far beyond the xml
+  offset = 20;
+  val.fromXml("", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 20);
+
+  // Test what happens with no <value> tag
+  offset = 0;
+  val.fromXml("<foo>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // Test what happens with <value> tag but nothing else
+  offset = 0;
+  val.fromXml("<value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><invalid></invalid></value> is invalid
+  offset = 0;
+  val.fromXml("<value><invalid></invalid></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value></value> combination is an implicit empty string
+  offset = 0;
+  val.fromXml("<value></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
+  EXPECT_EQ(offset, 15);
+  EXPECT_EQ(static_cast<std::string>(val), "");
+}
+
+TEST(XmlRpc, fromXmlBoolean) {
+  int offset = 0;
+  XmlRpcValue val;
+
+  // A <value><boolean></boolean></value> is invalid
+  offset = 0;
+  val.fromXml("<value><boolean></boolean></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><boolean></value> is invalid
+  offset = 0;
+  val.fromXml("<value><boolean></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><boolean>foo</boolean></value> is invalid
+  offset = 0;
+  val.fromXml("<value><boolean>foo</boolean></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><boolean>25</boolean></value> is invalid
+  offset = 0;
+  val.fromXml("<value><boolean>25</boolean></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><boolean>1foo</boolean></value> is valid
+  offset = 0;
+  // FIXME: this should fail, but currently does not
+  val.fromXml("<value><boolean>1foo</boolean></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
+  EXPECT_EQ(offset, 38);
+  EXPECT_EQ(static_cast<bool>(val), true);
+
+  // A <value><boolean>1</value> is valid
+  offset = 0;
+  // FIXME: this should fail, but currently does not
+  val.fromXml("<value><boolean>1</value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
+  EXPECT_EQ(offset, 25);
+  EXPECT_EQ(static_cast<bool>(val), true);
+
+  // A <value><boolean>0</boolean></value> is valid
+  offset = 0;
+  val.fromXml("<value><boolean>0</boolean></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
+  EXPECT_EQ(offset, 35);
+  EXPECT_EQ(static_cast<bool>(val), false);
+
+  // A <value><boolean>1</boolean></value> is valid
+  offset = 0;
+  val.fromXml("<value><boolean>1</boolean></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBoolean);
+  EXPECT_EQ(offset, 35);
+  EXPECT_EQ(static_cast<bool>(val), true);
+}
+
+TEST(XmlRpc, fromXmlI4) {
+  int offset = 0;
+  XmlRpcValue val;
+
+  // A <value><i4></i4></value> is invalid
+  offset = 0;
+  val.fromXml("<value><i4></i4></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><i4></value> is invalid
+  offset = 0;
+  val.fromXml("<value><i4></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><i4>foo</i4></value> is invalid
+  offset = 0;
+  val.fromXml("<value><i4>foo</i4></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><i4>25</i4></value> is valid
+  offset = 0;
+  val.fromXml("<value><i4>25</i4></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
+  EXPECT_EQ(offset, 26);
+  EXPECT_EQ(static_cast<int>(val), 25);
+
+  // A <value><i4>1foo</i4></value> is valid
+  offset = 0;
+  // FIXME: this should fail, but currently does not
+  val.fromXml("<value><i4>1foo</i4></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
+  EXPECT_EQ(offset, 28);
+  EXPECT_EQ(static_cast<int>(val), 1);
+
+  // A <value><i4>1</value> is valid
+  offset = 0;
+  // FIXME: this should fail, but currently does not
+  val.fromXml("<value><i4>99</value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
+  EXPECT_EQ(offset, 21);
+  EXPECT_EQ(static_cast<int>(val), 99);
+}
+
+TEST(XmlRpc, fromXmlInt) {
+  int offset = 0;
+  XmlRpcValue val;
+
+  // A <value><int></int></value> is invalid
+  offset = 0;
+  val.fromXml("<value><int></int></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><int></value> is invalid
+  offset = 0;
+  val.fromXml("<value><int></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><int>foo</int></value> is invalid
+  offset = 0;
+  val.fromXml("<value><int>foo</int></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><int>25</int></value> is valid
+  offset = 0;
+  val.fromXml("<value><int>25</int></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
+  EXPECT_EQ(offset, 28);
+  EXPECT_EQ(static_cast<int>(val), 25);
+
+  // A <value><int>1foo</int></value> is valid
+  offset = 0;
+  // FIXME: this should fail, but currently does not
+  val.fromXml("<value><int>1foo</int></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
+  EXPECT_EQ(offset, 30);
+  EXPECT_EQ(static_cast<int>(val), 1);
+
+  // A <value><int>1</value> is valid
+  offset = 0;
+  // FIXME: this should fail, but currently does not
+  val.fromXml("<value><int>99</value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInt);
+  EXPECT_EQ(offset, 22);
+  EXPECT_EQ(static_cast<int>(val), 99);
+}
+
+TEST(XmlRpc, fromXmlDouble) {
+  int offset = 0;
+  XmlRpcValue val;
+
+  // A <value><double></double></value> is invalid
+  offset = 0;
+  val.fromXml("<value><double></double></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><double></value> is invalid
+  offset = 0;
+  val.fromXml("<value><double></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><double>foo</double></value> is invalid
+  offset = 0;
+  val.fromXml("<value><double>foo</double></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><double>25</double></value> is valid
+  offset = 0;
+  val.fromXml("<value><double>25</double></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDouble);
+  EXPECT_EQ(offset, 34);
+  EXPECT_EQ(static_cast<double>(val), 25.0);
+
+  // A <value><double>25.876</double></value> is valid
+  offset = 0;
+  val.fromXml("<value><double>25.876</double></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDouble);
+  EXPECT_EQ(offset, 38);
+  EXPECT_NEAR(static_cast<double>(val), 25.876, 0.01);
+
+  // A <value><double>1foo</double></value> is valid
+  offset = 0;
+  // FIXME: this should fail, but currently does not
+  val.fromXml("<value><double>1foo</double></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDouble);
+  EXPECT_EQ(offset, 36);
+  EXPECT_EQ(static_cast<double>(val), 1);
+}
+
+TEST(XmlRpc, fromXmlImplicitString) {
+  int offset = 0;
+  XmlRpcValue val;
+
+  // A <value><foo></foo></value> is invalid
+  offset = 0;
+  val.fromXml("<value><foo></foo></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value>foo</value> is valid
+  offset = 0;
+  val.fromXml("<value>foo</value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
+  EXPECT_EQ(offset, 18);
+  EXPECT_EQ(static_cast<std::string>(val), "foo");
+  EXPECT_EQ(val.size(), 3);
+}
+
+TEST(XmlRpc, fromXmlExplicitString) {
+  int offset = 0;
+  XmlRpcValue val;
+
+  // A <value><string> is invalid
+  offset = 0;
+  val.fromXml("<value><string>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><string></value> is valid
+  offset = 0;
+  // FIXME: this should fail, but currently does not
+  val.fromXml("<value><string></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
+  EXPECT_EQ(offset, 23);
+  EXPECT_EQ(static_cast<std::string>(val), "");
+  EXPECT_EQ(val.size(), 0);
+
+  // A <value><string>foo</string></value> is valid
+  offset = 0;
+  val.fromXml("<value><string>foo</string></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeString);
+  EXPECT_EQ(offset, 35);
+  EXPECT_EQ(static_cast<std::string>(val), "foo");
+  EXPECT_EQ(val.size(), 3);
+}
+
+TEST(XmlRpc, fromXmlDateTime) {
+  int offset = 0;
+  XmlRpcValue val;
+  struct tm expected{};
+  struct tm returned;
+
+  // A <value><dateTime.iso8601></dateTime.iso8601></value> is invalid
+  offset = 0;
+  val.fromXml("<value><dateTime.iso8601></dateTime.iso8601></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><dateTime.iso8601> is invalid
+  offset = 0;
+  val.fromXml("<value><dateTime.iso8601>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><dateTime.iso8601></value> is invalid
+  offset = 0;
+  val.fromXml("<value><dateTime.iso8601></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><dateTime.iso8601>0000000T00:00<dateTime.iso8601></value> is invalid
+  offset = 0;
+  val.fromXml("<value><dateTime.iso8601>0000000T00:00<dateTime.iso8601></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><dateTime.iso8601>000000T00:00:00<dateTime.iso8601></value> is invalid
+  offset = 0;
+  val.fromXml("<value><dateTime.iso8601>000000T00:00:00<dateTime.iso8601></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><dateTime.iso8601>0000000T00:00:00</value> is valid
+  offset = 0;
+  // FIXME: this should fail, but currently does not
+  // FIXME: this currently leaves the returned struct tm fields 'tm_wday' and 'tm_yday' uninitialized
+  val.fromXml("<value><dateTime.iso8601>0000000T00:00:00</value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDateTime);
+  EXPECT_EQ(offset, 49);
+  returned = static_cast<struct tm>(val);
+  EXPECT_EQ(returned.tm_sec, expected.tm_sec);
+  EXPECT_EQ(returned.tm_min, expected.tm_min);
+  EXPECT_EQ(returned.tm_hour, expected.tm_hour);
+  EXPECT_EQ(returned.tm_mday, expected.tm_mday);
+  EXPECT_EQ(returned.tm_mon, expected.tm_mon);
+  EXPECT_EQ(returned.tm_year, expected.tm_year);
+  EXPECT_EQ(returned.tm_isdst, -1);
+
+  // A <value><dateTime.iso8601>0000000T00:00:0<dateTime.iso8601></value> is valid
+  offset = 0;
+  // FIXME: this should fail, but currently does not
+  val.fromXml("<value><dateTime.iso8601>0000000T00:00:0<dateTime.iso8601></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDateTime);
+  EXPECT_EQ(offset, 66);
+  returned = static_cast<struct tm>(val);
+  EXPECT_EQ(returned.tm_sec, expected.tm_sec);
+  EXPECT_EQ(returned.tm_min, expected.tm_min);
+  EXPECT_EQ(returned.tm_hour, expected.tm_hour);
+  EXPECT_EQ(returned.tm_mday, expected.tm_mday);
+  EXPECT_EQ(returned.tm_mon, expected.tm_mon);
+  EXPECT_EQ(returned.tm_year, expected.tm_year);
+  EXPECT_EQ(returned.tm_isdst, -1);
+
+  // A <value><dateTime.iso8601>0000000T00:00:00<dateTime.iso8601></value> is valid
+  offset = 0;
+  // FIXME: this currently leaves the returned struct tm fields 'tm_wday' and 'tm_yday' uninitialized
+  val.fromXml("<value><dateTime.iso8601>0000000T00:00:00<dateTime.iso8601></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeDateTime);
+  EXPECT_EQ(offset, 67);
+  returned = static_cast<struct tm>(val);
+  EXPECT_EQ(returned.tm_sec, expected.tm_sec);
+  EXPECT_EQ(returned.tm_min, expected.tm_min);
+  EXPECT_EQ(returned.tm_hour, expected.tm_hour);
+  EXPECT_EQ(returned.tm_mday, expected.tm_mday);
+  EXPECT_EQ(returned.tm_mon, expected.tm_mon);
+  EXPECT_EQ(returned.tm_year, expected.tm_year);
+  EXPECT_EQ(returned.tm_isdst, -1);
+}
+
+TEST(XmlRpc, fromXmlBase64) {
+  int offset = 0;
+  XmlRpcValue val;
+
+  // A <value><base64> is invalid
+  offset = 0;
+  val.fromXml("<value><base64>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><base64></base64></value> is valid
+  offset = 0;
+  val.fromXml("<value><base64></base64></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBase64);
+  EXPECT_EQ(offset, 32);
+  EXPECT_EQ(static_cast<const XmlRpc::XmlRpcValue::BinaryData &>(val), XmlRpc::XmlRpcValue::BinaryData());
+  EXPECT_EQ(val.size(), 0);
+
+  // A <value><base64>____</base64></value> is valid
+  offset = 0;
+  // FIXME: the underscore character is illegal in base64, so this should thrown an error
+  val.fromXml("<value><base64>____</base64></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBase64);
+  EXPECT_EQ(offset, 36);
+  EXPECT_EQ(static_cast<const XmlRpc::XmlRpcValue::BinaryData &>(val), XmlRpc::XmlRpcValue::BinaryData());
+  EXPECT_EQ(val.size(), 0);
+
+  // A <value><base64>aGVsbG8=</base64></value> is valid
+  XmlRpc::XmlRpcValue::BinaryData expected{'h', 'e', 'l', 'l', 'o'};
+  offset = 0;
+  val.fromXml("<value><base64>aGVsbG8=</base64></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeBase64);
+  EXPECT_EQ(offset, 40);
+  EXPECT_EQ(static_cast<const XmlRpc::XmlRpcValue::BinaryData &>(val), expected);
+  EXPECT_EQ(val.size(), 5);
+}
+
+TEST(XmlRpc, fromXmlArray) {
+  int offset = 0;
+  XmlRpcValue val;
+
+  // A <value><array> is invalid
+  offset = 0;
+  val.fromXml("<value><array>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><array></array></value> is invalid (no <data> tag)
+  offset = 0;
+  val.fromXml("<value><array></array></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeInvalid);
+  EXPECT_EQ(offset, 0);
+
+  // A <value><array><data></data></array></value> is valid
+  offset = 0;
+  val.fromXml("<value><array><data></data></array></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
+  EXPECT_EQ(offset, 43);
+  EXPECT_EQ(val.size(), 0);
+
+  // A <value><array><data><value><boolean>1</boolean></value></data></array></value> is valid
+  offset = 0;
+  val.fromXml("<value><array><data><value><boolean>1</boolean></value></data></array></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
+  EXPECT_EQ(offset, 78);
+  EXPECT_EQ(val.size(), 1);
+  EXPECT_EQ(static_cast<bool>(val[0]), true);
+
+  // A <value><array><data><value><boolean>1</boolean></value></array></value> is valid
+  offset = 0;
+  // FIXME: this should fail (missing an end </data>), but currently does not
+  val.fromXml("<value><array><data><value><boolean>1</boolean></value></array></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
+  EXPECT_EQ(offset, 71);
+  EXPECT_EQ(val.size(), 1);
+  EXPECT_EQ(static_cast<bool>(val[0]), true);
+
+  // A <value><array><data><value><boolean>1</boolean></value><value><double>23.4</double></value></data></array></value> is valid
+  offset = 0;
+  val.fromXml("<value><array><data><value><boolean>1</boolean></value><value><double>23.4</double></value></data></array></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeArray);
+  EXPECT_EQ(offset, 114);
+  EXPECT_EQ(val.size(), 2);
+  EXPECT_EQ(static_cast<bool>(val[0]), true);
+  EXPECT_NEAR(static_cast<double>(val[1]), 23.4, 0.01);
+}
+
+TEST(XmlRpc, fromXmlStruct) {
+  int offset = 0;
+  XmlRpcValue val;
+
+  // A <value><struct> is valid
+  offset = 0;
+  // FIXME: this should fail, but currently does not
+  val.fromXml("<value><struct>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
+  EXPECT_EQ(offset, 15);
+  EXPECT_EQ(val.size(), 0);
+
+  // A <value><struct><member><value><boolean>1</value> is valid
+  offset = 0;
+  // FIXME: this should fail (it is missing many end tags and a <name> tag), but currently does not
+  val.fromXml("<value><struct><member><value><boolean>1</value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
+  EXPECT_EQ(offset, 48);
+  EXPECT_EQ(val.size(), 1);
+  EXPECT_EQ(static_cast<bool>(val[""]), true);
+
+  // A <value><struct><member><value><boolean>1</boolean></value></member></struct></value> is valid
+  offset = 0;
+  // FIXME: this should fail (it is missing a <name> tag), but currently does not
+  val.fromXml("<value><struct><member><value><boolean>1</boolean></value></member></struct></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
+  EXPECT_EQ(offset, 84);
+  EXPECT_EQ(val.size(), 1);
+  EXPECT_EQ(static_cast<bool>(val[""]), true);
+
+  // A <value><struct><member><name></name><value><boolean>1</boolean></value></member></struct></value> is valid
+  offset = 0;
+  // FIXME: this should fail (the name tag is empty), but currently does not
+  val.fromXml("<value><struct><member><name></name><value><boolean>1</boolean></value></member></struct></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
+  EXPECT_EQ(offset, 97);
+  EXPECT_EQ(val.size(), 1);
+  EXPECT_EQ(static_cast<bool>(val[""]), true);
+
+  // A <value><struct><member><name>foo</name><value><boolean>1</boolean></value></member></struct></value> is valid
+  offset = 0;
+  val.fromXml("<value><struct><member><name>foo</name><value><boolean>1</boolean></value></member></struct></value>", &offset);
+  EXPECT_EQ(val.getType(), XmlRpcValue::Type::TypeStruct);
+  EXPECT_EQ(offset, 100);
+  EXPECT_EQ(val.size(), 1);
+  EXPECT_EQ(static_cast<bool>(val["foo"]), true);
+}
+
+int main(int argc, char **argv)
+{
+  ::testing::InitGoogleTest(&argc, argv);
+  return RUN_ALL_TESTS();
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/TestXml.cpp
@@ -0,0 +1,58 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ * Loosely based on the original TestXml.cpp by Chris Morley
+ *
+ */
+
+// TestXml.cpp : Test XML encoding and decoding.
+// The characters <>&'" are illegal in xml and must be encoded.
+
+#define WIN32_LEAN_AND_MEAN // Exclude rarely-used stuff from Windows headers
+
+#include <iostream>
+// If you are using MSVC++6, you should update <string> to fix
+// BUG: getline Template Function Reads Extra Character
+#include <string>
+#include <stdlib.h>
+
+#include "xmlrpcpp/XmlRpcUtil.h"
+
+#include <gtest/gtest.h>
+
+using namespace XmlRpc;
+
+TEST(XmlRpc, BasicXml) {
+  // Basic tests
+  std::string empty;
+  EXPECT_EQ(empty, XmlRpcUtil::xmlEncode(empty));
+  EXPECT_EQ(empty, XmlRpcUtil::xmlDecode(empty));
+  EXPECT_EQ(empty, XmlRpcUtil::xmlEncode(""));
+  EXPECT_EQ(empty, XmlRpcUtil::xmlDecode(""));
+
+  std::string raw("<>&'\"");
+  EXPECT_EQ(XmlRpcUtil::xmlDecode(XmlRpcUtil::xmlEncode(raw)), raw);
+}
+
+int main(int argc, char **argv)
+{
+  ::testing::InitGoogleTest(&argc, argv);
+  return RUN_ALL_TESTS();
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/mock_socket.cpp
@@ -0,0 +1,327 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ *
+ */
+
+#define xmlrpcpp_EXPORTS  // we are mocking XmlRpcSocket, define the symbol in order to export XmlRpcSocket class
+# include "xmlrpcpp/XmlRpcSocket.h"
+#undef xmlrpcpp_EXPORTS
+
+#include "xmlrpcpp/XmlRpcUtil.h"
+#include "mock_socket.h"
+
+#include <deque>
+
+#include <string.h>
+#include <errno.h>
+
+#include <gtest/gtest.h>
+
+using namespace XmlRpc;
+
+bool XmlRpcSocket::s_use_ipv6_ = false;
+
+// Returns message corresponding to last errno.
+// NOTE(austin): this matches the default implementation.
+std::string XmlRpcSocket::getErrorMsg() {
+  return getErrorMsg(getError());
+}
+
+// Returns message corresponding to errno
+// NOTE(austin): this matches the default implementation.
+std::string XmlRpcSocket::getErrorMsg(int error) {
+  char err[60];
+  std::snprintf(err, sizeof(err), "%s", strerror(error));
+  return std::string(err);
+}
+
+#define EXPECT_PROLOGUE(name)                                                  \
+  EXPECT_EQ(0, name##_calls)                                                   \
+      << "Test error; cannont expect " #name " more than once";
+
+std::deque<int> close_calls;
+void XmlRpcSocket::close(int fd) {
+  EXPECT_LE(1u, close_calls.size());
+  if (close_calls.size() > 0) {
+    int close_fd = close_calls.front();
+    close_calls.pop_front();
+    EXPECT_EQ(close_fd, fd);
+  }
+}
+
+void MockSocketTest::Expect_close(int fd) {
+  close_calls.push_back(fd);
+}
+
+int socket_ret = 0;
+int socket_calls = 0;
+int XmlRpcSocket::socket() {
+  EXPECT_EQ(1, socket_calls);
+  socket_calls--;
+  return socket_ret;
+}
+
+void MockSocketTest::Expect_socket(int ret) {
+  EXPECT_PROLOGUE(socket);
+  socket_calls = 1;
+  socket_ret = ret;
+}
+
+bool setNonBlocking_ret = true;
+int setNonBlocking_fd = 0;
+int setNonBlocking_calls = 0;
+bool XmlRpcSocket::setNonBlocking(int fd) {
+  EXPECT_EQ(1, setNonBlocking_calls);
+  setNonBlocking_calls--;
+  EXPECT_EQ(setNonBlocking_fd, fd);
+  return setNonBlocking_ret;
+}
+void MockSocketTest::Expect_setNonBlocking(int fd, bool ret) {
+  EXPECT_PROLOGUE(setNonBlocking);
+  setNonBlocking_calls = 1;
+  setNonBlocking_fd = fd;
+  setNonBlocking_ret = ret;
+}
+
+bool setReuseAddr_ret = true;
+int setReuseAddr_fd = 0;
+int setReuseAddr_calls = 0;
+bool XmlRpcSocket::setReuseAddr(int fd) {
+  EXPECT_EQ(1, setReuseAddr_calls);
+  setReuseAddr_calls--;
+  EXPECT_EQ(setReuseAddr_fd, fd);
+  return setReuseAddr_ret;
+}
+
+void MockSocketTest::Expect_setReuseAddr(int fd, bool ret) {
+  EXPECT_PROLOGUE(setReuseAddr);
+  setReuseAddr_calls = 1;
+  setReuseAddr_fd = fd;
+  setReuseAddr_ret = ret;
+}
+
+bool bind_ret = true;
+int bind_fd = 0;
+int bind_port = 0;
+int bind_calls = 0;
+bool XmlRpcSocket::bind(int fd, int port) {
+  bind_calls--;
+  EXPECT_EQ(bind_fd, fd);
+  EXPECT_EQ(bind_port, port);
+  return bind_ret;
+}
+
+void MockSocketTest::Expect_bind(int fd, int port, bool ret) {
+  EXPECT_PROLOGUE(bind);
+  bind_calls = 1;
+  bind_fd = fd;
+  bind_port = port;
+  bind_ret = ret;
+}
+
+bool listen_ret = true;
+int listen_fd = 0;
+int listen_backlog = 0;
+int listen_calls = 0;
+bool XmlRpcSocket::listen(int fd, int backlog) {
+  listen_calls--;
+  EXPECT_EQ(listen_fd, fd);
+  EXPECT_EQ(listen_backlog, backlog);
+  return listen_ret;
+}
+
+void MockSocketTest::Expect_listen(int fd, int backlog, bool ret) {
+  EXPECT_PROLOGUE(listen);
+  listen_calls = 1;
+  listen_fd = fd;
+  listen_backlog = backlog;
+  listen_ret = ret;
+}
+
+int accept_ret = 0;
+int accept_fd = 0;
+int accept_calls = 0;
+int XmlRpcSocket::accept(int fd) {
+  accept_calls--;
+  EXPECT_EQ(accept_fd, fd);
+  return accept_ret;
+}
+
+void MockSocketTest::Expect_accept(int fd, int ret) {
+  EXPECT_PROLOGUE(accept);
+  accept_calls = 1;
+  accept_fd = fd;
+  accept_ret = ret;
+}
+
+bool connect_ret = true;
+int connect_fd = 0;
+std::string connect_host = "";
+int connect_port = 0;
+int connect_calls = 0;
+bool XmlRpcSocket::connect(int fd, const std::string& host, int port) {
+  connect_calls--;
+  EXPECT_EQ(connect_fd, fd);
+  EXPECT_EQ(connect_host, host);
+  EXPECT_EQ(connect_port, port);
+  return connect_ret;
+}
+
+void MockSocketTest::Expect_connect(int fd,
+                                    const std::string& host,
+                                    int port,
+                                    bool ret) {
+  EXPECT_PROLOGUE(connect);
+  connect_calls = 1;
+  connect_fd = fd;
+  connect_host = host;
+  connect_port = port;
+  connect_ret = ret;
+}
+
+bool nbRead_ret = true;
+int nbRead_fd = 0;
+std::string nbRead_s = "";
+bool nbRead_eof = false;
+int nbRead_calls = 0;
+bool XmlRpcSocket::nbRead(int fd, std::string& s, bool* eof) {
+  nbRead_calls--;
+  EXPECT_EQ(nbRead_fd, fd);
+  s = nbRead_s;
+  *eof = nbRead_eof;
+  return nbRead_ret;
+}
+
+void MockSocketTest::Expect_nbRead(int fd,
+                                   const std::string& s,
+                                   bool eof,
+                                   bool ret) {
+  EXPECT_PROLOGUE(nbRead);
+  nbRead_calls = 1;
+  nbRead_fd = fd;
+  nbRead_s = s;
+  nbRead_eof = eof;
+  nbRead_ret = ret;
+}
+
+bool nbWrite_ret = true;
+int nbWrite_fd = 0;
+std::string nbWrite_s = "";
+int nbWrite_bytes = 0;
+int nbWrite_calls = 0;
+bool XmlRpcSocket::nbWrite(int fd, const std::string& s, int* bytesSoFar) {
+  nbWrite_calls--;
+  EXPECT_EQ(nbWrite_fd, fd);
+  EXPECT_EQ(nbWrite_s, s);
+  *bytesSoFar = nbWrite_bytes;
+  return nbWrite_ret;
+}
+
+void MockSocketTest::Expect_nbWrite(int fd,
+                                    const std::string& s,
+                                    int bytes,
+                                    bool ret) {
+  EXPECT_PROLOGUE(nbWrite);
+  nbWrite_calls = 1;
+  nbWrite_fd = fd;
+  nbWrite_s = s;
+  nbWrite_bytes = bytes;
+  nbWrite_ret = ret;
+}
+
+int getError_ret = 0;
+int getError_calls = 0;
+int XmlRpcSocket::getError() {
+  getError_calls--;
+  return getError_ret;
+}
+
+void MockSocketTest::Expect_getError(int ret) {
+  EXPECT_PROLOGUE(getError);
+  getError_calls = 1;
+  getError_ret = ret;
+}
+
+int get_port_ret = 0;
+int get_port_socket = 0;
+int get_port_calls = 0;
+int XmlRpcSocket::get_port(int socket) {
+  get_port_calls--;
+  EXPECT_EQ(get_port_socket, socket);
+  return get_port_ret;
+}
+
+void MockSocketTest::Expect_get_port(int socket, int ret) {
+  EXPECT_PROLOGUE(get_port);
+  get_port_calls = 1;
+  get_port_socket = socket;
+  get_port_ret = ret;
+}
+
+void MockSocketTest::SetUp() {
+  socket_calls = 0;
+  close_calls.clear();
+  setNonBlocking_calls = 0;
+  setReuseAddr_calls = 0;
+  bind_calls = 0;
+  listen_calls = 0;
+  accept_calls = 0;
+  connect_calls = 0;
+  nbRead_calls = 0;
+  nbWrite_calls = 0;
+  getError_calls = 0;
+  get_port_calls = 0;
+}
+
+void MockSocketTest::TearDown() {
+  CheckCalls();
+}
+
+void MockSocketTest::CheckCalls() {
+  // Check that call counters and queues are empty.
+  EXPECT_EQ(0, socket_calls);
+  EXPECT_EQ(0u, close_calls.size());
+  EXPECT_EQ(0, setNonBlocking_calls);
+  EXPECT_EQ(0, setReuseAddr_calls);
+  EXPECT_EQ(0, bind_calls);
+  EXPECT_EQ(0, listen_calls);
+  EXPECT_EQ(0, accept_calls);
+  EXPECT_EQ(0, connect_calls);
+  EXPECT_EQ(0, nbRead_calls);
+  EXPECT_EQ(0, nbWrite_calls);
+  EXPECT_EQ(0, getError_calls);
+  EXPECT_EQ(0, get_port_calls);
+
+  // Reset call counters and queues so we don't get leakage between different
+  // parts of the test.
+  socket_calls = 0;
+  close_calls.clear();
+  setNonBlocking_calls = 0;
+  setReuseAddr_calls = 0;
+  bind_calls = 0;
+  listen_calls = 0;
+  accept_calls = 0;
+  connect_calls = 0;
+  nbRead_calls = 0;
+  nbWrite_calls = 0;
+  getError_calls = 0;
+  get_port_calls = 0;
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/mock_socket.h
@@ -0,0 +1,47 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ *
+ */
+
+#pragma once
+#include <string>
+#include <gtest/gtest.h>
+
+class MockSocketTest : public ::testing::Test {
+protected:
+  void SetUp();
+
+  void CheckCalls();
+  void TearDown();
+
+  void Expect_socket(int ret);
+  void Expect_close(int fd);
+  void Expect_setNonBlocking(int fd, bool ret);
+  void Expect_setReuseAddr(int fd, bool ret);
+  void Expect_bind(int fd, int port, bool ret);
+  void Expect_listen(int fd, int backlog, bool ret);
+  void Expect_accept(int fd, int ret);
+  void Expect_connect(int fd, const std::string& host, int port, bool ret);
+  void Expect_nbRead(int fd, const std::string& s, bool eof, bool ret);
+  void Expect_nbWrite(int fd, const std::string& s, int bytes, bool ret);
+  void Expect_getError(int ret);
+  void Expect_get_port(int socket, int ret);
+};
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/test_base64.cpp
@@ -0,0 +1,165 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ *
+ */
+
+#include <b64/encode.h>
+#include <b64/decode.h>
+
+#include <gtest/gtest.h>
+
+// Test Data for a Base64 encode/decode test
+class Base64TestData {
+public:
+  Base64TestData(std::vector<char> raw, std::string encoded)
+    : raw(raw), encoded(encoded) {}
+
+  std::vector<char> raw;
+  std::string encoded;
+};
+
+class Base64Test : public ::testing::TestWithParam<Base64TestData> {};
+
+TEST_P(Base64Test, Encode) {
+  const std::vector<char> & data = GetParam().raw;
+
+  std::stringstream is;
+  is.write(&data[0], data.size());
+  std::stringstream os;
+  base64::encoder encoder;
+  encoder.encode(is, os);
+
+  std::string expected = GetParam().encoded;
+
+  EXPECT_EQ(expected, os.str());
+}
+
+TEST_P(Base64Test, Decode) {
+  const std::string& in = GetParam().encoded;
+  const int encoded_size = in.length();
+
+  // oversize our output vector (same method used by XmlRpcValue)
+  std::vector<char> out;
+  out.resize(encoded_size);
+
+  base64::decoder decoder;
+  const int size = decoder.decode(in.c_str(), encoded_size, out.data());
+  ASSERT_LE(0, size);
+  out.resize(size);
+
+  const std::vector<char> & expected = GetParam().raw;
+
+  EXPECT_EQ(expected, out);
+}
+
+INSTANTIATE_TEST_CASE_P(
+    Multiline,
+    Base64Test,
+    ::testing::Values(
+        Base64TestData({0}, "AA==\n"),
+        Base64TestData({1, 2}, "AQI=\n"),
+        Base64TestData({1, 2, 3}, "AQID\n"),
+        Base64TestData(
+            // clang-format off
+            {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
+             19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
+             35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
+             51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
+             67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82,
+             83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
+             99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
+             112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124,
+             125, 126, 127, -128, -127, -126, -125, -124, -123, -122, -121,
+             -120, -119, -118, -117, -116, -115, -114, -113, -112, -111, -110,
+             -109, -108, -107, -106, -105, -104, -103, -102, -101, -100, -99,
+             -98, -97, -96, -95, -94, -93, -92, -91, -90, -89, -88, -87, -86,
+             -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73,
+             -72, -71, -70, -69, -68, -67, -66, -65, -64, -63, -62, -61, -60,
+             -59, -58, -57, -56, -55, -54, -53, -52, -51, -50, -49, -48, -47,
+             -46, -45, -44, -43, -42, -41, -40, -39, -38, -37, -36, -35, -34,
+             -33, -32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21,
+             -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7,
+             -6, -5, -4, -3, -2, -1},
+            // clang-format on
+            "AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMD"
+            "EyMzQ1\nNjc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYG"
+            "FiY2RlZmdoaWpr\nbG1ub3BxcnN0dXZ3eHl6e3x9fn+AgYKDhIWGh4iJiouMjY6PkJ"
+            "GSk5SVlpeYmZqbnJ2en6Ch\noqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wM"
+            "HCw8TFxsfIycrLzM3Oz9DR0tPU1dbX\n2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8P"
+            "Hy8/T19vf4+fr7/P3+/w==\n")));
+
+class Base64ErrorData {
+public:
+  // TODO(future work): add error code representation here and check that error
+  //                    codes are reported correctly.
+  Base64ErrorData(std::string encoded)
+    : encoded(encoded) {}
+
+  std::string encoded;
+};
+
+class Base64ErrorTest : public ::testing::TestWithParam<Base64ErrorData> {};
+
+TEST_P(Base64ErrorTest, DecodeErrors) {
+  const std::string& in = GetParam().encoded;
+  const int encoded_size = in.length();
+
+  // oversize our output vector (same method used by XmlRpcValue)
+  std::vector<char> out;
+  out.resize(encoded_size);
+
+  base64::decoder decoder;
+  const int size = decoder.decode(in.c_str(), encoded_size, out.data());
+  // Assert that size is greater or equal to 0, to make sure that the follow-up
+  // resize will always succeed.
+  ASSERT_LE(0, size);
+  out.resize(size);
+
+  // FIXME(future work): decode does not report error on garbage input
+}
+
+INSTANTIATE_TEST_CASE_P(
+    Multiline,
+    Base64ErrorTest,
+    ::testing::Values(// Tests on incomplete data.
+                      Base64ErrorData("="),
+                      Base64ErrorData("A="),
+                      Base64ErrorData("A"),
+                      Base64ErrorData("AA"),
+                      Base64ErrorData("AAA"),
+                      Base64ErrorData("AA="),
+                      // Tests with 4 bytes of good data but which does not
+                      // terminate on the correct boundary.
+                      Base64ErrorData("BBBBA="),
+                      Base64ErrorData("BBBBA"),
+                      Base64ErrorData("BBBBAA"),
+                      Base64ErrorData("BBBBAAA"),
+                      Base64ErrorData("BBBBAA="),
+                      // Decode should succeed and do nothing on empty string.
+                      Base64ErrorData(""),
+                      // Character out of bounds for base64 encoding.
+                      Base64ErrorData("<")));
+
+int main(int argc, char **argv)
+{
+  ::testing::InitGoogleTest(&argc, argv);
+  return RUN_ALL_TESTS();
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/test_client.cpp
@@ -0,0 +1,1135 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ *
+ */
+
+#include "xmlrpcpp/XmlRpcClient.h"
+#include "xmlrpcpp/XmlRpcValue.h"
+
+#include "mock_socket.h"
+#include <errno.h>
+#include <climits>
+
+#include <gtest/gtest.h>
+
+using XmlRpc::XmlRpcClient;
+using XmlRpc::XmlRpcValue;
+
+// Helper class to change the accessibility of protected members of the class under test so we can test them
+class XmlRpcClientForTest : public XmlRpcClient
+{
+public:
+  XmlRpcClientForTest(const char* host, int port, const char* uri=0) : XmlRpcClient(host, port, uri)
+  {
+  }
+
+  using XmlRpcClient::doConnect;
+  using XmlRpcClient::setupConnection;
+  using XmlRpcClient::generateRequest;
+  using XmlRpcClient::generateHeader;
+  using XmlRpcClient::writeRequest;
+  using XmlRpcClient::readHeader;
+  using XmlRpcClient::readResponse;
+  using XmlRpcClient::parseResponse;
+
+  using XmlRpcClient::ClientConnectionState;
+  using XmlRpcClient::NO_CONNECTION;
+  using XmlRpcClient::CONNECTING;
+  using XmlRpcClient::WRITE_REQUEST;
+  using XmlRpcClient::READ_HEADER;
+  using XmlRpcClient::READ_RESPONSE;
+  using XmlRpcClient::IDLE;
+
+  using XmlRpcClient::_connectionState;
+  using XmlRpcClient::connectionStateStr;
+};
+namespace XmlRpc {
+void PrintTo(const XmlRpcClientForTest::ClientConnectionState& state,
+             ::std::ostream* os) {
+  *os << XmlRpcClientForTest::connectionStateStr(state);
+}
+}; // namespace XmlRpc
+
+// Helper function to check if our source is in the dispatch source list or not.
+bool sourceInList(XmlRpc::XmlRpcSource* source,
+                  const XmlRpc::XmlRpcDispatch::SourceList& list) {
+  XmlRpc::XmlRpcDispatch::SourceList::const_iterator itr;
+  for (itr = list.begin(); itr != list.end(); itr++) {
+    if (itr->getSource() == source) {
+      return true;
+    }
+  }
+  return false;
+}
+
+// Tests for XmlRpcClient
+//
+// Test connectionStateStr macro
+TEST(XmlRpcClient, connectionStateStr) {
+#define TEST_STATE(state)                                                      \
+  EXPECT_STREQ(#state, XmlRpcClientForTest::connectionStateStr(XmlRpcClientForTest::state))
+  TEST_STATE(NO_CONNECTION);
+  TEST_STATE(CONNECTING);
+  TEST_STATE(WRITE_REQUEST);
+  TEST_STATE(READ_HEADER);
+  TEST_STATE(READ_RESPONSE);
+  TEST_STATE(IDLE);
+}
+
+// Test state of client once constructor is done, including optional URL arg.
+TEST_F(MockSocketTest, constructor) {
+  XmlRpcClientForTest a("localhost", 42);
+  EXPECT_EQ("localhost", a.getHost());
+  EXPECT_EQ(42, a.getPort());
+  EXPECT_EQ("/RPC2", a.getUri());
+
+  EXPECT_EQ(XmlRpcClientForTest::NO_CONNECTION, a._connectionState);
+  EXPECT_EQ(false, a._executing);
+  EXPECT_EQ(false, a._eof);
+  EXPECT_EQ(true, a.getKeepOpen());
+  EXPECT_EQ(-1, a.getfd());
+  EXPECT_EQ(0, a._sendAttempts);
+  EXPECT_EQ(0, a._bytesWritten);
+  EXPECT_EQ(0, a._contentLength);
+  EXPECT_FALSE(a._isFault);
+  EXPECT_FALSE(sourceInList(&a, a._disp._sources));
+
+  XmlRpcClientForTest b("nowhere.com", 404, "/where");
+  EXPECT_EQ("nowhere.com", b.getHost());
+  EXPECT_EQ(404, b.getPort());
+  EXPECT_EQ("/where", b.getUri());
+  // Don't really need to repeat the tests for the other variables.
+}
+
+// Test close() function:
+//  * Does not call close when socket is already closed.
+TEST_F(MockSocketTest, close_invalid_fd) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  ASSERT_EQ(-1, a.getfd());
+
+  // Close when no file descriptor is set
+  a.close();
+  EXPECT_EQ(-1, a.getfd());
+}
+
+// Test close() function:
+//  * Correctly calls close when socket is not closed.
+TEST_F(MockSocketTest, close_valid_fd) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Set file descriptor and then expect that close is called once.
+  a.setfd(5);
+  Expect_close(5);
+  a.close();
+  EXPECT_EQ(-1, a.getfd());
+
+  // Intermediate check that all expected calls have been executed.
+  CheckCalls();
+
+  // Calling close again should have no effect.
+  a.close();
+  EXPECT_EQ(-1, a.getfd());
+}
+
+TEST_F(MockSocketTest, close_destructor) {
+  // Test that the XmlRpcClient destructor closes the file descriptor.
+  {
+    XmlRpcClientForTest a("localhost", 42);
+
+    // Set file descriptor and then expect that close is called once.
+    a.setfd(5);
+    Expect_close(5);
+    // XmlRpcClient destructor called at the end of this scope.
+  }
+}
+
+// Test execute() function? TODO(future work)
+//  This is a bit complicated; maybe test the underlying functions and then
+//  mock them out for this test.
+// Test exectuteNonBlock() function? TODO(future work)
+//  Again, complicated. Maybe test underlying functions.
+// Test executeCheckDone() ? TODO(future work)
+//  Complicated. There are known bugs here where the client never reports done
+//  if the connection is lost; we should try to test that logic.
+// Test handleEvent() TODO(future work)
+//  For each ConnectionState
+//   The correct sequence of socket functions is called.
+//   The correct action is taken if the socket operations fail.
+
+// Test setupConnection()
+//  Correct handling of initial states.
+//  Correct handling of errors.
+TEST_F(MockSocketTest, setupConnection) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Default initial state; expect socket, setNonBlocking and connect.
+  // NOTE(austin): This does not currently expect these calls in order; it just
+  // checks that all of them have been made.
+  Expect_socket(7);
+  Expect_setNonBlocking(7, true);
+  Expect_connect(7, "localhost", 42, true);
+
+  EXPECT_TRUE(a.setupConnection());
+
+  // Check that correct FD was set.
+  EXPECT_EQ(7, a.getfd());
+
+  // Check that source is in the dispatch source list now.
+  EXPECT_TRUE(sourceInList(&a, a._disp._sources));
+
+  // Check internal state is reset.
+  EXPECT_EQ(XmlRpcClientForTest::WRITE_REQUEST, a._connectionState);
+  EXPECT_EQ(0, a._bytesWritten);
+  CheckCalls();
+
+  Expect_close(7);
+}
+
+TEST_F(MockSocketTest, setupConnection_eof) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Initial state: file descriptor set, but _eof. Expect close and socket,
+  // setNonBlocking, connect.
+  a.setfd(5);
+  a._eof = true;
+  Expect_close(5);
+
+  Expect_socket(7);
+  Expect_setNonBlocking(7, true);
+  Expect_connect(7, "localhost", 42, true);
+
+  EXPECT_TRUE(a.setupConnection());
+
+  // Check that correct FD was set.
+  EXPECT_EQ(7, a.getfd());
+
+  // Check that source is in the dispatch source list now.
+  EXPECT_TRUE(sourceInList(&a, a._disp._sources));
+
+  // Check internal state is reset.
+  EXPECT_EQ(XmlRpcClientForTest::WRITE_REQUEST, a._connectionState);
+  EXPECT_EQ(0, a._bytesWritten);
+  CheckCalls();
+
+  Expect_close(7);
+}
+
+TEST_F(MockSocketTest, setupConnection_close) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Initial state: file descriptor set, but _eof
+  // NOTE(austin): Having multiple variables that imply that the fd is valid
+  //               smells funny.
+  a.setfd(5);
+  a._connectionState = XmlRpcClientForTest::WRITE_REQUEST;
+  Expect_close(5);
+
+  Expect_socket(7);
+  Expect_setNonBlocking(7, true);
+  Expect_connect(7, "localhost", 42, true);
+
+  EXPECT_TRUE(a.setupConnection());
+
+  // Check that correct FD was set.
+  EXPECT_EQ(7, a.getfd());
+
+  // Check that source is in the dispatch source list now.
+  EXPECT_TRUE(sourceInList(&a, a._disp._sources));
+
+  // Check internal state is reset.
+  EXPECT_EQ(XmlRpcClientForTest::WRITE_REQUEST, a._connectionState);
+  EXPECT_EQ(0, a._bytesWritten);
+  CheckCalls();
+
+  Expect_close(7);
+}
+
+TEST_F(MockSocketTest, setupConnection_err) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Connect failure. Any failure that causes doConnect here will do; we choose
+  // an arbitrary failure mode here and then separately test that doConnect
+  // reports failure correctly in a separate set of tests.
+  Expect_socket(7);
+  Expect_setNonBlocking(7, true);
+  Expect_connect(7, "localhost", 42, false);
+  Expect_getError(ECONNREFUSED);
+  Expect_close(7);
+
+  EXPECT_FALSE(a.setupConnection());
+
+  // Check that FD is not set.
+  EXPECT_EQ(-1, a.getfd());
+
+  // Check that source is not in the dispatch source list now.
+  EXPECT_FALSE(sourceInList(&a, a._disp._sources));
+
+  // Check internal state is NO_CONNECTION
+  EXPECT_EQ(XmlRpcClientForTest::NO_CONNECTION, a._connectionState);
+}
+
+// Check that _disp is left in the correct state after closing and then failing
+// to reopen the socket.
+TEST_F(MockSocketTest, setupConnection_eor_reopen) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Default initial state; expect socket, setNonBlocking and connect.
+  // NOTE(austin): This does not currently expect these calls in order; it just
+  // checks that all of them have been made.
+  Expect_socket(7);
+  Expect_setNonBlocking(7, true);
+  Expect_connect(7, "localhost", 42, true);
+
+  EXPECT_TRUE(a.setupConnection());
+
+  // Check that correct FD was set.
+  EXPECT_EQ(7, a.getfd());
+
+  // Check that source is in the dispatch source list now.
+  EXPECT_TRUE(sourceInList(&a, a._disp._sources));
+
+  // Check internal state is reset.
+  EXPECT_EQ(XmlRpcClientForTest::WRITE_REQUEST, a._connectionState);
+  EXPECT_EQ(0, a._bytesWritten);
+  CheckCalls();
+
+  // Simulate socket encountering EOF
+  a._eof = true;
+
+  // Expect close, socket, setNonBlocking and connect. Make connect fail.
+  Expect_close(7);
+  Expect_socket(8);
+  Expect_setNonBlocking(8, true);
+  Expect_connect(8, "localhost", 42, false);
+  Expect_getError(ECONNREFUSED);
+  Expect_close(8);
+
+  EXPECT_FALSE(a.setupConnection());
+
+  // Check that correct FD was set.
+  EXPECT_EQ(-1, a.getfd());
+
+  // Check that source is no longer in the dispatch source list now.
+  EXPECT_FALSE(sourceInList(&a, a._disp._sources));
+
+  // Check internal state is reset.
+  EXPECT_EQ(XmlRpcClientForTest::NO_CONNECTION, a._connectionState);
+  CheckCalls();
+}
+
+// Test doConnect()
+//  Correct sequence of calls to XmlRpcSocket
+//  Correct handling of socket errors.
+TEST_F(MockSocketTest, doConnect) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Expect that socket, setNonBlocking and connect are called.
+  // NOTE(austin): this doesn't enforce ordering.
+  Expect_socket(7);
+  Expect_setNonBlocking(7, true);
+  Expect_connect(7, "localhost", 42, true);
+
+  EXPECT_TRUE(a.doConnect());
+
+  // Check that correct FD was set.
+  EXPECT_EQ(7, a.getfd());
+
+  // Check that the expected calls have happened.
+  CheckCalls();
+
+  // Expect close on destruction.
+  Expect_close(7);
+}
+
+TEST_F(MockSocketTest, doConnect_socketerr) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  Expect_socket(-1);
+  Expect_getError(ENFILE);
+
+  EXPECT_FALSE(a.doConnect());
+
+  // Check that correct FD was set.
+  EXPECT_EQ(-1, a.getfd());
+}
+
+TEST_F(MockSocketTest, doConnect_nonBlockErr) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Expect that setNonBlocking causes the socket to be closed and getError to
+  // be called.
+  Expect_socket(7);
+  Expect_setNonBlocking(7, false);
+  Expect_getError(EBADF);
+  Expect_close(7);
+
+  EXPECT_FALSE(a.doConnect());
+
+  // Check that correct FD was set.
+  EXPECT_EQ(-1, a.getfd());
+}
+
+TEST_F(MockSocketTest, doConnect_connectErr) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Expect that a connection failure causes the socket to be closed.
+  Expect_socket(7);
+  Expect_setNonBlocking(7, true);
+  Expect_connect(7, "localhost", 42, false);
+  Expect_getError(ECONNREFUSED);
+  Expect_close(7);
+
+  EXPECT_FALSE(a.doConnect());
+
+  // Check that correct FD was set.
+  EXPECT_EQ(-1, a.getfd());
+}
+
+// Test generateRequest()
+//  Correct XML is generated for a variety of request types.
+//  Correct XML is generated for empty request
+TEST(XmlRpcClient, generateRequest) {
+  XmlRpcClientForTest a("localhost", 42);
+  // generateRequest takes a method name and params and puts the result in the
+  // _request member variable.
+  std::string header = "POST /RPC2 HTTP/1.1\r\n"
+                       "User-Agent: XMLRPC++ 0.7\r\n"
+                       "Host: localhost:42\r\n"
+                       "Content-Type: text/xml\r\n";
+
+  // Various tests for the nominal case of a normal XmlRpcValue
+  XmlRpcValue s("Hello");
+  EXPECT_TRUE(a.generateRequest("DoFoo", s));
+  EXPECT_EQ(header + "Content-length: 134\r\n\r\n"
+                     "<?xml version=\"1.0\"?>\r\n"
+                     "<methodCall><methodName>DoFoo</methodName>\r\n"
+                     "<params><param><value>Hello</value></param></params></"
+                     "methodCall>\r\n",
+            a._request);
+
+  XmlRpcValue b(true);
+  EXPECT_TRUE(a.generateRequest("DoFoo", b));
+  EXPECT_EQ(header + "Content-length: 149\r\n\r\n"
+                     "<?xml version=\"1.0\"?>\r\n"
+                     "<methodCall><methodName>DoFoo</methodName>\r\n"
+                     "<params><param><value><boolean>1</boolean></value></"
+                     "param></params></methodCall>\r\n",
+            a._request);
+
+  XmlRpcValue i(42);
+  EXPECT_TRUE(a.generateRequest("DoFoo", i));
+  EXPECT_EQ(header + "Content-length: 140\r\n\r\n"
+                     "<?xml version=\"1.0\"?>\r\n"
+                     "<methodCall><methodName>DoFoo</methodName>\r\n"
+                     "<params><param><value><i4>42</i4></value></param></"
+                     "params></methodCall>\r\n",
+            a._request);
+
+  // Array case is a bit special because it results in emitting multiple
+  // <param> tags.
+  XmlRpcValue arr;
+  arr[0] = 2;
+  arr[1] = 3;
+  arr[2] = 5;
+  arr[3] = 7;
+  arr[4] = 11;
+  arr[5] = 13;
+  arr[6] = 17;
+  EXPECT_TRUE(a.generateRequest("DoFoo", arr));
+  EXPECT_EQ(header + "Content-length: 382\r\n\r\n"
+                     "<?xml version=\"1.0\"?>\r\n"
+                     "<methodCall><methodName>DoFoo</methodName>\r\n"
+                     "<params>"
+                     "<param><value><i4>2</i4></value></param>"
+                     "<param><value><i4>3</i4></value></param>"
+                     "<param><value><i4>5</i4></value></param>"
+                     "<param><value><i4>7</i4></value></param>"
+                     "<param><value><i4>11</i4></value></param>"
+                     "<param><value><i4>13</i4></value></param>"
+                     "<param><value><i4>17</i4></value></param>"
+                     "</params></methodCall>\r\n",
+            a._request);
+
+  // Tests for errors in arguments.
+  // Method name null
+  // TODO(austin): this causes a segfault.
+  /*
+  EXPECT_TRUE(a.generateRequest(NULL, s));
+  EXPECT_EQ(header + "Content-length: 134\r\n\r\n" \
+      "<?xml version=\"1.0\"?>\r\n" \
+      "<methodCall><methodName></methodName>\r\n" \
+      "<params><param><value>Hello</value></param></params></methodCall>\r\n"
+      , a._request);
+      */
+
+  // Empty(invalid) param(s)
+  // NOTE(austin): this matches the existing implementation but seems unusual.
+  // I don't have a specification to check this against so I'm just going to
+  // assume it's OK.
+  XmlRpcValue empty;
+  EXPECT_FALSE(empty.valid());
+  EXPECT_TRUE(a.generateRequest("DoEmpty", empty));
+  EXPECT_EQ(header + "Content-length: 84\r\n\r\n"
+                     "<?xml version=\"1.0\"?>\r\n"
+                     "<methodCall><methodName>DoEmpty</methodName>\r\n"
+                     "</methodCall>\r\n",
+            a._request);
+}
+
+// Test generateHeader()
+//  Correct header is generated for various sizes and content of request body.
+TEST(XmlRpcClient, generateHeader) {
+  XmlRpcClientForTest a("localhost", 42);
+  // generateRequest takes a method name and params and puts the result in the
+  // _request member variable.
+  std::string header = "POST /RPC2 HTTP/1.1\r\n"
+                       "User-Agent: XMLRPC++ 0.7\r\n"
+                       "Host: localhost:42\r\n"
+                       "Content-Type: text/xml\r\n";
+
+  // Nonzero length message body.
+  EXPECT_EQ(header + "Content-length: 30\r\n\r\n", a.generateHeader(30));
+
+  // Zero-length body as degenerate case.
+  EXPECT_EQ(header + "Content-length: 0\r\n\r\n", a.generateHeader(0));
+}
+
+// Test writeRequest()
+//  Test that everything in a single write works; Client is left in the correct
+//   state.
+//  Test that partial write works, client is left in the correct state.
+//  Test that socket errors result in the correct state and that the socket
+//   is closed (or not) correctly.
+TEST_F(MockSocketTest, writeRequest) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::WRITE_REQUEST;
+  a._request = "FAKE_REQUEST";
+
+  // Check that request length is the correct size.
+  ASSERT_EQ(12u, a._request.size());
+
+  // Expect a write; write all bytes and return success.
+  Expect_nbWrite(7, "FAKE_REQUEST", 12, true);
+
+  // Expect that writeRequest is successful.
+  EXPECT_TRUE(a.writeRequest());
+
+  // Check that resulting state is READ_HEADER
+  EXPECT_EQ(XmlRpcClientForTest::READ_HEADER, a._connectionState);
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+
+  // Expect a close on destruction.
+  Expect_close(7);
+}
+
+TEST_F(MockSocketTest, writeRequest_partial) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::WRITE_REQUEST;
+  a._request = "FAKE_REQUEST";
+
+  // Check that request length is the correct size.
+  ASSERT_EQ(12u, a._request.size());
+
+  // Expect a write; only write 5 bytes and return success.
+  Expect_nbWrite(7, "FAKE_REQUEST", 5, true);
+  // Expect that writeRequest is successful.
+  EXPECT_TRUE(a.writeRequest());
+  // Check that resulting state is READ_HEADER
+  EXPECT_EQ(XmlRpcClientForTest::WRITE_REQUEST, a._connectionState);
+  // Check that all expected function calls were made.
+  CheckCalls();
+
+  // Expect a write; write remaining bytes and return success.
+  Expect_nbWrite(7, "REQUEST", 7, true);
+  // Expect that writeRequest is successful.
+  EXPECT_TRUE(a.writeRequest());
+  // Check that resulting state is READ_HEADER
+  EXPECT_EQ(XmlRpcClientForTest::READ_HEADER, a._connectionState);
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+
+  // Expect a close on destruction.
+  Expect_close(7);
+}
+
+TEST_F(MockSocketTest, writeRequest_partial_error) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::WRITE_REQUEST;
+  a._request = "FAKE_REQUEST";
+
+  // Check that request length is the correct size.
+  ASSERT_EQ(12u, a._request.size());
+
+  // Expect a write; only write 5 bytes and return success.
+  Expect_nbWrite(7, "FAKE_REQUEST", 5, true);
+  // Expect that writeRequest is successful.
+  EXPECT_TRUE(a.writeRequest());
+  // Check that resulting state is READ_HEADER
+  EXPECT_EQ(XmlRpcClientForTest::WRITE_REQUEST, a._connectionState);
+  // Check that all expected function calls were made.
+  CheckCalls();
+
+  // Expect a write; write no bytes and return failure.
+  Expect_nbWrite(7, "REQUEST", 0, false);
+  // Expect close, since the write failed.
+  Expect_close(7);
+  Expect_getError(ECONNREFUSED);
+  // Expect that writeRequest fails.
+  EXPECT_FALSE(a.writeRequest());
+  // Check that resulting state is not connected.
+  EXPECT_EQ(XmlRpcClientForTest::NO_CONNECTION, a._connectionState);
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+}
+
+TEST_F(MockSocketTest, writeRequest_error) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::WRITE_REQUEST;
+  a._request = "FAKE_REQUEST";
+
+  // Check that request length is the correct size.
+  ASSERT_EQ(12u, a._request.size());
+
+  // Expect a write; write no bytes and return error.
+  Expect_nbWrite(7, "FAKE_REQUEST", 0, false);
+  Expect_close(7);
+  Expect_getError(ECONNREFUSED);
+  // Expect that writeRequest fails.
+  EXPECT_FALSE(a.writeRequest());
+  // Check that resulting state is not connected.
+  EXPECT_EQ(XmlRpcClientForTest::NO_CONNECTION, a._connectionState);
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+}
+
+// Header as it would be generated by XmlRpcpp and body.
+const std::string header = "HTTP/1.1 200 OK\r\n"
+                           "Server: XMLRPC++ 0.7\r\n"
+                           "Content-Type: text/xml\r\n"
+                           "Content-length: 114\r\n\r\n";
+// Alternate header as returned by roscore
+const std::string header2 = "HTTP/1.0 200 OK\r\n"
+                            "Server: BaseHTTP/0.3 Python/2.7.6\r\n"
+                            "Date: Mon, 30 Oct 2017 22:28:12 GMT\r\n"
+                            "Content-type: text/xml\r\n"
+                            "Content-length: 114\r\n\r\n";
+// Header for testing a custom Content-length value
+const std::string header3 = "HTTP/1.1 200 OK\r\n"
+                           "Server: XMLRPC++ 0.7\r\n"
+                           "Content-Type: text/xml\r\n"
+                           "Content-length: ";
+// Generic response XML
+const std::string response = "<?xml version=\"1.0\"?>\r\n"
+                             "<methodResponse><params><param>\r\n"
+                             "<value>Hello</value>\r\n"
+                             "</param></params></methodResponse>\r\n";
+
+// Test readHeader()
+//  Test that a full read with just a header works correctly.
+//  Test that various partial reads of the header work.
+//  Test that stacked partial reads of the header eventually result in success.
+//  Test that a read that returns both header and response data correctly
+//   removes the header and leaves the response.
+// TODO(future work): Test the header parser in readHeader.
+// TODO(future work): Test cases where the Content-length header is absent,
+//                    zero, negative or garbage.
+//
+// Test that readHeader works correctly with the header from XmlRpcpp
+TEST_F(MockSocketTest, readHeader) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::READ_HEADER;
+
+  // Self-test that response length matches encoded values above.
+  ASSERT_EQ(114u, response.length());
+
+  // Expect a read and have it return the header and the response.
+  Expect_nbRead(7, header + response, false, true);
+
+  EXPECT_TRUE(a.readHeader());
+
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::READ_RESPONSE, a._connectionState);
+  // Check that the remaining response is stored in _response
+  EXPECT_EQ(response, a._response);
+  EXPECT_EQ(114, a._contentLength); // Check decoded content length
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+
+  // Expect close on destruction.
+  Expect_close(7);
+}
+
+// Test that readHeader works correctly with the header from roscore.
+TEST_F(MockSocketTest, readHeader2) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::READ_HEADER;
+
+  // Expect a read and have it return the header and the response.
+  Expect_nbRead(7, header2 + response, false, true);
+
+  EXPECT_TRUE(a.readHeader());
+
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::READ_RESPONSE, a._connectionState);
+  // Check that the remaining response is stored in _response
+  EXPECT_EQ(response, a._response);
+  EXPECT_EQ(114, a._contentLength); // Check decoded content length
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+
+  // Expect close on destruction.
+  Expect_close(7);
+}
+
+// Test that readHeader decodes the content-length when read only returns the
+// header.
+// TODO(future work): there appears to be a bug in the header parsing where it
+// doesn't pass the header parsing state until it gets the first byte of the
+// response body.
+TEST_F(MockSocketTest, readHeader_only) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::READ_HEADER;
+
+  // Expect a read and have it return only the header.
+  // NOTE(austin): the header parser doesn't terminate until it gets the first
+  // byte of the response; so give it one additional byte.
+  Expect_nbRead(7, header + " ", false, true);
+
+  EXPECT_TRUE(a.readHeader());
+
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::READ_RESPONSE, a._connectionState);
+  // Check that the remaining response is stored in _response
+  EXPECT_EQ(" ", a._response);
+  EXPECT_EQ(114, a._contentLength); // Check decoded content length
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+
+  // Expect close on destruction.
+  Expect_close(7);
+}
+
+// Test that readHeader correctly resumes after getting a partial header read.
+TEST_F(MockSocketTest, readHeader_partial) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::READ_HEADER;
+
+  std::string header_part1 = header.substr(0, 32);
+  std::string header_part2 = header.substr(32);
+
+  // Expect a read and have it return only part of the header.
+  Expect_nbRead(7, header_part1, false, true);
+  EXPECT_TRUE(a.readHeader());
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::READ_HEADER, a._connectionState);
+  // Check that the partial header is stored in _header.
+  EXPECT_EQ(header_part1, a._header);
+
+  // Check that all expected function calls were made before we proceed.
+  CheckCalls();
+
+  // Expect a read and have it return the remainder of the header.
+  Expect_nbRead(7, header_part2 + " ", false, true);
+  EXPECT_TRUE(a.readHeader());
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::READ_RESPONSE, a._connectionState);
+  // Check that the remaining response is stored in _response
+  EXPECT_EQ(" ", a._response);
+  EXPECT_EQ(114, a._contentLength); // Check decoded content length
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+
+  // Expect close on destruction.
+  Expect_close(7);
+}
+
+// Test that readHeader reports an error if the read fails.
+TEST_F(MockSocketTest, readHeader_err) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::READ_HEADER;
+
+  // Expect a read and have it fail.
+  Expect_nbRead(7, "", false, false);
+  // Expect the client to close the socket.
+  Expect_close(7);
+  // Expect a reconnect attempt
+  Expect_socket(8);
+  Expect_setNonBlocking(8, true);
+  Expect_connect(8, "localhost", 42, true);
+
+  EXPECT_TRUE(a.readHeader());
+
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::WRITE_REQUEST, a._connectionState);
+  EXPECT_EQ(1, a._sendAttempts);
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+
+  // Skip the state machine forward to READ_HEADER state again.
+  a._connectionState = XmlRpcClientForTest::READ_HEADER;
+
+  // Do it again, but this time don't expect a reconnect attempt
+  // Expect a read and have it return eof and success.
+  Expect_nbRead(8, "", true, true);
+  Expect_getError(ENOTCONN);
+  // Expect the client to close the socket.
+  Expect_close(8);
+
+  EXPECT_FALSE(a.readHeader());
+
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::NO_CONNECTION, a._connectionState);
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+}
+
+// Test that readHeader reports an error if it gets EOF before it gets the
+// content length.
+TEST_F(MockSocketTest, readHeader_eof) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::READ_HEADER;
+
+  // Expect a read and have it return eof and success.
+  Expect_nbRead(7, "", true, true);
+  // Expect the client to close the socket.
+  Expect_close(7);
+  // Expect a reconnect attempt
+  Expect_socket(8);
+  Expect_setNonBlocking(8, true);
+  Expect_connect(8, "localhost", 42, true);
+
+  EXPECT_TRUE(a.readHeader());
+
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::WRITE_REQUEST, a._connectionState);
+  EXPECT_EQ(1, a._sendAttempts);
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+
+  // Skip the state machine forward to READ_HEADER state again.
+  a._connectionState = XmlRpcClientForTest::READ_HEADER;
+
+  // Do it again, but this time don't expect a reconnect attempt
+  // Expect a read and have it return eof and success.
+  Expect_nbRead(8, "", true, true);
+  Expect_getError(ENOTCONN);
+  // Expect the client to close the socket.
+  Expect_close(8);
+
+  EXPECT_FALSE(a.readHeader());
+
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::NO_CONNECTION, a._connectionState);
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+}
+
+// Test that readHeader reports an error and closes the socket if the second
+// part of a partial read returns an error.
+TEST_F(MockSocketTest, readHeader_partial_err) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::READ_HEADER;
+
+  std::string header_part1 = header.substr(0, 32);
+
+  // Expect a read and have it return only part of the header.
+  Expect_nbRead(7, header_part1, false, true);
+  EXPECT_TRUE(a.readHeader());
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::READ_HEADER, a._connectionState);
+  // Check that the partial header is stored in _header.
+  EXPECT_EQ(header_part1, a._header);
+
+  // Check that all expected function calls were made before we proceed.
+  CheckCalls();
+
+  // Expect a read and have it return an error.
+  Expect_nbRead(7, "", false, false);
+  Expect_close(7);
+  // Expect a reconnect attempt
+  Expect_socket(8);
+  Expect_setNonBlocking(8, true);
+  Expect_connect(8, "localhost", 42, true);
+
+  EXPECT_TRUE(a.readHeader());
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::WRITE_REQUEST, a._connectionState);
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+
+  // Expect socket close on destruction.
+  Expect_close(8);
+}
+
+// Test that the read will fail when content-length is too large
+TEST_F(MockSocketTest, readHeader_oversize) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::READ_HEADER;
+
+  // Add a large content-length to the standard header
+  std::string header_cl = header3;
+  header_cl += std::to_string(size_t(INT_MAX) + 1);
+  header_cl += "\r\n\r\n ";
+
+  Expect_nbRead(7, header_cl, false, true);
+  Expect_close(7);
+
+  EXPECT_FALSE(a.readHeader());
+  EXPECT_EQ(0, a._contentLength); // Content length should be reset
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+}
+
+// Test readResponse()
+//  Test read of response in a single read call
+//  Test response spread across several read calls
+//  Test empty response
+//  Test read errors on first or subsequent reads
+//  Test for correct state after each of these events.
+
+// Test that readResponse does nothing if _response is already populated by
+// readHeader.
+TEST_F(MockSocketTest, readResponse_noop) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::READ_RESPONSE;
+  // Response was already read by readHeader
+  // (verified by previous tests).
+  a._response = response;
+  a._contentLength = 114;
+  ASSERT_EQ(114u, a._response.length());
+
+  // Don't expect any calls. Expect readResponse to return false since we don't
+  // need to keep monitoring this client.
+  EXPECT_FALSE(a.readResponse());
+
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::IDLE, a._connectionState);
+  // Check that the remaining response is stored in _response
+  EXPECT_EQ(response, a._response);
+  EXPECT_EQ(114, a._contentLength); // Check decoded content length
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+
+  // Expect close on destruction.
+  Expect_close(7);
+}
+
+// Test that readResponse works if the initial buffer is empty.
+TEST_F(MockSocketTest, readResponse) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::READ_RESPONSE;
+  // Start with empty response and pre-populated content length.
+  a._response = "";
+  a._contentLength = 114;
+  ASSERT_EQ(114u, response.length());
+
+  // Expect a read, have it return the full response and success.
+  Expect_nbRead(7, response, false, true);
+  // Expect readResponse to return false since we're done monitoring this
+  // socket.
+  EXPECT_FALSE(a.readResponse());
+
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::IDLE, a._connectionState);
+  // Check that the remaining response is stored in _response
+  EXPECT_EQ(response, a._response);
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+
+  // Expect close on destruction.
+  Expect_close(7);
+}
+
+// Test that readResponse works if the initial buffer is empty.
+TEST_F(MockSocketTest, readResponse_partial) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::READ_RESPONSE;
+  // Start with empty response and pre-populated content length.
+  a._response = "";
+  a._contentLength = 114;
+  ASSERT_EQ(114u, response.length());
+
+  const std::string response_part1 = response.substr(0, 60);
+  const std::string response_part2 = response.substr(60);
+
+  // Expect a read, have it return the first part of the response.
+  Expect_nbRead(7, response_part1, false, true);
+  EXPECT_TRUE(a.readResponse());
+
+  // Check that the first part of the response is stored in _response
+  EXPECT_EQ(response_part1, a._response);
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::READ_RESPONSE, a._connectionState);
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+
+  // Expect a read, have it return the remainder of the response and success.
+  Expect_nbRead(7, response_part2, false, true);
+
+  // Expect readResponse to return false now since we're done monitoring this
+  // socket.
+  EXPECT_FALSE(a.readResponse());
+
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::IDLE, a._connectionState);
+  // Check that the remaining response is stored in _response
+  EXPECT_EQ(response, a._response);
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+
+  // Expect close on destruction.
+  Expect_close(7);
+}
+
+// Test that readResponse closes the socket and returns an error if the read
+// fails.
+TEST_F(MockSocketTest, readResponse_err) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::READ_RESPONSE;
+  // Start with empty response and pre-populated content length.
+  a._response = "";
+  a._contentLength = 114;
+  ASSERT_EQ(114u, response.length());
+
+  // Expect a read, have it return an error.
+  Expect_nbRead(7, "", false, false);
+  // Expect getError and close()
+  Expect_getError(ENOTCONN);
+  Expect_close(7);
+  // Expect readResponse to return false since we're done monitoring this
+  // socket.
+  EXPECT_FALSE(a.readResponse());
+
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::NO_CONNECTION, a._connectionState);
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+}
+
+// Test that readResponse works if the initial buffer is empty.
+TEST_F(MockSocketTest, readResponse_eof) {
+  XmlRpcClientForTest a("localhost", 42);
+
+  // Hack us into the correct initial state.
+  a.setfd(7);
+  a._connectionState = XmlRpcClientForTest::READ_RESPONSE;
+  // Start with empty response and pre-populated content length.
+  a._response = "";
+  a._contentLength = 114;
+  ASSERT_EQ(114u, response.length());
+
+  // Expect a read, have it return nothing and EOF.
+  Expect_nbRead(7, "", true, true);
+  // Expect that we close the socket.
+  Expect_close(7);
+  // Expect readResponse to return false since we're done monitoring this
+  // socket.
+  EXPECT_FALSE(a.readResponse());
+
+  // Check that state machine is in the correct state after getting the header.
+  EXPECT_EQ(XmlRpcClientForTest::NO_CONNECTION, a._connectionState);
+
+  // Check that all expected function calls were made before destruction.
+  CheckCalls();
+}
+
+// Test parseResponse
+//  Test correct parsing of various response types: empty, int, double,
+//   string, bool, list, struct, date, base64, etc
+//  Test for correct handling of empty response body
+//  Test for correct parsing/handling of partial response
+//  Test for correct handling of garbage data
+//  Test for correct handling of mismatched XML tags at top level
+//  Test for correct handling of ALL UPPERCASE, lowercase and CamelCase tags
+
+int main(int argc, char **argv)
+{
+  ::testing::InitGoogleTest(&argc, argv);
+  return RUN_ALL_TESTS();
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/test_dispatch.cpp
@@ -0,0 +1,361 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ *
+ */
+
+#include "xmlrpcpp/XmlRpcDispatch.h"
+#include "xmlrpcpp/XmlRpcSource.h"
+#include "xmlrpcpp/XmlRpcSocket.h"
+#include "mock_socket.h"
+
+#include <fcntl.h>
+#ifndef _WIN32
+# include <netinet/in.h>
+# include <poll.h>
+# include <sys/socket.h>
+# include <unistd.h>
+#else
+# include <winsock2.h> // For struct timeval
+# include <ws2tcpip.h> // Must be after winsock2.h because MS didn't put proper inclusion guards in their headers.
+typedef unsigned long int nfds_t;
+#endif
+#include <stdlib.h>
+#include <sys/types.h>
+#include <time.h>
+#include <errno.h>
+
+#include <iostream>
+#include <functional>
+
+#include <gtest/gtest.h>
+
+// Mocks for select and poll. The build file specifies -Wl,--wrap for both of
+// these, so the original symbols are available as __real_xxx and any uses of
+// those symbols instead use __wrap_xxx
+extern "C" {
+// Mock for poll
+int (*fake_poll)(struct pollfd *, nfds_t, int) = 0;
+
+int __wrap_poll(struct pollfd *fds, nfds_t nfds, int timeout) {
+  if(fake_poll) {
+    return fake_poll(fds, nfds, timeout);
+  } else {
+    return 0;
+  }
+}
+
+}
+
+int poll_calls = 0;
+int poll_ret = 0;
+int poll_errno = 0;
+int poll_timeout = 0;
+std::vector<pollfd> poll_fds;
+int mock_poll(struct pollfd *fds, nfds_t nfds, int timeout) {
+  EXPECT_EQ(1, poll_calls);
+  poll_calls--;
+
+  EXPECT_EQ(poll_fds.size(), nfds);
+  EXPECT_EQ(poll_timeout, timeout);
+
+  for(nfds_t i=0; i<nfds && i<poll_fds.size(); i++) {
+    EXPECT_EQ(poll_fds[i].fd, fds[i].fd);
+    EXPECT_EQ(poll_fds[i].events, fds[i].events);
+    fds[i].revents = poll_fds[i].revents;
+  }
+
+  // HACK: Sleep for the requested duration
+  // This can be thought of as a simulation of select() getting an event
+  // exactly at the end of the timeout window, but really it's just here
+  // because the dispatch loop has its own timer to determine if it should call
+  // select again, and we don't want multiple calls.
+  if(timeout > 0) {
+    timespec ts;
+    ts.tv_sec = timeout / 1000;
+    ts.tv_nsec = (timeout % 1000) * 1000000;
+    // Call nanosleep repeatedly until it returns 0 (success).
+    // On failure it will update ts with the remaining time to sleep.
+    int ret = 0;
+    do {
+#ifndef _WIN32
+      ret = nanosleep(&ts, &ts);
+#else
+      Sleep(timeout);
+#endif
+    } while( ret != 0 && errno == EINTR);
+  }
+
+  errno = poll_errno;
+  return poll_ret;
+}
+
+void Expect_poll(std::vector<pollfd> fds, int timeout, int _errno, int ret) {
+  EXPECT_EQ(0, poll_calls) << "Test bug: Cannot expect more than one call to poll";
+  poll_calls = 1;
+  poll_ret = ret;
+  poll_errno = _errno;
+  poll_timeout = timeout;
+  poll_fds = fds;
+}
+
+using namespace XmlRpc;
+
+class MockSource : public XmlRpcSource {
+public:
+  MockSource(int fd)
+    : handleEvent_calls(0), last_event(0), event_result(0), close_calls(0) {
+    setfd(fd);
+  }
+
+  virtual ~MockSource() {
+  }
+
+  virtual unsigned handleEvent(unsigned eventType) {
+    handleEvent_calls++;
+    last_event = eventType;
+    return event_result;
+  }
+
+  virtual void close() {
+    close_calls++;
+  }
+
+  // variables used for mocking
+  int handleEvent_calls;
+  unsigned last_event;
+  unsigned event_result;
+
+  int close_calls;
+};
+
+#define EXPECT_CLOSE_CALLS(n)                                                  \
+  do {                                                                         \
+    EXPECT_EQ(m.close_calls, n);                                               \
+    m.close_calls = 0;                                                         \
+  } while (0)
+
+#define EXPECT_EVENTS(n)                                                       \
+  do {                                                                         \
+    EXPECT_EQ(m.handleEvent_calls, n);                                         \
+    m.handleEvent_calls = 0;                                                   \
+  } while (0)
+
+#define EXPECT_EVENT(event)                                                    \
+  do {                                                                         \
+    EXPECT_EQ(m.last_event, event);                                            \
+    EXPECT_EQ(m.handleEvent_calls, 1);                                         \
+    m.handleEvent_calls = 0;                                                   \
+  } while (0)
+
+class MockSourceTest : public ::testing::Test {
+  protected:
+    MockSourceTest() : m(4) {
+#ifndef _WIN32
+      pollfd f = { .fd = 4, .events = 0, .revents = 0 };
+#else
+      pollfd f {};
+      f.fd = 4;
+      f.events = 0;
+      f.revents = 0;
+#endif
+      fds.push_back(f);
+    }
+
+    void SetUp() {
+      fake_poll = mock_poll;
+      poll_calls = 0;
+    }
+
+    void TearDown() {
+      EXPECT_EQ(0, poll_calls);
+      fake_poll = 0;
+      poll_calls = 0;
+    }
+
+    MockSource m;
+    XmlRpcDispatch dispatch;
+    std::vector<pollfd> fds;
+};
+
+/*
+ * Use a socket to provide the requisite file descriptor
+ *
+ * Tests to perform on XmlRpcDispatch
+ * - Matrix of the following options:
+ *   - Proper handling of setKeepOpen
+ *   - Proper handling of deleteOnClose
+ *   - Proper handling of return values from handleEvent
+ * - Proper handling of file descriptor states
+ *   - Correct masking of events by the eventMask for the source
+ *   - Correct handling of exceptional file descriptor states
+ *     - These states seem to mostly be related to sending OOB data over TCP; I
+ *       don't see a way to simulate them with pipes, but it should be possible
+ *       to loop back a TCP connection and generate that condition directly
+ *   - Check that the argument to handleEvent matches the event that was
+ *     simulated
+ *   - Check that handleEvent is not called if no event was triggered
+ * - Proper handling of timeout in XmlRpcDispatch work() method
+ * - Proper removal of sources from _sources when errors occur
+ * - If possible, trigger error return values from select(); maybe one of the
+ *   following error cases from the select(2) man page:
+ *    - Invalid file descriptor in set (already closed?)
+ *    - Signal caught
+ *    - nfds negative or invalid timeout
+ *    - unable to allocate memory
+ * - Proper handling of multiple XmlRpcSource objects
+ *   - Multiple events during a single work() cycle
+ *   - Events delivered to the correct Source
+ */
+
+TEST_F(MockSourceTest, ReadEvent) {
+  m.event_result = XmlRpcDispatch::ReadableEvent;
+  dispatch.addSource(&m, XmlRpcDispatch::ReadableEvent);
+  EXPECT_EQ(dispatch._sources.size(), 1u);
+
+  // Select returns not readable; expect no events.
+  fds[0].events = POLLIN;
+  fds[0].revents = 0;
+  Expect_poll(fds, 100, 0, 0);
+  dispatch.work(0.1);
+
+  EXPECT_CLOSE_CALLS(0);
+  EXPECT_EVENTS(0);
+
+  // Select returns readable, expect readable event
+  fds[0].events = POLLIN;
+  fds[0].revents = POLLIN;
+  Expect_poll(fds, 100, 0, 0);
+  dispatch.work(0.1);
+  EXPECT_CLOSE_CALLS(0);
+  EXPECT_EVENT(XmlRpcDispatch::ReadableEvent);
+}
+
+TEST_F(MockSourceTest, WriteEvent) {
+  m.setKeepOpen();
+  m.event_result = 0;
+  dispatch.addSource(&m, XmlRpcDispatch::WritableEvent);
+  EXPECT_EQ(dispatch._sources.size(), 1u);
+
+  // Select returns writeable, expect one write event.
+  fds[0].events = POLLOUT;
+  fds[0].revents = POLLOUT;
+  Expect_poll(fds, 100, 0, 0);
+  dispatch.work(0.1);
+  EXPECT_EVENT(XmlRpcDispatch::WritableEvent);
+  // We have keepOpen set, so don't expect a close call
+  EXPECT_CLOSE_CALLS(0);
+  // However, even if keepOpen is set, we expect the socket to be removed from
+  // the sources list
+  EXPECT_EQ(dispatch._sources.size(), 0u);
+
+  // Expect no more events. Since there's nothing in the dispatch list, we
+  // don't expect that select will be called.
+  dispatch.work(0.1);
+  EXPECT_CLOSE_CALLS(0);
+  EXPECT_EVENTS(0);
+}
+
+TEST_F(MockSourceTest, NonWriteable) {
+  m.event_result = XmlRpcDispatch::WritableEvent;
+  dispatch.addSource(&m, XmlRpcDispatch::WritableEvent);
+  EXPECT_EQ(dispatch._sources.size(), 1u);
+
+  // Select doesn't return writable.
+  fds[0].events = POLLOUT;
+  fds[0].revents = 0;
+  Expect_poll(fds, 100, 0, 0);
+  dispatch.work(0.1);
+  EXPECT_EVENTS(0);
+  EXPECT_CLOSE_CALLS(0);
+  EXPECT_EQ(dispatch._sources.size(), 1u);
+}
+
+TEST_F(MockSourceTest, WriteClose) {
+  m.event_result = 0;
+  dispatch.addSource(&m, XmlRpcDispatch::WritableEvent);
+  EXPECT_EQ(dispatch._sources.size(), 1u);
+
+  // Socket is always writeable. Expect 1 write event since we clear the write
+  // event flag after we write once
+  fds[0].events = POLLOUT;
+  fds[0].revents = POLLOUT;
+  Expect_poll(fds, 100, 0, 0);
+  dispatch.work(0.1);
+  EXPECT_EVENT(XmlRpcDispatch::WritableEvent);
+
+  // Since we returned 0 from handleEvent and don't have keepOpen set, expect
+  // that the dispatch has called close() once and that the size of sources is
+  // now 0
+  EXPECT_CLOSE_CALLS(1);
+  EXPECT_EQ(dispatch._sources.size(), 0u);
+
+  // Expect no more events. Since there's nothing in the dispatch list, we
+  // don't expect that select will be called.
+  dispatch.work(0.1);
+  EXPECT_CLOSE_CALLS(0);
+  EXPECT_EVENTS(0);
+}
+
+TEST_F(MockSourceTest, Exception) {
+  m.event_result = XmlRpcDispatch::Exception;
+  dispatch.addSource(&m, XmlRpcDispatch::Exception);
+  EXPECT_EQ(dispatch._sources.size(), 1u);
+
+  // Select returns no exception, so expect that the handler was not called.
+  fds[0].events = POLLPRI;
+  fds[0].revents = 0;
+  Expect_poll(fds, 100, 0, 0);
+  dispatch.work(0.1);
+  EXPECT_CLOSE_CALLS(0);
+  EXPECT_EVENTS(0);
+
+  // Make exception, expect exception event.
+  fds[0].events = POLLPRI;
+  fds[0].revents = POLLPRI;
+  Expect_poll(fds, 100, 0, 0);
+  dispatch.work(0.1);
+  EXPECT_CLOSE_CALLS(0);
+  EXPECT_EVENT(XmlRpcDispatch::Exception);
+}
+
+// Test that dispatch works (or doesn't) with file descriptors above 1024
+TEST_F(MockSourceTest, LargeFd) {
+  m.setfd(1025);
+  m.event_result = XmlRpcDispatch::WritableEvent;
+  dispatch.addSource(&m, XmlRpcDispatch::WritableEvent);
+  EXPECT_EQ(dispatch._sources.size(), 1u);
+
+  // Make select return writable, expect 1 write event.
+  fds[0].fd = 1025;
+  fds[0].events = POLLOUT;
+  fds[0].revents = POLLOUT;
+  Expect_poll(fds, 100, 0, 0);
+  dispatch.work(0.1);
+  EXPECT_EVENT(XmlRpcDispatch::WritableEvent);
+  EXPECT_CLOSE_CALLS(0);
+  EXPECT_EQ(dispatch._sources.size(), 1u);
+}
+
+int main(int argc, char **argv)
+{
+  ::testing::InitGoogleTest(&argc, argv);
+  return RUN_ALL_TESTS();
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/test_dispatch_live.cpp
@@ -0,0 +1,195 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ * Loosely based on HelloServer.cpp and HelloClient.cpp by Chris Morley
+ *
+ */
+
+#include "xmlrpcpp/XmlRpc.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#ifndef _WIN32
+# include <sys/socket.h>
+#else
+# include <winsock2.h>
+#endif
+
+#include <iostream>
+#include <functional>
+
+#include <gtest/gtest.h>
+
+#include "test_fixtures.h"
+
+using namespace XmlRpc;
+
+TEST_F(XmlRpcTest, Hello)
+{
+  XmlRpcClient c("localhost", port);
+  XmlRpcValue noArgs, result;
+
+  // Call the Hello method
+  ASSERT_TRUE(c.execute("Hello", noArgs, result));
+
+  EXPECT_FALSE(c.isFault());
+  XmlRpcValue hello("Hello");
+  EXPECT_EQ(result, hello);
+}
+
+TEST_F(XmlRpcTest, HelloNonBlock)
+{
+  XmlRpcClient c("localhost", port);
+  XmlRpcValue noArgs, result;
+
+  // Call the Hello method, non-blocking
+  ASSERT_TRUE(c.executeNonBlock("Hello", noArgs));
+
+  bool done = false;
+  for (int i = 0; i < 30; i++)
+  {
+    done = c.executeCheckDone(result);
+    if (done)
+      break;
+    // run the client's dispatch loop to service the respond when it comes back
+    c._disp.work(0.1);
+  }
+
+  ASSERT_TRUE(done);
+
+  XmlRpcValue hello("Hello");
+  EXPECT_EQ(result, hello);
+}
+
+TEST_F(XmlRpcTest, HelloNonBlock2)
+{
+  XmlRpcClient c("localhost", port);
+  XmlRpcValue noArgs, result;
+
+  // Lock the hello mutex so that the service call cannot return immediately
+  hello.hello_mutex.lock();
+
+  // Call the Hello method, non-blocking
+  ASSERT_TRUE(c.executeNonBlock("Hello", noArgs));
+
+  bool done = false;
+  for (int i = 0; i < 100; i++)
+  {
+    done = c.executeCheckDone(result);
+    if (done)
+      break;
+    // run the client's dispatch loop to service the respond when it comes back
+    c._disp.work(0.1);
+
+    // unlock the hello mutex after 10 cycles
+    if (i == 10)
+      hello.hello_mutex.unlock();
+  }
+
+  ASSERT_TRUE(done);
+
+  XmlRpcValue hello("Hello");
+  EXPECT_EQ(result, hello);
+}
+
+TEST_F(XmlRpcTest, ClientDisconnect)
+{
+  XmlRpcClient* c = new XmlRpcClient("localhost", port);
+  XmlRpcValue noArgs, result;
+
+  // Lock the hello mutex so that the service call cannot return immediately
+  hello.hello_mutex.lock();
+
+  // Call the Hello method, non-blocking
+  ASSERT_TRUE(c->executeNonBlock("Hello", noArgs));
+
+  // Destroy the client before the server can answer
+  delete c;
+
+  // Unlock the mutex so the server can finish
+  hello.hello_mutex.unlock();
+}
+
+TEST_F(XmlRpcTest, ServerDisconnect)
+{
+  XmlRpcClient c("localhost", port);
+  XmlRpcValue noArgs, result;
+
+  XmlRpc::setVerbosity(3);
+
+  // Stop calling the work method on the server
+  server_done = true;
+  server_thread.join();
+
+  // Call the Hello method, non-blocking
+  ASSERT_TRUE(c.executeNonBlock("Hello", noArgs));
+
+  // Destroy the server before it can answer
+  s.shutdown();
+
+  // Run the client to completion
+  bool done = false;
+  for (int i = 0; i < 100; i++)
+  {
+    done = c.executeCheckDone(result);
+    if (done)
+      break;
+    // run the client's dispatch loop to service the respond when it comes back
+    c._disp.work(0.1);
+  }
+
+  // The client should return true because the request is done, even though it
+  // timed out and wasn't able to complete.
+  EXPECT_TRUE(done);
+  EXPECT_EQ(-1, c.getfd());
+
+  EXPECT_EQ(result, XmlRpcValue()); // Expect empty result
+}
+
+TEST_F(XmlRpcTest, ServerDisconnect2)
+{
+  XmlRpcClient c("localhost", port);
+  XmlRpcValue noArgs, result;
+
+  // Stop calling the work method on the server
+  server_done = true;
+  server_thread.join();
+  // Close the server socket to reads (ie incoming connections)
+  #ifndef _WIN32
+  shutdown(s.getfd(), SHUT_RD);
+  #else
+  shutdown(s.getfd(), SD_RECEIVE);
+  #endif
+
+  // Call the Hello method. Expect failure since the server socket is not
+  // accepting new connections.
+  ASSERT_FALSE(c.execute("Hello", noArgs, result));
+
+  XmlRpcValue hello; // Expect empty result
+  EXPECT_EQ(result, hello);
+}
+
+int main(int argc, char **argv)
+{
+  ::testing::InitGoogleTest(&argc, argv);
+  return RUN_ALL_TESTS();
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/test_fixtures.cpp
@@ -0,0 +1,75 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ * Loosely based on HelloServer.cpp by Chris Morley
+ *
+ */
+
+#include "test_fixtures.h"
+// No arguments, result is "Hello".
+
+using namespace XmlRpc;
+
+void Hello::execute(XmlRpcValue& params, XmlRpcValue& result)
+{
+  (void)params;
+  boost::unique_lock<boost::mutex> lock(hello_mutex);
+  result = "Hello";
+}
+
+XmlRpcTest::XmlRpcTest() : hello(&s), port(0), server_done(false) {}
+
+void XmlRpcTest::work()
+{
+  while (!server_done)
+  {
+    s.work(0.1); // run the worker queue for 100ms
+  }
+}
+
+void XmlRpcTest::SetUp()
+{
+  // XmlRpc::setVerbosity(5);
+
+  // Create the server socket on the specified port
+  s.bindAndListen(0);
+  port = s.get_port();
+
+  // Enable introspection
+  s.enableIntrospection(true);
+
+  // Start the worker thread
+  server_thread = boost::thread(boost::mem_fn(&XmlRpcTest::work), this);
+}
+
+void XmlRpcTest::TearDown()
+{
+  // TODO(austin): determine if we need to do anything here to avoid
+  // leaking resources
+  server_done = true;
+  if (server_thread.joinable())
+  {
+    server_thread.join();
+  }
+  s.shutdown();
+
+  // Reset verbosity in case a test raises the verbosity.
+  XmlRpc::setVerbosity(0);
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/test_fixtures.h
@@ -0,0 +1,64 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ *
+ */
+
+#include "xmlrpcpp/XmlRpc.h"
+
+#include <boost/thread/mutex.hpp>
+#include <boost/thread/thread.hpp>
+#include <gtest/gtest.h>
+
+// No arguments, result is "Hello".
+class Hello : public XmlRpc::XmlRpcServerMethod
+{
+public:
+  Hello(XmlRpc::XmlRpcServer* s) : XmlRpc::XmlRpcServerMethod("Hello", s) {}
+
+  virtual ~Hello() {}
+
+  void execute(XmlRpc::XmlRpcValue& params, XmlRpc::XmlRpcValue& result);
+
+  boost::mutex hello_mutex;
+};
+
+class XmlRpcTest : public ::testing::Test
+{
+protected:
+  XmlRpcTest();
+
+  void work();
+
+  virtual void SetUp();
+
+  virtual void TearDown();
+
+  // The server and its methods
+  XmlRpc::XmlRpcServer s;
+  Hello hello;
+
+  // Server port number (for clients)
+  int port;
+
+  // Server thread
+  bool server_done;
+  boost::thread server_thread;
+};
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/test_socket.cpp
@@ -0,0 +1,1392 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ *
+ */
+
+#include "xmlrpcpp/XmlRpcUtil.h"
+#include "xmlrpcpp/XmlRpcSocket.h"
+#include "test_system_mocks.h"
+
+#include <arpa/inet.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <limits.h>
+#include <netdb.h>
+#include <stdarg.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <deque>
+
+#include <gtest/gtest.h>
+
+#define FOR_ERRNO(itr, var, ...)                                               \
+  int var[] = {__VA_ARGS__};                                                   \
+  for (size_t itr = 0; itr < sizeof(var) / sizeof(int); itr++)
+
+using XmlRpc::XmlRpcSocket;
+
+class XmlRpcSocketTest : public ::testing::Test {
+protected:
+  void SetUp() {
+    accept_calls = 0;
+    bind_calls = 0;
+    close_calls = 0;
+    connect_calls = 0;
+    fcntl_calls = 0;
+    listen_calls = 0;
+    read_calls = 0;
+    select_calls = 0;
+    socket_calls = 0;
+    write_calls = 0;
+
+    XmlRpc::setVerbosity(5);
+    XmlRpcSocket::s_use_ipv6_ = false;
+  }
+
+  void TearDown() {
+    fake_accept = 0;
+    fake_bind = 0;
+    fake_close = 0;
+    fake_connect = 0;
+    fake_fcntl = 0;
+    fake_listen = 0;
+    fake_read = 0;
+    fake_select = 0;
+    fake_socket = 0;
+    fake_write = 0;
+  }
+};
+
+TEST_F(XmlRpcSocketTest, TestMocks) {
+  EXPECT_EQ(0, fake_accept);
+  EXPECT_EQ(0, accept_calls);
+  fake_accept = count_accept;
+  EXPECT_EQ(0, accept(0, 0, 0));
+  EXPECT_EQ(1, accept_calls);
+
+  EXPECT_EQ(0, fake_bind);
+  EXPECT_EQ(0, bind_calls);
+  fake_bind = count_bind;
+  EXPECT_EQ(0, bind(0, 0, 0));
+  EXPECT_EQ(1, bind_calls);
+
+  EXPECT_EQ(0, fake_close);
+  EXPECT_EQ(0, close_calls);
+  fake_close = count_close;
+  EXPECT_EQ(0, close(-1));
+  EXPECT_EQ(1, close_calls);
+
+  EXPECT_EQ(0, fake_connect);
+  EXPECT_EQ(0, connect_calls);
+  fake_connect = count_connect;
+  EXPECT_EQ(0, connect(0, 0, 0));
+  EXPECT_EQ(1, connect_calls);
+
+  EXPECT_EQ(0, fake_fcntl);
+  EXPECT_EQ(0, fcntl_calls);
+  fake_fcntl = count_fcntl;
+  EXPECT_EQ(0, fcntl(0, 0, 0));
+  EXPECT_EQ(1, fcntl_calls);
+
+  EXPECT_EQ(0, fake_freeaddrinfo);
+  EXPECT_EQ(0, freeaddrinfo_calls);
+  fake_freeaddrinfo = count_freeaddrinfo;
+  freeaddrinfo(0);
+  EXPECT_EQ(1, freeaddrinfo_calls);
+
+  EXPECT_EQ(0, fake_getaddrinfo);
+  EXPECT_EQ(0, getaddrinfo_calls);
+  fake_getaddrinfo = count_getaddrinfo;
+  EXPECT_EQ(0, getaddrinfo(0, 0, 0, 0));
+  EXPECT_EQ(1, getaddrinfo_calls);
+
+  EXPECT_EQ(0, fake_getsockname);
+  EXPECT_EQ(0, getsockname_calls);
+  fake_getsockname = count_getsockname;
+  EXPECT_EQ(0, getsockname(0, 0, 0));
+  EXPECT_EQ(1, getsockname_calls);
+
+  EXPECT_EQ(0, fake_listen);
+  EXPECT_EQ(0, listen_calls);
+  fake_listen = count_listen;
+  EXPECT_EQ(0, listen(0, 0));
+  EXPECT_EQ(1, listen_calls);
+
+  EXPECT_EQ(0, fake_read);
+  EXPECT_EQ(0, read_calls);
+  fake_read = count_read;
+  EXPECT_EQ(0, read(0, 0, 0));
+  EXPECT_EQ(1, read_calls);
+
+  EXPECT_EQ(0, fake_setsockopt);
+  EXPECT_EQ(0, setsockopt_calls);
+  fake_setsockopt = count_setsockopt;
+  EXPECT_EQ(0, setsockopt(0, 0, 0, 0, 0));
+  EXPECT_EQ(1, setsockopt_calls);
+
+  EXPECT_EQ(0, fake_select);
+  EXPECT_EQ(0, select_calls);
+  fake_select = count_select;
+  EXPECT_EQ(0, select(0, 0, 0, 0, 0));
+  EXPECT_EQ(1, select_calls);
+
+  EXPECT_EQ(0, fake_socket);
+  EXPECT_EQ(0, socket_calls);
+  fake_socket = count_socket;
+  EXPECT_EQ(0, socket(0, 0, 0));
+  EXPECT_EQ(1, socket_calls);
+
+  EXPECT_EQ(0, fake_write);
+  EXPECT_EQ(0, write_calls);
+  fake_write = count_write;
+  EXPECT_EQ(0, write(0, 0, 0));
+  EXPECT_EQ(1, write_calls);
+}
+
+int socket_ret = 0;
+int socket_errno = 0;
+int socket_domain = 0;
+int socket_type = 0;
+int socket_protocol = 0;
+int test_socket(int domain, int type, int protocol) {
+  socket_domain = domain;
+  socket_type = type;
+  socket_protocol = protocol;
+
+  socket_calls++;
+  errno = socket_errno;
+  return socket_ret;
+}
+
+TEST_F(XmlRpcSocketTest, socket) {
+  fake_socket = test_socket;
+
+  errno = 0;
+  EXPECT_EQ(0, errno);
+
+  socket_ret = 7;
+  socket_errno = 0;
+  socket_calls = 0;
+  EXPECT_EQ(7, XmlRpcSocket::socket());
+  EXPECT_EQ(0, XmlRpcSocket::getError());
+  EXPECT_EQ(1, socket_calls);
+  EXPECT_EQ(AF_INET, socket_domain);
+  EXPECT_EQ(SOCK_STREAM, socket_type);
+  EXPECT_EQ(0, socket_protocol);
+
+  // Check all of the errno values that the man page says socket can set if
+  // it fails
+  FOR_ERRNO(i,
+            errnos,
+            EACCES,
+            EAFNOSUPPORT,
+            EINVAL,
+            EMFILE,
+            ENFILE,
+            ENOBUFS,
+            ENOMEM,
+            EPROTONOSUPPORT) {
+    socket_ret = -1;
+    socket_errno = errnos[i];
+    socket_calls = 0;
+    EXPECT_EQ(-1, XmlRpcSocket::socket());
+    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
+    EXPECT_EQ(1, socket_calls);
+    EXPECT_EQ(AF_INET, socket_domain);
+    EXPECT_EQ(SOCK_STREAM, socket_type);
+    EXPECT_EQ(0, socket_protocol);
+  }
+}
+
+int close_fd = 0;
+int close_errno = 0;
+int close_ret = 0;
+int test_close(int fd) {
+  EXPECT_EQ(close_fd, fd);
+
+  close_calls++;
+  errno = close_errno;
+  return close_ret;
+}
+
+TEST_F(XmlRpcSocketTest, close) {
+  // TODO(austin): XmlRpcSocket does not check or return the return value from
+  //               close
+  close_fd = 8;
+  close_errno = 0;
+  close_ret = 0;
+  close_calls = 0;
+  fake_close = test_close;
+  XmlRpcSocket::close(8);
+  EXPECT_EQ(0, XmlRpcSocket::getError());
+  EXPECT_EQ(1, close_calls);
+
+  // TODO(austin): Close should automatically retry on EINTR but does not.
+  FOR_ERRNO(i, errnos, EBADF, EINTR, EIO) {
+    close_errno = errnos[i];
+    close_ret = -1;
+    close_calls = 0;
+    XmlRpcSocket::close(8);
+    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
+    EXPECT_EQ(1, close_calls);
+  }
+}
+
+int fcntl_fd = 0;
+int fcntl_cmd = 0;
+unsigned long fcntl_arg = 0;
+int fcntl_errno = 0;
+int fcntl_ret = 0;
+int test_fcntl(int fd, int cmd, unsigned long arg) {
+  EXPECT_EQ(fcntl_fd, fd);
+  EXPECT_EQ(fcntl_cmd, cmd);
+  EXPECT_EQ(fcntl_arg, arg);
+
+  errno = fcntl_errno;
+  fcntl_calls++;
+  return fcntl_ret;
+}
+
+TEST_F(XmlRpcSocketTest, setNonBlocking) {
+  fake_fcntl = test_fcntl;
+
+  fcntl_fd = 9;
+  fcntl_cmd = F_SETFL;
+  fcntl_arg = O_NONBLOCK;
+
+  fcntl_calls = 0;
+  fcntl_errno = 0;
+  fcntl_ret = 0;
+  EXPECT_TRUE(XmlRpcSocket::setNonBlocking(9));
+  EXPECT_EQ(0, XmlRpcSocket::getError());
+  EXPECT_EQ(1, fcntl_calls);
+
+  // Tests for the errno values that the man page indicates might reasonably be
+  // returned by F_SETFL
+  FOR_ERRNO(i, errnos, EACCES, EAGAIN, EBADF) {
+    fcntl_calls = 0;
+    fcntl_errno = errnos[i];
+    fcntl_ret = -1;
+    EXPECT_FALSE(XmlRpcSocket::setNonBlocking(9));
+    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
+    EXPECT_EQ(1, fcntl_calls);
+  }
+}
+
+struct expected_read {
+  expected_read(int fd, const void* buf, size_t sz)
+    : fd(fd), count(4095), buf(buf), sz(sz), ret(sz), _errno(0) {}
+
+  expected_read(int fd, int _errno)
+    : fd(fd), count(4095), buf(0), sz(0), ret(-1), _errno(_errno) {}
+
+  int fd;
+  size_t count;
+  const void* buf;
+  size_t sz;
+  ssize_t ret;
+  int _errno;
+};
+
+std::deque<expected_read> expected_reads;
+
+ssize_t mock_read(int fd, void* buf, size_t count) {
+  read_calls++;
+
+  // Check that we have another call in the queue. If not, fail the test and
+  // return 0 (EOF).
+  EXPECT_LE(1u, expected_reads.size());
+  if (expected_reads.size() < 1) {
+    errno = 0;
+    return 0;
+  }
+
+  // Get the next call off the queue.
+  expected_read r = expected_reads.front();
+  expected_reads.pop_front();
+
+  // Check file descriptor and count.
+  EXPECT_EQ(r.fd, fd);
+  EXPECT_EQ(r.count, count);
+
+  // Sanity check on count. Man pages say a count above SSIZE_MAX is undefined,
+  // so check that the count that is passed doesn't trigger undefined behavior.
+  EXPECT_GT(static_cast<size_t>(SSIZE_MAX), count);
+
+  // Check that the buffer size is less or equal to the requested buffer size.
+  EXPECT_LE(r.sz, count);
+  size_t cnt = std::min(count, r.sz);
+  // If we have a nonzero number of bytes to copy, copy them into the output
+  // buffer.
+  if (cnt > 0) {
+    memcpy(buf, r.buf, cnt);
+  }
+
+  // Check that the return value is what we expect it to be.
+  if (r.ret >= 0) {
+    EXPECT_EQ(cnt, static_cast<size_t>(r.ret));
+  }
+
+  // Update errno and return.
+  errno = r._errno;
+  return r.ret;
+}
+
+TEST_F(XmlRpcSocketTest, nbRead) {
+  fake_read = mock_read;
+
+  const char data[] = "read1 read2 read3 read4 read5 read6 read7 read8";
+  bool eof = false;
+  std::string data_out;
+
+  // Test: read some incoming data and then return EOF.
+  // This is a nominal case when reading from a blocking descriptor.
+  expected_reads.push_back(expected_read(7, data, 9));
+  expected_reads.push_back(expected_read(7, 0, 0));
+
+  EXPECT_TRUE(XmlRpcSocket::nbRead(7, data_out, &eof));
+  EXPECT_EQ("read1 rea", data_out);
+  EXPECT_TRUE(eof);
+  EXPECT_EQ(2, read_calls);
+  EXPECT_EQ(0, XmlRpcSocket::getError());
+  EXPECT_EQ(0u, expected_reads.size());
+  expected_reads.clear();
+}
+
+#define TEST_READ(RES, ERR)                                                    \
+  TEST_F(XmlRpcSocketTest, nbRead_##ERR) {                                     \
+    fake_read = mock_read;                                                     \
+    bool eof = false;                                                          \
+    std::string data_out;                                                      \
+                                                                               \
+    expected_reads.push_back(expected_read(7, ERR));                           \
+                                                                               \
+    EXPECT_##RES(XmlRpcSocket::nbRead(7, data_out, &eof));                     \
+    EXPECT_EQ("", data_out);                                                   \
+    EXPECT_FALSE(eof);                                                         \
+    EXPECT_EQ(1, read_calls);                                                  \
+    EXPECT_EQ(ERR, XmlRpcSocket::getError());                                  \
+    EXPECT_EQ(0u, expected_reads.size());                                       \
+    expected_reads.clear();                                                    \
+  }
+
+// EAGAIN: fd is ok, read should be expected to return 0 bytes.
+TEST_READ(TRUE, EAGAIN);
+
+// EWOULDBLOCK: same as EAGAIN.
+TEST_READ(TRUE, EWOULDBLOCK);
+
+// EINTR: interrupted by system call. Expected behavior is that the caller
+// should retry the read again immediately.
+TEST_F(XmlRpcSocketTest, nbRead_EINTR) {
+  fake_read = mock_read;
+
+  bool eof = false;
+  std::string data_out;
+
+  expected_reads.push_back(expected_read(7, EINTR));
+  // TODO(austin): expecting a second read causes the test to fail.
+  // expected_reads.push_back(expected_read(7, 0, 0));
+
+  EXPECT_TRUE(XmlRpcSocket::nbRead(7, data_out, &eof));
+  EXPECT_EQ("", data_out);
+  EXPECT_FALSE(eof);
+  // TODO(austin): expecting a second read causes the test to fail.
+  // EXPECT_EQ(2, read_calls);
+  EXPECT_EQ(1, read_calls);
+  EXPECT_EQ(EINTR, XmlRpcSocket::getError());
+}
+
+// EBADF: file descriptor is bad; read should fail.
+TEST_READ(FALSE, EBADF);
+
+// EFAULT: buf is bad; read should fail.
+// TODO(austin): this failure indicates that file descriptor is good, so if
+// we see this error elsewhere it indicates that we shouldn't close the socket.
+// Since XmlRpcSocket is handling the buffers, maybe this should be converted
+// into an assertion failure inside XmlRpcSocket, and this test should
+// EXPECT_DEATH?
+TEST_READ(FALSE, EFAULT);
+
+// EINVAL: File descriptor is not for reading. read should fail.
+TEST_READ(FALSE, EINVAL);
+
+// EIO: I/O error. read should probably fail.
+TEST_READ(FALSE, EIO);
+
+// EISDIR: File descriptor is a directory. read should fail.
+TEST_READ(FALSE, EISDIR);
+
+// More errors from recv (these should also apply to read on a socket).
+// EACCES: Permission denied. read should fail.
+TEST_READ(FALSE, EACCES);
+
+// ECONNREFUSED: Connection refused. read should fail.
+TEST_READ(FALSE, ECONNREFUSED);
+
+// ENOMEM: Could not allocate memory. read should fail.
+TEST_READ(FALSE, ENOMEM);
+
+// ENOTCONN: Socket is not connected. read should fail.
+TEST_READ(FALSE, ENOTCONN);
+
+struct expected_write {
+  expected_write(int fd, std::string data, size_t count, size_t max_write)
+    : fd(fd),
+      data(data),
+      count(count),
+      max_write(max_write),
+      ret(std::min(count, max_write)),
+      _errno(0) {}
+
+  expected_write(int fd, size_t count, ssize_t ret, int _errno)
+    : fd(fd), data(""), count(count), max_write(0), ret(ret), _errno(_errno) {}
+
+  int fd;
+  std::string data;
+  size_t count;
+  size_t max_write;
+  ssize_t ret;
+  int _errno;
+};
+
+std::deque<expected_write> expected_writes;
+
+ssize_t mock_write(int fd, const void* buf, size_t count) {
+  write_calls++;
+
+  // Check that we have another call in the queue. If not, fail the test and
+  // return 0 (EOF).
+  EXPECT_LE(1u, expected_writes.size());
+  if (expected_writes.size() < 1) {
+    // Since the socket is supposed to be non-blocking, return EWOULDBLOCK
+    // if we can't write.
+    errno = EWOULDBLOCK;
+    return -1;
+  }
+
+  expected_write w = expected_writes.front();
+  expected_writes.pop_front();
+
+  EXPECT_EQ(w.fd, fd);
+  EXPECT_EQ(w.count, count);
+  size_t sz = std::min(w.max_write, count);
+  if (sz > 0) {
+    std::string data((const char*)buf, sz);
+    EXPECT_EQ(w.data, data);
+    EXPECT_GE(w.ret, 0u);
+    EXPECT_EQ(static_cast<size_t>(w.ret), sz);
+  }
+
+  errno = w._errno;
+  return w.ret;
+}
+
+TEST_F(XmlRpcSocketTest, nbWrite) {
+  fake_write = mock_write;
+  int count = 0;
+  std::string hello = "hello world";
+
+  // Single write for all the data.
+  expected_writes.push_back(expected_write(10, "hello world", 11, 11));
+  count = 0;
+  write_calls = 0;
+  errno = 0;
+  EXPECT_TRUE(XmlRpcSocket::nbWrite(10, hello, &count));
+  EXPECT_EQ(count, 11);
+  EXPECT_EQ(0, XmlRpcSocket::getError());
+  EXPECT_EQ(0u, expected_writes.size());
+  EXPECT_EQ(1, write_calls);
+
+  // Write in two parts, both succeed.
+  expected_writes.push_back(expected_write(10, "hello", 11, 5));
+  expected_writes.push_back(expected_write(10, " world", 6, 10));
+  count = 0;
+  write_calls = 0;
+  errno = 0;
+  EXPECT_TRUE(XmlRpcSocket::nbWrite(10, hello, &count));
+  EXPECT_EQ(count, 11);
+  EXPECT_EQ(0, XmlRpcSocket::getError());
+  EXPECT_EQ(0u, expected_writes.size());
+  EXPECT_EQ(2, write_calls);
+
+  // Partial write.
+  count = 0;
+  write_calls = 0;
+  errno = 0;
+  expected_writes.push_back(expected_write(10, "hello", 11, 5));
+  expected_writes.push_back(expected_write(10, 6, -1, EWOULDBLOCK));
+  EXPECT_TRUE(XmlRpcSocket::nbWrite(10, hello, &count));
+  EXPECT_EQ(count, 5);
+  EXPECT_EQ(EWOULDBLOCK, XmlRpcSocket::getError());
+  EXPECT_EQ(0u, expected_writes.size());
+  EXPECT_EQ(2, write_calls);
+}
+
+#define TEST_WRITE(RES, ERR)                                                   \
+  TEST_F(XmlRpcSocketTest, nbWrite_##ERR) {                                    \
+    fake_write = mock_write;                                                   \
+    int count = 0;                                                             \
+    std::string hello = "hello world";                                         \
+    errno = 0;                                                                 \
+    expected_writes.push_back(expected_write(10, 11, -1, ERR));                \
+    EXPECT_##RES(XmlRpcSocket::nbWrite(10, hello, &count));                    \
+    EXPECT_EQ(count, 0);                                                       \
+    EXPECT_EQ(ERR, XmlRpcSocket::getError());                                  \
+    EXPECT_EQ(0u, expected_writes.size());                                     \
+    EXPECT_EQ(1, write_calls);                                                 \
+    expected_writes.clear();                                                   \
+  }
+
+TEST_WRITE(TRUE, EAGAIN);
+TEST_WRITE(TRUE, EWOULDBLOCK);
+TEST_WRITE(TRUE, EINTR); // TODO(austin): this should retry immediately.
+TEST_WRITE(FALSE, EBADF);
+TEST_WRITE(FALSE, EDESTADDRREQ);
+TEST_WRITE(FALSE, EDQUOT);
+TEST_WRITE(FALSE, EFAULT);
+TEST_WRITE(FALSE, EFBIG);
+TEST_WRITE(FALSE, EINVAL);
+TEST_WRITE(FALSE, EIO);
+TEST_WRITE(FALSE, ENOSPC);
+TEST_WRITE(FALSE, EPIPE);
+TEST_WRITE(FALSE, EACCES);
+TEST_WRITE(FALSE, ECONNRESET);
+TEST_WRITE(FALSE, EISCONN);
+TEST_WRITE(FALSE, ENOBUFS);
+TEST_WRITE(FALSE, ENOMEM);
+TEST_WRITE(FALSE, ENOTCONN);
+
+int setsockopt_ret = 0;
+int setsockopt_errno = 0;
+int setsockopt_sockfd = 0;
+int test_setsockopt(
+    int sockfd, int level, int optname, const void* optval, socklen_t optlen) {
+  setsockopt_calls++;
+  setsockopt_sockfd = sockfd;
+
+  // These arguments are all fixed, so just test for them here.
+  EXPECT_EQ(SOL_SOCKET, level);
+  EXPECT_EQ(SO_REUSEADDR, optname);
+  EXPECT_EQ(sizeof(int), optlen);
+  if (sizeof(int) == optlen) {
+    EXPECT_EQ(1, *(int*)optval);
+  }
+
+  errno = setsockopt_errno;
+  return setsockopt_ret;
+}
+
+TEST_F(XmlRpcSocketTest, setReuseAddr) {
+  fake_setsockopt = test_setsockopt;
+
+  errno = 0;
+  setsockopt_sockfd = 0;
+  setsockopt_calls = 0;
+
+  setsockopt_errno = 0;
+  setsockopt_ret = 0;
+  EXPECT_TRUE(XmlRpcSocket::setReuseAddr(11));
+  EXPECT_EQ(0, XmlRpcSocket::getError());
+  EXPECT_EQ(11, setsockopt_sockfd);
+  EXPECT_EQ(1, setsockopt_calls);
+
+  FOR_ERRNO(i, errnos, EBADF, EFAULT, EINVAL, ENOPROTOOPT, ENOTSOCK) {
+    errno = 0;
+    setsockopt_sockfd = 0;
+    setsockopt_calls = 0;
+
+    setsockopt_errno = errnos[i];
+    setsockopt_ret = -1;
+    EXPECT_FALSE(XmlRpcSocket::setReuseAddr(11));
+    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
+    EXPECT_EQ(11, setsockopt_sockfd);
+    EXPECT_EQ(1, setsockopt_calls);
+  }
+}
+
+bool operator==(const in6_addr a, const in6_addr b) {
+  // Delegate to IPv6 address comparison macro.
+  return IN6_ARE_ADDR_EQUAL(&a, &b);
+}
+
+int bind_ret = 0;
+int bind_errno = 0;
+int bind_sockfd = 0;
+int bind_family = 0;
+int bind_port = 0;
+int test_bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen) {
+  bind_calls++;
+  EXPECT_EQ(bind_sockfd, sockfd);
+
+  EXPECT_TRUE(NULL != addr);
+  if (NULL != addr) {
+    EXPECT_EQ(bind_family, addr->sa_family);
+    if (AF_INET == addr->sa_family) {
+      EXPECT_EQ(sizeof(struct sockaddr_in), addrlen);
+      struct sockaddr_in* in_addr = (struct sockaddr_in*)addr;
+      EXPECT_EQ(INADDR_ANY, ntohl(in_addr->sin_addr.s_addr));
+      EXPECT_EQ(bind_port, ntohs(in_addr->sin_port));
+
+    } else if (AF_INET6 == addr->sa_family) {
+      EXPECT_EQ(sizeof(struct sockaddr_in6), addrlen);
+      struct sockaddr_in6* in6_addr = (struct sockaddr_in6*)addr;
+      EXPECT_EQ(in6addr_any, in6_addr->sin6_addr);
+      EXPECT_EQ(bind_port, ntohs(in6_addr->sin6_port));
+    } else {
+      ADD_FAILURE() << "Unrecognized sockaddr family";
+    }
+  }
+
+  errno = bind_errno;
+  return bind_ret;
+}
+
+TEST_F(XmlRpcSocketTest, bind) {
+  fake_bind = test_bind;
+
+  // Nominal case: bind returns success.
+  bind_sockfd = 12;
+  bind_family = AF_INET;
+  bind_port = 22;
+
+  bind_calls = 0;
+  bind_errno = 0;
+  bind_ret = 0;
+  EXPECT_TRUE(XmlRpcSocket::bind(12, 22));
+  EXPECT_EQ(1, bind_calls);
+  EXPECT_EQ(0, XmlRpcSocket::getError());
+
+  // Errors that the man page indicates can happen for all sockets; this does
+  // not include the errors that are specific to UNIX domain sockets.
+  FOR_ERRNO(i, errnos, EACCES, EADDRINUSE, EBADF, EINVAL, ENOTSOCK) {
+    bind_calls = 0;
+
+    bind_family = AF_INET;
+    bind_port = 22;
+
+    bind_errno = errnos[i];
+    bind_ret = -1;
+    EXPECT_FALSE(XmlRpcSocket::bind(12, 22));
+    EXPECT_EQ(1, bind_calls);
+    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
+  }
+
+  // Basic test for IPv6 functionality.
+  XmlRpcSocket::s_use_ipv6_ = true;
+
+  bind_calls = 0;
+
+  bind_family = AF_INET6;
+  bind_port = 22;
+
+  bind_errno = 0;
+  bind_ret = 0;
+  EXPECT_TRUE(XmlRpcSocket::bind(12, 22));
+  EXPECT_EQ(1, bind_calls);
+  EXPECT_EQ(0, XmlRpcSocket::getError());
+}
+
+int getsockname_ret = 0;
+int getsockname_errno = 0;
+int getsockname_sockfd = 0;
+void* getsockname_addr = 0;
+socklen_t getsockname_len = 0;
+int test_getsockname(int sockfd, struct sockaddr* addr, socklen_t* addrlen) {
+  getsockname_calls++;
+
+  EXPECT_EQ(getsockname_sockfd, sockfd);
+
+  EXPECT_TRUE(NULL != addr);
+  EXPECT_LE(getsockname_len, *addrlen);
+  if (NULL != addr) {
+    socklen_t len = std::min(*addrlen, getsockname_len);
+    if (len > 0)
+      memcpy(addr, getsockname_addr, len);
+  }
+  EXPECT_TRUE(NULL != addrlen);
+  if (NULL != addrlen) {
+    *addrlen = getsockname_len;
+  }
+
+  errno = getsockname_errno;
+  return getsockname_ret;
+}
+
+TEST_F(XmlRpcSocketTest, get_port) {
+  fake_getsockname = test_getsockname;
+
+  struct sockaddr_in inet_addr;
+  inet_addr.sin_family = AF_INET;
+  inet_addr.sin_port = htons(123);
+
+  struct sockaddr_in6 inet6_addr;
+  inet6_addr.sin6_family = AF_INET6;
+  inet6_addr.sin6_port = htons(4224);
+
+  getsockname_sockfd = 14;
+
+  getsockname_errno = 0;
+  getsockname_ret = 0;
+
+  getsockname_calls = 0;
+  getsockname_addr = &inet_addr;
+  getsockname_len = sizeof(struct sockaddr_in);
+  EXPECT_EQ(123, XmlRpcSocket::get_port(14));
+  EXPECT_EQ(0, XmlRpcSocket::getError());
+  EXPECT_EQ(1, getsockname_calls);
+
+  getsockname_calls = 0;
+  getsockname_addr = &inet6_addr;
+  getsockname_len = sizeof(struct sockaddr_in6);
+  EXPECT_EQ(4224, XmlRpcSocket::get_port(14));
+  EXPECT_EQ(0, XmlRpcSocket::getError());
+  EXPECT_EQ(1, getsockname_calls);
+
+  getsockname_ret = -1;
+  FOR_ERRNO(i, errnos, EBADF, EFAULT, EINVAL, ENOBUFS, ENOTSOCK) {
+    getsockname_errno = errnos[i];
+
+    // Errors, no data written to buffer.
+    getsockname_calls = 0;
+    getsockname_addr = NULL;
+    getsockname_len = 0;
+    EXPECT_EQ(0, XmlRpcSocket::get_port(14));
+    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
+    EXPECT_EQ(1, getsockname_calls);
+
+    // Same errors, but this time put valid data and expect that it is ignored.
+    getsockname_calls = 0;
+    getsockname_addr = &inet_addr;
+    getsockname_len = sizeof(struct sockaddr_in);
+    EXPECT_EQ(0, XmlRpcSocket::get_port(14));
+    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
+    EXPECT_EQ(1, getsockname_calls);
+  }
+}
+
+int listen_ret = 0;
+int listen_errno = 0;
+int listen_sockfd = 0;
+int listen_backlog = 0;
+int test_listen(int sockfd, int backlog) {
+  EXPECT_EQ(listen_sockfd, sockfd);
+  EXPECT_EQ(listen_backlog, backlog);
+
+  errno = listen_errno;
+  return listen_ret;
+}
+
+TEST_F(XmlRpcSocketTest, listen) {
+  fake_listen = test_listen;
+
+  listen_sockfd = 13;
+  listen_backlog = 10;
+
+  listen_ret = 0;
+  listen_errno = 0;
+  EXPECT_TRUE(XmlRpcSocket::listen(13, 10));
+  EXPECT_EQ(0, XmlRpcSocket::getError());
+
+  FOR_ERRNO(i, errnos, EADDRINUSE, EBADF, ENOTSOCK, EOPNOTSUPP) {
+    listen_ret = -1;
+    listen_errno = errnos[i];
+    EXPECT_FALSE(XmlRpcSocket::listen(13, 10));
+    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
+  }
+}
+
+int accept_ret = 0;
+int accept_errno = 0;
+int accept_sockfd = 0;
+void* accept_addr = 0;
+socklen_t accept_addrlen = 0;
+int test_accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen) {
+  accept_calls++;
+  EXPECT_EQ(accept_sockfd, sockfd);
+
+  if (accept_addr) {
+    EXPECT_TRUE(NULL != addr);
+    EXPECT_TRUE(NULL != addrlen);
+    if (NULL != addr && NULL != addrlen) {
+      socklen_t len = std::min(accept_addrlen, *addrlen);
+      memcpy(addr, accept_addr, len);
+      *addrlen = accept_addrlen;
+    }
+  } else {
+    EXPECT_EQ(NULL, addr);
+    EXPECT_EQ(NULL, addrlen);
+  }
+
+  errno = accept_errno;
+  return accept_ret;
+}
+
+TEST_F(XmlRpcSocketTest, accept) {
+  fake_accept = test_accept;
+
+  // Set up address. XmlRpcSocket::accept expects this, even if it isn't used.
+  struct sockaddr_in addr;
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons(45);
+  addr.sin_addr.s_addr = 0xDEADBEEF;
+
+  accept_addr = &addr;
+  accept_addrlen = sizeof(struct sockaddr);
+
+  accept_sockfd = 15;
+
+  accept_calls = 0;
+  accept_ret = 16;
+  accept_errno = 0;
+  EXPECT_EQ(16, XmlRpcSocket::accept(15));
+  EXPECT_EQ(0, XmlRpcSocket::getError());
+  EXPECT_EQ(1, accept_calls);
+
+  FOR_ERRNO(i,
+            errnos,
+            EAGAIN,
+            EWOULDBLOCK,
+            EBADF,
+            ECONNABORTED,
+            EFAULT,
+            EINTR, // TODO(austin): Should this retry immediately?
+            EINVAL,
+            EMFILE,
+            ENFILE,
+            ENOBUFS,
+            ENOMEM,
+            ENOTSOCK,
+            EOPNOTSUPP,
+            EPROTO,
+            EPERM) {
+    accept_calls = 0;
+    accept_ret = -1;
+    accept_errno = errnos[i];
+    EXPECT_EQ(-1, XmlRpcSocket::accept(15));
+    EXPECT_EQ(errnos[i], XmlRpcSocket::getError());
+    EXPECT_EQ(1, accept_calls);
+  }
+}
+
+// To test connect() we need mocks for getaddrinfo(), freeaddrinfo(), connect()
+// and XmlRpc logging hooks to validate that the correct error messages are
+// logged.
+
+int getaddrinfo_ret = 0;
+int getaddrinfo_errno = 0;
+const char* getaddrinfo_node = 0;
+const char* getaddrinfo_service = 0;
+struct addrinfo getaddrinfo_hints = {.ai_flags = 0,
+                                     .ai_family = 0,
+                                     .ai_socktype = 0,
+                                     .ai_protocol = 0,
+                                     .ai_addrlen = 0,
+                                     .ai_addr = 0,
+                                     .ai_canonname = 0,
+                                     .ai_next = 0};
+struct addrinfo* getaddrinfo_res = 0;
+int test_getaddrinfo(const char* node,
+                     const char* service,
+                     const struct addrinfo* hints,
+                     struct addrinfo** res) {
+  getaddrinfo_calls++;
+
+  EXPECT_STREQ(getaddrinfo_node, node);
+  EXPECT_STREQ(getaddrinfo_service, service);
+
+  EXPECT_TRUE(NULL != hints);
+  if (NULL != hints) {
+    EXPECT_TRUE(memcmp(hints, &getaddrinfo_hints, sizeof(struct addrinfo)) ==
+                0);
+  }
+
+  EXPECT_TRUE(NULL != res);
+  if (NULL != res) {
+    *res = getaddrinfo_res;
+  }
+
+  errno = getaddrinfo_errno;
+  return getaddrinfo_ret;
+}
+
+struct addrinfo* freeaddrinfo_res = 0;
+void test_freeaddrinfo(struct addrinfo* res) {
+  // The man page does not indicate any errors that freeaddrinfo may encounter.
+  freeaddrinfo_calls++;
+
+  EXPECT_EQ(freeaddrinfo_res, res);
+
+  return;
+}
+
+void EXPECT_SOCKADDR_EQ(const sockaddr* addr1, const sockaddr* addr2) {
+  EXPECT_EQ((NULL == addr1), (NULL == addr2));
+  if (NULL != addr1 && NULL != addr2) {
+    EXPECT_EQ(addr1->sa_family, addr2->sa_family);
+    if (addr1->sa_family == addr2->sa_family) {
+      switch (addr1->sa_family) {
+      case AF_INET: {
+        const sockaddr_in* addr1_in = (const sockaddr_in*)addr1;
+        const sockaddr_in* addr2_in = (const sockaddr_in*)addr2;
+        EXPECT_EQ(addr1_in->sin_port, addr2_in->sin_port);
+        EXPECT_EQ(addr1_in->sin_addr.s_addr, addr2_in->sin_addr.s_addr);
+      } break;
+      case AF_INET6: {
+        const sockaddr_in6* addr1_in6 = (const sockaddr_in6*)addr1;
+        const sockaddr_in6* addr2_in6 = (const sockaddr_in6*)addr2;
+        EXPECT_EQ(addr1_in6->sin6_port, addr2_in6->sin6_port);
+        EXPECT_EQ(addr1_in6->sin6_flowinfo, addr2_in6->sin6_flowinfo);
+        EXPECT_EQ(addr1_in6->sin6_scope_id, addr2_in6->sin6_scope_id);
+        EXPECT_TRUE(
+            IN6_ARE_ADDR_EQUAL(&addr1_in6->sin6_addr, &addr2_in6->sin6_addr));
+        for (int i = 0; i < 16; i++) {
+          EXPECT_EQ(addr1_in6->sin6_addr.s6_addr[i],
+                    addr2_in6->sin6_addr.s6_addr[i])
+              << "IPv6 address mismstach at byte " << i;
+        }
+      } break;
+      default:
+        ADD_FAILURE() << "Unrecognized address type; cannot compare";
+      }
+    }
+  }
+}
+
+int connect_ret = 0;
+int connect_errno = 0;
+int connect_sockfd = 0;
+const struct sockaddr* connect_addr = 0;
+socklen_t connect_addrlen = 0;
+int test_connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen) {
+  connect_calls++;
+
+  EXPECT_EQ(connect_sockfd, sockfd);
+
+  EXPECT_TRUE(NULL != addr);
+  EXPECT_EQ(connect_addrlen, addrlen);
+  EXPECT_SOCKADDR_EQ(connect_addr, addr);
+
+  errno = connect_errno;
+  return connect_ret;
+}
+
+class XmlRpcConnectTest : public XmlRpcSocketTest,
+                          XmlRpc::XmlRpcLogHandler,
+                          XmlRpc::XmlRpcErrorHandler {
+public:
+  virtual void log(int level, const char* msg) {
+    last_level = level;
+    last_msg = msg;
+    std::cout << "LOG(" << level << "):" << msg;
+  }
+
+  virtual void error(const char* msg) {
+    last_error = msg;
+    std::cout << "ERROR: " << msg;
+  }
+
+  int last_level;
+  std::string last_msg;
+  std::string last_error;
+
+  void EXPECT_LOG(int level, const std::string& msg) {
+    EXPECT_EQ(level, last_level);
+    EXPECT_EQ(msg, last_msg);
+  }
+
+  void EXPECT_ERROR(const std::string& msg) {
+    EXPECT_EQ(msg, last_error);
+  }
+
+protected:
+  void SetUp() {
+    XmlRpcSocketTest::SetUp();
+
+    // Install mock functions.
+    fake_getaddrinfo = test_getaddrinfo;
+    fake_freeaddrinfo = test_freeaddrinfo;
+    fake_connect = test_connect;
+
+    XmlRpc::XmlRpcLogHandler::setLogHandler(this);
+    XmlRpc::XmlRpcErrorHandler::setErrorHandler(this);
+
+    // Set up address data structures for testing use.
+    addr_ip4_22.sin_family = AF_INET;
+    addr_ip4_22.sin_port = htons(22);
+    addr_ip4_22.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+
+    addr_ip4_404.sin_family = AF_INET;
+    addr_ip4_404.sin_port = htons(404);
+    addr_ip4_404.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+
+    addr_ip6_44.sin6_family = AF_INET6;
+    addr_ip6_44.sin6_port = htons(44);
+    addr_ip6_44.sin6_flowinfo = 0;
+    addr_ip6_44.sin6_addr = in6addr_loopback;
+    addr_ip6_44.sin6_scope_id = 0;
+
+    addr_ip6_404.sin6_family = AF_INET6;
+    addr_ip6_404.sin6_port = htons(404);
+    addr_ip6_404.sin6_flowinfo = 0;
+    addr_ip6_404.sin6_addr = in6addr_loopback;
+    addr_ip6_404.sin6_scope_id = 0;
+
+    info_ip4.ai_flags = 0;
+    info_ip4.ai_family = AF_INET;
+    info_ip4.ai_socktype = SOCK_STREAM;
+    info_ip4.ai_protocol = 0;
+    info_ip4.ai_addrlen = sizeof(struct sockaddr_in);
+    info_ip4.ai_addr = (struct sockaddr*)&addr_ip4_22;
+    info_ip4.ai_canonname = 0;
+    info_ip4.ai_next = 0;
+
+    info_ip6.ai_flags = 0;
+    info_ip6.ai_family = AF_INET6;
+    info_ip6.ai_socktype = SOCK_STREAM;
+    info_ip6.ai_protocol = 0;
+    info_ip6.ai_addrlen = sizeof(struct sockaddr_in6);
+    info_ip6.ai_addr = (struct sockaddr*)&addr_ip6_44;
+    info_ip6.ai_canonname = 0;
+    info_ip6.ai_next = 0;
+
+    info_canon.ai_flags = 0;
+    info_canon.ai_family = 0;
+    info_canon.ai_socktype = 0;
+    info_canon.ai_protocol = 0;
+    info_canon.ai_addrlen = 0;
+    info_canon.ai_addr = 0;
+    info_canon.ai_canonname = 0;
+    info_canon.ai_next = 0;
+
+    // Set up expected hints.
+    getaddrinfo_hints.ai_family = AF_UNSPEC;
+    // TODO(austin): hints should probably specify SOCK_STREAM
+    // getaddrinfo_hints.ai_socktype = SOCK_STREAM;
+
+    getaddrinfo_node = "nowhere.com";
+    getaddrinfo_service = 0;
+
+    connect_sockfd = 19;
+  }
+
+  void TestConnect() {
+    // Always free the same getaddrinfo that we started with.
+    freeaddrinfo_res = getaddrinfo_res;
+
+    // Clear last log message.
+    last_level = 0;
+    last_msg = "";
+    last_error = "";
+
+    // Actually start running tests.
+    getaddrinfo_calls = 0;
+    freeaddrinfo_calls = 0;
+    connect_calls = 0;
+    EXPECT_TRUE(XmlRpcSocket::connect(19, "nowhere.com", 404));
+    EXPECT_EQ(1, getaddrinfo_calls);
+    EXPECT_EQ(1, freeaddrinfo_calls);
+    EXPECT_EQ(1, connect_calls);
+  }
+
+  void TestLookupFail() {
+    // Always free the same getaddrinfo that we started with.
+    freeaddrinfo_res = getaddrinfo_res;
+
+    // Clear last log message.
+    last_level = 0;
+    last_msg = "";
+    last_error = "";
+
+    // Actually start running tests.
+    getaddrinfo_calls = 0;
+    freeaddrinfo_calls = 0;
+    connect_calls = 0;
+    EXPECT_FALSE(XmlRpcSocket::connect(19, "nowhere.com", 404));
+    EXPECT_EQ(1, getaddrinfo_calls);
+    EXPECT_EQ(0, freeaddrinfo_calls);
+    EXPECT_EQ(0, connect_calls);
+  }
+
+  void TestConnectFail() {
+    // Always free the same getaddrinfo that we started with.
+    freeaddrinfo_res = getaddrinfo_res;
+
+    // Clear last log message.
+    last_level = 0;
+    last_msg = "";
+    last_error = "";
+
+    // Actually start running tests.
+    getaddrinfo_calls = 0;
+    freeaddrinfo_calls = 0;
+    connect_calls = 0;
+    EXPECT_FALSE(XmlRpcSocket::connect(19, "nowhere.com", 404));
+    EXPECT_EQ(1, getaddrinfo_calls);
+    EXPECT_EQ(1, freeaddrinfo_calls);
+    EXPECT_EQ(1, connect_calls);
+  }
+
+  void TearDown() {
+    XmlRpcLogHandler::setLogHandler(NULL);
+    XmlRpcErrorHandler::setErrorHandler(NULL);
+
+    XmlRpcSocketTest::TearDown();
+  }
+
+  struct sockaddr_in addr_ip4_22;
+  struct sockaddr_in addr_ip4_404;
+  struct sockaddr_in6 addr_ip6_44;
+  struct sockaddr_in6 addr_ip6_404;
+  struct addrinfo info_ip4;
+  struct addrinfo info_ip6;
+  struct addrinfo info_canon;
+};
+
+TEST_F(XmlRpcConnectTest, connect_ipv4) {
+  // Expected results from getaddrinfo.
+  getaddrinfo_ret = 0;
+  getaddrinfo_errno = 0;
+
+  // Expected results from connect.
+  connect_ret = 0;
+  connect_errno = 0;
+  connect_addr = (struct sockaddr*)&addr_ip4_404;
+  connect_addrlen = sizeof(struct sockaddr_in);
+
+  // Canonical address first, then IPv4, IPv6.
+  getaddrinfo_res = &info_canon;
+  info_canon.ai_next = &info_ip4;
+  info_ip4.ai_next = &info_ip6;
+  info_ip6.ai_next = 0;
+  TestConnect();
+
+  // List with IPv6 first.
+  getaddrinfo_res = &info_canon;
+  info_canon.ai_next = &info_ip6;
+  info_ip6.ai_next = &info_ip4;
+  info_ip4.ai_next = 0;
+  TestConnect();
+
+  // List without canon address, IPv6 first.
+  getaddrinfo_res = &info_ip6;
+  info_ip6.ai_next = &info_ip4;
+  info_ip4.ai_next = 0;
+  TestConnect();
+
+  // List without canon address, IPv4 first.
+  getaddrinfo_res = &info_ip4;
+  info_ip4.ai_next = &info_ip6;
+  info_ip6.ai_next = 0;
+  TestConnect();
+}
+
+TEST_F(XmlRpcConnectTest, connect_ipv6) {
+  // Basic IPv6 tests.
+  XmlRpcSocket::s_use_ipv6_ = true;
+
+  // Expected results from getaddrinfo.
+  getaddrinfo_ret = 0;
+  getaddrinfo_errno = 0;
+
+  // Expected results from connect.
+  connect_ret = 0;
+  connect_errno = 0;
+  connect_addr = (struct sockaddr*)&addr_ip6_404;
+  connect_addrlen = sizeof(struct sockaddr_in6);
+
+  // List without canon address, IPv4 first.
+  getaddrinfo_res = &info_ip4;
+  info_ip4.ai_next = &info_ip6;
+  info_ip6.ai_next = 0;
+  TestConnect();
+
+  // List without canon address, IPv6 first.
+  getaddrinfo_res = &info_ip6;
+  info_ip6.ai_next = &info_ip4;
+  info_ip4.ai_next = 0;
+  TestConnect();
+}
+
+// Simulate error returns from getaddrinfo. Check that the error is logged
+// correctly, that connect is not called, that the result is freed(or not)
+// and that connect correctly returns an error.
+TEST_F(XmlRpcConnectTest, connect_lookup_fail) {
+  // Expected results from connect.
+  connect_ret = 0;
+  connect_errno = 0;
+  connect_addr = (struct sockaddr*)&addr_ip4_404;
+  connect_addrlen = sizeof(struct sockaddr_in);
+
+  // List without canon address, IPv4 first.
+  getaddrinfo_res = &info_ip4;
+  info_ip4.ai_next = &info_ip6;
+  info_ip6.ai_next = 0;
+
+  // Enumerate possible return codes from getaddrinfo and make sure that
+  // connect() fails and that the correct error message is reported.
+  FOR_ERRNO(i,
+            addr_errs,
+            EAI_ADDRFAMILY,
+            EAI_AGAIN,
+            EAI_BADFLAGS,
+            EAI_FAIL,
+            EAI_FAMILY,
+            EAI_MEMORY,
+            EAI_NODATA,
+            EAI_NONAME,
+            EAI_SERVICE,
+            EAI_SOCKTYPE) {
+    // Results from getaddrinfo.
+    getaddrinfo_ret = addr_errs[i];
+    getaddrinfo_errno = 0;
+
+    TestLookupFail();
+    EXPECT_ERROR(
+        std::string("Couldn't find an AF_INET address for [nowhere.com]: ") +
+        std::string(gai_strerror(addr_errs[i])) + std::string("\n"));
+  }
+
+  // Enumerate system failures from getaddrinfo and make sure that connect()
+  // fails and that the correct error from perror is reported.
+  // TODO(austin): getaddrinfo should retry on EINTR but it doesn't.
+  getaddrinfo_ret = EAI_SYSTEM;
+  FOR_ERRNO(i, errnos, ENFILE, EMFILE, EAGAIN, EINTR) {
+    getaddrinfo_errno = errnos[i];
+    TestLookupFail();
+    EXPECT_ERROR(
+        std::string("Couldn't find an AF_INET address for [nowhere.com]: ") +
+        std::string(strerror(errnos[i])) + std::string("\n"));
+  }
+
+  // IPv4 lookup only returns IPv6 results.
+  getaddrinfo_res = &info_ip6;
+  info_ip6.ai_next = 0;
+
+  // Results from getaddrinfo.
+  getaddrinfo_ret = 0;
+  getaddrinfo_errno = 0;
+
+  // Always free the same getaddrinfo that we started with.
+  freeaddrinfo_res = getaddrinfo_res;
+
+  // Clear last log message.
+  last_level = 0;
+  last_msg = "";
+  last_error = "";
+
+  // Call connect and analyze results. We do this inline here instead of
+  // using one of the convenience functions because none of the convenience
+  // functions fit this pattern.
+  getaddrinfo_calls = 0;
+  freeaddrinfo_calls = 0;
+  connect_calls = 0;
+  EXPECT_FALSE(XmlRpcSocket::connect(19, "nowhere.com", 404));
+  EXPECT_EQ(1, getaddrinfo_calls);
+  EXPECT_EQ(1, freeaddrinfo_calls);
+  EXPECT_EQ(0, connect_calls);
+  EXPECT_ERROR(
+      std::string("Couldn't find an AF_INET address for [nowhere.com]") +
+      std::string("\n"));
+}
+
+// TODO(austin): this probably won't work, isn't supported upstream and isn't
+// required by our current use case. Future work.
+// Simulate multiple results for a hostname lookup. Simulate failure to
+// connect to the first hostname and verify that another attempt is made
+// for the second address.
+TEST_F(XmlRpcConnectTest, connect_multiple_result) {}
+
+// Simulate various error results from connect().
+TEST_F(XmlRpcConnectTest, connect_failure) {
+  // Expected results from getaddrinfo.
+  getaddrinfo_ret = 0;
+  getaddrinfo_errno = 0;
+
+  // Expected results from connect.
+  connect_ret = 0;
+  connect_errno = 0;
+  connect_addr = (struct sockaddr*)&addr_ip4_404;
+  connect_addrlen = sizeof(struct sockaddr_in);
+
+  // List without canon address, IPv4 first.
+  getaddrinfo_res = &info_ip4;
+  info_ip4.ai_next = &info_ip6;
+  info_ip6.ai_next = 0;
+
+  // EINPROGRESS indicates that the socket is non-blocking and the connection
+  // request has started but not finished, so we expect success.
+  connect_ret = -1;
+  connect_errno = EINPROGRESS;
+  TestConnect();
+  EXPECT_ERROR("");
+
+  // On Windows, EWOULDBLOCK (really WSAEWOULDBLOCK) indicates that the
+  // socket is non-blocking and could not be completed immediately (success)
+  // but on Linux it it synonymous with EAGAIN which indicates that there are
+  // no more available local ports.
+  //
+  // NOTE(austin): if this comparison fails, create separate tests for EAGAIN
+  //               and EWOULDBLOCK.
+  EXPECT_EQ(EWOULDBLOCK, EAGAIN);
+  connect_ret = -1;
+  connect_errno = EWOULDBLOCK;
+#if defined(_WINDOWS)
+  TestConnect();
+  EXPECT_ERROR("");
+#else
+  TestConnectFail();
+  EXPECT_ERROR(std::string("::connect error = ") +
+               std::string(strerror(EWOULDBLOCK)) + std::string("\n"));
+#endif
+
+  // All other errors that connect may return should be reported as an error.
+  // TODO(austin): Connect should immediately retry on EINTR but it doesn't.
+  FOR_ERRNO(i,
+            errnos,
+            EACCES,
+            EPERM,
+            EADDRINUSE,
+            EAFNOSUPPORT,
+            EALREADY,
+            EBADF,
+            ECONNREFUSED,
+            EFAULT,
+            EINTR,
+            EISCONN,
+            ENETUNREACH,
+            ENOTSOCK,
+            ETIMEDOUT) {
+    connect_ret = -1;
+    connect_errno = errnos[i];
+    TestConnectFail();
+    EXPECT_ERROR(std::string("::connect error = ") +
+                 std::string(strerror(errnos[i])) + std::string("\n"));
+  }
+}
+
+int main(int argc, char **argv)
+{
+  ::testing::InitGoogleTest(&argc, argv);
+  return RUN_ALL_TESTS();
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/test_system_mocks.c
@@ -0,0 +1,81 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ *
+ */
+
+// The auto-generated mocks here don't use their parameters, so we disable
+// that warning.
+#ifdef __GNUC__
+#pragma GCC diagnostic ignored "-Wunused-parameter"
+#endif
+
+#define MOCK_SYSCALL(ret, name, ARG_TYPES, ARG_NAMES)                          \
+  ret(*fake_##name) ARG_TYPES = 0;                                             \
+  ret __wrap_##name ARG_TYPES {                                                \
+    if (fake_##name) {                                                         \
+      return fake_##name ARG_NAMES;                                            \
+    } else {                                                                   \
+      return -1;                                                                \
+    }                                                                          \
+  }                                                                            \
+  int name##_calls = 0;                                                        \
+  ret count_##name ARG_TYPES {                                                 \
+    name##_calls++;                                                            \
+    return 0;                                                                  \
+  }
+
+#include "test_system_mocks.h"
+
+// custom mock for fcntl because it is varargs
+// the mocked version always takes the third argument
+int (*fake_fcntl)(int fd, int cmd, unsigned long) = 0;
+int __wrap_fcntl(int fd, int cmd, ...) {
+  va_list ap;
+  va_start(ap, cmd);
+  unsigned long arg = va_arg(ap, unsigned long);
+  va_end(ap);
+
+  if (fake_fcntl) {
+    return fake_fcntl(fd, cmd, arg);
+  } else {
+    return -1;
+  }
+}
+int fcntl_calls = 0;
+int count_fcntl(int fd, int cmd, unsigned long arg) {
+  fcntl_calls++;
+  return 0;
+}
+
+// Custom mock for freeaddrinfo because it returns void.
+void (*fake_freeaddrinfo)(struct addrinfo* res) = 0;
+void __wrap_freeaddrinfo(struct addrinfo* res) {
+  if (fake_freeaddrinfo) {
+    return fake_freeaddrinfo(res);
+  } else {
+    return;
+  }
+}
+int freeaddrinfo_calls = 0;
+void count_freeaddrinfo(struct addrinfo* res) {
+  freeaddrinfo_calls++;
+  return;
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/test_system_mocks.h
@@ -0,0 +1,110 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ *
+ */
+
+#pragma once
+
+#include <arpa/inet.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <netdb.h>
+#include <stdarg.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#ifndef MOCK_SYSCALL
+#define MOCK_SYSCALL(ret, name, ARG_TYPES, ARG_NAMES)                          \
+  extern ret(*fake_##name) ARG_TYPES;                                          \
+  extern int name##_calls;                                                     \
+  ret count_##name ARG_TYPES;
+#endif // MOCK_SYSCALL
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+MOCK_SYSCALL(int,
+             accept,
+             (int sockfd, struct sockaddr* addr, socklen_t* addrlen),
+             (sockfd, addr, addrlen));
+MOCK_SYSCALL(int,
+             bind,
+             (int sockfd, const struct sockaddr* addr, socklen_t addrlen),
+             (sockfd, addr, addrlen));
+MOCK_SYSCALL(int, close, (int socket), (socket));
+MOCK_SYSCALL(int,
+             connect,
+             (int sockfd, const struct sockaddr* addr, socklen_t addrlen),
+             (sockfd, addr, addrlen));
+MOCK_SYSCALL(int,
+             getaddrinfo,
+             (const char* node,
+              const char* service,
+              const struct addrinfo* hints,
+              struct addrinfo** res),
+             (node, service, hints, res));
+MOCK_SYSCALL(int,
+             getsockname,
+             (int sockfd, struct sockaddr* addr, socklen_t* addrlen),
+             (sockfd, addr, addrlen));
+MOCK_SYSCALL(int, listen, (int sockfd, int backlog), (sockfd, backlog));
+MOCK_SYSCALL(ssize_t,
+             read,
+             (int fd, void* buf, size_t count),
+             (fd, buf, count));
+MOCK_SYSCALL(
+    int,
+    setsockopt,
+    (int sockfd, int level, int optname, const void* optval, socklen_t optlen),
+    (sockfd, level, optname, optval, optlen));
+MOCK_SYSCALL(int,
+             select,
+             (int nfds,
+              fd_set* readfds,
+              fd_set* writefds,
+              fd_set* exceptfds,
+              struct timeval* timeout),
+             (nfds, readfds, writefds, exceptfds, timeout));
+MOCK_SYSCALL(int,
+             socket,
+             (int domain, int type, int protocol),
+             (domain, type, protocol));
+MOCK_SYSCALL(ssize_t,
+             write,
+             (int fd, const void* buf, size_t count),
+             (fd, buf, count));
+
+// custom mock for fcntl because it is varargs
+// the mocked version always takes the third argument
+extern int (*fake_fcntl)(int fd, int cmd, unsigned long);
+extern int fcntl_calls;
+int count_fcntl(int fd, int cmd, unsigned long arg);
+
+// Custom mock for freeaddrinfo because it returns void.
+extern void (*fake_freeaddrinfo)(struct addrinfo* res);
+extern int freeaddrinfo_calls;
+void count_freeaddrinfo(struct addrinfo* res);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/test_ulimit.cpp
@@ -0,0 +1,82 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ *
+ */
+
+#include "test_fixtures.h"
+
+#ifndef _WIN32
+# include <sys/resource.h>
+#endif
+
+using namespace XmlRpc;
+
+TEST_F(XmlRpcTest, Ulimit)
+{
+#ifndef _WIN32
+  XmlRpcClient c("localhost", port);
+  XmlRpcValue noArgs, result;
+
+  // Call the Hello method
+  ASSERT_TRUE(c.execute("Hello", noArgs, result));
+
+  EXPECT_FALSE(c.isFault());
+  XmlRpcValue hello("Hello");
+  EXPECT_EQ(result, hello);
+
+  c.close();
+  result.clear();
+
+  // Get the current open file limits and check that we have a reasonable
+  // margin. We need to reduce the limit to 8 open files to starve the server
+  // side, so we would need 9 or 10 open files for it to work correctly
+  // Ensuring that we have a hard limit of at least 64 file descriptors gives
+  // a very wide margin above that.
+  struct rlimit limit = {.rlim_cur = 0, .rlim_max = 0};
+  ASSERT_EQ(0, getrlimit(RLIMIT_NOFILE, &limit));
+  ASSERT_LT(64u, limit.rlim_max);
+  ASSERT_LT(64u, limit.rlim_cur);
+
+  // Reduce the number of open file descriptors so that we can create a client
+  // but can't accept the connection on the server side. 32 is more than the
+  // number of currently open files, but less than minimum unused file
+  // descriptors. We expect the server to be able to accept the connection and
+  // then immediately reject it without servicing it.
+  limit.rlim_cur = 32;
+  ASSERT_EQ(0, setrlimit(RLIMIT_NOFILE, &limit));
+
+  XmlRpcClient c2("127.0.0.1", port);
+  EXPECT_FALSE(c2.execute("Hello", noArgs, result));
+
+  // Raise the limit and verify that clients can connect again
+  limit.rlim_cur = limit.rlim_max;
+  ASSERT_EQ(0, setrlimit(RLIMIT_NOFILE, &limit));
+  c2.close();
+  EXPECT_TRUE(c2.execute("Hello", noArgs, result));
+  EXPECT_EQ(result, hello);
+#endif
+}
+
+int main(int argc, char **argv)
+{
+  ::testing::InitGoogleTest(&argc, argv);
+  return RUN_ALL_TESTS();
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/test_util.cpp
@@ -0,0 +1,128 @@
+/*
+ * Unit tests for XmlRpc++
+ *
+ * Copyright (C) 2017, Zoox Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Austin Hendrix <austin@zoox.com>
+ *
+ */
+
+#include "xmlrpcpp/XmlRpcUtil.h"
+
+#include <gtest/gtest.h>
+
+using namespace XmlRpc;
+
+class FakeLogHandler : public XmlRpcLogHandler {
+public:
+  FakeLogHandler() : last_level(-1), last_msg(""){};
+
+  virtual void log(int level, const char* msg) {
+    last_level = level;
+    last_msg = msg;
+  }
+
+  int last_level;
+  std::string last_msg;
+};
+
+TEST(XmlRpc, Log) {
+  FakeLogHandler fakelog;
+
+  // Check that setting log handler is reflected in getLogHandler().
+  XmlRpcLogHandler::setLogHandler(&fakelog);
+  ASSERT_EQ(&fakelog, XmlRpcLogHandler::getLogHandler());
+
+  // Check default verbosity.
+  ASSERT_EQ(0, XmlRpcLogHandler::getVerbosity());
+  EXPECT_EQ(0, XmlRpc::getVerbosity());
+
+  // Test all messages masked at default verbosity.
+  for (int i = 1; i < 6; i++) {
+    XmlRpcUtil::log(i, "Hello");
+    ASSERT_EQ(-1, fakelog.last_level);
+    ASSERT_EQ("", fakelog.last_msg);
+  }
+
+  // Test masking at levels below maximum verbosity.
+  for (int i = 1; i < 5; i++) {
+    XmlRpc::setVerbosity(i);
+
+    for (int j = 1; j <= i; j++) {
+      XmlRpcUtil::log(j, "Hello1");
+      EXPECT_EQ(j, fakelog.last_level);
+      EXPECT_EQ("Hello1", fakelog.last_msg);
+
+      fakelog.last_level = -1;
+      fakelog.last_msg = "";
+    }
+
+    XmlRpcUtil::log(i + 1, "Hello2");
+    ASSERT_EQ(-1, fakelog.last_level);
+    ASSERT_EQ("", fakelog.last_msg);
+  }
+
+  // Test no messages masked at max verbosity.
+  XmlRpc::setVerbosity(5);
+  for (int i = 1; i < 5; i++) {
+    XmlRpcUtil::log(i, "Hello3");
+    EXPECT_EQ(i, fakelog.last_level);
+    EXPECT_EQ("Hello3", fakelog.last_msg);
+
+    fakelog.last_level = -1;
+    fakelog.last_msg = "";
+  }
+
+  // Basic formatting test.
+  XmlRpcUtil::log(2, "Hello %d", 42);
+  EXPECT_EQ(2, fakelog.last_level);
+  EXPECT_EQ("Hello 42", fakelog.last_msg);
+}
+
+class FakeErrorHandler : public XmlRpcErrorHandler {
+public:
+  FakeErrorHandler() : last_msg(""){};
+
+  virtual void error(const char* msg) {
+    last_msg = msg;
+  }
+
+  std::string last_msg;
+};
+
+TEST(XmlRpc, error) {
+  FakeErrorHandler errors;
+
+  // Check that setErrorHandler is reflected in getErrorHandler.
+  XmlRpcErrorHandler::setErrorHandler(&errors);
+  EXPECT_EQ(&errors, XmlRpcErrorHandler::getErrorHandler());
+
+  // Basic error check.
+  XmlRpcUtil::error("Error!");
+  EXPECT_EQ("Error!", errors.last_msg);
+  errors.last_msg = "";
+
+  // Error check with formatting.
+  XmlRpcUtil::error("%d: I'm a teapot", 408);
+  EXPECT_EQ("408: I'm a teapot", errors.last_msg);
+}
+
+int main(int argc, char **argv)
+{
+  ::testing::InitGoogleTest(&argc, argv);
+  return RUN_ALL_TESTS();
+}
--- /dev/null
+++ ros-noetic-xmlrpcpp-1.16.0/test/xmlrpcvalue_base64.cpp
@@ -0,0 +1,150 @@
+#include <gtest/gtest.h>
+#include "xmlrpcpp/XmlRpcValue.h"
+
+#include <algorithm>
+#include <string>
+#include <sstream>
+
+int main(int argc, char **argv)
+{
+  ::testing::InitGoogleTest(&argc, argv);
+  return RUN_ALL_TESTS();
+}
+
+namespace XmlRpc
+{
+
+  XmlRpcValue base64Value(std::string const & data)
+  {
+    return XmlRpcValue(const_cast<char *>(&data[0]), data.size());
+  }
+
+  XmlRpcValue fromXml(std::string const & data)
+  {
+    int offset = 0;
+    return XmlRpcValue(data, &offset);
+  }
+
+  void removeNewlines(std::string & data)
+  {
+    data.erase(std::remove(data.begin(), data.end(), '\n'), data.end());
+  }
+
+  void assertEncodeDecode(std::string const & raw, std::string const & base64)
+  {
+    XmlRpcValue value  = base64Value(raw);
+    std::string xml    ="<value><base64>" + base64 + "</base64></value>";
+    XmlRpcValue parsed_value = fromXml(xml);
+    std::string generated_xml = value.toXml();
+    removeNewlines(generated_xml);
+
+    std::stringstream buffer;
+    value.write(buffer);
+    std::string streamed = buffer.str();
+    removeNewlines(streamed);
+    ASSERT_EQ(streamed, base64);
+
+    ASSERT_EQ(generated_xml, "<value><base64>" + base64 + "</base64></value>");
+    ASSERT_EQ(parsed_value, value);
+  }
+
+
+  TEST(xmlrpcvalue_base64, empty_string)
+  {
+    assertEncodeDecode("", "");
+  }
+
+  TEST(xmlrpcvalue_base64, hello_world)
+  {
+    assertEncodeDecode("Hello World!", "SGVsbG8gV29ybGQh");
+    assertEncodeDecode("Hello World!\n", "SGVsbG8gV29ybGQhCg==");
+  }
+
+  TEST(xmlrpcvalue_base64, random)
+  {
+    assertEncodeDecode(
+      std::string("\261", 1),
+      "sQ=="
+    );
+    assertEncodeDecode(
+      std::string("\341\370", 2),
+      "4fg="
+    );
+    assertEncodeDecode(
+      std::string("\206\262J", 3),
+      "hrJK"
+    );
+    assertEncodeDecode(
+      std::string("|5Q%", 4),
+      "fDVRJQ=="
+    );
+    assertEncodeDecode(
+      std::string("5\220,+X", 5),
+      "NZAsK1g="
+    );
+    assertEncodeDecode(
+      std::string("\247\342\007M@\270", 6),
+      "p+IHTUC4"
+    );
+    assertEncodeDecode(
+      std::string("\012\247e\013;\232*", 7),
+      "CqdlCzuaKg=="
+    );
+    assertEncodeDecode(
+      std::string("U\374\336w\351-\2503", 8),
+      "Vfzed+ktqDM="
+    );
+    assertEncodeDecode(
+      std::string("\264\204`\310\001\306\253g\026", 9),
+      "tIRgyAHGq2cW"
+    );
+    assertEncodeDecode(
+      std::string("\224\307\217\336|J^\223\237v", 10),
+      "lMeP3nxKXpOfdg=="
+    );
+    assertEncodeDecode(
+      std::string("~%\305\024\264P)\206\224\247N", 11),
+      "fiXFFLRQKYaUp04="
+    );
+    assertEncodeDecode(
+      std::string("-4\355\215Q|\367\332j\013\027\006", 12),
+      "LTTtjVF899pqCxcG"
+    );
+    assertEncodeDecode(
+      std::string("\026Q\304\204\244s%\203\023?\364\320\005", 13),
+      "FlHEhKRzJYMTP/TQBQ=="
+    );
+    assertEncodeDecode(
+      std::string("G0\306B\251\351;mwM\312i(\000", 14),
+      "RzDGQqnpO213TcppKAA="
+    );
+    assertEncodeDecode(
+      std::string("\031kpC)[t\205\026\230\343S\367\016\263", 15),
+      "GWtwQylbdIUWmONT9w6z"
+    );
+    assertEncodeDecode(
+      std::string("B&\134a\013\246u^V\001\260a\247\231}U\3278\367=G\317g\020{\277\042\373", 28),
+      "QiZcYQumdV5WAbBhp5l9Vdc49z1Hz2cQe78i+w=="
+    );
+    assertEncodeDecode(
+      std::string("[>\303\210`\270o\023FJ\004r\360\361\357\2517\345\204|\245\267P \247V\251v\025", 29),
+      "Wz7DiGC4bxNGSgRy8PHvqTflhHylt1Agp1apdhU="
+    );
+    assertEncodeDecode(
+      std::string("\264\245\360=\273E%8\023\3138\227k\222WS\227uf\314\345Y\031\365Q\024\331.\210&", 30),
+      "tKXwPbtFJTgTyziXa5JXU5d1ZszlWRn1URTZLogm"
+    );
+    assertEncodeDecode(
+      std::string("II\036\326\353\232T\221/\021\3265F}\2647A)O\2302CLY?\367O\261E\246\332\376\333\230\343\326_\373\303\225\343\351\354[\326~\264\034\305\035V\227\034\331[\012\263Y", 58),
+      "SUke1uuaVJEvEdY1Rn20N0EpT5gyQ0xZP/dPsUWm2v7bmOPWX/vDlePp7FvWfrQcxR1WlxzZWwqzWQ=="
+    );
+    assertEncodeDecode(
+      std::string("\353\317\000-\333\230\2701\251\310&J\225\347+\221q\245tb\336\225\350\323\310\327*q\261&;\2448\033X\346\277\245GM\216Oz\365\025K1\341w\230\277\272*\365\343\204\376\334E", 59),
+      "688ALduYuDGpyCZKlecrkXGldGLelejTyNcqcbEmO6Q4G1jmv6VHTY5PevUVSzHhd5i/uir144T+3EU="
+    );
+    assertEncodeDecode(
+      std::string("\235\232\352\362\304\351n\244\227\220\202hh\226\346\271\042\021d\362c\267\260\310`\000\034\247\215\350\013;#2\204(^_\333w\2233\374\337\205\253y\372\352\305F-\200v\034\331\216\205\011", 60),
+      "nZrq8sTpbqSXkIJoaJbmuSIRZPJjt7DIYAAcp43oCzsjMoQoXl/bd5Mz/N+Fq3n66sVGLX+AdhzZjoUJ"
+    );
+  }
+}
