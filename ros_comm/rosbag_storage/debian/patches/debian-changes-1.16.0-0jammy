Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ros-noetic-rosbag-storage (1.16.0-0jammy) jammy; urgency=high
Author: Michael Carroll <michael@openrobotics.org>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2024-08-18

--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/CHANGELOG.rst
@@ -0,0 +1,238 @@
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Changelog for package rosbag_storage
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+1.16.0 (2023-02-15)
+-------------------
+
+1.15.15 (2022-11-23)
+--------------------
+* Move @jacobperron from maintainer to author (`#2302 <https://github.com/ros/ros_comm/issues/2302>`_)
+* Add missing include (`#2248 <https://github.com/ros/ros_comm/issues/2248>`_)
+* Contributors: Jochen Sprickerhof, Shane Loretz
+
+1.15.14 (2022-01-06)
+--------------------
+
+1.15.13 (2021-09-22)
+--------------------
+
+1.15.12 (2021-09-21)
+--------------------
+
+1.15.11 (2021-04-06)
+--------------------
+
+1.15.10 (2021-03-18)
+--------------------
+
+1.15.9 (2020-10-16)
+-------------------
+* Update maintainers (`#2075 <https://github.com/ros/ros_comm/issues/2075>`_)
+* Fix compatibility issue with boost 1.73 and above (`#2023 <https://github.com/ros/ros_comm/issues/2023>`_)
+* Contributors: Sean Yen, Shane Loretz
+
+1.15.8 (2020-07-23)
+-------------------
+
+1.15.7 (2020-05-28)
+-------------------
+
+1.15.6 (2020-05-21)
+-------------------
+
+1.15.5 (2020-05-15)
+-------------------
+* fix brief description comments after members (`#1920 <https://github.com/ros/ros_comm/issues/1920>`_)
+
+1.15.4 (2020-03-19)
+-------------------
+* restrict boost dependencies to components used (`#1871 <https://github.com/ros/ros_comm/issues/1871>`_)
+
+1.15.3 (2020-02-28)
+-------------------
+
+1.15.2 (2020-02-25)
+-------------------
+
+1.15.1 (2020-02-24)
+-------------------
+
+1.15.0 (2020-02-21)
+-------------------
+
+1.14.4 (2020-02-20)
+-------------------
+* catch polymorphic exceptions by reference (`#1887 <https://github.com/ros/ros_comm/issues/1887>`_)
+* bump CMake minimum version to avoid CMP0048 warning (`#1869 <https://github.com/ros/ros_comm/issues/1869>`_)
+* use find_library for abs path of crypto and gpgme libraries (`#1867 <https://github.com/ros/ros_comm/issues/1867>`_)
+* remove unnecessary writing to map in write only mode (`#1798 <https://github.com/ros/ros_comm/issues/1798>`_)
+* check for fclose returning 0 (`#1750 <https://github.com/ros/ros_comm/issues/1750>`_)
+* fix windows build (`#1687 <https://github.com/ros/ros_comm/issues/1687>`_)
+* move bag encryption plugins into separate library (`#1499 <https://github.com/ros/ros_comm/issues/1499>`_)
+* modernization: replaced BOOST_FOREACH with range-based for loops, used algorithm, where appropriated (`#1640 <https://github.com/ros/ros_comm/issues/1640>`_)
+* fix dangeling if-else (`#1637 <https://github.com/ros/ros_comm/issues/1637>`_)
+* fix infinite loop in rosbag buffer resize (`#1623 <https://github.com/ros/ros_comm/issues/1623>`_)
+* update CMakeLists.txt in rosbag_storage (`#1618 <https://github.com/ros/ros_comm/issues/1618>`_)
+* fix various test problems (`#1601 <https://github.com/ros/ros_comm/issues/1601>`_)
+* visibility macros update (`#1591 <https://github.com/ros/ros_comm/issues/1591>`_)
+* fix issues when built or run on Windows (`#1466 <https://github.com/ros/ros_comm/issues/1466>`_)
+
+1.14.3 (2018-08-06)
+-------------------
+
+1.14.2 (2018-06-06)
+-------------------
+
+1.14.1 (2018-05-21)
+-------------------
+* add in -D_FILE_OFFSET_BITS=64 on machines less than 64-bits (`#1406 <https://github.com/ros/ros_comm/issues/1406>`_)
+
+1.14.0 (2018-05-21)
+-------------------
+* specialize BagCallbackT for MessageInstance (`#1374 <https://github.com/ros/ros_comm/issues/1374>`_)
+* fix compiler warning of test_aes_encryptor (`#1376 <https://github.com/ros/ros_comm/issues/1376>`_)
+* implement bag encryption/decryption (`#1206 <https://github.com/ros/ros_comm/issues/1206>`_)
+* use boost::shared_ptr to fix memory leak (`#1373 <https://github.com/ros/ros_comm/issues/1373>`_)
+
+1.13.6 (2018-02-05)
+-------------------
+* performance improvement for lower/upper bound (`#1223 <https://github.com/ros/ros_comm/issues/1223>`_)
+* use namespaced logging macros of console_bridge instead of deprecated macros (`#1239 <https://github.com/ros/ros_comm/issues/1239>`_)
+
+1.13.5 (2017-11-09)
+-------------------
+
+1.13.4 (2017-11-02)
+-------------------
+
+1.13.3 (2017-10-25)
+-------------------
+* fix corrupted messages when reopening a rosbag with a different file (`#1176 <https://github.com/ros/ros_comm/issues/1176>`_)
+* addd rosbag::Bag::isOpen (`#1190 <https://github.com/ros/ros_comm/issues/1190>`_)
+* enable rosbag::Bag move operations if compiler support is available (`#1189 <https://github.com/ros/ros_comm/issues/1189>`_)
+* check if bzfile\_ and lz4s\_ handle is valid before reading/writing/closing (`#1183 <https://github.com/ros/ros_comm/issues/1183>`_)
+* fix an out of bounds read in rosbag::View::iterator::increment() (`#1191 <https://github.com/ros/ros_comm/issues/1191>`_)
+* replace usage deprecated console_bridge macros (`#1149 <https://github.com/ros/ros_comm/issues/1149>`_)
+
+1.13.2 (2017-08-15)
+-------------------
+* fix whitespace warnings with g++ 7 (`#1138 <https://github.com/ros/ros_comm/issues/1138>`_)
+* remove deprecated dynamic exception specifications (`#1137 <https://github.com/ros/ros_comm/issues/1137>`_)
+
+1.13.1 (2017-07-27)
+-------------------
+* fix buffer overflow vulnerability (`#1092 <https://github.com/ros/ros_comm/issues/1092>`_)
+* fix rosbag::View::iterator copy assignment operator (`#1017 <https://github.com/ros/ros_comm/issues/1017>`_)
+* fix open mode on Windows (`#1005 <https://github.com/ros/ros_comm/pull/1005>`_)
+* add swap function instead of copy constructor / assignment operator for rosbag::Bag (`#1000 <https://github.com/ros/ros_comm/issues/1000>`_)
+
+1.13.0 (2017-02-22)
+-------------------
+
+1.12.7 (2017-02-17)
+-------------------
+
+1.12.6 (2016-10-26)
+-------------------
+
+1.12.5 (2016-09-30)
+-------------------
+
+1.12.4 (2016-09-19)
+-------------------
+
+1.12.3 (2016-09-17)
+-------------------
+* make Bag constructor explicit (`#835 <https://github.com/ros/ros_comm/pull/835>`_)
+
+1.12.2 (2016-06-03)
+-------------------
+
+1.12.1 (2016-04-18)
+-------------------
+* use directory specific compiler flags (`#785 <https://github.com/ros/ros_comm/pull/785>`_)
+
+1.12.0 (2016-03-18)
+-------------------
+
+1.11.18 (2016-03-17)
+--------------------
+* fix compiler warnings
+
+1.11.17 (2016-03-11)
+--------------------
+* use boost::make_shared instead of new for constructing boost::shared_ptr (`#740 <https://github.com/ros/ros_comm/issues/740>`_)
+
+1.11.16 (2015-11-09)
+--------------------
+
+1.11.15 (2015-10-13)
+--------------------
+
+1.11.14 (2015-09-19)
+--------------------
+
+1.11.13 (2015-04-28)
+--------------------
+
+1.11.12 (2015-04-27)
+--------------------
+
+1.11.11 (2015-04-16)
+--------------------
+* support large bagfiles (>2GB) on 32-bit systems (`#464 <https://github.com/ros/ros_comm/issues/464>`_)
+
+1.11.10 (2014-12-22)
+--------------------
+* fix various defects reported by coverity
+
+1.11.9 (2014-08-18)
+-------------------
+
+1.11.8 (2014-08-04)
+-------------------
+
+1.11.7 (2014-07-18)
+-------------------
+
+1.11.6 (2014-07-10)
+-------------------
+
+1.11.5 (2014-06-24)
+-------------------
+* convert to use console bridge from upstream debian package (`ros/rosdistro#4633 <https://github.com/ros/rosdistro/issues/4633>`_)
+
+1.11.4 (2014-06-16)
+-------------------
+
+1.11.3 (2014-05-21)
+-------------------
+
+1.11.2 (2014-05-08)
+-------------------
+
+1.11.1 (2014-05-07)
+-------------------
+* add lz4 compression to rosbag (Python and C++) (`#356 <https://github.com/ros/ros_comm/issues/356>`_)
+* move rosbag dox to rosbag_storage (`#389 <https://github.com/ros/ros_comm/issues/389>`_)
+
+1.11.0 (2014-03-04)
+-------------------
+
+1.10.0 (2014-02-11)
+-------------------
+* remove use of __connection header
+
+1.9.54 (2014-01-27)
+-------------------
+
+1.9.53 (2014-01-14)
+-------------------
+
+1.9.52 (2014-01-08)
+-------------------
+
+1.9.51 (2014-01-07)
+-------------------
+* move several client library independent parts from ros_comm into roscpp_core, split rosbag storage specific stuff from client library usage (`#299 <https://github.com/ros/ros_comm/issues/299>`_)
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/CMakeLists.txt
@@ -0,0 +1,100 @@
+cmake_minimum_required(VERSION 3.0.2)
+
+project(rosbag_storage)
+
+if(NOT WIN32)
+  set_directory_properties(PROPERTIES COMPILE_OPTIONS "-Wall;-Wextra")
+endif()
+
+find_package(console_bridge REQUIRED)
+find_package(catkin REQUIRED COMPONENTS cpp_common pluginlib roscpp_serialization roscpp_traits rostime roslz4 std_msgs)
+find_package(Boost REQUIRED COMPONENTS filesystem)
+find_package(BZip2 REQUIRED)
+
+catkin_package(
+  CFG_EXTRAS rosbag_storage-extras.cmake
+  INCLUDE_DIRS include
+  LIBRARIES rosbag_storage
+  CATKIN_DEPENDS pluginlib roslz4
+  DEPENDS console_bridge Boost
+)
+
+# Support large bags (>2GB) on 32-bit systems
+add_definitions(-D_FILE_OFFSET_BITS=64)
+
+include_directories(include ${catkin_INCLUDE_DIRS} ${console_bridge_INCLUDE_DIRS} ${Boost_INCLUDE_DIRS} ${BZIP2_INCLUDE_DIR})
+add_definitions(${BZIP2_DEFINITIONS})
+
+set(AES_ENCRYPT_SOURCE "")
+set(AES_ENCRYPT_LIBRARIES "")
+if(NOT WIN32)
+  set(AES_ENCRYPT_SOURCE "src/aes_encryptor.cpp" "src/gpgme_utils.cpp")
+  find_library(GPGME_LIBRARY
+    NAMES "gpgme"
+    PATHS /usr/local/lib)
+  find_library(CRYPTO_LIBRARY
+    NAMES "crypto"
+    PATHS /usr/local/lib)
+  set(AES_ENCRYPT_LIBRARIES ${GPGME_LIBRARY} ${CRYPTO_LIBRARY})
+endif()
+
+add_library(rosbag_storage
+  src/bag.cpp
+  src/bag_player.cpp
+  src/buffer.cpp
+  src/bz2_stream.cpp
+  src/lz4_stream.cpp
+  src/chunked_file.cpp
+  src/message_instance.cpp
+  src/query.cpp
+  src/stream.cpp
+  src/view.cpp
+  src/uncompressed_stream.cpp
+)
+target_link_libraries(rosbag_storage ${catkin_LIBRARIES} ${Boost_LIBRARIES} ${BZIP2_LIBRARIES} ${console_bridge_LIBRARIES} ${AES_ENCRYPT_LIBRARIES})
+if(WIN32)
+  # On Windows, default library runtime output set to CATKIN_GLOBAL_BIN_DESTINATION,
+  # change it back to CATKIN_PACKAGE_LIB_DESTINATION to match the library path described in plugin description file
+  set_target_properties(rosbag_storage PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CATKIN_DEVEL_PREFIX}/${CATKIN_PACKAGE_LIB_DESTINATION})
+endif()
+
+# Install library
+install(TARGETS rosbag_storage
+  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION}
+)
+
+add_library(rosbag_default_encryption_plugins
+  ${AES_ENCRYPT_SOURCE}
+  src/no_encryptor.cpp
+)
+
+target_link_libraries(rosbag_default_encryption_plugins rosbag_storage ${catkin_LIBRARIES} ${Boost_LIBRARIES} ${AES_ENCRYPT_LIBRARIES})
+
+install(TARGETS rosbag_default_encryption_plugins
+  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION}
+)
+
+install(DIRECTORY include/
+  DESTINATION ${CATKIN_GLOBAL_INCLUDE_DESTINATION}
+  FILES_MATCHING PATTERN "*.h"
+)
+
+install(FILES encryptor_plugins.xml
+  DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}
+)
+
+if(NOT WIN32)
+  if(CATKIN_ENABLE_TESTING)
+    find_package(rostest)
+
+    catkin_add_gtest(test_aes_encryptor test/test_aes_encryptor.cpp src/gpgme_utils.cpp
+      WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}/test)
+    if(TARGET test_aes_encryptor)
+      target_link_libraries(test_aes_encryptor rosbag_storage ${BZIP2_LIBRARIES}  ${AES_ENCRYPT_LIBRARIES} ${catkin_LIBRARIES} ${Boost_LIBRARIES})
+    endif()
+  endif()
+endif()
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/cmake/rosbag_storage-extras.cmake
@@ -0,0 +1,10 @@
+# PR https://github.com/ros/ros_comm/pull/1206 added support for encryption
+# and decryption of rosbags by utilizing libgpgme-dev.  On armhf, libgpgme-dev
+# is compiled with -D_FILE_OFF_BITS=64, which means that all downstream
+# consumers of it must also be compiled with that
+# (https://www.gnupg.org/documentation/manuals/gpgme/Largefile-Support-_0028LFS_0029.html
+# has some more information).  Add that flag to the CMAKE_CXX_FLAGS for all
+# architectures where the size of the pointer is less than 8 bytes.
+if(CMAKE_SIZEOF_VOID_P LESS 8)
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D_FILE_OFFSET_BITS=64")
+endif()
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/encryptor_plugins.xml
@@ -0,0 +1,8 @@
+<library path="lib/librosbag_default_encryption_plugins">
+  <class name="rosbag/NoEncryptor" type="rosbag::NoEncryptor" base_class_type="rosbag::EncryptorBase">
+    <description>This is a plugin for no encryption.</description>
+  </class>
+  <class name="rosbag/AesCbcEncryptor" type="rosbag::AesCbcEncryptor" base_class_type="rosbag::EncryptorBase">
+    <description>This is a plugin for AES-128 CBC encryption using a GPG key.</description>
+  </class>
+</library>
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/aes_encryptor.h
@@ -0,0 +1,80 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2017, Open Source Robotics Foundation
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#ifndef ROSBAG_AES_ENCRYPTION_H
+#define ROSBAG_AES_ENCRYPTION_H
+
+#include "rosbag/encryptor.h"
+
+#ifndef _WIN32
+  #include <openssl/aes.h>
+
+namespace rosbag {
+
+class AesCbcEncryptor : public EncryptorBase
+{
+public:
+    static const std::string GPG_USER_FIELD_NAME;
+    static const std::string ENCRYPTED_KEY_FIELD_NAME;
+
+public:
+    AesCbcEncryptor() { }
+    ~AesCbcEncryptor() { }
+
+    void initialize(Bag const& bag, std::string const& gpg_key_user);
+    uint32_t encryptChunk(const uint32_t chunk_size, const uint64_t chunk_data_pos, ChunkedFile& file);
+    void decryptChunk(ChunkHeader const& chunk_header, Buffer& decrypted_chunk, ChunkedFile& file) const;
+    void addFieldsToFileHeader(ros::M_string& header_fields) const;
+    void readFieldsFromFileHeader(ros::M_string const& header_fields);
+    void writeEncryptedHeader(boost::function<void(ros::M_string const&)>, ros::M_string const& header_fields, ChunkedFile&);
+    bool readEncryptedHeader(boost::function<bool(ros::Header&)>, ros::Header& header, Buffer& header_buffer, ChunkedFile&);
+
+private:
+    void buildSymmetricKey();
+
+private:
+    // User name of GPG key used for symmetric key encryption
+    std::string gpg_key_user_;
+    // Symmetric key for encryption/decryption
+    std::basic_string<unsigned char> symmetric_key_;
+    // Encrypted symmetric key
+    std::string encrypted_symmetric_key_;
+    // AES keys for encryption/decryption
+    AES_KEY aes_encrypt_key_;
+    AES_KEY aes_decrypt_key_;
+};
+}
+#endif
+
+#endif
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/bag.h
@@ -0,0 +1,680 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#ifndef ROSBAG_BAG_H
+#define ROSBAG_BAG_H
+
+#include "rosbag/macros.h"
+
+#include "rosbag/buffer.h"
+#include "rosbag/chunked_file.h"
+#include "rosbag/constants.h"
+#include "rosbag/encryptor.h"
+#include "rosbag/exceptions.h"
+#include "rosbag/structures.h"
+
+#include "ros/header.h"
+#include "ros/time.h"
+#include "ros/message_traits.h"
+#include "ros/message_event.h"
+#include "ros/serialization.h"
+
+//#include "ros/subscription_callback_helper.h"
+
+#include <ios>
+#include <map>
+#include <queue>
+#include <set>
+#include <stdexcept>
+
+#include <boost/config.hpp>
+#include <boost/format.hpp>
+#include <boost/iterator/iterator_facade.hpp>
+
+#include <pluginlib/class_loader.hpp>
+
+#include "console_bridge/console.h"
+#if defined logDebug
+# undef logDebug
+#endif
+#if defined logInform
+# undef logInform
+#endif
+#if defined logWarn
+# undef logWarn
+#endif
+#if defined logError
+# undef logError
+#endif
+
+namespace rosbag {
+
+namespace bagmode
+{
+    //! The possible modes to open a bag in
+    enum BagMode
+    {
+        Write   = 1,
+        Read    = 2,
+        Append  = 4
+    };
+}
+typedef bagmode::BagMode BagMode;
+
+class MessageInstance;
+class View;
+class Query;
+
+class ROSBAG_STORAGE_DECL Bag
+{
+    friend class MessageInstance;
+    friend class View;
+
+public:
+    Bag();
+
+    //! Open a bag file
+    /*!
+     * \param filename The bag file to open
+     * \param mode     The mode to use (either read, write or append)
+     *
+     * Can throw BagException
+     */
+    explicit Bag(std::string const& filename, uint32_t mode = bagmode::Read);
+
+    ~Bag();
+
+#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES
+    Bag(Bag&& other);
+
+    Bag& operator=(Bag&& other);
+#endif // BOOST_NO_CXX11_RVALUE_REFERENCES
+
+    //! Open a bag file.
+    /*!
+     * \param filename The bag file to open
+     * \param mode     The mode to use (either read, write or append)
+     *
+     * Can throw BagException
+     */
+    void open(std::string const& filename, uint32_t mode = bagmode::Read);
+
+    //! Close the bag file
+    void close();
+
+    std::string     getFileName()     const;                      //!< Get the filename of the bag
+    BagMode         getMode()         const;                      //!< Get the mode the bag is in
+    uint32_t        getMajorVersion() const;                      //!< Get the major-version of the open bag file
+    uint32_t        getMinorVersion() const;                      //!< Get the minor-version of the open bag file
+    uint64_t        getSize()         const;                      //!< Get the current size of the bag file (a lower bound)
+
+    void            setCompression(CompressionType compression);  //!< Set the compression method to use for writing chunks
+    CompressionType getCompression() const;                       //!< Get the compression method to use for writing chunks
+    void            setChunkThreshold(uint32_t chunk_threshold);  //!< Set the threshold for creating new chunks
+    uint32_t        getChunkThreshold() const;                    //!< Get the threshold for creating new chunks
+
+    //! Set encryptor of the bag file
+    /*!
+     * \param plugin_name The name of the encryptor plugin
+     * \param plugin_param The string parameter to be passed to the plugin initialization method
+     *
+     * Call this method to specify an encryptor for writing bag contents. This method need not be called when
+     * reading or appending a bag file: The encryptor is read from the bag file header.
+     */
+    void setEncryptorPlugin(const std::string& plugin_name, const std::string& plugin_param = std::string());
+
+    //! Write a message into the bag file
+    /*!
+     * \param topic The topic name
+     * \param event The message event to be added
+     *
+     * Can throw BagIOException
+     */
+    template<class T>
+    void write(std::string const& topic, ros::MessageEvent<T> const& event);
+
+    //! Write a message into the bag file
+    /*!
+     * \param topic The topic name
+     * \param time  Timestamp of the message
+     * \param msg   The message to be added
+     * \param connection_header  A connection header.
+     *
+     * Can throw BagIOException
+     */
+    template<class T>
+    void write(std::string const& topic, ros::Time const& time, T const& msg,
+               boost::shared_ptr<ros::M_string> connection_header = boost::shared_ptr<ros::M_string>());
+
+    //! Write a message into the bag file
+    /*!
+     * \param topic The topic name
+     * \param time  Timestamp of the message
+     * \param msg   The message to be added
+     * \param connection_header  A connection header.
+     *
+     * Can throw BagIOException
+     */
+    template<class T>
+    void write(std::string const& topic, ros::Time const& time, boost::shared_ptr<T const> const& msg,
+               boost::shared_ptr<ros::M_string> connection_header = boost::shared_ptr<ros::M_string>());
+
+    //! Write a message into the bag file
+    /*!
+     * \param topic The topic name
+     * \param time  Timestamp of the message
+     * \param msg   The message to be added
+     * \param connection_header  A connection header.
+     *
+     * Can throw BagIOException
+     */
+    template<class T>
+    void write(std::string const& topic, ros::Time const& time, boost::shared_ptr<T> const& msg,
+               boost::shared_ptr<ros::M_string> connection_header = boost::shared_ptr<ros::M_string>());
+
+    void swap(Bag&);
+
+    bool isOpen() const;
+
+private:
+    // disable copying
+    Bag(const Bag&);
+    Bag& operator=(const Bag&);
+
+    void init();
+
+    // This helper function actually does the write with an arbitrary serializable message
+    template<class T>
+    void doWrite(std::string const& topic, ros::Time const& time, T const& msg, boost::shared_ptr<ros::M_string> const& connection_header);
+
+    void openRead  (std::string const& filename);
+    void openWrite (std::string const& filename);
+    void openAppend(std::string const& filename);
+
+    void closeWrite();
+
+    template<class T>
+    boost::shared_ptr<T> instantiateBuffer(IndexEntry const& index_entry) const;  //!< deserializes the message held in record_buffer_
+
+    void startWriting();
+    void stopWriting();
+
+    void startReadingVersion102();
+    void startReadingVersion200();
+
+    // Writing
+    
+    void writeVersion();
+    void writeFileHeaderRecord();
+    void writeConnectionRecord(ConnectionInfo const* connection_info, const bool encrypt);
+    void appendConnectionRecordToBuffer(Buffer& buf, ConnectionInfo const* connection_info);
+    template<class T>
+    void writeMessageDataRecord(uint32_t conn_id, ros::Time const& time, T const& msg);
+    void writeIndexRecords();
+    void writeConnectionRecords();
+    void writeChunkInfoRecords();
+    void startWritingChunk(ros::Time time);
+    void writeChunkHeader(CompressionType compression, uint32_t compressed_size, uint32_t uncompressed_size);
+    void stopWritingChunk();
+
+    // Reading
+
+    void readVersion();
+    void readFileHeaderRecord();
+    void readConnectionRecord();
+    void readChunkHeader(ChunkHeader& chunk_header) const;
+    void readChunkInfoRecord();
+    void readConnectionIndexRecord200();
+
+    void readTopicIndexRecord102();
+    void readMessageDefinitionRecord102();
+    void readMessageDataRecord102(uint64_t offset, ros::Header& header) const;
+
+    ros::Header readMessageDataHeader(IndexEntry const& index_entry);
+    uint32_t    readMessageDataSize(IndexEntry const& index_entry) const;
+
+    template<typename Stream>
+    void readMessageDataIntoStream(IndexEntry const& index_entry, Stream& stream) const;
+
+    void     decompressChunk(uint64_t chunk_pos) const;
+    void     decompressRawChunk(ChunkHeader const& chunk_header) const;
+    void     decompressBz2Chunk(ChunkHeader const& chunk_header) const;
+    void     decompressLz4Chunk(ChunkHeader const& chunk_header) const;
+    uint32_t getChunkOffset() const;
+
+    // Record header I/O
+
+    void writeHeader(ros::M_string const& fields);
+    void writeDataLength(uint32_t data_len);
+    void appendHeaderToBuffer(Buffer& buf, ros::M_string const& fields);
+    void appendDataLengthToBuffer(Buffer& buf, uint32_t data_len);
+
+    void readHeaderFromBuffer(Buffer& buffer, uint32_t offset, ros::Header& header, uint32_t& data_size, uint32_t& bytes_read) const;
+    void readMessageDataHeaderFromBuffer(Buffer& buffer, uint32_t offset, ros::Header& header, uint32_t& data_size, uint32_t& bytes_read) const;
+    bool readHeader(ros::Header& header) const;
+    bool readDataLength(uint32_t& data_size) const;
+    bool isOp(ros::M_string& fields, uint8_t reqOp) const;
+
+    // Header fields
+
+    template<typename T>
+    std::string toHeaderString(T const* field) const;
+
+    std::string toHeaderString(ros::Time const* field) const;
+
+    template<typename T>
+    bool readField(ros::M_string const& fields, std::string const& field_name, bool required, T* data) const;
+
+    bool readField(ros::M_string const& fields, std::string const& field_name, unsigned int min_len, unsigned int max_len, bool required, std::string& data) const;
+    bool readField(ros::M_string const& fields, std::string const& field_name, bool required, std::string& data) const;
+
+    bool readField(ros::M_string const& fields, std::string const& field_name, bool required, ros::Time& data) const;
+
+    ros::M_string::const_iterator checkField(ros::M_string const& fields, std::string const& field,
+                                             unsigned int min_len, unsigned int max_len, bool required) const;
+
+    // Low-level I/O
+
+    void write(char const* s, std::streamsize n);
+    void write(std::string const& s);
+    void read(char* b, std::streamsize n) const;
+    void seek(uint64_t pos, int origin = std::ios_base::beg) const;
+
+private:
+    BagMode             mode_;
+    mutable ChunkedFile file_;
+    int                 version_;
+    CompressionType     compression_;
+    uint32_t            chunk_threshold_;
+    uint32_t            bag_revision_;
+
+    uint64_t file_size_;
+    uint64_t file_header_pos_;
+    uint64_t index_data_pos_;
+    uint32_t connection_count_;
+    uint32_t chunk_count_;
+    
+    // Current chunk
+    bool      chunk_open_;
+    ChunkInfo curr_chunk_info_;
+    uint64_t  curr_chunk_data_pos_;
+
+    std::map<std::string, uint32_t>                topic_connection_ids_;
+    std::map<ros::M_string, uint32_t>              header_connection_ids_;
+    std::map<uint32_t, ConnectionInfo*>            connections_;
+
+    std::vector<ChunkInfo>                         chunks_;
+
+    std::map<uint32_t, std::multiset<IndexEntry> > connection_indexes_;
+    std::map<uint32_t, std::multiset<IndexEntry> > curr_chunk_connection_indexes_;
+
+    mutable Buffer   header_buffer_;           //!< reusable buffer in which to assemble the record header before writing to file
+    mutable Buffer   record_buffer_;           //!< reusable buffer in which to assemble the record data before writing to file
+
+    mutable Buffer   chunk_buffer_;            //!< reusable buffer to read chunk into
+    mutable Buffer   decompress_buffer_;       //!< reusable buffer to decompress chunks into
+
+    mutable Buffer   outgoing_chunk_buffer_;   //!< reusable buffer to read chunk into
+
+    mutable Buffer*  current_buffer_;
+
+    mutable uint64_t decompressed_chunk_;      //!< position of decompressed chunk
+
+    // Encryptor plugin loader
+    pluginlib::ClassLoader<rosbag::EncryptorBase> encryptor_loader_;
+    // Active encryptor
+    boost::shared_ptr<rosbag::EncryptorBase> encryptor_;
+};
+
+} // namespace rosbag
+
+#include "rosbag/message_instance.h"
+
+namespace rosbag {
+
+// Templated method definitions
+
+template<class T>
+void Bag::write(std::string const& topic, ros::MessageEvent<T> const& event) {
+    doWrite(topic, event.getReceiptTime(), *event.getMessage(), event.getConnectionHeaderPtr());
+}
+
+template<class T>
+void Bag::write(std::string const& topic, ros::Time const& time, T const& msg, boost::shared_ptr<ros::M_string> connection_header) {
+    doWrite(topic, time, msg, connection_header);
+}
+
+template<class T>
+void Bag::write(std::string const& topic, ros::Time const& time, boost::shared_ptr<T const> const& msg, boost::shared_ptr<ros::M_string> connection_header) {
+    doWrite(topic, time, *msg, connection_header);
+}
+
+template<class T>
+void Bag::write(std::string const& topic, ros::Time const& time, boost::shared_ptr<T> const& msg, boost::shared_ptr<ros::M_string> connection_header) {
+    doWrite(topic, time, *msg, connection_header);
+}
+
+template<typename T>
+std::string Bag::toHeaderString(T const* field) const {
+    return std::string((char*) field, sizeof(T));
+}
+
+template<typename T>
+bool Bag::readField(ros::M_string const& fields, std::string const& field_name, bool required, T* data) const {
+    ros::M_string::const_iterator i = checkField(fields, field_name, sizeof(T), sizeof(T), required);
+    if (i == fields.end())
+    	return false;
+    memcpy(data, i->second.data(), sizeof(T));
+    return true;
+}
+
+template<typename Stream>
+void Bag::readMessageDataIntoStream(IndexEntry const& index_entry, Stream& stream) const {
+    ros::Header header;
+    uint32_t data_size;
+    uint32_t bytes_read;
+    switch (version_)
+    {
+    case 200:
+    {
+        decompressChunk(index_entry.chunk_pos);
+        readMessageDataHeaderFromBuffer(*current_buffer_, index_entry.offset, header, data_size, bytes_read);
+        if (data_size > 0)
+            memcpy(stream.advance(data_size), current_buffer_->getData() + index_entry.offset + bytes_read, data_size);
+        break;
+    }
+    case 102:
+    {
+        readMessageDataRecord102(index_entry.chunk_pos, header);
+        data_size = record_buffer_.getSize();
+        if (data_size > 0)
+            memcpy(stream.advance(data_size), record_buffer_.getData(), data_size);
+        break;
+    }
+    default:
+        throw BagFormatException((boost::format("Unhandled version: %1%") % version_).str());
+    }
+}
+
+template<class T>
+boost::shared_ptr<T> Bag::instantiateBuffer(IndexEntry const& index_entry) const {
+    switch (version_)
+    {
+    case 200:
+	{
+        decompressChunk(index_entry.chunk_pos);
+
+        // Read the message header
+        ros::Header header;
+        uint32_t data_size;
+        uint32_t bytes_read;
+        readMessageDataHeaderFromBuffer(*current_buffer_, index_entry.offset, header, data_size, bytes_read);
+
+        // Read the connection id from the header
+        uint32_t connection_id;
+        readField(*header.getValues(), CONNECTION_FIELD_NAME, true, &connection_id);
+
+        std::map<uint32_t, ConnectionInfo*>::const_iterator connection_iter = connections_.find(connection_id);
+        if (connection_iter == connections_.end())
+            throw BagFormatException((boost::format("Unknown connection ID: %1%") % connection_id).str());
+        ConnectionInfo* connection_info = connection_iter->second;
+
+        boost::shared_ptr<T> p = boost::make_shared<T>();
+
+        ros::serialization::PreDeserializeParams<T> predes_params;
+        predes_params.message = p;
+        predes_params.connection_header = connection_info->header;
+        ros::serialization::PreDeserialize<T>::notify(predes_params);
+
+        // Deserialize the message
+        ros::serialization::IStream s(current_buffer_->getData() + index_entry.offset + bytes_read, data_size);
+        ros::serialization::deserialize(s, *p);
+
+        return p;
+	}
+    case 102:
+	{
+        // Read the message record
+        ros::Header header;
+        readMessageDataRecord102(index_entry.chunk_pos, header);
+
+        ros::M_string& fields = *header.getValues();
+
+        // Read the connection id from the header
+        std::string topic, latching("0"), callerid;
+        readField(fields, TOPIC_FIELD_NAME,    true,  topic);
+        readField(fields, LATCHING_FIELD_NAME, false, latching);
+        readField(fields, CALLERID_FIELD_NAME, false, callerid);
+
+        std::map<std::string, uint32_t>::const_iterator topic_conn_id_iter = topic_connection_ids_.find(topic);
+        if (topic_conn_id_iter == topic_connection_ids_.end())
+            throw BagFormatException((boost::format("Unknown topic: %1%") % topic).str());
+        uint32_t connection_id = topic_conn_id_iter->second;
+
+        std::map<uint32_t, ConnectionInfo*>::const_iterator connection_iter = connections_.find(connection_id);
+        if (connection_iter == connections_.end())
+            throw BagFormatException((boost::format("Unknown connection ID: %1%") % connection_id).str());
+        ConnectionInfo* connection_info = connection_iter->second;
+
+        boost::shared_ptr<T> p = boost::make_shared<T>();
+
+        // Create a new connection header, updated with the latching and callerid values
+        boost::shared_ptr<ros::M_string> message_header(boost::make_shared<ros::M_string>());
+        for (ros::M_string::const_iterator i = connection_info->header->begin(); i != connection_info->header->end(); i++)
+            (*message_header)[i->first] = i->second;
+        (*message_header)["latching"] = latching;
+        (*message_header)["callerid"] = callerid;
+
+        ros::serialization::PreDeserializeParams<T> predes_params;
+        predes_params.message = p;
+        predes_params.connection_header = message_header;
+        ros::serialization::PreDeserialize<T>::notify(predes_params);
+
+        // Deserialize the message
+        ros::serialization::IStream s(record_buffer_.getData(), record_buffer_.getSize());
+        ros::serialization::deserialize(s, *p);
+
+        return p;
+	}
+    default:
+        throw BagFormatException((boost::format("Unhandled version: %1%") % version_).str());
+    }
+}
+
+template<class T>
+void Bag::doWrite(std::string const& topic, ros::Time const& time, T const& msg, boost::shared_ptr<ros::M_string> const& connection_header) {
+
+    if (time < ros::TIME_MIN)
+    {
+        throw BagException("Tried to insert a message with time less than ros::TIME_MIN");
+    }
+
+    // Whenever we write we increment our revision
+    bag_revision_++;
+
+    // Get ID for connection header
+    ConnectionInfo* connection_info = NULL;
+    uint32_t conn_id = 0;
+    if (!connection_header) {
+        // No connection header: we'll manufacture one, and store by topic
+
+        std::map<std::string, uint32_t>::iterator topic_connection_ids_iter = topic_connection_ids_.find(topic);
+        if (topic_connection_ids_iter == topic_connection_ids_.end()) {
+            conn_id = connections_.size();
+            topic_connection_ids_[topic] = conn_id;
+        }
+        else {
+            conn_id = topic_connection_ids_iter->second;
+            connection_info = connections_[conn_id];
+        }
+    }
+    else {
+        // Store the connection info by the address of the connection header
+
+        // Add the topic name to the connection header, so that when we later search by 
+        // connection header, we can disambiguate connections that differ only by topic name (i.e.,
+        // same callerid, same message type), #3755.  This modified connection header is only used
+        // for our bookkeeping, and will not appear in the resulting .bag.
+        ros::M_string connection_header_copy(*connection_header);
+        connection_header_copy["topic"] = topic;
+
+        std::map<ros::M_string, uint32_t>::iterator header_connection_ids_iter = header_connection_ids_.find(connection_header_copy);
+        if (header_connection_ids_iter == header_connection_ids_.end()) {
+            conn_id = connections_.size();
+            header_connection_ids_[connection_header_copy] = conn_id;
+        }
+        else {
+            conn_id = header_connection_ids_iter->second;
+            connection_info = connections_[conn_id];
+        }
+    }
+
+    {
+        // Seek to the end of the file (needed in case previous operation was a read)
+        seek(0, std::ios::end);
+        file_size_ = file_.getOffset();
+
+        // Write the chunk header if we're starting a new chunk
+        if (!chunk_open_)
+            startWritingChunk(time);
+
+        // Write connection info record, if necessary
+        if (connection_info == NULL) {
+            connection_info = new ConnectionInfo();
+            connection_info->id       = conn_id;
+            connection_info->topic    = topic;
+            connection_info->datatype = std::string(ros::message_traits::datatype(msg));
+            connection_info->md5sum   = std::string(ros::message_traits::md5sum(msg));
+            connection_info->msg_def  = std::string(ros::message_traits::definition(msg));
+            if (connection_header != NULL) {
+                connection_info->header = connection_header;
+            }
+            else {
+                connection_info->header = boost::make_shared<ros::M_string>();
+                (*connection_info->header)["type"]               = connection_info->datatype;
+                (*connection_info->header)["md5sum"]             = connection_info->md5sum;
+                (*connection_info->header)["message_definition"] = connection_info->msg_def;
+            }
+            connections_[conn_id] = connection_info;
+            // No need to encrypt connection records in chunks
+            writeConnectionRecord(connection_info, false);
+            appendConnectionRecordToBuffer(outgoing_chunk_buffer_, connection_info);
+        }
+
+        // Add to topic indexes
+        IndexEntry index_entry;
+        index_entry.time      = time;
+        index_entry.chunk_pos = curr_chunk_info_.pos;
+        index_entry.offset    = getChunkOffset();
+
+        std::multiset<IndexEntry>& chunk_connection_index = curr_chunk_connection_indexes_[connection_info->id];
+        chunk_connection_index.insert(chunk_connection_index.end(), index_entry);
+
+        if (mode_ != BagMode::Write) {
+          std::multiset<IndexEntry>& connection_index = connection_indexes_[connection_info->id];
+          connection_index.insert(connection_index.end(), index_entry);
+        }
+
+        // Increment the connection count
+        curr_chunk_info_.connection_counts[connection_info->id]++;
+
+        // Write the message data
+        writeMessageDataRecord(conn_id, time, msg);
+
+        // Check if we want to stop this chunk
+        uint32_t chunk_size = getChunkOffset();
+        CONSOLE_BRIDGE_logDebug("  curr_chunk_size=%d (threshold=%d)", chunk_size, chunk_threshold_);
+        if (chunk_size > chunk_threshold_) {
+            // Empty the outgoing chunk
+            stopWritingChunk();
+            outgoing_chunk_buffer_.setSize(0);
+
+            // We no longer have a valid curr_chunk_info
+            curr_chunk_info_.pos = -1;
+        }
+    }
+}
+
+template<class T>
+void Bag::writeMessageDataRecord(uint32_t conn_id, ros::Time const& time, T const& msg) {
+    ros::M_string header;
+    header[OP_FIELD_NAME]         = toHeaderString(&OP_MSG_DATA);
+    header[CONNECTION_FIELD_NAME] = toHeaderString(&conn_id);
+    header[TIME_FIELD_NAME]       = toHeaderString(&time);
+
+    // Assemble message in memory first, because we need to write its length
+    uint32_t msg_ser_len = ros::serialization::serializationLength(msg);
+
+    record_buffer_.setSize(msg_ser_len);
+    
+    ros::serialization::OStream s(record_buffer_.getData(), msg_ser_len);
+
+    // todo: serialize into the outgoing_chunk_buffer & remove record_buffer_
+    ros::serialization::serialize(s, msg);
+
+    // We do an extra seek here since writing our data record may
+    // have indirectly moved our file-pointer if it was a
+    // MessageInstance for our own bag
+    seek(0, std::ios::end);
+    file_size_ = file_.getOffset();
+
+    CONSOLE_BRIDGE_logDebug("Writing MSG_DATA [%llu:%d]: conn=%d sec=%d nsec=%d data_len=%d",
+              (unsigned long long) file_.getOffset(), getChunkOffset(), conn_id, time.sec, time.nsec, msg_ser_len);
+
+    writeHeader(header);
+    writeDataLength(msg_ser_len);
+    write((char*) record_buffer_.getData(), msg_ser_len);
+    
+    // todo: use better abstraction than appendHeaderToBuffer
+    appendHeaderToBuffer(outgoing_chunk_buffer_, header);
+    appendDataLengthToBuffer(outgoing_chunk_buffer_, msg_ser_len);
+
+    uint32_t offset = outgoing_chunk_buffer_.getSize();
+    outgoing_chunk_buffer_.setSize(outgoing_chunk_buffer_.getSize() + msg_ser_len);
+    memcpy(outgoing_chunk_buffer_.getData() + offset, record_buffer_.getData(), msg_ser_len);
+    
+    // Update the current chunk time range
+    if (time > curr_chunk_info_.end_time)
+    	curr_chunk_info_.end_time = time;
+    else if (time < curr_chunk_info_.start_time)
+        curr_chunk_info_.start_time = time;
+}
+
+inline void swap(Bag& a, Bag& b) {
+    a.swap(b);
+}
+
+} // namespace rosbag
+
+#endif
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/bag_player.h
@@ -0,0 +1,151 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2013, Open Source Robotics Foundation
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#ifndef ROSBAG_BAG_PLAYER_H
+#define ROSBAG_BAG_PLAYER_H
+
+#include "rosbag/bag.h"
+#include "rosbag/view.h"
+
+namespace rosbag
+{
+
+
+// A helper struct
+struct BagCallback
+{
+    virtual ~BagCallback() {};
+    virtual void call(MessageInstance m) = 0;
+};
+
+// A helper class for the callbacks
+template<class T>
+class BagCallbackT : public BagCallback
+{
+public:
+    typedef boost::function<void (const boost::shared_ptr<const T>&)> Callback;
+
+    BagCallbackT(Callback cb) :
+        cb_(cb)
+    {}
+
+    void call(MessageInstance m) {
+        cb_(m.instantiate<T>());
+    }
+
+private:
+    Callback cb_;
+};
+
+template<>
+class BagCallbackT<MessageInstance> : public BagCallback
+{
+public:
+    typedef boost::function<void (const MessageInstance&)> Callback;
+
+    BagCallbackT(Callback cb) :
+        cb_(cb)
+    {}
+
+    void call(MessageInstance m) {
+        cb_(m);
+    }
+
+private:
+    Callback cb_;
+};
+
+
+/* A class for playing back bag files at an API level. It supports
+   relatime, as well as accelerated and slowed playback. */
+class ROSBAG_STORAGE_DECL BagPlayer
+{
+public:
+  /* Constructor expecting the filename of a bag */
+  BagPlayer(const std::string &filename);
+
+  /* Register a callback for a specific topic and type */
+  template<class T>
+  void register_callback(const std::string &topic,
+                         typename BagCallbackT<T>::Callback f);
+
+  /* Unregister a callback for a topic already registered */
+  void unregister_callback(const std::string &topic);
+
+  /* Set the time in the bag to start.  
+   * Default is the first message */
+  void set_start(const ros::Time &start);
+
+  /* Set the time in the bag to stop. 
+   * Default is the last message */
+  void set_end(const ros::Time &end);
+
+  /* Set the speed to playback.  1.0 is the default. 
+   * 2.0 would be twice as fast, 0.5 is half realtime.  */
+  void set_playback_speed(double scale);
+
+  /* Start playback of the bag file using the parameters previously
+     set */
+  void start_play();
+  
+  /* Get the current time of the playback */
+  ros::Time get_time();
+
+  // Destructor
+  virtual ~BagPlayer();
+  
+
+  // The bag file interface loaded in the constructor. 
+  Bag bag;
+  
+private:
+    ros::Time real_time(const ros::Time &msg_time);
+
+    std::map<std::string, boost::shared_ptr<BagCallback> > cbs_;
+    ros::Time bag_start_;
+    ros::Time bag_end_;
+    ros::Time last_message_time_;
+    double playback_speed_;
+    ros::Time play_start_;
+};
+
+template<class T>
+void BagPlayer::register_callback(const std::string &topic,
+        typename BagCallbackT<T>::Callback cb) {
+    cbs_[topic] = boost::make_shared<BagCallbackT<T> >(cb);
+}
+
+}
+
+#endif
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/buffer.h
@@ -0,0 +1,73 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+********************************************************************/
+
+#ifndef ROSBAG_BUFFER_H
+#define ROSBAG_BUFFER_H
+
+#include <stdint.h>
+#include "macros.h"
+
+namespace rosbag {
+
+class ROSBAG_STORAGE_DECL Buffer
+{
+public:
+    Buffer();
+    ~Buffer();
+
+    uint8_t* getData();
+    uint32_t getCapacity() const;
+    uint32_t getSize()     const;
+
+    void setSize(uint32_t size);
+    void swap(Buffer& other);
+
+private:
+    Buffer(const Buffer&);
+    Buffer& operator=(const Buffer&);
+    void ensureCapacity(uint32_t capacity);
+
+private:
+    uint8_t* buffer_;
+    uint32_t capacity_;
+    uint32_t size_;
+};
+
+inline void swap(Buffer& a, Buffer& b) {
+    a.swap(b);
+}
+
+} // namespace rosbag
+
+#endif
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/chunked_file.h
@@ -0,0 +1,111 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+********************************************************************/
+
+#ifndef ROSBAG_CHUNKED_FILE_H
+#define ROSBAG_CHUNKED_FILE_H
+
+#include <ios>
+#include <stdint.h>
+#include <string>
+#include "macros.h"
+#include <boost/shared_ptr.hpp>
+
+#include <bzlib.h>
+
+#include "rosbag/stream.h"
+
+namespace rosbag {
+
+//! ChunkedFile reads and writes files which contain interleaved chunks of compressed and uncompressed data.
+class ROSBAG_STORAGE_DECL ChunkedFile
+{
+    friend class Stream;
+
+public:
+    ChunkedFile();
+    ~ChunkedFile();
+
+    void openWrite    (std::string const& filename);            //!< open file for writing
+    void openRead     (std::string const& filename);            //!< open file for reading
+    void openReadWrite(std::string const& filename);            //!< open file for reading & writing
+
+    void close();                                               //!< close the file
+
+    std::string getFileName()          const;                   //!< return path of currently open file
+    uint64_t    getOffset()            const;                   //!< return current offset from the beginning of the file
+    uint32_t    getCompressedBytesIn() const;                   //!< return the number of bytes written to current compressed stream
+    bool        isOpen()               const;                   //!< return true if file is open for reading or writing
+    bool        good()                 const;                   //!< return true if hasn't reached end-of-file and no error
+
+    void        setReadMode(CompressionType type);
+    void        setWriteMode(CompressionType type);
+
+    // File I/O
+    void        write(std::string const& s);
+    void        write(void* ptr, size_t size);                          //!< write size bytes from ptr to the file
+    void        read(void* ptr, size_t size);                           //!< read size bytes from the file into ptr
+    std::string getline();
+    bool        truncate(uint64_t length);
+    void        seek(uint64_t offset, int origin = std::ios_base::beg); //!< seek to given offset from origin
+    void        decompress(CompressionType compression, uint8_t* dest, unsigned int dest_len, uint8_t* source, unsigned int source_len);
+    void        swap(ChunkedFile& other);
+
+private:
+    ChunkedFile(const ChunkedFile&);
+    ChunkedFile& operator=(const ChunkedFile&);
+
+    void open(std::string const& filename, std::string const& mode);
+    void clearUnused();
+
+private:
+    std::string filename_;       //!< path to file
+    FILE*       file_;           //!< file pointer
+    uint64_t    offset_;         //!< current position in the file
+    uint64_t    compressed_in_;  //!< number of bytes written to current compressed stream
+    char*       unused_;         //!< extra data read by compressed stream
+    int         nUnused_;        //!< number of bytes of extra data read by compressed stream
+
+    boost::shared_ptr<StreamFactory> stream_factory_;
+
+    boost::shared_ptr<Stream> read_stream_;
+    boost::shared_ptr<Stream> write_stream_;
+};
+
+inline void swap(ChunkedFile& a, ChunkedFile& b) {
+    a.swap(b);
+}
+
+} // namespace rosbag
+
+#endif
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/constants.h
@@ -0,0 +1,102 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#ifndef ROSBAG_CONSTANTS_H
+#define ROSBAG_CONSTANTS_H
+
+#include <string>
+#include <stdint.h>
+
+namespace rosbag {
+
+// Bag file version to write
+static const std::string VERSION = "2.0";
+
+// Header field delimiter
+static const unsigned char FIELD_DELIM = '=';
+
+// Current header fields
+static const std::string OP_FIELD_NAME               = "op";
+static const std::string TOPIC_FIELD_NAME            = "topic";
+static const std::string VER_FIELD_NAME              = "ver";
+static const std::string COUNT_FIELD_NAME            = "count";
+static const std::string INDEX_POS_FIELD_NAME        = "index_pos";     // 1.2+
+static const std::string CONNECTION_COUNT_FIELD_NAME = "conn_count";    // 2.0+
+static const std::string CHUNK_COUNT_FIELD_NAME      = "chunk_count";   // 2.0+
+static const std::string CONNECTION_FIELD_NAME       = "conn";          // 2.0+
+static const std::string COMPRESSION_FIELD_NAME      = "compression";   // 2.0+
+static const std::string SIZE_FIELD_NAME             = "size";          // 2.0+
+static const std::string TIME_FIELD_NAME             = "time";          // 2.0+
+static const std::string START_TIME_FIELD_NAME       = "start_time";    // 2.0+
+static const std::string END_TIME_FIELD_NAME         = "end_time";      // 2.0+
+static const std::string CHUNK_POS_FIELD_NAME        = "chunk_pos";     // 2.0+
+static const std::string ENCRYPTOR_FIELD_NAME        = "encryptor";     // 2.0+
+
+// Legacy header fields
+static const std::string MD5_FIELD_NAME      = "md5";           // <2.0
+static const std::string TYPE_FIELD_NAME     = "type";          // <2.0
+static const std::string DEF_FIELD_NAME      = "def";           // <2.0
+static const std::string SEC_FIELD_NAME      = "sec";           // <2.0
+static const std::string NSEC_FIELD_NAME     = "nsec";          // <2.0
+static const std::string LATCHING_FIELD_NAME = "latching";      // <2.0
+static const std::string CALLERID_FIELD_NAME = "callerid";      // <2.0
+
+// Current "op" field values
+static const unsigned char OP_MSG_DATA    = 0x02;
+static const unsigned char OP_FILE_HEADER = 0x03;
+static const unsigned char OP_INDEX_DATA  = 0x04;
+static const unsigned char OP_CHUNK       = 0x05;
+static const unsigned char OP_CHUNK_INFO  = 0x06;
+static const unsigned char OP_CONNECTION  = 0x07;
+
+// Legacy "op" field values
+static const unsigned char OP_MSG_DEF     = 0x01;
+
+// Bytes reserved for file header record (4KB)
+static const uint32_t FILE_HEADER_LENGTH = 4 * 1024;
+
+// Index data record version to write
+static const uint32_t INDEX_VERSION = 1;
+
+// Chunk info record version to write
+static const uint32_t CHUNK_INFO_VERSION = 1;
+
+// Compression types
+static const std::string COMPRESSION_NONE = "none";
+static const std::string COMPRESSION_BZ2  = "bz2";
+static const std::string COMPRESSION_LZ4  = "lz4";
+
+} // namespace rosbag
+
+#endif
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/encryptor.h
@@ -0,0 +1,134 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2017, Open Source Robotics Foundation
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#ifndef ROSBAG_ENCRYPTION_H
+#define ROSBAG_ENCRYPTION_H
+
+#include "rosbag/buffer.h"
+#include "rosbag/chunked_file.h"
+#include "rosbag/structures.h"
+
+#include "ros/header.h"
+
+#include <stdint.h>
+#include <string>
+
+#include <boost/function.hpp>
+
+
+namespace rosbag {
+
+class Bag;
+
+class EncryptorBase
+{
+protected:
+    EncryptorBase() { }
+
+public:
+    virtual ~EncryptorBase() { }
+
+    //! Initialize encryptor
+    /*!
+     * \param bag The Bag instance
+     * \param plugin_param The string parameter used while initializing the encryptor
+     *
+     * This method is called by setEncryptorPlugin, which loads an encryptor plugin.
+     */
+    virtual void initialize(Bag const& bag, std::string const& plugin_param) = 0;
+
+    //! Encrypt chunk
+    /*!
+     * \return The byte size of the encrypted chunk
+     * \param chunk_size The byte size of the original chunk
+     * \param chunk_data_pos The start position of the chunk data in bag file stream
+     * \param file The bag file stream
+     *
+     * This method reads the original chunk from [chunk_data_pos, chunk_data_pos+chunk_size), encrypts it, and
+     * writes back to the file stream starting at chunk_data_pos.
+     */
+    virtual uint32_t encryptChunk(const uint32_t chunk_size, const uint64_t chunk_data_pos, ChunkedFile& file) = 0;
+
+    //! Decrypt chunk
+    /*!
+     * \param chunk_header The header of the encrypted chunk
+     * \param decrypted_chunk The buffer where decrypted chunk is written to
+     * \param file The bag file stream from which the encrypted chunk is read
+     *
+     * This method reads the encrypted chunk from file stream, decrypts, and writes it to decrypted_chunk.
+     */
+    virtual void decryptChunk(ChunkHeader const& chunk_header, Buffer& decrypted_chunk, ChunkedFile& file) const = 0;
+
+    //! Add encryptor information to bag file header
+    /*!
+     * \param header_fields The header fields of the bag
+     *
+     * Called for a bag being written, this method adds encryptor-specific fields to the bag file header. Those fields
+     * are used when decrypting the bag. ENCRYPTOR_FIELD_NAME must be specified in the header except for NoEncryptor.
+     */
+    virtual void addFieldsToFileHeader(ros::M_string& header_fields) const = 0;
+
+    //! Read encryptor information from bag file header
+    /*!
+     * \param header_fields The header fields of the bag
+     *
+     * Called for a bag being read, this method reads encryptor-specific fields from the bag file header.
+     */
+    virtual void readFieldsFromFileHeader(ros::M_string const& header_fields) = 0;
+
+    //! Write encrypted header to bag file
+    /*!
+     * \param write_header The functor writing unencrypted header
+     * \param header_fields The header fields to be written
+     * \param file The bag file stream
+     *
+     * This method encrypts given header fields, and writes them to the bag file.
+     */
+    virtual void writeEncryptedHeader(boost::function<void(ros::M_string const&)> write_header, ros::M_string const& header_fields, ChunkedFile& file) = 0;
+
+    //! Read encrypted header from bag file
+    /*!
+     * \param read_header The functor reading unencrypted header
+     * \param header The header object read
+     * \param header_buffer The header buffer read
+     * \param file The bag file stream
+     *
+     * This method reads and decrypts encrypted header to output header object (header) and buffer (header_buffer).
+     */
+    virtual bool readEncryptedHeader(boost::function<bool(ros::Header&)> read_header, ros::Header& header, Buffer& header_buffer, ChunkedFile& file) = 0;
+};
+
+}
+
+#endif
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/exceptions.h
@@ -0,0 +1,72 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#ifndef ROSBAG_EXCEPTIONS_H
+#define ROSBAG_EXCEPTIONS_H
+
+#include <ros/exception.h>
+
+namespace rosbag {
+
+//! Base class for rosbag exceptions
+class BagException : public ros::Exception
+{
+public:
+    BagException(std::string const& msg) : ros::Exception(msg) { }
+};
+
+//! Exception thrown when on IO problems
+class BagIOException : public BagException
+{
+public:
+    BagIOException(std::string const& msg) : BagException(msg) { }
+};
+
+//! Exception thrown on problems reading the bag format
+class BagFormatException : public BagException
+{
+public:
+    BagFormatException(std::string const& msg) : BagException(msg) { }
+};
+
+//! Exception thrown on problems reading the bag index
+class BagUnindexedException : public BagException
+{
+public:
+    BagUnindexedException() : BagException("Bag unindexed") { }
+};
+
+} // namespace rosbag
+
+#endif
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/gpgme_utils.h
@@ -0,0 +1,65 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2017, Open Source Robotics Foundation
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#ifndef ROSBAG_GPGME_UTILS_H
+#define ROSBAG_GPGME_UTILS_H
+
+#include "rosbag/encryptor.h"
+
+#ifndef _WIN32
+  #include <gpgme.h>
+
+namespace rosbag {
+
+//! Initialize GPGME library
+/*!
+ * This method initializes GPGME library, and set locale.
+ */
+void initGpgme();
+
+//! Get GPG key
+/*!
+ * \param ctx GPGME context
+ * \param user User name of the GPG key
+ * \param key GPG key found
+ *
+ * This method outputs a GPG key in the system keyring corresponding to the given user name.
+ * This method throws BagException if the key is not found or error occurred.
+ */
+void getGpgKey(gpgme_ctx_t& ctx, std::string const& user, gpgme_key_t& key);
+
+}
+#endif
+
+#endif
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/macros.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2008, Willow Garage, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the names of Stanford University or Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived from
+ *     this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef ROSBAG_MACROS_H_
+#define ROSBAG_MACROS_H_
+
+#include <ros/macros.h> // for the DECL's
+
+// Import/export for windows dll's and visibility for gcc shared libraries.
+
+#ifdef ROS_BUILD_SHARED_LIBS // ros is being built around shared libraries
+  #ifdef rosbag_EXPORTS // we are building a shared lib/dll
+    #define ROSBAG_DECL ROS_HELPER_EXPORT
+  #else // we are using shared lib/dll
+    #define ROSBAG_DECL ROS_HELPER_IMPORT
+  #endif
+
+  #ifdef rosbag_storage_EXPORTS // we are building a shared lib/dll
+    #define ROSBAG_STORAGE_DECL ROS_HELPER_EXPORT
+  #else // we are using shared lib/dll
+    #define ROSBAG_STORAGE_DECL ROS_HELPER_IMPORT
+  #endif
+
+#else // ros is being built around static libraries
+  #define ROSBAG_DECL
+  #define ROSBAG_STORAGE_DECL
+#endif
+
+#endif /* ROSBAG_MACROS_H_ */
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/message_instance.h
@@ -0,0 +1,175 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#ifndef ROSBAG_MESSAGE_INSTANCE_H
+#define ROSBAG_MESSAGE_INSTANCE_H
+
+#include <ros/message_traits.h>
+#include <ros/serialization.h>
+//#include <ros/ros.h>
+#include <ros/time.h>
+
+#include "rosbag/structures.h"
+#include "rosbag/macros.h"
+
+namespace rosbag {
+
+class Bag;
+
+//! A class pointing into a bag file
+/*!
+ *  The MessageInstance class itself is fairly light weight.  It
+ *  simply contains a pointer to a bag-file and the index_entry
+ *  necessary to get access to the corresponding data.
+ *
+ *  It adheres to the necessary ros::message_traits to be directly
+ *  serializable.
+ */
+class ROSBAG_STORAGE_DECL MessageInstance
+{
+    friend class View;
+  
+public:
+    ros::Time   const& getTime()              const;
+    std::string const& getTopic()             const;
+    std::string const& getDataType()          const;
+    std::string const& getMD5Sum()            const;
+    std::string const& getMessageDefinition() const;
+
+    boost::shared_ptr<ros::M_string> getConnectionHeader() const;
+
+    std::string getCallerId() const;
+    bool        isLatching()  const;
+
+    //! Test whether the underlying message of the specified type.
+    /*!
+     * returns true iff the message is of the template type
+     */
+    template<class T>
+    bool isType() const;
+
+    //! Templated call to instantiate a message
+    /*!
+     * returns NULL pointer if incompatible
+     */
+    template<class T>
+    boost::shared_ptr<T> instantiate() const;
+  
+    //! Write serialized message contents out to a stream
+    template<typename Stream>
+    void write(Stream& stream) const;
+
+    //! Size of serialized message
+    uint32_t size() const;
+
+private:
+    MessageInstance(ConnectionInfo const* connection_info, IndexEntry const& index, Bag const& bag);
+
+    ConnectionInfo const* connection_info_;
+    IndexEntry const      index_entry_;
+    Bag const*            bag_;
+};
+
+
+} // namespace rosbag
+
+namespace ros {
+namespace message_traits {
+
+template<>
+struct MD5Sum<rosbag::MessageInstance>
+{
+    static const char* value(const rosbag::MessageInstance& m) { return m.getMD5Sum().c_str(); }
+};
+
+template<>
+struct DataType<rosbag::MessageInstance>
+{
+    static const char* value(const rosbag::MessageInstance& m) { return m.getDataType().c_str(); }
+};
+
+template<>
+struct Definition<rosbag::MessageInstance>
+{
+    static const char* value(const rosbag::MessageInstance& m) { return m.getMessageDefinition().c_str(); }
+};
+
+} // namespace message_traits
+
+namespace serialization
+{
+
+template<>
+struct Serializer<rosbag::MessageInstance>
+{
+    template<typename Stream>
+    inline static void write(Stream& stream, const rosbag::MessageInstance& m) {
+        m.write(stream);
+    }
+
+    inline static uint32_t serializedLength(const rosbag::MessageInstance& m) {
+        return m.size();
+    }
+};
+
+} // namespace serialization
+
+} // namespace ros
+
+#include "rosbag/bag.h"
+
+namespace rosbag {
+
+template<class T>
+bool MessageInstance::isType() const {
+    char const* md5sum = ros::message_traits::MD5Sum<T>::value();
+    return md5sum == std::string("*") || md5sum == getMD5Sum();
+}
+
+template<class T>
+boost::shared_ptr<T> MessageInstance::instantiate() const {
+    if (!isType<T>())
+        return boost::shared_ptr<T>();
+
+    return bag_->instantiateBuffer<T>(index_entry_);
+}
+
+template<typename Stream>
+void MessageInstance::write(Stream& stream) const {
+    bag_->readMessageDataIntoStream(index_entry_, stream);
+}
+
+} // namespace rosbag
+
+#endif
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/no_encryptor.h
@@ -0,0 +1,59 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2017, Open Source Robotics Foundation
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#ifndef ROSBAG_NO_ENCRYPTION_H
+#define ROSBAG_NO_ENCRYPTION_H
+
+#include "rosbag/encryptor.h"
+
+
+namespace rosbag {
+
+class NoEncryptor : public EncryptorBase
+{
+public:
+    NoEncryptor() { }
+    ~NoEncryptor() { }
+
+    void initialize(Bag const&, std::string const&) { }
+    uint32_t encryptChunk(const uint32_t, const uint64_t, ChunkedFile&);
+    void decryptChunk(ChunkHeader const&, Buffer&, ChunkedFile&) const;
+    void addFieldsToFileHeader(ros::M_string&) const { }
+    void readFieldsFromFileHeader(ros::M_string const&) { }
+    void writeEncryptedHeader(boost::function<void(ros::M_string const&)>, ros::M_string const&, ChunkedFile&);
+    bool readEncryptedHeader(boost::function<bool(ros::Header&)>, ros::Header&, Buffer&, ChunkedFile&);
+};
+}
+
+#endif
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/query.h
@@ -0,0 +1,138 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#ifndef ROSBAG_QUERY_H
+#define ROSBAG_QUERY_H
+
+#include "ros/time.h"
+
+#include <vector>
+#include <map>
+#include <set>
+
+#include <boost/function.hpp>
+#include "rosbag/macros.h"
+#include "rosbag/structures.h"
+
+namespace rosbag {
+
+class Bag;
+
+class ROSBAG_STORAGE_DECL Query
+{
+public:
+    //! The base query takes an optional time-range
+    /*!
+     * param start_time the beginning of the time_range for the query
+     * param end_time   the end of the time_range for the query
+     */
+    Query(boost::function<bool(ConnectionInfo const*)>& query,
+    	  ros::Time const& start_time = ros::TIME_MIN,
+          ros::Time const& end_time   = ros::TIME_MAX);
+
+    boost::function<bool(ConnectionInfo const*)> const& getQuery() const;  //!< Get the query functor
+
+    ros::Time const& getStartTime() const; //!< Get the start-time
+    ros::Time const& getEndTime()   const; //!< Get the end-time
+
+private:
+    boost::function<bool(ConnectionInfo const*)> query_;
+    ros::Time start_time_;
+    ros::Time end_time_;
+};
+
+class ROSBAG_STORAGE_DECL TopicQuery
+{
+public:
+    TopicQuery(std::string const& topic);
+    TopicQuery(std::vector<std::string> const& topics);
+
+    bool operator()(ConnectionInfo const*) const;
+
+private:
+    std::vector<std::string> topics_;
+};
+
+class ROSBAG_STORAGE_DECL TypeQuery
+{
+public:
+    TypeQuery(std::string const& type);
+    TypeQuery(std::vector<std::string> const& types);
+
+    bool operator()(ConnectionInfo const*) const;
+
+private:
+    std::vector<std::string> types_;
+};
+
+//! Pairs of queries and the bags they come from (used internally by View)
+struct ROSBAG_STORAGE_DECL BagQuery
+{
+    BagQuery(Bag const* _bag, Query const& _query, uint32_t _bag_revision);
+
+    Bag const* bag;
+    Query      query;
+    uint32_t   bag_revision;
+};
+
+struct ROSBAG_STORAGE_DECL MessageRange
+{
+    MessageRange(std::multiset<IndexEntry>::const_iterator const& _begin,
+                 std::multiset<IndexEntry>::const_iterator const& _end,
+                 ConnectionInfo const* _connection_info,
+                 BagQuery const* _bag_query);
+
+    std::multiset<IndexEntry>::const_iterator begin;
+    std::multiset<IndexEntry>::const_iterator end;
+    ConnectionInfo const* connection_info;
+    BagQuery const* bag_query;           //!< pointer to vector of queries in View
+};
+
+//! The actual iterator data structure
+struct ROSBAG_STORAGE_DECL ViewIterHelper
+{
+    ViewIterHelper(std::multiset<IndexEntry>::const_iterator _iter, MessageRange const* _range);
+
+    std::multiset<IndexEntry>::const_iterator iter;
+    MessageRange const* range;  //!< pointer to vector of ranges in View
+};
+
+struct ROSBAG_STORAGE_DECL ViewIterHelperCompare
+{
+    bool operator()(ViewIterHelper const& a, ViewIterHelper const& b);
+};
+
+} // namespace rosbag
+
+#endif
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/stream.h
@@ -0,0 +1,200 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+********************************************************************/
+
+#ifndef ROSBAG_STREAM_H
+#define ROSBAG_STREAM_H
+
+#include <ios>
+#include <stdint.h>
+#include <string>
+
+#include <boost/shared_ptr.hpp>
+
+#include <bzlib.h>
+
+#include <roslz4/lz4s.h>
+
+#include "rosbag/exceptions.h"
+#include "rosbag/macros.h"
+
+namespace rosbag {
+
+namespace compression
+{
+    enum CompressionType
+    {
+        Uncompressed = 0,
+        BZ2          = 1,
+        LZ4          = 2,
+    };
+}
+typedef compression::CompressionType CompressionType;
+
+class ChunkedFile;
+
+class FileAccessor;
+
+class ROSBAG_STORAGE_DECL Stream
+{
+    friend class FileAccessor;
+public:
+    Stream(ChunkedFile* file);
+    virtual ~Stream();
+
+    virtual CompressionType getCompressionType() const = 0;
+
+    virtual void write(void* ptr, size_t size) = 0;
+    virtual void read (void* ptr, size_t size) = 0;
+
+    virtual void decompress(uint8_t* dest, unsigned int dest_len, uint8_t* source, unsigned int source_len) = 0;
+
+    virtual void startWrite();
+    virtual void stopWrite();
+
+    virtual void startRead();
+    virtual void stopRead();
+
+protected:
+    FILE*    getFilePointer();
+    uint64_t getCompressedIn();
+    void     setCompressedIn(uint64_t nbytes);
+    void     advanceOffset(uint64_t nbytes);
+    char*    getUnused();
+    int      getUnusedLength();
+    void     setUnused(char* unused);
+    void     setUnusedLength(int nUnused);
+    void     clearUnused();
+
+protected:
+    ChunkedFile* file_;
+};
+
+class ROSBAG_STORAGE_DECL StreamFactory
+{
+public:
+    StreamFactory(ChunkedFile* file);
+
+    boost::shared_ptr<Stream> getStream(CompressionType type) const;
+
+private:
+    boost::shared_ptr<Stream> uncompressed_stream_;
+    boost::shared_ptr<Stream> bz2_stream_;
+    boost::shared_ptr<Stream> lz4_stream_;
+};
+
+class FileAccessor {
+    friend class ChunkedFile;
+    static void setFile(Stream& a, ChunkedFile* file) {
+        a.file_ = file;
+    }
+};
+
+class ROSBAG_STORAGE_DECL UncompressedStream : public Stream
+{
+public:
+    UncompressedStream(ChunkedFile* file);
+
+    CompressionType getCompressionType() const;
+
+    void write(void* ptr, size_t size);
+    void read(void* ptr, size_t size);
+
+    void decompress(uint8_t* dest, unsigned int dest_len, uint8_t* source, unsigned int source_len);
+};
+
+/*!
+ * BZ2Stream uses libbzip2 (http://www.bzip.org) for reading/writing compressed data in the BZ2 format.
+ */
+class ROSBAG_STORAGE_DECL BZ2Stream : public Stream
+{
+public:
+    BZ2Stream(ChunkedFile* file);
+
+    CompressionType getCompressionType() const;
+
+    void startWrite();
+    void write(void* ptr, size_t size);
+    void stopWrite();
+
+    void startRead();
+    void read(void* ptr, size_t size);
+    void stopRead();
+
+    void decompress(uint8_t* dest, unsigned int dest_len, uint8_t* source, unsigned int source_len);
+
+private:
+    int     verbosity_;        //!< level of debugging output (0-4; 0 default). 0 is silent, 4 is max verbose debugging output
+    int     block_size_100k_;  //!< compression block size (1-9; 9 default). 9 is best compression, most memory
+    int     work_factor_;      //!< compression behavior for worst case, highly repetitive data (0-250; 30 default)
+
+    BZFILE* bzfile_;           //!< bzlib compressed file stream
+    int     bzerror_;          //!< last error from bzlib
+};
+
+// LZ4Stream reads/writes compressed datat in the LZ4 format
+// https://code.google.com/p/lz4/
+class ROSBAG_STORAGE_DECL LZ4Stream : public Stream
+{
+public:
+    LZ4Stream(ChunkedFile* file);
+    ~LZ4Stream();
+
+    CompressionType getCompressionType() const;
+
+    void startWrite();
+    void write(void* ptr, size_t size);
+    void stopWrite();
+
+    void startRead();
+    void read(void* ptr, size_t size);
+    void stopRead();
+
+    void decompress(uint8_t* dest, unsigned int dest_len, uint8_t* source, unsigned int source_len);
+
+private:
+    LZ4Stream(const LZ4Stream&);
+    LZ4Stream operator=(const LZ4Stream&);
+    void writeStream(int action);
+
+    char *buff_;
+    int buff_size_;
+    int block_size_id_;
+    roslz4_stream lz4s_;
+};
+
+
+
+} // namespace rosbag
+
+#endif
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/structures.h
@@ -0,0 +1,93 @@
+/*********************************************************************
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2008, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *********************************************************************/
+
+#ifndef ROSBAG_STRUCTURES_H
+#define ROSBAG_STRUCTURES_H
+
+#include <map>
+#include <vector>
+
+#include "ros/time.h"
+#include "ros/datatypes.h"
+#include "macros.h"
+
+namespace rosbag {
+
+struct ROSBAG_STORAGE_DECL ConnectionInfo
+{
+    ConnectionInfo() : id(-1) { }
+
+    uint32_t    id;
+    std::string topic;
+    std::string datatype;
+    std::string md5sum;
+    std::string msg_def;
+
+    boost::shared_ptr<ros::M_string> header;
+};
+
+struct ChunkInfo
+{
+    ros::Time   start_time;    //!< earliest timestamp of a message in the chunk
+    ros::Time   end_time;      //!< latest timestamp of a message in the chunk
+    uint64_t    pos;           //!< absolute byte offset of chunk record in bag file
+
+    std::map<uint32_t, uint32_t> connection_counts;   //!< number of messages in each connection stored in the chunk
+};
+
+struct ROSBAG_STORAGE_DECL ChunkHeader
+{
+    std::string compression;          //!< chunk compression type, e.g. "none" or "bz2" (see constants.h)
+    uint32_t    compressed_size;      //!< compressed size of the chunk in bytes
+    uint32_t    uncompressed_size;    //!< uncompressed size of the chunk in bytes
+};
+
+struct ROSBAG_STORAGE_DECL IndexEntry
+{
+    ros::Time time;            //!< timestamp of the message
+    uint64_t  chunk_pos;       //!< absolute byte offset of the chunk record containing the message
+    uint32_t  offset;          //!< relative byte offset of the message record (either definition or data) in the chunk
+
+    bool operator<(IndexEntry const& b) const { return time < b.time; }
+};
+
+struct ROSBAG_STORAGE_DECL IndexEntryCompare
+{
+    bool operator()(ros::Time const& a, IndexEntry const& b) const { return a < b.time; }
+    bool operator()(IndexEntry const& a, ros::Time const& b) const { return a.time < b; }
+};
+
+} // namespace rosbag
+
+#endif
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/include/rosbag/view.h
@@ -0,0 +1,179 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#ifndef ROSBAG_VIEW_H
+#define ROSBAG_VIEW_H
+
+#include <boost/function.hpp>
+#include <boost/iterator/iterator_facade.hpp>
+
+#include "rosbag/message_instance.h"
+#include "rosbag/query.h"
+#include "rosbag/macros.h"
+#include "rosbag/structures.h"
+
+namespace rosbag {
+
+class ROSBAG_STORAGE_DECL View
+{
+    friend class Bag;
+
+public:
+    //! An iterator that points to a MessageInstance from a bag
+    /*!
+     * This iterator stores the MessageInstance that it is returning a
+     * reference to.  If you increment the iterator that
+     * MessageInstance is destroyed.  You should never store the
+     * pointer to this reference.
+     */
+    class ROSBAG_STORAGE_DECL iterator : public boost::iterator_facade<iterator,
+                                                   MessageInstance,
+                                                   boost::forward_traversal_tag>
+    {
+    public:
+        iterator(iterator const& i);
+        iterator &operator=(iterator const& i);
+        iterator();
+        ~iterator();
+
+    protected:
+        iterator(View* view, bool end = false);
+
+    private:
+        friend class View;
+        friend class boost::iterator_core_access;
+
+		void populate();
+		void populateSeek(std::multiset<IndexEntry>::const_iterator iter);
+
+        bool equal(iterator const& other) const;
+
+        void increment();
+
+        MessageInstance& dereference() const;
+
+    private:
+        View* view_;
+        std::vector<ViewIterHelper> iters_;
+        uint32_t view_revision_;
+        mutable MessageInstance* message_instance_;
+    };
+
+    typedef iterator const_iterator;
+
+    struct TrueQuery {
+    	bool operator()(ConnectionInfo const*) const { return true; };
+    };
+
+    //! Create a view on a bag
+    /*!
+     * param reduce_overlap  If multiple views return the same messages, reduce them to a single message
+     */
+    View(bool const& reduce_overlap = false);
+
+    //! Create a view on a bag
+    /*!
+     * param bag             The bag file on which to run this query
+     * param start_time      The beginning of the time range for the query
+     * param end_time        The end of the time range for the query
+     * param reduce_overlap  If multiple views return the same messages, reduce them to a single message
+     */
+    View(Bag const& bag, ros::Time const& start_time = ros::TIME_MIN, ros::Time const& end_time = ros::TIME_MAX, bool const& reduce_overlap = false);
+
+    //! Create a view and add a query
+    /*!
+     * param bag             The bag file on which to run this query
+     * param query           The actual query to evaluate which connections to include
+     * param start_time      The beginning of the time range for the query
+     * param end_time        The end of the time range for the query
+     * param reduce_overlap  If multiple views return the same messages, reduce them to a single message
+     */
+    View(Bag const& bag, boost::function<bool(ConnectionInfo const*)> query,
+         ros::Time const& start_time = ros::TIME_MIN, ros::Time const& end_time = ros::TIME_MAX, bool const& reduce_overlap = false);
+
+    ~View();
+
+    iterator begin();
+    iterator end();
+    uint32_t size();
+
+    //! Add a query to a view
+    /*!
+     * param bag        The bag file on which to run this query
+     * param start_time The beginning of the time range for the query
+     * param end_time   The end of the time range for the query
+     */
+    void addQuery(Bag const& bag, ros::Time const& start_time = ros::TIME_MIN, ros::Time const& end_time = ros::TIME_MAX);
+
+    //! Add a query to a view
+    /*!
+     * param bag        The bag file on which to run this query
+     * param query      The actual query to evaluate which connections to include
+     * param start_time The beginning of the time range for the query
+     * param end_time   The end of the time range for the query
+     */
+    void addQuery(Bag const& bag, boost::function<bool(ConnectionInfo const*)> query,
+    		      ros::Time const& start_time = ros::TIME_MIN, ros::Time const& end_time = ros::TIME_MAX);
+
+    std::vector<const ConnectionInfo*> getConnections();
+
+    ros::Time getBeginTime();
+    ros::Time getEndTime();
+  
+protected:
+    friend class iterator;
+
+    void updateQueries(BagQuery* q);
+    void update();
+
+    MessageInstance* newMessageInstance(ConnectionInfo const* connection_info, IndexEntry const& index, Bag const& bag);
+
+private:
+    View(View const& view);
+    View& operator=(View const& view);
+
+protected:
+    std::vector<MessageRange*> ranges_;
+    std::vector<BagQuery*>     queries_;
+    uint32_t                   view_revision_;
+
+    uint32_t size_cache_;
+    uint32_t size_revision_;
+
+    bool reduce_overlap_;
+};
+
+} // namespace rosbag
+
+#endif
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/mainpage.dox
@@ -0,0 +1,66 @@
+/**
+\mainpage
+\htmlinclude manifest.html
+
+\b rosbag_storage is a set of tools and API's for recording/writing messages to bag files and playing/reading them back without relying on the ROS client library.
+
+The code is still in the rosbag namespace since it was extracted from the <a href="../../../rosbag/html/c++/">rosbag</a> package without renaming any API.
+
+\section codeapi Code API
+
+The C++ and Python API's are provided for serializing bag files.  The C++ API consists of the following classes:
+
+- rosbag::Bag - Serializes to/from a bag file on disk.
+- rosbag::View - Specifies a view into a bag file to allow for querying for messages on specific connections withn a time range.
+
+Here's a simple example of writing to a bag file:
+
+\verbatim
+#include "rosbag/bag.h"
+...
+rosbag::Bag bag("test.bag", rosbag::bagmode::Write);
+std_msgs::Int32 i;
+i.data = 42;
+bag.write("numbers", ros::Time::now(), i);
+bag.close();
+\endverbatim
+
+Likewise, to read from that bag file:
+
+\verbatim
+#include "rosbag/bag.h"
+...
+rosbag::Bag bag("test.bag");
+rosbag::View view(bag, rosbag::TopicQuery("numbers"));
+BOOST_FOREACH(rosbag::MessageInstance const m, view)
+{
+    std_msgs::Int32::ConstPtr i = m.instantiate<std_msgs::Int32>();
+    if (i != NULL)
+    	std::cout << i->data << std::endl;
+}
+bag.close();
+\endverbatim
+
+The Python API is similar.  Writing to a bag file:
+
+\verbatim
+import rosbag
+from std_msgs.msg import Int32, String
+bag = rosbag.Bag('test.bag', 'w')
+i = Int32()
+i.data = 42
+bag.write('numbers', i);
+bag.close();
+\endverbatim
+
+Example usage for read:
+
+\verbatim
+import rosbag
+bag = rosbag.Bag('test.bag')
+for topic, msg, t in bag.read_messages('numbers'):
+    print msg.data
+bag.close();
+\endverbatim
+
+*/
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/package.xml
@@ -0,0 +1,46 @@
+<package>
+  <name>rosbag_storage</name>
+  <version>1.16.0</version>
+  <description>
+    This is a set of tools for recording from and playing back ROS
+    message without relying on the ROS client library.
+  </description>
+  <maintainer email="michael@openrobotics.org">Michael Carroll</maintainer>
+  <maintainer email="sloretz@openrobotics.org">Shane Loretz</maintainer>
+  <license>BSD</license>
+  <author email="dthomas@osrfoundation.org">Dirk Thomas</author>
+  <author email="jacob@openrobotics.org">Jacob Perron</author>
+
+  <buildtool_depend>catkin</buildtool_depend>
+
+  <build_depend>bzip2</build_depend>
+  <build_depend version_gte="0.3.17">cpp_common</build_depend>
+  <build_depend>libboost-filesystem-dev</build_depend>
+  <build_depend>libconsole-bridge-dev</build_depend>
+  <build_depend>libgpgme-dev</build_depend>
+  <build_depend>libssl-dev</build_depend>
+  <build_depend>pluginlib</build_depend>
+  <build_depend>roscpp_serialization</build_depend>
+  <build_depend version_gte="0.3.17">roscpp_traits</build_depend>
+  <build_depend>rostest</build_depend>
+  <build_depend>rostime</build_depend>
+  <build_depend>roslz4</build_depend>
+  <build_depend>std_msgs</build_depend>
+
+  <run_depend>bzip2</run_depend>
+  <run_depend version_gte="0.3.17">cpp_common</run_depend>
+  <run_depend>libboost-filesystem-dev</run_depend>
+  <run_depend>libconsole-bridge-dev</run_depend>
+  <run_depend>libgpgme-dev</run_depend>
+  <run_depend>libssl-dev</run_depend>
+  <run_depend>pluginlib</run_depend>
+  <run_depend>roscpp_serialization</run_depend>
+  <run_depend version_gte="0.3.17">roscpp_traits</run_depend>
+  <run_depend>rostime</run_depend>
+  <run_depend>roslz4</run_depend>
+
+  <export>
+    <rosdoc config="${prefix}/rosdoc.yaml"/>
+    <rosbag_storage plugin="${prefix}/encryptor_plugins.xml" />
+  </export>
+</package>
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/rosdoc.yaml
@@ -0,0 +1,4 @@
+ - builder: doxygen
+   name: C++ API
+   output_dir: c++
+   file_patterns: '*.c *.cpp *.h *.cc *.hh *.dox'
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/src/aes_encryptor.cpp
@@ -0,0 +1,326 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2017, Open Source Robotics Foundation
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#include "rosbag/bag.h"
+#include "rosbag/aes_encryptor.h"
+#include "rosbag/gpgme_utils.h"
+
+#include <openssl/rand.h>
+
+#include <pluginlib/class_list_macros.hpp>
+
+PLUGINLIB_EXPORT_CLASS(rosbag::AesCbcEncryptor, rosbag::EncryptorBase)
+
+namespace rosbag
+{
+
+const std::string AesCbcEncryptor::GPG_USER_FIELD_NAME = "gpg_user";
+const std::string AesCbcEncryptor::ENCRYPTED_KEY_FIELD_NAME = "encrypted_key";
+
+//! Encrypt string using GPGME
+/*!
+ * \return Encrypted string
+ * \param user User name of the GPG key to be used for encryption
+ * \param input Input string to be encrypted
+ *
+ * This method encrypts the given string using the GPG key owned by the specified user.
+ * This method throws BagException in case of errors.
+ */
+static std::string encryptStringGpg(std::string& user, std::basic_string<unsigned char> const& input) {
+    gpgme_ctx_t ctx;
+    gpgme_error_t err = gpgme_new(&ctx);
+    if (err) {
+        throw BagException((boost::format("Failed to create a GPG context: %1%") % gpgme_strerror(err)).str());
+    }
+
+    gpgme_key_t keys[2] = {NULL, NULL};
+    getGpgKey(ctx, user, keys[0]);
+    if (user == std::string("*")) {
+        user = std::string(keys[0]->uids->name);
+    }
+
+    gpgme_data_t input_data;
+    err = gpgme_data_new_from_mem(&input_data, reinterpret_cast<const char*>(input.c_str()), input.length(), 1);
+    if (err) {
+        gpgme_release(ctx);
+        throw BagException(
+            (boost::format("Failed to encrypt string: gpgme_data_new_from_mem returned %1%") % gpgme_strerror(err)).str());
+    }
+    gpgme_data_t output_data;
+    err = gpgme_data_new(&output_data);
+    if (err) {
+        gpgme_data_release(input_data);
+        gpgme_release(ctx);
+        throw BagException(
+            (boost::format("Failed to encrypt string: gpgme_data_new returned %1%") % gpgme_strerror(err)).str());
+    }
+    err = gpgme_op_encrypt(ctx, keys, static_cast<gpgme_encrypt_flags_t>(GPGME_ENCRYPT_ALWAYS_TRUST), input_data, output_data);
+    if (err) {
+        gpgme_data_release(output_data);
+        gpgme_data_release(input_data);
+        gpgme_release(ctx);
+        throw BagException((boost::format("Failed to encrypt: %1%.  Have you installed a public key %2%?") % gpgme_strerror(err) % user).str());
+    }
+    gpgme_key_release(keys[0]);
+    std::size_t output_length = gpgme_data_seek(output_data, 0, SEEK_END);
+    std::string output(output_length, 0);
+    gpgme_data_seek(output_data, 0, SEEK_SET);
+    ssize_t bytes_read = gpgme_data_read(output_data, &output[0], output_length);
+    // Release resources and return
+    gpgme_data_release(output_data);
+    gpgme_data_release(input_data);
+    gpgme_release(ctx);
+    if (-1 == bytes_read) {
+        throw BagException("Failed to read encrypted string");
+    }
+    return output;
+}
+
+//! Decrypt string using GPGME
+/*!
+ * \return Decrypted string
+ * \param user User name of the GPG key to be used for decryption
+ * \param input Encrypted string
+ *
+ * This method decrypts the given encrypted string. This method throws BagException in case of errors.
+ */
+static std::basic_string<unsigned char> decryptStringGpg(std::string const& user, std::string const& input) {
+    gpgme_ctx_t ctx;
+    gpgme_error_t err = gpgme_new(&ctx);
+    if (err) {
+        throw BagException((boost::format("Failed to create a GPG context: %1%") % gpgme_strerror(err)).str());
+    }
+
+    gpgme_data_t input_data;
+    err = gpgme_data_new_from_mem(&input_data, input.c_str(), input.length(), 1);
+    if (err) {
+        gpgme_release(ctx);
+        throw BagException(
+            (boost::format("Failed to decrypt bag: gpgme_data_new_from_mem returned %1%") % gpgme_strerror(err)).str());
+    }
+    gpgme_data_t output_data;
+    err = gpgme_data_new(&output_data);
+    if (err) {
+        gpgme_data_release(input_data);
+        gpgme_release(ctx);
+        throw BagException(
+            (boost::format("Failed to decrypt bag: gpgme_data_new returned %1%") % gpgme_strerror(err)).str());
+    }
+    err = gpgme_op_decrypt(ctx, input_data, output_data);
+    if (err) {
+        gpgme_data_release(output_data);
+        gpgme_data_release(input_data);
+        gpgme_release(ctx);
+        throw BagException((boost::format("Failed to decrypt bag: %1%.  Have you installed a private key %2%?") % gpgme_strerror(err) % user).str());
+    }
+    std::size_t output_length = gpgme_data_seek(output_data, 0, SEEK_END);
+    if (output_length != AES_BLOCK_SIZE) {
+        gpgme_data_release(output_data);
+        gpgme_data_release(input_data);
+        gpgme_release(ctx);
+        throw BagException("Decrypted string length mismatches");
+    }
+    std::basic_string<unsigned char> output(output_length, 0);
+    gpgme_data_seek(output_data, 0, SEEK_SET);
+    ssize_t bytes_read = gpgme_data_read(output_data, reinterpret_cast<char*>(&output[0]), output_length);
+    // Release resources and return
+    gpgme_data_release(output_data);
+    gpgme_data_release(input_data);
+    gpgme_release(ctx);
+    if (-1 == bytes_read) {
+        throw BagException("Failed to read decrypted symmetric key");
+    }
+    return output;
+}
+
+static std::string readHeaderField(ros::M_string const& header_fields, std::string const& field_name) {
+    ros::M_string::const_iterator it = header_fields.find(field_name);
+    if (it == header_fields.end()) {
+        return std::string();
+    }
+    return it->second;
+}
+
+void AesCbcEncryptor::initialize(Bag const& bag, std::string const& gpg_key_user) {
+    // GPGME must be initialized even when reading
+    initGpgme();
+    // Encryption user can be set only when writing a bag file
+    if (bag.getMode() != bagmode::Write) {
+        return;
+    }
+    if (gpg_key_user_ == gpg_key_user) {
+        return;
+    }
+    if (gpg_key_user_.empty()) {
+        gpg_key_user_ = gpg_key_user;
+        buildSymmetricKey();
+        AES_set_encrypt_key(&symmetric_key_[0], AES_BLOCK_SIZE*8, &aes_encrypt_key_);
+    } else {
+        // Encryption user cannot change once set
+        throw BagException(
+            (boost::format("Encryption user has already been set to %s") % gpg_key_user_.c_str()).str());
+    }
+}
+
+uint32_t AesCbcEncryptor::encryptChunk(const uint32_t chunk_size, const uint64_t chunk_data_pos, ChunkedFile& file) {
+    // Read existing (compressed) chunk
+    std::basic_string<unsigned char> compressed_chunk(chunk_size, 0);
+    file.seek(chunk_data_pos);
+    file.read((char*) &compressed_chunk[0], chunk_size);
+    // Apply PKCS#7 padding to the chunk
+    std::size_t pad_size = AES_BLOCK_SIZE - chunk_size % AES_BLOCK_SIZE;
+    compressed_chunk.resize(compressed_chunk.length() + pad_size, pad_size);
+    // Encrypt chunk
+    std::basic_string<unsigned char> encrypted_chunk(compressed_chunk.length(), 0);
+    std::basic_string<unsigned char> iv(AES_BLOCK_SIZE, 0);
+    if (!RAND_bytes(&iv[0], AES_BLOCK_SIZE)) {
+        throw BagException("Failed to build initialization vector");
+    }
+    file.seek(chunk_data_pos);
+    file.write((char*) &iv[0], AES_BLOCK_SIZE);
+    AES_cbc_encrypt(&compressed_chunk[0], &encrypted_chunk[0], encrypted_chunk.length(), &aes_encrypt_key_, &iv[0], AES_ENCRYPT);
+    // Write encrypted chunk
+    file.write((char*) &encrypted_chunk[0], encrypted_chunk.length());
+    file.truncate(chunk_data_pos + AES_BLOCK_SIZE + encrypted_chunk.length());
+    return AES_BLOCK_SIZE + encrypted_chunk.length();
+}
+
+void AesCbcEncryptor::decryptChunk(ChunkHeader const& chunk_header, Buffer& decrypted_chunk, ChunkedFile& file) const {
+    // Test encrypted chunk size
+    if (chunk_header.compressed_size % AES_BLOCK_SIZE != 0) {
+        throw BagFormatException((boost::format("Error in encrypted chunk size: %d") % chunk_header.compressed_size).str());
+    }
+    // Read encrypted chunk
+    if (chunk_header.compressed_size < AES_BLOCK_SIZE) {
+        throw BagFormatException((boost::format("No initialization vector in encrypted chunk: %d") % chunk_header.compressed_size).str());
+    }
+    std::basic_string<unsigned char> iv(AES_BLOCK_SIZE, 0);
+    file.read((char*) &iv[0], AES_BLOCK_SIZE);
+    std::basic_string<unsigned char> encrypted_chunk(chunk_header.compressed_size - AES_BLOCK_SIZE, 0);
+    file.read((char*) &encrypted_chunk[0], chunk_header.compressed_size - AES_BLOCK_SIZE);
+    // Decrypt chunk
+    decrypted_chunk.setSize(chunk_header.compressed_size - AES_BLOCK_SIZE);
+    AES_cbc_encrypt(&encrypted_chunk[0], (unsigned char*) decrypted_chunk.getData(), chunk_header.compressed_size - AES_BLOCK_SIZE,
+        &aes_decrypt_key_, &iv[0], AES_DECRYPT);
+    if (decrypted_chunk.getSize() == 0) {
+        throw BagFormatException("Decrypted chunk is empty");
+    }
+    decrypted_chunk.setSize(decrypted_chunk.getSize() - *(decrypted_chunk.getData()+decrypted_chunk.getSize()-1));
+}
+
+void AesCbcEncryptor::addFieldsToFileHeader(ros::M_string &header_fields) const {
+    header_fields[ENCRYPTOR_FIELD_NAME] = "rosbag/AesCbcEncryptor";
+    header_fields[GPG_USER_FIELD_NAME] = gpg_key_user_;
+    header_fields[ENCRYPTED_KEY_FIELD_NAME] = encrypted_symmetric_key_;
+}
+
+void AesCbcEncryptor::readFieldsFromFileHeader(ros::M_string const& header_fields) {
+    encrypted_symmetric_key_ = readHeaderField(header_fields, ENCRYPTED_KEY_FIELD_NAME);
+    if (encrypted_symmetric_key_.empty()) {
+        throw BagFormatException("Encrypted symmetric key is not found in header");
+    }
+    gpg_key_user_ = readHeaderField(header_fields, GPG_USER_FIELD_NAME);
+    if (gpg_key_user_.empty()) {
+        throw BagFormatException("GPG key user is not found in header");
+    }
+    symmetric_key_ = decryptStringGpg(gpg_key_user_, encrypted_symmetric_key_);
+    AES_set_decrypt_key(&symmetric_key_[0], AES_BLOCK_SIZE*8, &aes_decrypt_key_);
+}
+
+void AesCbcEncryptor::writeEncryptedHeader(boost::function<void(ros::M_string const&)>, ros::M_string const& header_fields, ChunkedFile& file) {
+    boost::shared_array<uint8_t> header_buffer;
+    uint32_t header_len;
+    ros::Header::write(header_fields, header_buffer, header_len);
+    // Apply PKCS#7 padding to the header
+    std::size_t pad_size = AES_BLOCK_SIZE - header_len % AES_BLOCK_SIZE;
+    uint32_t encrypted_buffer_size = header_len + pad_size;
+    std::basic_string<unsigned char> header_buffer_with_pad(encrypted_buffer_size, pad_size);
+    memcpy(&header_buffer_with_pad[0], header_buffer.get(), header_len);
+    // Encrypt chunk
+    std::basic_string<unsigned char> encrypted_buffer(encrypted_buffer_size, 0);
+    std::basic_string<unsigned char> iv(AES_BLOCK_SIZE, 0);
+    if (!RAND_bytes(&iv[0], AES_BLOCK_SIZE)) {
+        throw BagException("Failed to build initialization vector");
+    }
+    encrypted_buffer_size += AES_BLOCK_SIZE;
+    file.write((char*) &encrypted_buffer_size, 4);
+    encrypted_buffer_size -= AES_BLOCK_SIZE;
+    file.write((char*) &iv[0], AES_BLOCK_SIZE);
+    AES_cbc_encrypt(&header_buffer_with_pad[0], &encrypted_buffer[0], encrypted_buffer_size, &aes_encrypt_key_, &iv[0], AES_ENCRYPT);
+    // Write
+    file.write((char*) &encrypted_buffer[0], encrypted_buffer_size);
+}
+
+bool AesCbcEncryptor::readEncryptedHeader(boost::function<bool(ros::Header&)>, ros::Header& header, Buffer& header_buffer, ChunkedFile& file) {
+    // Read the encrypted header length
+    uint32_t encrypted_header_len;
+    file.read((char*) &encrypted_header_len, 4);
+    if (encrypted_header_len % AES_BLOCK_SIZE != 0) {
+        throw BagFormatException((boost::format("Error in encrypted header length: %d") % encrypted_header_len).str());
+    }
+    if (encrypted_header_len < AES_BLOCK_SIZE) {
+        throw BagFormatException((boost::format("No initialization vector in encrypted header: %d") % encrypted_header_len).str());
+    }
+    // Read encrypted header
+    std::basic_string<unsigned char> iv(AES_BLOCK_SIZE, 0);
+    file.read((char*) &iv[0], AES_BLOCK_SIZE);
+    encrypted_header_len -= AES_BLOCK_SIZE;
+    std::basic_string<unsigned char> encrypted_header(encrypted_header_len, 0);
+    file.read((char*) &encrypted_header[0], encrypted_header_len);
+    // Decrypt header
+    header_buffer.setSize(encrypted_header_len);
+    AES_cbc_encrypt(&encrypted_header[0], (unsigned char*) header_buffer.getData(), encrypted_header_len, &aes_decrypt_key_, &iv[0], AES_DECRYPT);
+    if (header_buffer.getSize() == 0) {
+        throw BagFormatException("Decrypted header is empty");
+    }
+    header_buffer.setSize(header_buffer.getSize() - *(header_buffer.getData()+header_buffer.getSize()-1));
+    // Parse the header
+    std::string error_msg;
+    return header.parse(header_buffer.getData(), header_buffer.getSize(), error_msg);
+}
+
+void AesCbcEncryptor::buildSymmetricKey() {
+    // Compose a new symmetric key for a bag file to be written
+    if (gpg_key_user_.empty()) {
+        return;
+    }
+    symmetric_key_.resize(AES_BLOCK_SIZE);
+    if (!RAND_bytes(&symmetric_key_[0], AES_BLOCK_SIZE)) {
+        throw BagException("Failed to build symmetric key");
+    }
+    // Encrypted session key is written in bag file header
+    encrypted_symmetric_key_ = encryptStringGpg(gpg_key_user_, symmetric_key_);
+}
+
+}  // namespace rosbag
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/src/bag.cpp
@@ -0,0 +1,1185 @@
+// Copyright (c) 2009, Willow Garage, Inc.
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in the
+//       documentation and/or other materials provided with the distribution.
+//     * Neither the name of Willow Garage, Inc. nor the names of its
+//       contributors may be used to endorse or promote products derived from
+//       this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "rosbag/bag.h"
+#include "rosbag/message_instance.h"
+#include "rosbag/query.h"
+#include "rosbag/view.h"
+
+#if defined(_MSC_VER)
+  #include <stdint.h> // only on v2010 and later -> is this enough for msvc and linux?
+#else
+  #include <inttypes.h>
+#endif
+#include <signal.h>
+#include <assert.h>
+#include <iomanip>
+
+#include <boost/bind/bind.hpp>
+
+#include "console_bridge/console.h"
+
+using std::map;
+using std::priority_queue;
+using std::string;
+using std::vector;
+using std::multiset;
+using boost::format;
+using boost::shared_ptr;
+using ros::M_string;
+using ros::Time;
+
+namespace rosbag {
+
+Bag::Bag() : encryptor_loader_("rosbag_storage", "rosbag::EncryptorBase")
+{
+    init();
+}
+
+Bag::Bag(string const& filename, uint32_t mode) : encryptor_loader_("rosbag_storage", "rosbag::EncryptorBase")
+{
+    init();
+    open(filename, mode);
+}
+
+#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES
+
+Bag::Bag(Bag&& other) : encryptor_loader_("rosbag_storage", "rosbag::EncryptorBase") {
+    init();
+    swap(other);
+}
+
+Bag& Bag::operator=(Bag&& other) {
+    swap(other);
+    return *this;
+}
+
+#endif // BOOST_NO_CXX11_RVALUE_REFERENCES
+
+Bag::~Bag() {
+    close();
+}
+
+void Bag::init() {
+    mode_ = bagmode::Write;
+    version_ = 0;
+    compression_ = compression::Uncompressed;
+    chunk_threshold_ = 768 * 1024;  // 768KB chunks
+    bag_revision_ = 0;
+    file_size_ = 0;
+    file_header_pos_ = 0;
+    index_data_pos_ = 0;
+    connection_count_ = 0;
+    chunk_count_ = 0;
+    chunk_open_ = false;
+    curr_chunk_data_pos_ = 0;
+    current_buffer_ = 0;
+    decompressed_chunk_ = 0;
+    setEncryptorPlugin(std::string("rosbag/NoEncryptor"));
+}
+
+void Bag::open(string const& filename, uint32_t mode) {
+    mode_ = (BagMode) mode;
+
+    if (mode_ & bagmode::Append)
+        openAppend(filename);
+    else if (mode_ & bagmode::Write)
+        openWrite(filename);
+    else if (mode_ & bagmode::Read)
+        openRead(filename);
+    else
+        throw BagException((format("Unknown mode: %1%") % (int) mode).str());
+
+    // Determine file size
+    uint64_t offset = file_.getOffset();
+    seek(0, std::ios::end);
+    file_size_ = file_.getOffset();
+    seek(offset);
+}
+
+void Bag::openRead(string const& filename) {
+    file_.openRead(filename);
+
+    readVersion();
+
+    switch (version_) {
+    case 102: startReadingVersion102(); break;
+    case 200: startReadingVersion200(); break;
+    default:
+        throw BagException((format("Unsupported bag file version: %1%.%2%") % getMajorVersion() % getMinorVersion()).str());
+    }
+}
+
+void Bag::openWrite(string const& filename) {
+    file_.openWrite(filename);
+
+    startWriting();
+}
+
+void Bag::openAppend(string const& filename) {
+    file_.openReadWrite(filename);
+
+    readVersion();
+
+    if (version_ != 200)
+        throw BagException((format("Bag file version %1%.%2% is unsupported for appending") % getMajorVersion() % getMinorVersion()).str());
+
+    startReadingVersion200();
+
+    // Truncate the file to chop off the index
+    file_.truncate(index_data_pos_);
+    index_data_pos_ = 0;
+
+    // Rewrite the file header, clearing the index position (so we know if the index is invalid)
+    seek(file_header_pos_);
+    writeFileHeaderRecord();
+
+    // Seek to the end of the file
+    seek(0, std::ios::end);
+}
+
+void Bag::close() {
+    if (!isOpen())
+        return;
+
+    if (mode_ & bagmode::Write || mode_ & bagmode::Append)
+    	closeWrite();
+    
+    file_.close();
+
+    topic_connection_ids_.clear();
+    header_connection_ids_.clear();
+    for (map<uint32_t, ConnectionInfo*>::iterator i = connections_.begin(); i != connections_.end(); i++)
+        delete i->second;
+    connections_.clear();
+    chunks_.clear();
+    connection_indexes_.clear();
+    curr_chunk_connection_indexes_.clear();
+
+    init();
+}
+
+void Bag::closeWrite() {
+    stopWriting();
+}
+
+string   Bag::getFileName() const { return file_.getFileName(); }
+BagMode  Bag::getMode()     const { return mode_;               }
+uint64_t Bag::getSize()     const { return file_size_;          }
+
+uint32_t Bag::getChunkThreshold() const { return chunk_threshold_; }
+
+void Bag::setChunkThreshold(uint32_t chunk_threshold) {
+    if (isOpen() && chunk_open_)
+        stopWritingChunk();
+
+    chunk_threshold_ = chunk_threshold;
+}
+
+CompressionType Bag::getCompression() const { return compression_; }
+
+void Bag::setCompression(CompressionType compression) {
+    if (isOpen() && chunk_open_)
+        stopWritingChunk();
+
+    if (!(compression == compression::Uncompressed ||
+          compression == compression::BZ2 ||
+          compression == compression::LZ4)) {
+        throw BagException(
+            (format("Unknown compression type: %i")  % compression).str());
+    }
+
+    compression_ = compression;
+}
+
+void Bag::setEncryptorPlugin(std::string const& plugin_name, std::string const& plugin_param) {
+    if (!chunks_.empty()) {
+        throw BagException("Cannot set encryption plugin after chunks are written");
+    }
+    encryptor_ = encryptor_loader_.createInstance(plugin_name);
+    encryptor_->initialize(*this, plugin_param);
+}
+
+// Version
+
+void Bag::writeVersion() {
+    string version = string("#ROSBAG V") + VERSION + string("\n");
+
+    CONSOLE_BRIDGE_logDebug("Writing VERSION [%llu]: %s", (unsigned long long) file_.getOffset(), version.c_str());
+
+    version_ = 200;
+
+    write(version);
+}
+
+void Bag::readVersion() {
+    string version_line = file_.getline();
+
+    file_header_pos_ = file_.getOffset();
+
+    char logtypename[100];
+    int version_major, version_minor;
+#if defined(_MSC_VER)
+    if (sscanf_s(version_line.c_str(), "#ROS%s V%d.%d", logtypename, sizeof(logtypename), &version_major, &version_minor) != 3)
+#else
+    if (sscanf(version_line.c_str(), "#ROS%99s V%d.%d", logtypename, &version_major, &version_minor) != 3)
+#endif
+        throw BagIOException("Error reading version line");
+
+    version_ = version_major * 100 + version_minor;
+
+    CONSOLE_BRIDGE_logDebug("Read VERSION: version=%d", version_);
+}
+
+uint32_t Bag::getMajorVersion() const { return version_ / 100; }
+uint32_t Bag::getMinorVersion() const { return version_ % 100; }
+
+//
+
+void Bag::startWriting() {
+    writeVersion();
+    file_header_pos_ = file_.getOffset();
+    writeFileHeaderRecord();
+}
+
+void Bag::stopWriting() {
+    if (chunk_open_)
+        stopWritingChunk();
+
+    seek(0, std::ios::end);
+
+    index_data_pos_ = file_.getOffset();
+    writeConnectionRecords();
+    writeChunkInfoRecords();
+
+    seek(file_header_pos_);
+    writeFileHeaderRecord();
+}
+
+void Bag::startReadingVersion200() {
+    // Read the file header record, which points to the end of the chunks
+    readFileHeaderRecord();
+
+    // Seek to the end of the chunks
+    seek(index_data_pos_);
+
+    // Read the connection records (one for each connection)
+    for (uint32_t i = 0; i < connection_count_; i++)
+        readConnectionRecord();
+
+    // Read the chunk info records
+    for (uint32_t i = 0; i < chunk_count_; i++)
+        readChunkInfoRecord();
+
+    // Read the connection indexes for each chunk
+    for (ChunkInfo const& chunk_info : chunks_) {
+        curr_chunk_info_ = chunk_info;
+
+        seek(curr_chunk_info_.pos);
+
+        // Skip over the chunk data
+        ChunkHeader chunk_header;
+        readChunkHeader(chunk_header);
+        seek(chunk_header.compressed_size, std::ios::cur);
+
+        // Read the index records after the chunk
+        for (unsigned int i = 0; i < chunk_info.connection_counts.size(); i++)
+            readConnectionIndexRecord200();
+    }
+
+    // At this point we don't have a curr_chunk_info anymore so we reset it
+    curr_chunk_info_ = ChunkInfo();
+}
+
+void Bag::startReadingVersion102() {
+    try
+    {
+        // Read the file header record, which points to the start of the topic indexes
+        readFileHeaderRecord();
+    }
+    catch (const BagFormatException& ex) {
+        throw BagUnindexedException();
+    }
+
+    // Get the length of the file
+    seek(0, std::ios::end);
+    uint64_t filelength = file_.getOffset();
+
+    // Seek to the beginning of the topic index records
+    seek(index_data_pos_);
+
+    // Read the topic index records, which point to the offsets of each message in the file
+    while (file_.getOffset() < filelength)
+        readTopicIndexRecord102();
+
+    // Read the message definition records (which are the first entry in the topic indexes)
+    for (map<uint32_t, multiset<IndexEntry> >::const_iterator i = connection_indexes_.begin(); i != connection_indexes_.end(); i++) {
+        multiset<IndexEntry> const& index       = i->second;
+        IndexEntry const&           first_entry = *index.begin();
+
+        CONSOLE_BRIDGE_logDebug("Reading message definition for connection %d at %llu", i->first, (unsigned long long) first_entry.chunk_pos);
+
+        seek(first_entry.chunk_pos);
+
+        readMessageDefinitionRecord102();
+    }
+}
+
+// File header record
+
+void Bag::writeFileHeaderRecord() {
+    connection_count_ = connections_.size();
+    chunk_count_      = chunks_.size();
+
+    CONSOLE_BRIDGE_logDebug("Writing FILE_HEADER [%llu]: index_pos=%llu connection_count=%d chunk_count=%d",
+              (unsigned long long) file_.getOffset(), (unsigned long long) index_data_pos_, connection_count_, chunk_count_);
+    
+    // Write file header record
+    M_string header;
+    header[OP_FIELD_NAME]               = toHeaderString(&OP_FILE_HEADER);
+    header[INDEX_POS_FIELD_NAME]        = toHeaderString(&index_data_pos_);
+    header[CONNECTION_COUNT_FIELD_NAME] = toHeaderString(&connection_count_);
+    header[CHUNK_COUNT_FIELD_NAME]      = toHeaderString(&chunk_count_);
+    encryptor_->addFieldsToFileHeader(header);
+
+    boost::shared_array<uint8_t> header_buffer;
+    uint32_t header_len;
+    ros::Header::write(header, header_buffer, header_len);
+    uint32_t data_len = 0;
+    if (header_len < FILE_HEADER_LENGTH)
+        data_len = FILE_HEADER_LENGTH - header_len;
+    write((char*) &header_len, 4);
+    write((char*) header_buffer.get(), header_len);
+    write((char*) &data_len, 4);
+    
+    // Pad the file header record out
+    if (data_len > 0) {
+        string padding;
+        padding.resize(data_len, ' ');
+        write(padding);
+    }
+}
+
+void Bag::readFileHeaderRecord() {
+    ros::Header header;
+    uint32_t data_size;
+    if (!readHeader(header) || !readDataLength(data_size))
+        throw BagFormatException("Error reading FILE_HEADER record");
+
+    M_string& fields = *header.getValues();
+
+    if (!isOp(fields, OP_FILE_HEADER))
+        throw BagFormatException("Expected FILE_HEADER op not found");
+
+    // Read index position
+    readField(fields, INDEX_POS_FIELD_NAME, true, (uint64_t*) &index_data_pos_);
+
+    if (index_data_pos_ == 0)
+        throw BagUnindexedException();
+
+    // Read topic and chunks count
+    if (version_ >= 200) {
+        readField(fields, CONNECTION_COUNT_FIELD_NAME, true, &connection_count_);
+        readField(fields, CHUNK_COUNT_FIELD_NAME,      true, &chunk_count_);
+        std::string encryptor_plugin_name;
+        readField(fields, ENCRYPTOR_FIELD_NAME, 0, UINT_MAX, false, encryptor_plugin_name);
+        if (!encryptor_plugin_name.empty()) {
+            setEncryptorPlugin(encryptor_plugin_name);
+            encryptor_->readFieldsFromFileHeader(fields);
+        }
+    }
+
+    CONSOLE_BRIDGE_logDebug("Read FILE_HEADER: index_pos=%llu connection_count=%d chunk_count=%d",
+              (unsigned long long) index_data_pos_, connection_count_, chunk_count_);
+
+    // Skip the data section (just padding)
+    seek(data_size, std::ios::cur);
+}
+
+uint32_t Bag::getChunkOffset() const {
+    if (compression_ == compression::Uncompressed)
+        return file_.getOffset() - curr_chunk_data_pos_;
+    else
+        return file_.getCompressedBytesIn();
+}
+
+void Bag::startWritingChunk(Time time) {
+    // Initialize chunk info
+    curr_chunk_info_.pos        = file_.getOffset();
+    curr_chunk_info_.start_time = time;
+    curr_chunk_info_.end_time   = time;
+
+    // Write the chunk header, with a place-holder for the data sizes (we'll fill in when the chunk is finished)
+    writeChunkHeader(compression_, 0, 0);
+
+    // Turn on compressed writing
+    file_.setWriteMode(compression_);
+    
+    // Record where the data section of this chunk started
+    curr_chunk_data_pos_ = file_.getOffset();
+
+    chunk_open_ = true;
+}
+
+void Bag::stopWritingChunk() {
+    // Add this chunk to the index
+    chunks_.push_back(curr_chunk_info_);
+    
+    // Get the uncompressed and compressed sizes
+    uint32_t uncompressed_size = getChunkOffset();
+    file_.setWriteMode(compression::Uncompressed);
+    uint32_t compressed_size = file_.getOffset() - curr_chunk_data_pos_;
+
+    // When encryption is on, compressed_size represents encrypted chunk size;
+    // When decrypting, the actual compressed size can be deduced from the decrypted chunk
+    compressed_size = encryptor_->encryptChunk(compressed_size, curr_chunk_data_pos_, file_);
+
+    // Rewrite the chunk header with the size of the chunk (remembering current offset)
+    uint64_t end_of_chunk_pos = file_.getOffset();
+
+    seek(curr_chunk_info_.pos);
+    writeChunkHeader(compression_, compressed_size, uncompressed_size);
+
+    // Write out the indexes and clear them
+    seek(end_of_chunk_pos);
+    writeIndexRecords();
+    curr_chunk_connection_indexes_.clear();
+
+    // Clear the connection counts
+    curr_chunk_info_.connection_counts.clear();
+    
+    // Flag that we're starting a new chunk
+    chunk_open_ = false;
+}
+
+void Bag::writeChunkHeader(CompressionType compression, uint32_t compressed_size, uint32_t uncompressed_size) {
+    ChunkHeader chunk_header;
+    switch (compression) {
+    case compression::Uncompressed: chunk_header.compression = COMPRESSION_NONE; break;
+    case compression::BZ2:          chunk_header.compression = COMPRESSION_BZ2;  break;
+    case compression::LZ4:          chunk_header.compression = COMPRESSION_LZ4;
+    //case compression::ZLIB:         chunk_header.compression = COMPRESSION_ZLIB; break;
+    }
+    chunk_header.compressed_size   = compressed_size;
+    chunk_header.uncompressed_size = uncompressed_size;
+
+    CONSOLE_BRIDGE_logDebug("Writing CHUNK [%llu]: compression=%s compressed=%d uncompressed=%d",
+              (unsigned long long) file_.getOffset(), chunk_header.compression.c_str(), chunk_header.compressed_size, chunk_header.uncompressed_size);
+
+    M_string header;
+    header[OP_FIELD_NAME]          = toHeaderString(&OP_CHUNK);
+    header[COMPRESSION_FIELD_NAME] = chunk_header.compression;
+    header[SIZE_FIELD_NAME]        = toHeaderString(&chunk_header.uncompressed_size);
+    writeHeader(header);
+
+    writeDataLength(chunk_header.compressed_size);
+}
+
+void Bag::readChunkHeader(ChunkHeader& chunk_header) const {
+    ros::Header header;
+    if (!readHeader(header) || !readDataLength(chunk_header.compressed_size))
+        throw BagFormatException("Error reading CHUNK record");
+        
+    M_string& fields = *header.getValues();
+
+    if (!isOp(fields, OP_CHUNK))
+        throw BagFormatException("Expected CHUNK op not found");
+
+    readField(fields, COMPRESSION_FIELD_NAME, true, chunk_header.compression);
+    readField(fields, SIZE_FIELD_NAME,        true, &chunk_header.uncompressed_size);
+
+    CONSOLE_BRIDGE_logDebug("Read CHUNK: compression=%s size=%d uncompressed=%d (%f)", chunk_header.compression.c_str(), chunk_header.compressed_size, chunk_header.uncompressed_size, 100 * ((double) chunk_header.compressed_size) / chunk_header.uncompressed_size);
+}
+
+// Index records
+
+void Bag::writeIndexRecords() {
+    for (map<uint32_t, multiset<IndexEntry> >::const_iterator i = curr_chunk_connection_indexes_.begin(); i != curr_chunk_connection_indexes_.end(); i++) {
+        uint32_t                    connection_id = i->first;
+        multiset<IndexEntry> const& index         = i->second;
+
+        // Write the index record header
+        uint32_t index_size = index.size();
+        M_string header;
+        header[OP_FIELD_NAME]         = toHeaderString(&OP_INDEX_DATA);
+        header[CONNECTION_FIELD_NAME] = toHeaderString(&connection_id);
+        header[VER_FIELD_NAME]        = toHeaderString(&INDEX_VERSION);
+        header[COUNT_FIELD_NAME]      = toHeaderString(&index_size);
+        writeHeader(header);
+
+        writeDataLength(index_size * 12);
+
+        CONSOLE_BRIDGE_logDebug("Writing INDEX_DATA: connection=%d ver=%d count=%d", connection_id, INDEX_VERSION, index_size);
+
+        // Write the index record data (pairs of timestamp and position in file)
+        for (IndexEntry const& e : index) {
+            write((char*) &e.time.sec,  4);
+            write((char*) &e.time.nsec, 4);
+            write((char*) &e.offset,    4);
+
+            CONSOLE_BRIDGE_logDebug("  - %d.%d: %d", e.time.sec, e.time.nsec, e.offset);
+        }
+    }
+}
+
+void Bag::readTopicIndexRecord102() {
+    ros::Header header;
+    uint32_t data_size;
+    if (!readHeader(header) || !readDataLength(data_size))
+        throw BagFormatException("Error reading INDEX_DATA header");
+    M_string& fields = *header.getValues();
+
+    if (!isOp(fields, OP_INDEX_DATA))
+        throw BagFormatException("Expected INDEX_DATA record");
+
+    uint32_t index_version;
+    string topic;
+    uint32_t count = 0;
+    readField(fields, VER_FIELD_NAME,   true, &index_version);
+    readField(fields, TOPIC_FIELD_NAME, true, topic);
+    readField(fields, COUNT_FIELD_NAME, true, &count);
+
+    CONSOLE_BRIDGE_logDebug("Read INDEX_DATA: ver=%d topic=%s count=%d", index_version, topic.c_str(), count);
+
+    if (index_version != 0)
+        throw BagFormatException((format("Unsupported INDEX_DATA version: %1%") % index_version).str());
+
+    uint32_t connection_id;
+    map<string, uint32_t>::const_iterator topic_conn_id_iter = topic_connection_ids_.find(topic);
+    if (topic_conn_id_iter == topic_connection_ids_.end()) {
+    	connection_id = connections_.size();
+
+        CONSOLE_BRIDGE_logDebug("Creating connection: id=%d topic=%s", connection_id, topic.c_str());
+        ConnectionInfo* connection_info = new ConnectionInfo();
+        connection_info->id       = connection_id;
+        connection_info->topic    = topic;
+        connections_[connection_id] = connection_info;
+
+        topic_connection_ids_[topic] = connection_id;
+    }
+    else
+    	connection_id = topic_conn_id_iter->second;
+
+    multiset<IndexEntry>& connection_index = connection_indexes_[connection_id];
+
+    for (uint32_t i = 0; i < count; i++) {
+        IndexEntry index_entry;
+        uint32_t sec;
+        uint32_t nsec;
+        read((char*) &sec,                   4);
+        read((char*) &nsec,                  4);
+        read((char*) &index_entry.chunk_pos, 8);   //<! store position of the message in the chunk_pos field as it's 64 bits
+        index_entry.time = Time(sec, nsec);
+        index_entry.offset = 0;
+
+        CONSOLE_BRIDGE_logDebug("  - %d.%d: %llu", sec, nsec, (unsigned long long) index_entry.chunk_pos);
+
+        if (index_entry.time < ros::TIME_MIN || index_entry.time > ros::TIME_MAX)
+        {
+          CONSOLE_BRIDGE_logError("Index entry for topic %s contains invalid time.", topic.c_str());
+        } else
+        {
+          connection_index.insert(connection_index.end(), index_entry);
+        }
+    }
+}
+
+void Bag::readConnectionIndexRecord200() {
+    ros::Header header;
+    uint32_t data_size;
+    if (!readHeader(header) || !readDataLength(data_size))
+        throw BagFormatException("Error reading INDEX_DATA header");
+    M_string& fields = *header.getValues();
+    
+    if (!isOp(fields, OP_INDEX_DATA))
+        throw BagFormatException("Expected INDEX_DATA record");
+    
+    uint32_t index_version;
+    uint32_t connection_id;
+    uint32_t count = 0;
+    readField(fields, VER_FIELD_NAME,        true, &index_version);
+    readField(fields, CONNECTION_FIELD_NAME, true, &connection_id);
+    readField(fields, COUNT_FIELD_NAME,      true, &count);
+
+    CONSOLE_BRIDGE_logDebug("Read INDEX_DATA: ver=%d connection=%d count=%d", index_version, connection_id, count);
+
+    if (index_version != 1)
+        throw BagFormatException((format("Unsupported INDEX_DATA version: %1%") % index_version).str());
+
+    uint64_t chunk_pos = curr_chunk_info_.pos;
+
+    multiset<IndexEntry>& connection_index = connection_indexes_[connection_id];
+
+    for (uint32_t i = 0; i < count; i++) {
+        IndexEntry index_entry;
+        index_entry.chunk_pos = chunk_pos;
+        uint32_t sec;
+        uint32_t nsec;
+        read((char*) &sec,                4);
+        read((char*) &nsec,               4);
+        read((char*) &index_entry.offset, 4);
+        index_entry.time = Time(sec, nsec);
+
+        CONSOLE_BRIDGE_logDebug("  - %d.%d: %llu+%d", sec, nsec, (unsigned long long) index_entry.chunk_pos, index_entry.offset);
+
+        if (index_entry.time < ros::TIME_MIN || index_entry.time > ros::TIME_MAX)
+        {
+          CONSOLE_BRIDGE_logError("Index entry for topic %s contains invalid time.  This message will not be loaded.", connections_[connection_id]->topic.c_str());
+        } else
+        {
+          connection_index.insert(connection_index.end(), index_entry);
+        }
+    }
+}
+
+// Connection records
+
+void Bag::writeConnectionRecords() {
+    for (map<uint32_t, ConnectionInfo*>::const_iterator i = connections_.begin(); i != connections_.end(); i++) {
+        ConnectionInfo const* connection_info = i->second;
+        writeConnectionRecord(connection_info, true);
+    }
+}
+
+void Bag::writeConnectionRecord(ConnectionInfo const* connection_info, const bool encrypt) {
+    CONSOLE_BRIDGE_logDebug("Writing CONNECTION [%llu:%d]: topic=%s id=%d",
+              (unsigned long long) file_.getOffset(), getChunkOffset(), connection_info->topic.c_str(), connection_info->id);
+
+    M_string header;
+    header[OP_FIELD_NAME]         = toHeaderString(&OP_CONNECTION);
+    header[TOPIC_FIELD_NAME]      = connection_info->topic;
+    header[CONNECTION_FIELD_NAME] = toHeaderString(&connection_info->id);
+
+    if (encrypt)
+        encryptor_->writeEncryptedHeader(boost::bind(&Bag::writeHeader, this, boost::placeholders::_1), header, file_);
+    else
+        writeHeader(header);
+
+    if (encrypt)
+        encryptor_->writeEncryptedHeader(boost::bind(&Bag::writeHeader, this, boost::placeholders::_1), *connection_info->header, file_);
+    else
+        writeHeader(*connection_info->header);
+}
+
+void Bag::appendConnectionRecordToBuffer(Buffer& buf, ConnectionInfo const* connection_info) {
+    M_string header;
+    header[OP_FIELD_NAME]         = toHeaderString(&OP_CONNECTION);
+    header[TOPIC_FIELD_NAME]      = connection_info->topic;
+    header[CONNECTION_FIELD_NAME] = toHeaderString(&connection_info->id);
+    appendHeaderToBuffer(buf, header);
+
+    appendHeaderToBuffer(buf, *connection_info->header);
+}
+
+void Bag::readConnectionRecord() {
+    ros::Header header;
+    if (!encryptor_->readEncryptedHeader(boost::bind(&Bag::readHeader, this, boost::placeholders::_1), header, header_buffer_, file_))
+        throw BagFormatException("Error reading CONNECTION header");
+    M_string& fields = *header.getValues();
+
+    if (!isOp(fields, OP_CONNECTION))
+        throw BagFormatException("Expected CONNECTION op not found");
+
+    uint32_t id;
+    readField(fields, CONNECTION_FIELD_NAME, true, &id);
+    string topic;
+    readField(fields, TOPIC_FIELD_NAME,      true, topic);
+
+    ros::Header connection_header;
+    if (!encryptor_->readEncryptedHeader(boost::bind(&Bag::readHeader, this, boost::placeholders::_1), connection_header, header_buffer_, file_))
+        throw BagFormatException("Error reading connection header");
+
+    // If this is a new connection, update connections
+    map<uint32_t, ConnectionInfo*>::iterator key = connections_.find(id);
+    if (key == connections_.end()) {
+        ConnectionInfo* connection_info = new ConnectionInfo();
+        connection_info->id       = id;
+        connection_info->topic    = topic;
+        connection_info->header = boost::make_shared<M_string>();
+        for (M_string::const_iterator i = connection_header.getValues()->begin(); i != connection_header.getValues()->end(); i++)
+            (*connection_info->header)[i->first] = i->second;
+        connection_info->msg_def  = (*connection_info->header)["message_definition"];
+        connection_info->datatype = (*connection_info->header)["type"];
+        connection_info->md5sum   = (*connection_info->header)["md5sum"];
+        connections_[id] = connection_info;
+
+        CONSOLE_BRIDGE_logDebug("Read CONNECTION: topic=%s id=%d", topic.c_str(), id);
+    }
+}
+
+void Bag::readMessageDefinitionRecord102() {
+    ros::Header header;
+    uint32_t data_size;
+    if (!readHeader(header) || !readDataLength(data_size))
+        throw BagFormatException("Error reading message definition header");
+    M_string& fields = *header.getValues();
+
+    if (!isOp(fields, OP_MSG_DEF))
+        throw BagFormatException("Expected MSG_DEF op not found");
+
+    string topic, md5sum, datatype, message_definition;
+    readField(fields, TOPIC_FIELD_NAME,               true, topic);
+    readField(fields, MD5_FIELD_NAME,   32,       32, true, md5sum);
+    readField(fields, TYPE_FIELD_NAME,                true, datatype);
+    readField(fields, DEF_FIELD_NAME,    0, UINT_MAX, true, message_definition);
+
+    ConnectionInfo* connection_info;
+
+    map<string, uint32_t>::const_iterator topic_conn_id_iter = topic_connection_ids_.find(topic);
+    if (topic_conn_id_iter == topic_connection_ids_.end()) {
+    	uint32_t id = connections_.size();
+
+        CONSOLE_BRIDGE_logDebug("Creating connection: topic=%s md5sum=%s datatype=%s", topic.c_str(), md5sum.c_str(), datatype.c_str());
+        connection_info = new ConnectionInfo();
+        connection_info->id       = id;
+        connection_info->topic    = topic;
+
+        connections_[id] = connection_info;
+        topic_connection_ids_[topic] = id;
+    }
+    else
+        connection_info = connections_[topic_conn_id_iter->second];
+
+    connection_info->msg_def  = message_definition;
+    connection_info->datatype = datatype;
+    connection_info->md5sum   = md5sum;
+    connection_info->header = boost::make_shared<ros::M_string>();
+    (*connection_info->header)["type"]               = connection_info->datatype;
+    (*connection_info->header)["md5sum"]             = connection_info->md5sum;
+    (*connection_info->header)["message_definition"] = connection_info->msg_def;
+
+    CONSOLE_BRIDGE_logDebug("Read MSG_DEF: topic=%s md5sum=%s datatype=%s", topic.c_str(), md5sum.c_str(), datatype.c_str());
+}
+
+void Bag::decompressChunk(uint64_t chunk_pos) const {
+    if (curr_chunk_info_.pos == chunk_pos) {
+        current_buffer_ = &outgoing_chunk_buffer_;
+        return;
+    }
+
+    current_buffer_ = &decompress_buffer_;
+
+    if (decompressed_chunk_ == chunk_pos)
+        return;
+
+    // Seek to the start of the chunk
+    seek(chunk_pos);
+
+    // Read the chunk header
+    ChunkHeader chunk_header;
+    readChunkHeader(chunk_header);
+
+    // Read and decompress the chunk.  These assume we are at the right place in the stream already
+    if (chunk_header.compression == COMPRESSION_NONE)
+        decompressRawChunk(chunk_header);
+    else if (chunk_header.compression == COMPRESSION_BZ2)
+        decompressBz2Chunk(chunk_header);
+    else if (chunk_header.compression == COMPRESSION_LZ4)
+        decompressLz4Chunk(chunk_header);
+    else
+        throw BagFormatException("Unknown compression: " + chunk_header.compression);
+    
+    decompressed_chunk_ = chunk_pos;
+}
+
+void Bag::readMessageDataRecord102(uint64_t offset, ros::Header& header) const {
+    CONSOLE_BRIDGE_logDebug("readMessageDataRecord: offset=%llu", (unsigned long long) offset);
+
+    seek(offset);
+
+    uint32_t data_size;
+    uint8_t op;
+    do {
+        if (!readHeader(header) || !readDataLength(data_size))
+            throw BagFormatException("Error reading header");
+
+        readField(*header.getValues(), OP_FIELD_NAME, true, &op);
+    }
+    while (op == OP_MSG_DEF);
+
+    if (op != OP_MSG_DATA)
+        throw BagFormatException((format("Expected MSG_DATA op, got %d") % op).str());
+
+    record_buffer_.setSize(data_size);
+    file_.read((char*) record_buffer_.getData(), data_size);
+}
+
+// Reading this into a buffer isn't completely necessary, but we do it anyways for now
+void Bag::decompressRawChunk(ChunkHeader const& chunk_header) const {
+    assert(chunk_header.compression == COMPRESSION_NONE);
+
+    CONSOLE_BRIDGE_logDebug("compressed_size: %d uncompressed_size: %d", chunk_header.compressed_size, chunk_header.uncompressed_size);
+
+    encryptor_->decryptChunk(chunk_header, decompress_buffer_, file_);
+
+    // todo check read was successful
+}
+
+void Bag::decompressBz2Chunk(ChunkHeader const& chunk_header) const {
+    assert(chunk_header.compression == COMPRESSION_BZ2);
+
+    CompressionType compression = compression::BZ2;
+
+    CONSOLE_BRIDGE_logDebug("compressed_size: %d uncompressed_size: %d", chunk_header.compressed_size, chunk_header.uncompressed_size);
+
+    encryptor_->decryptChunk(chunk_header, chunk_buffer_, file_);
+
+    decompress_buffer_.setSize(chunk_header.uncompressed_size);
+    file_.decompress(compression, decompress_buffer_.getData(), decompress_buffer_.getSize(), chunk_buffer_.getData(), chunk_buffer_.getSize());
+
+    // todo check read was successful
+}
+
+void Bag::decompressLz4Chunk(ChunkHeader const& chunk_header) const {
+    assert(chunk_header.compression == COMPRESSION_LZ4);
+
+    CompressionType compression = compression::LZ4;
+
+    CONSOLE_BRIDGE_logDebug("lz4 compressed_size: %d uncompressed_size: %d",
+             chunk_header.compressed_size, chunk_header.uncompressed_size);
+
+    encryptor_->decryptChunk(chunk_header, chunk_buffer_, file_);
+
+    decompress_buffer_.setSize(chunk_header.uncompressed_size);
+    file_.decompress(compression, decompress_buffer_.getData(), decompress_buffer_.getSize(), chunk_buffer_.getData(), chunk_buffer_.getSize());
+
+    // todo check read was successful
+}
+
+ros::Header Bag::readMessageDataHeader(IndexEntry const& index_entry) {
+    ros::Header header;
+    uint32_t data_size;
+    uint32_t bytes_read;
+    switch (version_)
+    {
+    case 200:
+        decompressChunk(index_entry.chunk_pos);
+        readMessageDataHeaderFromBuffer(*current_buffer_, index_entry.offset, header, data_size, bytes_read);
+        return header;
+    case 102:
+        readMessageDataRecord102(index_entry.chunk_pos, header);
+        return header;
+    default:
+        throw BagFormatException((format("Unhandled version: %1%") % version_).str());
+    }
+}
+
+// NOTE: this loads the header, which is unnecessary
+uint32_t Bag::readMessageDataSize(IndexEntry const& index_entry) const {
+    ros::Header header;
+    uint32_t data_size;
+    uint32_t bytes_read;
+    switch (version_)
+    {
+    case 200:
+        decompressChunk(index_entry.chunk_pos);
+        readMessageDataHeaderFromBuffer(*current_buffer_, index_entry.offset, header, data_size, bytes_read);
+        return data_size;
+    case 102:
+        readMessageDataRecord102(index_entry.chunk_pos, header);
+        return record_buffer_.getSize();
+    default:
+        throw BagFormatException((format("Unhandled version: %1%") % version_).str());
+    }
+}
+
+void Bag::writeChunkInfoRecords() {
+    for (ChunkInfo const& chunk_info : chunks_) {
+        // Write the chunk info header
+        M_string header;
+        uint32_t chunk_connection_count = chunk_info.connection_counts.size();
+        header[OP_FIELD_NAME]         = toHeaderString(&OP_CHUNK_INFO);
+        header[VER_FIELD_NAME]        = toHeaderString(&CHUNK_INFO_VERSION);
+        header[CHUNK_POS_FIELD_NAME]  = toHeaderString(&chunk_info.pos);
+        header[START_TIME_FIELD_NAME] = toHeaderString(&chunk_info.start_time);
+        header[END_TIME_FIELD_NAME]   = toHeaderString(&chunk_info.end_time);
+        header[COUNT_FIELD_NAME]      = toHeaderString(&chunk_connection_count);
+
+        CONSOLE_BRIDGE_logDebug("Writing CHUNK_INFO [%llu]: ver=%d pos=%llu start=%d.%d end=%d.%d",
+                  (unsigned long long) file_.getOffset(), CHUNK_INFO_VERSION, (unsigned long long) chunk_info.pos,
+                  chunk_info.start_time.sec, chunk_info.start_time.nsec,
+                  chunk_info.end_time.sec, chunk_info.end_time.nsec);
+
+        writeHeader(header);
+
+        writeDataLength(8 * chunk_connection_count);
+
+        // Write the topic names and counts
+        for (map<uint32_t, uint32_t>::const_iterator i = chunk_info.connection_counts.begin(); i != chunk_info.connection_counts.end(); i++) {
+            uint32_t connection_id = i->first;
+            uint32_t count         = i->second;
+
+            write((char*) &connection_id, 4);
+            write((char*) &count, 4);
+
+            CONSOLE_BRIDGE_logDebug("  - %d: %d", connection_id, count);
+        }
+    }
+}
+
+void Bag::readChunkInfoRecord() {
+    // Read a CHUNK_INFO header
+    ros::Header header;
+    uint32_t data_size;
+    if (!readHeader(header) || !readDataLength(data_size))
+        throw BagFormatException("Error reading CHUNK_INFO record header");
+    M_string& fields = *header.getValues();
+    if (!isOp(fields, OP_CHUNK_INFO))
+        throw BagFormatException("Expected CHUNK_INFO op not found");
+
+    // Check that the chunk info version is current
+    uint32_t chunk_info_version;
+    readField(fields, VER_FIELD_NAME, true, &chunk_info_version);
+    if (chunk_info_version != CHUNK_INFO_VERSION)
+        throw BagFormatException((format("Expected CHUNK_INFO version %1%, read %2%") % CHUNK_INFO_VERSION % chunk_info_version).str());
+
+    // Read the chunk position, timestamp, and topic count fields
+    ChunkInfo chunk_info;
+    readField(fields, CHUNK_POS_FIELD_NAME,  true, &chunk_info.pos);
+    readField(fields, START_TIME_FIELD_NAME, true,  chunk_info.start_time);
+    readField(fields, END_TIME_FIELD_NAME,   true,  chunk_info.end_time);
+    uint32_t chunk_connection_count = 0;
+    readField(fields, COUNT_FIELD_NAME,      true, &chunk_connection_count);
+
+    CONSOLE_BRIDGE_logDebug("Read CHUNK_INFO: chunk_pos=%llu connection_count=%d start=%d.%d end=%d.%d",
+              (unsigned long long) chunk_info.pos, chunk_connection_count,
+              chunk_info.start_time.sec, chunk_info.start_time.nsec,
+              chunk_info.end_time.sec, chunk_info.end_time.nsec);
+
+    // Read the topic count entries
+    for (uint32_t i = 0; i < chunk_connection_count; i ++) {
+        uint32_t connection_id, connection_count;
+        read((char*) &connection_id,    4);
+        read((char*) &connection_count, 4);
+
+        CONSOLE_BRIDGE_logDebug("  %d: %d messages", connection_id, connection_count);
+
+        chunk_info.connection_counts[connection_id] = connection_count;
+    }
+
+    chunks_.push_back(chunk_info);
+}
+
+// Record I/O
+
+bool Bag::isOp(M_string& fields, uint8_t reqOp) const {
+    uint8_t op = 0xFF; // nonexistent op
+    readField(fields, OP_FIELD_NAME, true, &op);
+    return op == reqOp;
+}
+
+void Bag::writeHeader(M_string const& fields) {
+    boost::shared_array<uint8_t> header_buffer;
+    uint32_t header_len;
+    ros::Header::write(fields, header_buffer, header_len);
+    write((char*) &header_len, 4);
+    write((char*) header_buffer.get(), header_len);
+}
+
+void Bag::writeDataLength(uint32_t data_len) {
+    write((char*) &data_len, 4);
+}
+
+void Bag::appendHeaderToBuffer(Buffer& buf, M_string const& fields) {
+    boost::shared_array<uint8_t> header_buffer;
+    uint32_t header_len;
+    ros::Header::write(fields, header_buffer, header_len);
+
+    uint32_t offset = buf.getSize();
+
+    buf.setSize(buf.getSize() + 4 + header_len);
+
+    memcpy(buf.getData() + offset, &header_len, 4);
+    offset += 4;
+    memcpy(buf.getData() + offset, header_buffer.get(), header_len);
+}
+
+void Bag::appendDataLengthToBuffer(Buffer& buf, uint32_t data_len) {
+    uint32_t offset = buf.getSize();
+
+    buf.setSize(buf.getSize() + 4);
+
+    memcpy(buf.getData() + offset, &data_len, 4);
+}
+
+//! \todo clean this up
+void Bag::readHeaderFromBuffer(Buffer& buffer, uint32_t offset, ros::Header& header, uint32_t& data_size, uint32_t& bytes_read) const {
+    assert(buffer.getSize() > 8);
+
+    uint8_t* start = (uint8_t*) buffer.getData() + offset;
+
+    uint8_t* ptr = start;
+
+    // Read the header length
+    uint32_t header_len;
+    memcpy(&header_len, ptr, 4);
+    ptr += 4;
+
+    // Parse the header
+    string error_msg;
+    bool parsed = header.parse(ptr, header_len, error_msg);
+    if (!parsed)
+        throw BagFormatException("Error parsing header");
+    ptr += header_len;
+
+    // Read the data size
+    memcpy(&data_size, ptr, 4);
+    ptr += 4;
+
+    bytes_read = ptr - start;
+}
+
+void Bag::readMessageDataHeaderFromBuffer(Buffer& buffer, uint32_t offset, ros::Header& header, uint32_t& data_size, uint32_t& total_bytes_read) const {
+    (void)buffer;
+    total_bytes_read = 0;
+    uint8_t op = 0xFF;
+    do {
+        CONSOLE_BRIDGE_logDebug("reading header from buffer: offset=%d", offset);
+        uint32_t bytes_read;
+        readHeaderFromBuffer(*current_buffer_, offset, header, data_size, bytes_read);
+
+        offset += bytes_read;
+        total_bytes_read += bytes_read;
+        
+        readField(*header.getValues(), OP_FIELD_NAME, true, &op);
+    }
+    while (op == OP_MSG_DEF || op == OP_CONNECTION);
+
+    if (op != OP_MSG_DATA)
+        throw BagFormatException("Expected MSG_DATA op not found");
+}
+
+bool Bag::readHeader(ros::Header& header) const {
+    // Read the header length
+    uint32_t header_len;
+    read((char*) &header_len, 4);
+
+    // Read the header
+    header_buffer_.setSize(header_len);
+    read((char*) header_buffer_.getData(), header_len);
+
+    // Parse the header
+    string error_msg;
+    bool parsed = header.parse(header_buffer_.getData(), header_len, error_msg);
+    if (!parsed)
+        return false;
+
+    return true;
+}
+
+bool Bag::readDataLength(uint32_t& data_size) const {
+    read((char*) &data_size, 4);
+    return true;
+}
+
+M_string::const_iterator Bag::checkField(M_string const& fields, string const& field, unsigned int min_len, unsigned int max_len, bool required) const {
+    M_string::const_iterator fitr = fields.find(field);
+    if (fitr == fields.end()) {
+        if (required)
+            throw BagFormatException("Required '" + field + "' field missing");
+    }
+    else if ((fitr->second.size() < min_len) || (fitr->second.size() > max_len))
+        throw BagFormatException((format("Field '%1%' is wrong size (%2% bytes)") % field % (uint32_t) fitr->second.size()).str());
+
+    return fitr;
+}
+
+bool Bag::readField(M_string const& fields, string const& field_name, bool required, string& data) const {
+    return readField(fields, field_name, 1, UINT_MAX, required, data);
+}
+
+bool Bag::readField(M_string const& fields, string const& field_name, unsigned int min_len, unsigned int max_len, bool required, string& data) const {
+    M_string::const_iterator fitr = checkField(fields, field_name, min_len, max_len, required);
+    if (fitr == fields.end())
+    	return false;
+
+    data = fitr->second;
+    return true;
+}
+
+bool Bag::readField(M_string const& fields, string const& field_name, bool required, Time& data) const {
+    uint64_t packed_time;
+    if (!readField(fields, field_name, required, &packed_time))
+    	return false;
+
+    uint64_t bitmask = (1LL << 33) - 1;
+    data.sec  = (uint32_t) (packed_time & bitmask);
+    data.nsec = (uint32_t) (packed_time >> 32);
+
+    return true;
+}
+
+std::string Bag::toHeaderString(Time const* field) const {
+    uint64_t packed_time = (((uint64_t) field->nsec) << 32) + field->sec;
+    return toHeaderString(&packed_time);
+}
+
+
+// Low-level I/O
+
+void Bag::write(string const& s)                  { write(s.c_str(), s.length()); }
+void Bag::write(char const* s, std::streamsize n) { file_.write((char*) s, n);    }
+
+void Bag::read(char* b, std::streamsize n) const  { file_.read(b, n);             }
+void Bag::seek(uint64_t pos, int origin) const    { file_.seek(pos, origin);      }
+
+void Bag::swap(Bag& other) {
+    using std::swap;
+    swap(mode_, other.mode_);
+    swap(file_, other.file_);
+    swap(version_, other.version_);
+    swap(compression_, other.compression_);
+    swap(chunk_threshold_, other.chunk_threshold_);
+    swap(bag_revision_, other.bag_revision_);
+    swap(file_size_, other.file_size_);
+    swap(file_header_pos_, other.file_header_pos_);
+    swap(index_data_pos_, other.index_data_pos_);
+    swap(connection_count_, other.connection_count_);
+    swap(chunk_count_, other.chunk_count_);
+    swap(chunk_open_, other.chunk_open_);
+    swap(curr_chunk_info_, other.curr_chunk_info_);
+    swap(curr_chunk_data_pos_, other.curr_chunk_data_pos_);
+    swap(topic_connection_ids_, other.topic_connection_ids_);
+    swap(header_connection_ids_, other.header_connection_ids_);
+    swap(connections_, other.connections_);
+    swap(chunks_, other.chunks_);
+    swap(connection_indexes_, other.connection_indexes_);
+    swap(curr_chunk_connection_indexes_, other.curr_chunk_connection_indexes_);
+    swap(header_buffer_, other.header_buffer_);
+    swap(record_buffer_, other.record_buffer_);
+    swap(chunk_buffer_, other.chunk_buffer_);
+    swap(decompress_buffer_, other.decompress_buffer_);
+    swap(outgoing_chunk_buffer_, other.outgoing_chunk_buffer_);
+    swap(current_buffer_, other.current_buffer_);
+    swap(decompressed_chunk_, other.decompressed_chunk_);
+    swap(encryptor_, other.encryptor_);
+}
+
+bool Bag::isOpen() const { return file_.isOpen(); }
+
+} // namespace rosbag
+
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/src/bag_player.cpp
@@ -0,0 +1,67 @@
+#include "rosbag/bag_player.h"
+
+namespace rosbag
+{
+
+BagPlayer::BagPlayer(const std::string &fname) {
+    bag.open(fname, rosbag::bagmode::Read);
+    ros::Time::init();
+    View v(bag);
+    bag_start_ = v.getBeginTime();
+    bag_end_ = v.getEndTime();
+    last_message_time_ = ros::Time(0);
+    playback_speed_ = 1.0;
+}
+
+BagPlayer::~BagPlayer() {
+    bag.close();
+}
+
+ros::Time BagPlayer::get_time() {
+    return last_message_time_;
+}
+
+void BagPlayer::set_start(const ros::Time &start) {
+    bag_start_ = start;
+}
+
+void BagPlayer::set_end(const ros::Time &end) {
+    bag_end_ = end;
+}
+
+void BagPlayer::set_playback_speed(double scale) {
+  if (scale > 0.0)
+    playback_speed_ = scale;
+}
+
+ros::Time BagPlayer::real_time(const ros::Time &msg_time) {
+  return play_start_ + (msg_time - bag_start_) * (1 / playback_speed_);
+}
+
+void BagPlayer::start_play() {
+
+    std::vector<std::string> topics;
+    for (const auto& cb : cbs_)
+        topics.push_back(cb.first);
+
+    View view(bag, TopicQuery(topics), bag_start_, bag_end_);
+    play_start_ = ros::Time::now();
+
+    for (MessageInstance const& m : view)
+    {
+        if (cbs_.find(m.getTopic()) == cbs_.end())
+            continue;
+
+        ros::Time::sleepUntil(real_time(m.getTime()));
+
+        last_message_time_ = m.getTime(); /* this is the recorded time */
+        cbs_[m.getTopic()]->call(m);
+    }
+}
+
+void BagPlayer::unregister_callback(const std::string &topic) {
+    cbs_.erase(topic);
+}
+
+}
+
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/src/buffer.cpp
@@ -0,0 +1,88 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+********************************************************************/
+
+#include <stdlib.h>
+#include <assert.h>
+#include <utility>
+#include <limits>
+
+#include "rosbag/buffer.h"
+
+//#include <ros/ros.h>
+
+namespace rosbag {
+
+Buffer::Buffer() : buffer_(NULL), capacity_(0), size_(0) { }
+
+Buffer::~Buffer() {
+    free(buffer_);
+}
+
+uint8_t* Buffer::getData()           { return buffer_;   }
+uint32_t Buffer::getCapacity() const { return capacity_; }
+uint32_t Buffer::getSize()     const { return size_;     }
+
+void Buffer::setSize(uint32_t size) {
+    size_ = size;
+    ensureCapacity(size);
+}
+
+void Buffer::ensureCapacity(uint32_t capacity) {
+    if (capacity <= capacity_)
+        return;
+
+    if (capacity_ == 0)
+        capacity_ = capacity;
+    else {
+        while (capacity_ < capacity)
+        {
+          if (static_cast<uint64_t>(capacity) * 2 > std::numeric_limits<uint32_t>::max())
+            capacity_ = std::numeric_limits<uint32_t>::max();
+          else
+            capacity_ *= 2;
+        }
+    }
+
+    buffer_ = (uint8_t*) realloc(buffer_, capacity_);
+    assert(buffer_);
+}
+
+void Buffer::swap(Buffer& other) {
+    using std::swap;
+    swap(buffer_, other.buffer_);
+    swap(capacity_, other.capacity_);
+    swap(size_, other.size_);
+}
+
+} // namespace rosbag
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/src/bz2_stream.cpp
@@ -0,0 +1,174 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+********************************************************************/
+
+#include "rosbag/chunked_file.h"
+
+#include <iostream>
+#include <cstring>
+#include "console_bridge/console.h"
+
+using std::string;
+
+namespace rosbag {
+
+BZ2Stream::BZ2Stream(ChunkedFile* file) :
+    Stream(file),
+    verbosity_(0),
+    block_size_100k_(9),
+    work_factor_(30),
+    bzfile_(NULL),
+    bzerror_(0)
+{ }
+
+CompressionType BZ2Stream::getCompressionType() const {
+    return compression::BZ2;
+}
+
+void BZ2Stream::startWrite() {
+    bzfile_ = BZ2_bzWriteOpen(&bzerror_, getFilePointer(), block_size_100k_, verbosity_, work_factor_);
+
+    switch (bzerror_) {
+        case BZ_OK: break;
+        default: {
+            BZ2_bzWriteClose(&bzerror_, bzfile_, 0, NULL, NULL);
+            throw BagException("Error opening file for writing compressed stream");
+        }
+    }
+
+    setCompressedIn(0);
+}
+
+void BZ2Stream::write(void* ptr, size_t size) {
+    if (!bzfile_) {
+        throw BagException("cannot write to unopened bzfile");
+    }
+
+    BZ2_bzWrite(&bzerror_, bzfile_, ptr, size);
+
+    switch (bzerror_) {
+    case BZ_IO_ERROR: throw BagException("BZ_IO_ERROR: error writing the compressed file");
+    }
+
+    setCompressedIn(getCompressedIn() + size);
+}
+
+void BZ2Stream::stopWrite() {
+    if (!bzfile_) {
+        throw BagException("cannot close unopened bzfile");
+    }
+
+    unsigned int nbytes_in;
+    unsigned int nbytes_out;
+    BZ2_bzWriteClose(&bzerror_, bzfile_, 0, &nbytes_in, &nbytes_out);
+
+    switch (bzerror_) {
+        case BZ_IO_ERROR: throw BagIOException("BZ_IO_ERROR");
+    }
+
+    advanceOffset(nbytes_out);
+    setCompressedIn(0);
+}
+
+void BZ2Stream::startRead() {
+    bzfile_ = BZ2_bzReadOpen(&bzerror_, getFilePointer(), verbosity_, 0, getUnused(), getUnusedLength());
+
+    switch (bzerror_) {
+        case BZ_OK: break;
+        default: {
+            BZ2_bzReadClose(&bzerror_, bzfile_);
+            throw BagException("Error opening file for reading compressed stream");
+        }
+    }
+
+    clearUnused();
+}
+
+void BZ2Stream::read(void* ptr, size_t size) {
+    if (!bzfile_) {
+        throw BagException("cannot read from unopened bzfile");
+    }
+
+    BZ2_bzRead(&bzerror_, bzfile_, ptr, size);
+
+    advanceOffset(size);
+
+    switch (bzerror_) {
+    case BZ_OK: return;
+    case BZ_STREAM_END:
+        if (getUnused() || getUnusedLength() > 0) {
+            CONSOLE_BRIDGE_logError("unused data already available");
+	} else {
+            char* unused;
+            int nUnused;
+            BZ2_bzReadGetUnused(&bzerror_, bzfile_, (void**) &unused, &nUnused);
+            setUnused(unused);
+            setUnusedLength(nUnused);
+        }
+        return;
+    case BZ_IO_ERROR:         throw BagIOException("BZ_IO_ERROR: error reading from compressed stream");                                break;
+    case BZ_UNEXPECTED_EOF:   throw BagIOException("BZ_UNEXPECTED_EOF: compressed stream ended before logical end-of-stream detected"); break;
+    case BZ_DATA_ERROR:       throw BagIOException("BZ_DATA_ERROR: data integrity error detected in compressed stream");                break;
+    case BZ_DATA_ERROR_MAGIC: throw BagIOException("BZ_DATA_ERROR_MAGIC: stream does not begin with requisite header bytes");           break;
+    case BZ_MEM_ERROR:        throw BagIOException("BZ_MEM_ERROR: insufficient memory available");                                      break;
+    }
+}
+
+void BZ2Stream::stopRead() {
+    if (!bzfile_) {
+        throw BagException("cannot close unopened bzfile");
+    }
+
+    BZ2_bzReadClose(&bzerror_, bzfile_);
+
+    switch (bzerror_) {
+        case BZ_IO_ERROR: throw BagIOException("BZ_IO_ERROR");
+    }
+}
+
+void BZ2Stream::decompress(uint8_t* dest, unsigned int dest_len, uint8_t* source, unsigned int source_len) {
+    int result = BZ2_bzBuffToBuffDecompress((char*) dest, &dest_len, (char*) source, source_len, 0, verbosity_);
+
+    switch (result) {
+    case BZ_OK:               break;
+    case BZ_CONFIG_ERROR:     throw BagException("library has been mis-compiled"); break;
+    case BZ_PARAM_ERROR:      throw BagException("dest is NULL or destLen is NULL or small != 0 && small != 1 or verbosity < 0 or verbosity > 4"); break;
+    case BZ_MEM_ERROR:        throw BagException("insufficient memory is available"); break;
+    case BZ_OUTBUFF_FULL:     throw BagException("size of the compressed data exceeds *destLen"); break;
+    case BZ_DATA_ERROR:       throw BagException("data integrity error was detected in the compressed data"); break;
+    case BZ_DATA_ERROR_MAGIC: throw BagException("compressed data doesn't begin with the right magic bytes"); break;
+    case BZ_UNEXPECTED_EOF:   throw BagException("compressed data ends unexpectedly"); break;
+    }
+}
+
+} // namespace rosbag
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/src/chunked_file.cpp
@@ -0,0 +1,259 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+********************************************************************/
+
+#include "rosbag/chunked_file.h"
+
+#include <iostream>
+
+#include <boost/format.hpp>
+#include <boost/make_shared.hpp>
+
+//#include <ros/ros.h>
+#ifdef _WIN32
+#    ifdef __MINGW32__
+#      define fseeko fseeko64
+#      define ftello ftello64
+//     not sure if we need a ftruncate here yet or not
+#    else
+#        include <io.h>
+#        define fseeko _fseeki64
+#        define ftello _ftelli64
+#        define fileno _fileno
+#        define ftruncate _chsize
+#    endif
+#endif
+
+using std::string;
+using boost::format;
+using boost::shared_ptr;
+using ros::Exception;
+
+namespace rosbag {
+
+ChunkedFile::ChunkedFile() :
+    file_(NULL),
+    offset_(0),
+    compressed_in_(0),
+    unused_(NULL),
+    nUnused_(0)
+{
+    stream_factory_ = boost::make_shared<StreamFactory>(this);
+}
+
+ChunkedFile::~ChunkedFile() {
+    close();
+}
+
+void ChunkedFile::openReadWrite(string const& filename) { open(filename, "r+b"); }
+void ChunkedFile::openWrite    (string const& filename) { open(filename, "w+b");  }
+void ChunkedFile::openRead     (string const& filename) { open(filename, "rb");  }
+
+void ChunkedFile::open(string const& filename, string const& mode) {
+    // Check if file is already open
+    if (file_)
+        throw BagIOException((format("File already open: %1%") % filename_.c_str()).str());
+
+    // Open the file
+    if (mode == "r+b") {
+        // check if file already exists
+        #if defined(_MSC_VER) && (_MSC_VER >= 1400 )
+            fopen_s( &file_, filename.c_str(), "r" );
+        #else
+            file_ = fopen(filename.c_str(), "r");
+        #endif
+        if (file_ == NULL)
+            // create an empty file and open it for update
+            #if defined(_MSC_VER) && (_MSC_VER >= 1400 )
+                fopen_s( &file_, filename.c_str(), "w+b" );
+            #else
+                file_ = fopen(filename.c_str(), "w+b");
+            #endif
+        else {
+            if (fclose(file_) != 0)
+              throw BagIOException((format("Error closing file: %1%") % filename.c_str()).str());
+
+            // open existing file for update
+            #if defined(_MSC_VER) && (_MSC_VER >= 1400 )
+                fopen_s( &file_, filename.c_str(), "r+b" );
+            #else
+                file_ = fopen(filename.c_str(), "r+b");
+            #endif
+        }
+    }
+    else
+        #if defined(_MSC_VER) && (_MSC_VER >= 1400 )
+            fopen_s( &file_, filename.c_str(), mode.c_str() );
+        #else
+            file_ = fopen(filename.c_str(), mode.c_str());
+        #endif
+
+    if (!file_)
+        throw BagIOException((format("Error opening file: %1%") % filename.c_str()).str());
+
+    read_stream_  = boost::make_shared<UncompressedStream>(this);
+    write_stream_ = boost::make_shared<UncompressedStream>(this);
+    filename_     = filename;
+    offset_       = ftello(file_);
+}
+
+bool ChunkedFile::good() const {
+    return feof(file_) == 0 && ferror(file_) == 0;
+}
+
+bool   ChunkedFile::isOpen()      const { return file_ != NULL; }
+string ChunkedFile::getFileName() const { return filename_;     }
+
+void ChunkedFile::close() {
+    if (!file_)
+        return;
+
+    // Close any compressed stream by changing to uncompressed mode
+    setWriteMode(compression::Uncompressed);
+
+    // Close the file
+    int success = fclose(file_);
+    if (success != 0)
+        throw BagIOException((format("Error closing file: %1%") % filename_.c_str()).str());
+
+    file_ = NULL;
+    filename_.clear();
+    
+    clearUnused();
+    offset_ = 0;
+    compressed_in_ = 0;
+}
+
+// Read/write modes
+
+void ChunkedFile::setWriteMode(CompressionType type) {
+    if (!file_)
+        throw BagIOException("Can't set compression mode before opening a file");
+
+    if (type != write_stream_->getCompressionType()) {
+        write_stream_->stopWrite();
+        shared_ptr<Stream> stream = stream_factory_->getStream(type);
+        stream->startWrite();
+        write_stream_ = stream;
+    }
+}
+
+void ChunkedFile::setReadMode(CompressionType type) {
+    if (!file_)
+        throw BagIOException("Can't set compression mode before opening a file");
+
+    if (type != read_stream_->getCompressionType()) {
+        read_stream_->stopRead();
+        shared_ptr<Stream> stream = stream_factory_->getStream(type);
+        stream->startRead();
+        read_stream_ = stream;
+    }
+}
+
+void ChunkedFile::seek(uint64_t offset, int origin) {
+    if (!file_)
+        throw BagIOException("Can't seek - file not open");
+
+    setReadMode(compression::Uncompressed);
+
+    int success = fseeko(file_, offset, origin);
+    if (success != 0)
+        throw BagIOException("Error seeking");
+
+    offset_ = ftello(file_);
+}
+
+uint64_t ChunkedFile::getOffset()            const { return offset_;        }
+uint32_t ChunkedFile::getCompressedBytesIn() const { return compressed_in_; }
+
+void ChunkedFile::write(string const& s)        { write((void*) s.c_str(), s.size()); }
+void ChunkedFile::write(void* ptr, size_t size) { write_stream_->write(ptr, size);    }
+void ChunkedFile::read(void* ptr, size_t size)  { read_stream_->read(ptr, size);      }
+
+bool ChunkedFile::truncate(uint64_t length) {
+    int fd = fileno(file_);
+    return ftruncate(fd, length) == 0;
+}
+
+//! \todo add error handling
+string ChunkedFile::getline() {
+    char buffer[1024];
+    if(fgets(buffer, 1024, file_))
+    {
+      string s(buffer);
+      offset_ += s.size();
+      return s;
+    }
+    else
+      return string("");
+}
+
+void ChunkedFile::decompress(CompressionType compression, uint8_t* dest, unsigned int dest_len, uint8_t* source, unsigned int source_len) {
+    stream_factory_->getStream(compression)->decompress(dest, dest_len, source, source_len);
+}
+
+void ChunkedFile::clearUnused() {
+    unused_ = NULL;
+    nUnused_ = 0;
+}
+
+void ChunkedFile::swap(ChunkedFile& other) {
+    using std::swap;
+    using boost::swap;
+    swap(filename_, other.filename_);
+    swap(file_, other.file_);
+    swap(offset_, other.offset_);
+    swap(compressed_in_, other.compressed_in_);
+    swap(unused_, other.unused_);
+    swap(nUnused_, other.nUnused_);
+
+    swap(stream_factory_, other.stream_factory_);
+
+    FileAccessor::setFile(*stream_factory_->getStream(compression::Uncompressed), this);
+    FileAccessor::setFile(*stream_factory_->getStream(compression::BZ2), this);
+    FileAccessor::setFile(*stream_factory_->getStream(compression::LZ4), this);
+
+    FileAccessor::setFile(*other.stream_factory_->getStream(compression::Uncompressed), &other);
+    FileAccessor::setFile(*other.stream_factory_->getStream(compression::BZ2), &other);
+    FileAccessor::setFile(*other.stream_factory_->getStream(compression::LZ4), &other);
+
+    swap(read_stream_, other.read_stream_);
+    FileAccessor::setFile(*read_stream_, this);
+    FileAccessor::setFile(*other.read_stream_, &other);
+
+    swap(write_stream_, other.write_stream_);
+    FileAccessor::setFile(*write_stream_, this);
+    FileAccessor::setFile(*other.write_stream_, &other);
+}
+
+} // namespace rosbag
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/src/gpgme_utils.cpp
@@ -0,0 +1,90 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2017, Open Source Robotics Foundation
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#include "rosbag/gpgme_utils.h"
+
+#include <boost/format.hpp>
+
+namespace rosbag
+{
+
+void initGpgme() {
+    // Check version method must be called before en/decryption
+    gpgme_check_version(0);
+    // Set locale
+    setlocale(LC_ALL, "");
+    gpgme_set_locale(NULL, LC_CTYPE, setlocale(LC_CTYPE, NULL));
+#ifdef LC_MESSAGES
+    gpgme_set_locale(NULL, LC_MESSAGES, setlocale(LC_MESSAGES, NULL));
+#endif
+}
+
+void getGpgKey(gpgme_ctx_t& ctx, std::string const& user, gpgme_key_t& key) {
+    gpgme_error_t err;
+    // Asterisk means an arbitrary user.
+    if (user == std::string("*")) {
+        err = gpgme_op_keylist_start(ctx, 0, 0);
+    } else {
+        err = gpgme_op_keylist_start(ctx, user.c_str(), 0);
+    }
+    if (err) {
+        throw BagException((boost::format("gpgme_op_keylist_start returned %1%") % gpgme_strerror(err)).str());
+    }
+    while (true) {
+        err = gpgme_op_keylist_next(ctx, &key);
+        if (!err) {
+            if (user == std::string("*") || strcmp(key->uids->name, user.c_str()) == 0) {
+                break;
+            }
+            gpgme_key_release(key);
+        } else if (gpg_err_code(err) == GPG_ERR_EOF) {
+            if (user == std::string("*")) {
+                // A method throws an exception (instead of returning a specific value) if the key is not found
+                // This allows rosbag client applications to work without modifying their source code
+                throw BagException("GPG key not found");
+            } else {
+                throw BagException((boost::format("GPG key not found for a user %1%") % user.c_str()).str());
+            }
+        } else {
+            throw BagException((boost::format("gpgme_op_keylist_next returned %1%") % err).str());
+        }
+    }
+    err = gpgme_op_keylist_end(ctx);
+    if (err) {
+        throw BagException((boost::format("gpgme_op_keylist_end returned %1%") % gpgme_strerror(err)).str());
+    }
+}
+
+
+}  // namespace rosbag
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/src/lz4_stream.cpp
@@ -0,0 +1,229 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2014, Ben Charrow
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+********************************************************************/
+
+#include "rosbag/chunked_file.h"
+
+#include <iostream>
+#include <cstring>
+#include "console_bridge/console.h"
+
+using std::string;
+
+namespace rosbag {
+
+LZ4Stream::LZ4Stream(ChunkedFile* file)
+    : Stream(file), block_size_id_(6) {
+    buff_size_ = roslz4_blockSizeFromIndex(block_size_id_) + 64;
+    buff_ = new char[buff_size_];
+    lz4s_.state = NULL;
+}
+
+LZ4Stream::~LZ4Stream() {
+    delete[] buff_;
+}
+
+CompressionType LZ4Stream::getCompressionType() const {
+    return compression::LZ4;
+}
+
+void LZ4Stream::startWrite() {
+    if (lz4s_.state) {
+        throw BagException("cannot start writing to already opened lz4 stream");
+    }
+
+    setCompressedIn(0);
+
+    int ret = roslz4_compressStart(&lz4s_, block_size_id_);
+    switch(ret) {
+    case ROSLZ4_OK: break;
+    case ROSLZ4_MEMORY_ERROR: throw BagIOException("ROSLZ4_MEMORY_ERROR: insufficient memory available"); break;
+    case ROSLZ4_PARAM_ERROR: throw BagIOException("ROSLZ4_PARAM_ERROR: bad block size"); break;
+    default: throw BagException("Unhandled return code");
+    }
+    lz4s_.output_next = buff_;
+    lz4s_.output_left = buff_size_;
+}
+
+void LZ4Stream::write(void* ptr, size_t size) {
+    if (!lz4s_.state) {
+        throw BagException("cannot write to unopened lz4 stream");
+    }
+
+    lz4s_.input_left = size;
+    lz4s_.input_next = (char*) ptr;
+
+    writeStream(ROSLZ4_RUN);
+    setCompressedIn(getCompressedIn() + size);
+}
+
+void LZ4Stream::writeStream(int action) {
+    int ret = ROSLZ4_OK;
+    while (lz4s_.input_left > 0 ||
+           (action == ROSLZ4_FINISH && ret != ROSLZ4_STREAM_END)) {
+        ret = roslz4_compress(&lz4s_, action);
+        switch(ret) {
+        case ROSLZ4_OK: break;
+        case ROSLZ4_OUTPUT_SMALL:
+            if (lz4s_.output_next - buff_ == buff_size_) {
+                throw BagIOException("ROSLZ4_OUTPUT_SMALL: output buffer is too small");
+            } else {
+                // There's data to be written in buff_; this will free up space
+                break;
+            }
+        case ROSLZ4_STREAM_END: break;
+        case ROSLZ4_PARAM_ERROR: throw BagIOException("ROSLZ4_PARAM_ERROR: bad block size"); break;
+        case ROSLZ4_ERROR: throw BagIOException("ROSLZ4_ERROR: compression error"); break;
+        default: throw BagException("Unhandled return code");
+        }
+
+        // If output data is ready, write to disk
+        int to_write = lz4s_.output_next - buff_;
+        if (to_write > 0) {
+            if (fwrite(buff_, 1, to_write, getFilePointer()) != static_cast<size_t>(to_write)) {
+                throw BagException("Problem writing data to disk");
+            }
+            advanceOffset(to_write);
+            lz4s_.output_next = buff_;
+            lz4s_.output_left = buff_size_;
+        }
+    }
+}
+
+void LZ4Stream::stopWrite() {
+    if (!lz4s_.state) {
+        throw BagException("cannot close unopened lz4 stream");
+    }
+
+    writeStream(ROSLZ4_FINISH);
+    setCompressedIn(0);
+    roslz4_compressEnd(&lz4s_);
+}
+
+void LZ4Stream::startRead() {
+    if (lz4s_.state) {
+        throw BagException("cannot start reading from already opened lz4 stream");
+    }
+
+    int ret = roslz4_decompressStart(&lz4s_);
+    switch(ret) {
+    case ROSLZ4_OK: break;
+    case ROSLZ4_MEMORY_ERROR: throw BagException("ROSLZ4_MEMORY_ERROR: insufficient memory available"); break;
+    default: throw BagException("Unhandled return code");
+    }
+
+    if (getUnusedLength() > buff_size_) {
+        throw BagException("Too many unused bytes to decompress");
+    }
+
+    // getUnused() could be pointing to part of buff_, so don't use memcpy
+    memmove(buff_, getUnused(), getUnusedLength());
+    lz4s_.input_next = buff_;
+    lz4s_.input_left = getUnusedLength();
+    clearUnused();
+}
+
+void LZ4Stream::read(void* ptr, size_t size) {
+    if (!lz4s_.state) {
+        throw BagException("cannot read from unopened lz4 stream");
+    }
+
+    // Setup stream by filling buffer with data from file
+    int to_read = buff_size_ - lz4s_.input_left;
+    char *input_start = buff_ + lz4s_.input_left;
+    int nread = fread(input_start, 1, to_read, getFilePointer());
+    if (ferror(getFilePointer())) {
+        throw BagIOException("Problem reading from file");
+    }
+    lz4s_.input_next = buff_;
+    lz4s_.input_left += nread;
+    lz4s_.output_next = (char*) ptr;
+    lz4s_.output_left = size;
+
+    // Decompress.  If reach end of stream, store unused data
+    int ret = roslz4_decompress(&lz4s_);
+    switch (ret) {
+    case ROSLZ4_OK: break;
+    case ROSLZ4_STREAM_END:
+        if (getUnused() || getUnusedLength() > 0) {
+            CONSOLE_BRIDGE_logError("unused data already available");
+	} else {
+            setUnused(lz4s_.input_next);
+            setUnusedLength(lz4s_.input_left);
+        }
+        return;
+    case ROSLZ4_ERROR: throw BagException("ROSLZ4_ERROR: decompression error"); break;
+    case ROSLZ4_MEMORY_ERROR: throw BagException("ROSLZ4_MEMORY_ERROR: insufficient memory available"); break;
+    case ROSLZ4_OUTPUT_SMALL: throw BagException("ROSLZ4_OUTPUT_SMALL: output buffer is too small"); break;
+    case ROSLZ4_DATA_ERROR: throw BagException("ROSLZ4_DATA_ERROR: malformed data to decompress"); break;
+    default: throw BagException("Unhandled return code");
+    }
+    if (feof(getFilePointer())) {
+        throw BagIOException("Reached end of file before reaching end of stream");
+    }
+
+    size_t total_out = lz4s_.output_next - (char*)ptr;
+    advanceOffset(total_out);
+
+    // Shift input buffer if there's unconsumed data
+    if (lz4s_.input_left > 0) {
+        memmove(buff_, lz4s_.input_next, lz4s_.input_left);
+    }
+}
+
+void LZ4Stream::stopRead() {
+    if (!lz4s_.state) {
+        throw BagException("cannot close unopened lz4 stream");
+    }
+
+    roslz4_decompressEnd(&lz4s_);
+}
+
+void LZ4Stream::decompress(uint8_t* dest, unsigned int dest_len, uint8_t* source, unsigned int source_len) {
+    unsigned int actual_dest_len = dest_len;
+    int ret = roslz4_buffToBuffDecompress((char*)source, source_len,
+                                          (char*)dest, &actual_dest_len);
+    switch(ret) {
+    case ROSLZ4_OK: break;
+    case ROSLZ4_ERROR: throw BagException("ROSLZ4_ERROR: decompression error"); break;
+    case ROSLZ4_MEMORY_ERROR: throw BagException("ROSLZ4_MEMORY_ERROR: insufficient memory available"); break;
+    case ROSLZ4_OUTPUT_SMALL: throw BagException("ROSLZ4_OUTPUT_SMALL: output buffer is too small"); break;
+    case ROSLZ4_DATA_ERROR: throw BagException("ROSLZ4_DATA_ERROR: malformed data to decompress"); break;
+    default: throw BagException("Unhandled return code");
+    }
+    if (actual_dest_len != dest_len) {
+        throw BagException("Decompression size mismatch in LZ4 chunk");
+    }
+}
+
+} // namespace rosbag
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/src/message_instance.cpp
@@ -0,0 +1,65 @@
+// Copyright (c) 2009, Willow Garage, Inc.
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in the
+//       documentation and/or other materials provided with the distribution.
+//     * Neither the name of Willow Garage, Inc. nor the names of its
+//       contributors may be used to endorse or promote products derived from
+//       this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "rosbag/message_instance.h"
+
+#include "ros/message_event.h"
+
+using std::string;
+using ros::Time;
+using boost::shared_ptr;
+
+namespace rosbag {
+
+MessageInstance::MessageInstance(ConnectionInfo const* connection_info, IndexEntry const& index_entry, Bag const& bag) :
+	connection_info_(connection_info), index_entry_(index_entry), bag_(&bag)
+{
+}
+
+Time const&   MessageInstance::getTime()              const { return index_entry_.time;          }
+string const& MessageInstance::getTopic()             const { return connection_info_->topic;    }
+string const& MessageInstance::getDataType()          const { return connection_info_->datatype; }
+string const& MessageInstance::getMD5Sum()            const { return connection_info_->md5sum;   }
+string const& MessageInstance::getMessageDefinition() const { return connection_info_->msg_def;  }
+
+shared_ptr<ros::M_string> MessageInstance::getConnectionHeader() const { return connection_info_->header; }
+
+string MessageInstance::getCallerId() const {
+    ros::M_string::const_iterator header_iter = connection_info_->header->find("callerid");
+    return header_iter != connection_info_->header->end() ? header_iter->second : string("");
+}
+
+bool MessageInstance::isLatching() const {
+    ros::M_string::const_iterator header_iter = connection_info_->header->find("latching");
+    return header_iter != connection_info_->header->end() && header_iter->second == "1";
+}
+
+uint32_t MessageInstance::size() const {
+    return bag_->readMessageDataSize(index_entry_);
+}
+
+} // namespace rosbag
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/src/no_encryptor.cpp
@@ -0,0 +1,60 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2017, Open Source Robotics Foundation
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#include "rosbag/bag.h"
+#include "rosbag/no_encryptor.h"
+
+#include <pluginlib/class_list_macros.hpp>
+
+PLUGINLIB_EXPORT_CLASS(rosbag::NoEncryptor, rosbag::EncryptorBase)
+
+namespace rosbag
+{
+
+uint32_t NoEncryptor::encryptChunk(const uint32_t chunk_size, const uint64_t, ChunkedFile&) { return chunk_size; }
+
+void NoEncryptor::decryptChunk(ChunkHeader const& chunk_header, Buffer& decrypted_chunk, ChunkedFile& file) const {
+    decrypted_chunk.setSize(chunk_header.compressed_size);
+    file.read((char*) decrypted_chunk.getData(), chunk_header.compressed_size);
+}
+
+void NoEncryptor::writeEncryptedHeader(boost::function<void(ros::M_string const&)> write_header, ros::M_string const& header_fields, ChunkedFile&) {
+    write_header(header_fields);
+}
+
+bool NoEncryptor::readEncryptedHeader(boost::function<bool(ros::Header&)> read_header, ros::Header& header, Buffer&, ChunkedFile&) {
+    return read_header(header);
+}
+
+}  // namespace rosbag
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/src/query.cpp
@@ -0,0 +1,102 @@
+// Copyright (c) 2009, Willow Garage, Inc.
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in the
+//       documentation and/or other materials provided with the distribution.
+//     * Neither the name of Willow Garage, Inc. nor the names of its
+//       contributors may be used to endorse or promote products derived from
+//       this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "rosbag/query.h"
+#include "rosbag/bag.h"
+
+using std::map;
+using std::string;
+using std::vector;
+using std::multiset;
+
+namespace rosbag {
+
+// Query
+
+Query::Query(boost::function<bool(ConnectionInfo const*)>& query, ros::Time const& start_time, ros::Time const& end_time)
+	: query_(query), start_time_(start_time), end_time_(end_time)
+{
+}
+
+boost::function<bool(ConnectionInfo const*)> const& Query::getQuery() const {
+	return query_;
+}
+
+ros::Time const& Query::getStartTime() const { return start_time_; }
+ros::Time const& Query::getEndTime()   const { return end_time_;   }
+
+// TopicQuery
+
+TopicQuery::TopicQuery(std::string const& topic) {
+    topics_.push_back(topic);
+}
+
+TopicQuery::TopicQuery(std::vector<std::string> const& topics) : topics_(topics) { }
+
+bool TopicQuery::operator()(ConnectionInfo const* info) const {
+    return std::find(std::begin(topics_), std::end(topics_), info->topic) != std::end(topics_);
+}
+
+// TypeQuery
+
+TypeQuery::TypeQuery(std::string const& type) {
+    types_.push_back(type);
+}
+
+TypeQuery::TypeQuery(std::vector<std::string> const& types) : types_(types) { }
+
+bool TypeQuery::operator()(ConnectionInfo const* info) const {
+    return std::find(std::begin(types_), std::end(types_), info->datatype) != std::end(types_);
+}
+
+// BagQuery
+
+BagQuery::BagQuery(Bag const* _bag, Query const& _query, uint32_t _bag_revision) : bag(_bag), query(_query), bag_revision(_bag_revision) {
+}
+
+// MessageRange
+
+MessageRange::MessageRange(std::multiset<IndexEntry>::const_iterator const& _begin,
+                           std::multiset<IndexEntry>::const_iterator const& _end,
+                           ConnectionInfo const* _connection_info,
+                           BagQuery const* _bag_query)
+	: begin(_begin), end(_end), connection_info(_connection_info), bag_query(_bag_query)
+{
+}
+
+// ViewIterHelper
+
+ViewIterHelper::ViewIterHelper(std::multiset<IndexEntry>::const_iterator _iter, MessageRange const* _range)
+	: iter(_iter), range(_range)
+{
+}
+
+bool ViewIterHelperCompare::operator()(ViewIterHelper const& a, ViewIterHelper const& b) {
+	return (a.iter)->time > (b.iter)->time;
+}
+
+} // namespace rosbag
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/src/stream.cpp
@@ -0,0 +1,83 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+********************************************************************/
+
+#include "rosbag/stream.h"
+#include "rosbag/chunked_file.h"
+
+//#include <ros/ros.h>
+
+using boost::shared_ptr;
+
+namespace rosbag {
+
+// StreamFactory
+
+StreamFactory::StreamFactory(ChunkedFile* file) :
+    uncompressed_stream_(new UncompressedStream(file)),
+    bz2_stream_         (new BZ2Stream(file)),
+    lz4_stream_         (new LZ4Stream(file))
+{
+}
+
+shared_ptr<Stream> StreamFactory::getStream(CompressionType type) const {
+    switch (type) {
+        case compression::Uncompressed: return uncompressed_stream_;
+        case compression::BZ2:          return bz2_stream_;
+        case compression::LZ4:          return lz4_stream_;
+        default:                        return shared_ptr<Stream>();
+    }
+}
+
+// Stream
+
+Stream::Stream(ChunkedFile* file) : file_(file) { }
+
+Stream::~Stream() { }
+
+void Stream::startWrite() { }
+void Stream::stopWrite()  { }
+void Stream::startRead()  { }
+void Stream::stopRead()   { }
+
+FILE*    Stream::getFilePointer()                 { return file_->file_;            }
+uint64_t Stream::getCompressedIn()                { return file_->compressed_in_;   }
+void     Stream::setCompressedIn(uint64_t nbytes) { file_->compressed_in_ = nbytes; }
+void     Stream::advanceOffset(uint64_t nbytes)   { file_->offset_ += nbytes;       }
+char*    Stream::getUnused()                      { return file_->unused_;          }
+int      Stream::getUnusedLength()                { return file_->nUnused_;         }
+void     Stream::setUnused(char* unused)          { file_->unused_ = unused;        }
+void     Stream::setUnusedLength(int nUnused)     { file_->nUnused_ = nUnused;      }
+void     Stream::clearUnused()                    { file_->clearUnused();           }
+
+} // namespace rosbag
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/src/uncompressed_stream.cpp
@@ -0,0 +1,114 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+********************************************************************/
+
+#include "rosbag/chunked_file.h"
+
+#include <iostream>
+#include <cstring>
+
+#include <boost/format.hpp>
+
+using std::string;
+using boost::format;
+using ros::Exception;
+
+namespace rosbag {
+
+UncompressedStream::UncompressedStream(ChunkedFile* file) : Stream(file) { }
+
+CompressionType UncompressedStream::getCompressionType() const {
+    return compression::Uncompressed;
+}
+
+void UncompressedStream::write(void* ptr, size_t size) {
+    size_t result = fwrite(ptr, 1, size, getFilePointer());
+    if (result != size)
+        throw BagIOException((format("Error writing to file: writing %1% bytes, wrote %2% bytes") % size % result).str());
+
+    advanceOffset(size);
+}
+
+void UncompressedStream::read(void* ptr, size_t size) {
+    size_t nUnused = (size_t) getUnusedLength();
+    char* unused = getUnused();
+
+    if (nUnused > 0) {
+        // We have unused data from the last compressed read
+        if (nUnused == size) {
+            // Copy the unused data into the buffer
+            memcpy(ptr, unused, nUnused);
+
+            clearUnused();
+        }
+        else if (nUnused < size) {
+            // Copy the unused data into the buffer
+            memcpy(ptr, unused, nUnused);
+
+            // Still have data to read
+            size -= nUnused;
+
+            // Read the remaining data from the file
+            int result = fread((char*) ptr + nUnused, 1, size, getFilePointer());
+            if ((size_t) result != size)
+                throw BagIOException((format("Error reading from file + unused: wanted %1% bytes, read %2% bytes") % size % result).str());
+
+            advanceOffset(size);
+
+            clearUnused();
+        }
+        else {
+            // nUnused_ > size
+            memcpy(ptr, unused, size);
+
+            setUnused(unused + size);
+            setUnusedLength(nUnused - size);
+        }
+    }
+    
+    // No unused data - read from stream
+    int result = fread(ptr, 1, size, getFilePointer());
+    if ((size_t) result != size)
+        throw BagIOException((format("Error reading from file: wanted %1% bytes, read %2% bytes") % size % result).str());
+
+    advanceOffset(size);
+}
+
+void UncompressedStream::decompress(uint8_t* dest, unsigned int dest_len, uint8_t* source, unsigned int source_len) {
+    if (dest_len < source_len)
+        throw BagException("dest_len not large enough");
+
+    memcpy(dest, source, source_len);
+}
+
+} // namespace rosbag
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/src/view.cpp
@@ -0,0 +1,348 @@
+// Copyright (c) 2009, Willow Garage, Inc.
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in the
+//       documentation and/or other materials provided with the distribution.
+//     * Neither the name of Willow Garage, Inc. nor the names of its
+//       contributors may be used to endorse or promote products derived from
+//       this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "rosbag/view.h"
+#include "rosbag/bag.h"
+#include "rosbag/message_instance.h"
+
+#include <set>
+#include <assert.h>
+
+using std::map;
+using std::string;
+using std::vector;
+using std::multiset;
+
+namespace rosbag {
+
+// View::iterator
+
+View::iterator::iterator() : view_(NULL), view_revision_(0), message_instance_(NULL) { }
+
+View::iterator::~iterator()
+{
+  if (message_instance_ != NULL)
+    delete message_instance_;
+}
+
+View::iterator::iterator(View* view, bool end) : view_(view), view_revision_(0), message_instance_(NULL) {
+    if (view != NULL && !end)
+        populate();
+}
+
+View::iterator::iterator(const iterator& i) : view_(i.view_), iters_(i.iters_), view_revision_(i.view_revision_), message_instance_(NULL) { }
+
+View::iterator &View::iterator::operator=(iterator const& i) {
+    if (this != &i) {
+        view_ = i.view_;
+        iters_ = i.iters_;
+        view_revision_ = i.view_revision_;
+        if (message_instance_ != NULL) {
+            delete message_instance_;
+            message_instance_ = NULL;
+        }
+    }
+    return *this;
+}
+
+void View::iterator::populate() {
+    assert(view_ != NULL);
+
+    iters_.clear();
+    for (MessageRange const* range : view_->ranges_)
+        if (range->begin != range->end)
+            iters_.push_back(ViewIterHelper(range->begin, range));
+
+    std::sort(iters_.begin(), iters_.end(), ViewIterHelperCompare());
+    view_revision_ = view_->view_revision_;
+}
+
+void View::iterator::populateSeek(multiset<IndexEntry>::const_iterator iter) {
+    assert(view_ != NULL);
+
+    iters_.clear();
+    for (MessageRange const* range : view_->ranges_) {
+        multiset<IndexEntry>::const_iterator start = std::lower_bound(range->begin, range->end, iter->time, IndexEntryCompare());
+        if (start != range->end)
+            iters_.push_back(ViewIterHelper(start, range));
+    }
+
+    std::sort(iters_.begin(), iters_.end(), ViewIterHelperCompare());
+    while (iter != iters_.back().iter)
+        increment();
+
+    view_revision_ = view_->view_revision_;
+}
+
+bool View::iterator::equal(View::iterator const& other) const {
+    // We need some way of verifying these are actually talking about
+    // the same merge_queue data since we shouldn't be able to compare
+    // iterators from different Views.
+
+    if (iters_.empty())
+        return other.iters_.empty();
+    if (other.iters_.empty())
+        return false;
+
+    return iters_.back().iter == other.iters_.back().iter;
+}
+
+void View::iterator::increment() {
+    assert(view_ != NULL);
+
+    // Our message instance is no longer valid
+    if (message_instance_ != NULL)
+    {
+      delete message_instance_;
+      message_instance_ = NULL;
+    }
+
+    view_->update();
+
+    // Note, updating may have blown away our message-ranges and
+    // replaced them in general the ViewIterHelpers are no longer
+    // valid, but the iterator it stores should still be good.
+    if (view_revision_ != view_->view_revision_)
+        populateSeek(iters_.back().iter);
+
+    if (view_->reduce_overlap_)
+    {
+        std::multiset<IndexEntry>::const_iterator last_iter = iters_.back().iter;
+    
+        while (!iters_.empty() && iters_.back().iter == last_iter)
+        {
+            iters_.back().iter++;
+            if (iters_.back().iter == iters_.back().range->end)
+                iters_.pop_back();
+      
+            std::sort(iters_.begin(), iters_.end(), ViewIterHelperCompare());
+        }
+
+    } else {
+
+        iters_.back().iter++;
+        if (iters_.back().iter == iters_.back().range->end)
+            iters_.pop_back();
+      
+        std::sort(iters_.begin(), iters_.end(), ViewIterHelperCompare());
+    }
+}
+
+MessageInstance& View::iterator::dereference() const {
+    ViewIterHelper const& i = iters_.back();
+
+    if (message_instance_ == NULL)
+      message_instance_ = view_->newMessageInstance(i.range->connection_info, *(i.iter), *(i.range->bag_query->bag));
+
+    return *message_instance_;
+}
+
+// View
+
+View::View(bool const& reduce_overlap) : view_revision_(0), size_cache_(0), size_revision_(0), reduce_overlap_(reduce_overlap) { }
+
+View::View(Bag const& bag, ros::Time const& start_time, ros::Time const& end_time, bool const& reduce_overlap) : view_revision_(0), size_cache_(0), size_revision_(0), reduce_overlap_(reduce_overlap) {
+	addQuery(bag, start_time, end_time);
+}
+
+View::View(Bag const& bag, boost::function<bool(ConnectionInfo const*)> query, ros::Time const& start_time, ros::Time const& end_time, bool const& reduce_overlap) : view_revision_(0), size_cache_(0), size_revision_(0), reduce_overlap_(reduce_overlap) {
+	addQuery(bag, query, start_time, end_time);
+}
+
+View::~View() {
+    for (MessageRange* range : ranges_)
+        delete range;
+    for (BagQuery* query : queries_)
+        delete query;
+}
+
+
+ros::Time View::getBeginTime()
+{
+  update();
+
+  ros::Time begin = ros::TIME_MAX;
+
+  for (rosbag::MessageRange* range : ranges_)
+  {
+    if (range->begin->time < begin)
+      begin = range->begin->time;
+  }
+
+  return begin;
+}
+
+ros::Time View::getEndTime()
+{
+  update();
+
+  ros::Time end = ros::TIME_MIN;
+
+  for (rosbag::MessageRange* range : ranges_)
+  {
+    std::multiset<IndexEntry>::const_iterator e = range->end;
+    e--;
+
+    if (e->time > end)
+      end = e->time;
+  }
+
+  return end;
+}
+
+//! Simply copy the merge_queue state into the iterator
+View::iterator View::begin() {
+    update();
+    return iterator(this);
+}
+
+//! Default constructed iterator signifies end
+View::iterator View::end() { return iterator(this, true); }
+
+uint32_t View::size() { 
+
+  update();
+
+  if (size_revision_ != view_revision_)
+  {
+    size_cache_ = 0;
+
+    for (MessageRange* range : ranges_)
+    {
+      size_cache_ += std::distance(range->begin, range->end);
+    }
+
+    size_revision_ = view_revision_;
+  }
+
+  return size_cache_;
+}
+
+void View::addQuery(Bag const& bag, ros::Time const& start_time, ros::Time const& end_time) {
+    if ((bag.getMode() & bagmode::Read) != bagmode::Read)
+        throw BagException("Bag not opened for reading");
+
+    boost::function<bool(ConnectionInfo const*)> query = TrueQuery();
+
+    queries_.push_back(new BagQuery(&bag, Query(query, start_time, end_time), bag.bag_revision_));
+
+    updateQueries(queries_.back());
+}
+
+void View::addQuery(Bag const& bag, boost::function<bool(ConnectionInfo const*)> query, ros::Time const& start_time, ros::Time const& end_time) {
+    if ((bag.getMode() & bagmode::Read) != bagmode::Read)
+        throw BagException("Bag not opened for reading");
+
+    queries_.push_back(new BagQuery(&bag, Query(query, start_time, end_time), bag.bag_revision_));
+
+    updateQueries(queries_.back());
+}
+
+void View::updateQueries(BagQuery* q) {
+    for (map<uint32_t, ConnectionInfo*>::const_iterator i = q->bag->connections_.begin(); i != q->bag->connections_.end(); i++) {
+        ConnectionInfo const* connection = i->second;
+
+        // Skip if the query doesn't evaluate to true
+        if (!q->query.getQuery()(connection))
+            continue;
+
+        map<uint32_t, multiset<IndexEntry> >::const_iterator j = q->bag->connection_indexes_.find(connection->id);
+
+        // Skip if the bag doesn't have the corresponding index
+        if (j == q->bag->connection_indexes_.end())
+            continue;
+        multiset<IndexEntry> const& index = j->second;
+
+        // lower_bound/upper_bound do a binary search to find the appropriate range of Index Entries given our time range
+        IndexEntry start_time_lookup_entry = { q->query.getStartTime(), 0, 0 };
+        IndexEntry end_time_lookup_entry   = { q->query.getEndTime()  , 0, 0 };
+        std::multiset<IndexEntry>::const_iterator begin = index.lower_bound(start_time_lookup_entry);
+        std::multiset<IndexEntry>::const_iterator end   = index.upper_bound(end_time_lookup_entry);
+	    
+        // Make sure we are at the right beginning
+        while (begin != index.begin() && begin->time >= q->query.getStartTime())
+        {
+          begin--;
+          if (begin->time < q->query.getStartTime())
+          {
+            begin++;
+            break;
+          }
+        }
+
+        if (begin != end)
+        {
+            // todo: make faster with a map of maps
+            bool found = false;
+            for (vector<MessageRange*>::iterator k = ranges_.begin(); k != ranges_.end(); k++) {
+                MessageRange* r = *k;
+                
+                // If the topic and query are already in our ranges, we update
+                if (r->bag_query == q && r->connection_info->id == connection->id) {
+                    r->begin = begin;
+                    r->end   = end;
+                    found    = true;
+                    break;
+                }
+            }
+            if (!found)
+                ranges_.push_back(new MessageRange(begin, end, connection, q));
+        }
+    }
+
+    view_revision_++;
+}
+
+void View::update() {
+    for (BagQuery* query : queries_) {
+        if (query->bag->bag_revision_ != query->bag_revision) {
+            updateQueries(query);
+            query->bag_revision = query->bag->bag_revision_;
+        }
+    }
+}
+
+std::vector<const ConnectionInfo*> View::getConnections()
+{
+  std::vector<const ConnectionInfo*> connections;
+  connections.reserve(ranges_.size());
+
+  for (MessageRange* range : ranges_)
+  {
+    connections.push_back(range->connection_info);
+  }
+
+  return connections;
+}
+
+MessageInstance* View::newMessageInstance(ConnectionInfo const* connection_info, IndexEntry const& index, Bag const& bag)
+{
+  return new MessageInstance(connection_info, index, bag);
+}
+
+
+} // namespace rosbag
--- /dev/null
+++ ros-noetic-rosbag-storage-1.16.0/test/test_aes_encryptor.cpp
@@ -0,0 +1,165 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2017, Open Source Robotics Foundation
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#include <cstdio>
+
+#include <boost/filesystem.hpp>
+
+#include <gtest/gtest.h>
+
+#include <gpgme.h>
+
+#include "std_msgs/String.h"
+
+#include "rosbag/bag.h"
+#include "rosbag/aes_encryptor.h"
+#include "rosbag/gpgme_utils.h"
+#include "rosbag/view.h"
+
+const char *GPG_KEY_USER = "Foo00";
+const char *GPG_PRIVATE_SUBKEY = "-----BEGIN PGP PRIVATE KEY BLOCK-----\n"
+    "Version: GnuPG v1\n\n"
+    "lQEVBFn3acoBCACwhq4iofk2V3/4yQy9++pHa3D4SPJdt1G/h83D+t9m95FoTHZl"
+    "zIY5bjKAKQ+NI6u5eQKNndAA7QLg8UGML6VqO7wmlxYSMOqRc4i0QMuUTA87hK4u"
+    "ozcHnjwaRhQzapwhnAMUu4058DIUyTus7ugD81C6y0nNT2PPwQzKifMmMcIgBvKm"
+    "vio7IK1A2tOsyQJD3jo99ZQhxq/eOQIwCs/BZfxu0OWnSJkx98Rsf7w3GC8tqhWK"
+    "avt/rBaFVoS3eZMkgQfT/ep92dYSLi/3/1pMtAt3kEVw3ZrvrCi47KDhpuaIV0kI"
+    "WlfHJF/YBNFbe4rRNwmQ5PkZYW1IwR14A+QFABEBAAH+B2UCR05VAbQqRm9vMDAg"
+    "KEEgR1BHIGtleSBmb3IgdGVzdCBjYXNlcykgPGJhckBiYXo+iQE4BBMBAgAiBQJZ"
+    "92nKAhsDBgsJCAcDAgYVCAIJCgsEFgIDAQIeAQIXgAAKCRCvPh8IgO8IzWTJB/9d"
+    "PO8BrpXtm/tosaGJFHT8FDt4PerCoKD6SqKj6HDrSU8tgUh+qLd+S1SkZ9Zg+yLq"
+    "ccCTeUg40XEvcKeTob8hWbTMKdl1cijM1jJCAUTe9zZd7URHoEkNWdEgA/saCZUj"
+    "TDeImYNcvv93SisKldf4gd67vkBETB4kEY7v7EE2YTge12S1vd9/9Ra6ZQn/qJSh"
+    "aPfZ5RfL1FEexQW+h2+bfpxW+ej/s2uM05AdEMmmGDaSVpimpPDkfF2YX4ESM7cl"
+    "fQzn1sCyVeHQWYvvEFTChdPlIR+gMZUhW+KicEqKsCDleh/jnSG/OoVZQkzec6Kt"
+    "zls7NO+fqIqFDLrNBWMTnQOXBFn3acoBCAClwRyFmeIkocrnodiqViqoGaBPOrwh"
+    "2NTaPvoiinwYwqUb9TynsrosEZTfjxfzDBawFG/nuBB7y0LhQYJKIEW6dKBT3HRe"
+    "hdhzfhZEaGGLwWxCqq5yywDt0JWrT92BX8hzwxKquRs3fynFGuW9YG5pdQ/wC3Na"
+    "j4uXg5Qy5wJZ0tqi/AiMIZTZGXBc/nP7rP7sryu3BYAXSPndx1mZYbSU1K5vBL3f"
+    "FkDAkon++cvF1+5D9Aoy1ukVmYn5fEhB4GoZwJEYCtgYofY5Fwbb7NsGHqrLBUgv"
+    "PwD5khZQ092rXEYPqkYrJ7vRX3/LdO4gmJupD1e1U2sRBOgzD/Pfw15FABEBAAEA"
+    "B/jMvmgLEV+bbnffNZpszcocE8Rjbw1mT/7Vl2bxCsmUr73uIFSTQxXRIMoZlRmO"
+    "dLWRrleo/3tc/UT0+fZoRJFrTjK88j5ag933PR2Zm1X/S9DgT7wQSOrc13Ts0mUD"
+    "aff4lMTr5J5kmZLGHx4beazpCM0Y0tM40TPVu10bg1srJUyCJgmqPJD0sbBfCBcT"
+    "jY99eWdT7tMr60G1Xw487RMXr/5eT7V2jcTe6JRivzQwvcsx1TuPWJajXY/l8BUJ"
+    "C7DitQP9x5DrA3s7qDxVbqiD0xrzCFc5FuOpcG2yV7LCuvT1144a1teCBh/gIoxh"
+    "EAnethtCVlmEufH74guq9ikEAMiZTkgsMNNHGtl7zNDc5ZEW22ESbrq81sbW9Z2p"
+    "CEvFU2HUsUQRkun6BcGpewTD+IOv2nSLlZQHEue4Ny9k7d4dWSew1ab3FMk9klpX"
+    "C7SEPYYDnZ8Ar+3nFozxKI3D1BvR374jSf2akMuIITteCnMXhvMLLFsk1Dz5zuWX"
+    "ARGfBADTiDyw387tZoR0Mhsiw1FwDJRISNYnC5YxWWzpDPfrZ3HZD44PqdwcxgBd"
+    "Uvtr8BtWHxs3skzn3oeNFT0yhVJi2Bn0QvGMIuGWBnhUvASv/rM3Zt22G5dCUVyz"
+    "RVGr1yx2xSZnVOeXQRSfp9yevAixcC8ATa8GUx9K8OSP/0NtmwP/Z5nW5s0WoG1H"
+    "Yna4s5bhNJ1y6Jue7bhw0gKXhx/9RNilTmq7NU6vTc1vqj0nw5e45WpojqZvSt0f"
+    "+bEL5eW+YnFb0MLJ9gIey4QZbOJeHB1xOaqz54Fnf8t9MmV/efLKvTHdj/WFM3fL"
+    "Z2iesAjK4hCyB2raeD9SOCP2ofztcmpIGYkBHwQYAQIACQUCWfdpygIbDAAKCRCv"
+    "Ph8IgO8Izd2IB/sFNTx/3l4mX9NUvyTpEhXKseti7JncjxZblUTV5MJ154nrfb2w"
+    "Xc81OmPmEDtE0PxTjYVasBD3lZNyLglw9kPpS5qZXU8kO4D6kNjRhdgKd/GqNHSo"
+    "U1LqutU/nbJc5H3AtGMLhg4Afa9xsYIRcszgtyWBbYCJ1MhkBaROAY42VzOyOi6z"
+    "pHOsnQH3xGlOdBYLeIvStCVP4XmHw/Mcx7LVnIfx48MFxVDw1iDiZej0K3cO24Ne"
+    "dSCgzJUVZQ5K4fTSu2xq1jD5zgWZ/Iu8PvAl5skKzgB2HpDVxIMVAELvxaMgKh3S"
+    "LYxADpgShsNtJiU/Dbn8jA+BlK/77fGnkvnc"
+    "=YcIw"
+    "-----END PGP PRIVATE KEY BLOCK-----";
+const char *MESSAGE = "message foo";
+const char *TOPIC_NAME = "topic_bar";
+
+void importGpgKey(gpgme_ctx_t &ctx) {
+    gpgme_data_t key_data;
+    gpgme_error_t err = gpgme_data_new_from_mem(&key_data, GPG_PRIVATE_SUBKEY, std::strlen(GPG_PRIVATE_SUBKEY), 1);
+    if (err) {
+        gpgme_release(ctx);
+        FAIL() << "gpgme_data_new_from_mem returned " << gpgme_strerror(err);
+    }
+    err = gpgme_op_import(ctx, key_data);
+    if (err) {
+        gpgme_data_release(key_data);
+        gpgme_release(ctx);
+        FAIL() << "gpgme_op_import returned " << gpgme_strerror(err);
+    }
+    gpgme_import_result_t res = gpgme_op_import_result(ctx);
+    EXPECT_TRUE(res->imports);
+    gpgme_data_release(key_data);
+}
+
+TEST(AesCbcEncryptor, EncryptAndDecryptBag) {
+    // Import key
+    rosbag::initGpgme();
+    gpgme_ctx_t ctx;
+    gpgme_error_t err = gpgme_new(&ctx);
+    if (err) {
+        FAIL() << "Failed to create a GPG context: " << gpgme_strerror(err);
+    }
+    importGpgKey(ctx);
+
+    // Test if the key has been imported
+    gpgme_key_t key;
+    try {
+        rosbag::getGpgKey(ctx, GPG_KEY_USER, key);
+    }
+    catch (rosbag::BagException const& e) {
+        gpgme_release(ctx);
+        FAIL() << "Failed to get the imported GPG key: " << e.what();
+    }
+
+    // Write a message to an encrypted bag file
+    char temp_dir_templ[] = "/tmp/bagXXXXXX";
+    char *temp_dir = mkdtemp(temp_dir_templ);
+    std::string bag_file_name = std::string(temp_dir) + "/foo.bag";
+    rosbag::Bag bag(bag_file_name, rosbag::bagmode::Write);
+    bag.setEncryptorPlugin("rosbag/AesCbcEncryptor", GPG_KEY_USER);
+    std_msgs::String msg;
+    msg.data = MESSAGE;
+    bag.write(TOPIC_NAME, ros::TIME_MIN, msg);
+    bag.close();
+
+    // Test the message decrypted from the bag file
+    bag.open(bag_file_name, rosbag::bagmode::Read);
+    rosbag::View view(bag);
+    EXPECT_EQ(view.size(), 1u);
+    EXPECT_EQ(TOPIC_NAME, view.begin()->getTopic());
+    EXPECT_EQ(MESSAGE, view.begin()->instantiate<std_msgs::String>()->data);
+    bag.close();
+
+    // Remove the bag file
+    boost::filesystem::remove(bag_file_name);
+    // Delete the key
+    gpgme_op_delete(ctx, key, 1);
+    // Release GPG context
+    gpgme_release(ctx);
+}
+
+int main(int argc, char **argv) {
+    testing::InitGoogleTest(&argc, argv);
+    return RUN_ALL_TESTS();
+}
