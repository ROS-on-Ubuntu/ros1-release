Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ros-noetic-depth-image-proc (1.17.0-0jammy) jammy; urgency=high
 .
   * Switch to hpp headers of pluginlib
   * Drop old C++ standard compiler flag
   * Switch to new boost/bind/bind.hpp
   * Add missing CATKIN_DEPENDS
   * Update frame id to match depth_front, rgb_front
   * Create point_cloud_xyzrgb.launch
     Created launch file for point_cloud_xyzrgb
   * Delete depth_image_proc/script directory
   * Delete depth_image_proc/launch directory
   * Contributors: Anirban Dam, Jochen Sprickerhof
Author: Vincent Rabaud <vincent.rabaud@gmail.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2024-08-18

--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/CHANGELOG.rst
@@ -0,0 +1,192 @@
+1.17.0 (2022-10-17)
+-------------------
+* Switch to hpp headers of pluginlib
+* Drop old C++ standard compiler flag
+* Switch to new boost/bind/bind.hpp
+* Add missing CATKIN_DEPENDS
+* Update frame id to match depth_front, rgb_front
+* Create point_cloud_xyzrgb.launch
+  Created launch file for point_cloud_xyzrgb
+* Delete depth_image_proc/script directory
+* Delete depth_image_proc/launch directory
+* Contributors: Anirban Dam, Jochen Sprickerhof
+
+1.16.0 (2021-11-12)
+-------------------
+* Fix includes
+  In the following commit in vision_opencv, the include
+  opencv2/calib3d/calib3d.hpp was removed from pinhole_camera_model.h :
+  https://github.com/ros-perception/vision_opencv/commit/51ca54354a8353fc728fcc8bd8ead7d2b6cf7444
+  Since we indirectly depended on this include, we now have to add it
+  directly.
+* support rgba8 and bgra8 encodings by skipping alpha channel
+* functional xyzrgb radial nodelet
+* add xyzrgb radial nodelet
+* Support MONO16 image encodings.
+* Add missing cstdint, vector, cmath includes.
+* Contributors: Avinash Thakur, Evan Flynn, Martin Günther, Mike Purvis
+
+1.15.3 (2020-12-11)
+-------------------
+* remove email blasts from steve macenski (`#595 <https://github.com/ros-perception/image_pipeline/issues/595>`_)
+* Contributors: Steve Macenski
+
+1.15.2 (2020-05-19)
+-------------------
+
+1.15.1 (2020-05-18)
+-------------------
+
+1.15.0 (2020-05-14)
+-------------------
+* Python 3 compatibility (`#530 <https://github.com/ros-perception/image_pipeline/issues/530>`_)
+* cmake_minimum_required to 3.0.2
+* Adapted to OpenCV4
+* import setup from setuptools instead of distutils-core
+* updated install locations for better portability. (`#500 <https://github.com/ros-perception/image_pipeline/issues/500>`_)
+* Contributors: Joshua Whitley, Sean Yen
+
+1.14.0 (2020-01-12)
+-------------------
+* Merge pull request `#478 <https://github.com/ros-perception/image_pipeline/issues/478>`_ from ros-perception/steve_main
+  added option to fill the sparse areas with neareast neighbor depth va…
+* Merge pull request `#336 <https://github.com/ros-perception/image_pipeline/issues/336>`_ from madsherlock/indigo
+  depth_image_proc/point_cloud_xyzi_radial Add intensity conversion (copy) for float
+* depth_image_proc: fix support for mono16 intensity encoding in point_cloud_xyzi node (`#352 <https://github.com/ros-perception/image_pipeline/issues/352>`_)
+* added option to fill the sparse areas with neareast neighbor depth values on upsampling operations in depth_image_proc/register
+* point_cloud_xyzi Add intensity conversion for float
+* Add intensity conversion (copy) for float
+  This commit enables the generation of xyzi point clouds from 32-bit floating point intensity images.
+  The destination data type for intensity storage is 32-bit float, so all that is required is a data copy.
+  The change in this commit is simply an extension of the if-else statement to include the TYPE_32FC1 type and apply the usual convert_intensity() method.
+* Contributors: Mikael Westermann, Richard Bormann, Steven Macenski, Stewart Jamieson, Tim Übelhör
+
+1.13.0 (2019-06-12)
+-------------------
+* Merge pull request `#395 <https://github.com/ros-perception/image_pipeline/issues/395>`_ from ros-perception/steve_maintain
+* adding autonomoustuff mainainer
+* adding stevemacenski as maintainer to get emails
+* Contributors: Joshua Whitley, Yoshito Okada, stevemacenski
+
+1.12.23 (2018-05-10)
+--------------------
+
+1.12.22 (2017-12-08)
+--------------------
+
+1.12.21 (2017-11-05)
+--------------------
+* Fix C++11 compilation
+  This fixes `#292 <https://github.com/ros-perception/image_pipeline/issues/292>`_ and `#291 <https://github.com/ros-perception/image_pipeline/issues/291>`_
+* Contributors: Vincent Rabaud
+
+1.12.20 (2017-04-30)
+--------------------
+* Fix CMake warnings about Eigen.
+* Convert depth image metric from [m] to [mm]
+* address gcc6 build error
+  With gcc6, compiling fails with `stdlib.h: No such file or directory`,
+  as including '-isystem /usr/include' breaks with gcc6, cf.,
+  https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70129.
+  This commit addresses this issue for this package in the same way
+  it was addressed in various other ROS packages. A list of related
+  commits and pull requests is at:
+  https://github.com/ros/rosdistro/issues/12783
+  Signed-off-by: Lukas Bulwahn <lukas.bulwahn@oss.bmw-carit.de>
+* Contributors: Kentaro Wada, Lukas Bulwahn, Vincent Rabaud
+
+1.12.19 (2016-07-24)
+--------------------
+
+1.12.18 (2016-07-12)
+--------------------
+
+1.12.17 (2016-07-11)
+--------------------
+
+1.12.16 (2016-03-19)
+--------------------
+* check number of channels before the process
+* search minimum value with OpenCV
+* Use OpenCV to be faster
+* Add a feature for a depth image to crop foremost image
+* Contributors: Kenta Yonekura
+
+1.12.15 (2016-01-17)
+--------------------
+* Add option for exact time sync for point_cloud_xyzrgb
+* simplify OpenCV3 conversion
+* Contributors: Kentaro Wada, Vincent Rabaud
+
+1.12.14 (2015-07-22)
+--------------------
+
+1.12.13 (2015-04-06)
+--------------------
+* Add radial point cloud processors
+* Contributors: Hunter Laux
+
+1.12.12 (2014-12-31)
+--------------------
+* adds range_max
+* exports depth_conversions
+  with convert for xyz PC only
+* exports DepthTraits
+* Contributors: enriquefernandez
+
+1.12.11 (2014-10-26)
+--------------------
+
+1.12.10 (2014-09-28)
+--------------------
+
+1.12.9 (2014-09-21)
+-------------------
+* get code to compile with OpenCV3
+  fixes `#96 <https://github.com/ros-perception/image_pipeline/issues/96>`_
+* Contributors: Vincent Rabaud
+
+1.12.8 (2014-08-19)
+-------------------
+
+1.12.6 (2014-07-27)
+-------------------
+* Add point_cloud_xyzi nodelet
+  This is for cameras that output depth and intensity images.
+  It's based on the point_cloud_xyzrgb nodelet.
+* Missing runtime dependency - eigen_conversions
+  `libdepth_image_proc` is missing this dependency at runtime
+  ```
+  > ldd libdepth_image_proc.so  | grep eigen
+  libeigen_conversions.so => not found
+  ```
+  Which causes the following error on loading depth_image_proc:
+  ```
+  [ INFO] [1402564815.530736554]: /camera/rgb/camera_info -> /camera/rgb/camera_info
+  [ERROR] [1402564815.727176562]: Failed to load nodelet [/camera/depth_metric_rect] of type
+  [depth_image_proc/convert_metric]: Failed to load library /opt/ros/indigo/lib//libdepth_image_proc.so.
+  Make sure that you are calling the PLUGINLIB_EXPORT_CLASS macro in the library code, and that
+  names are consistent between this macro and your XML. Error string: Could not load library (Poco
+  exception = libeigen_conversions.so: cannot open shared object file: No such file or directory)
+  [FATAL] [1402564815.727410623]: Service call failed!
+  ```
+* Contributors: Daniel Stonier, Hunter Laux
+
+1.12.4 (2014-04-28)
+-------------------
+* depth_image_proc: fix missing symbols in nodelets
+* Contributors: Michael Ferguson
+
+1.12.3 (2014-04-12)
+-------------------
+
+1.12.2 (2014-04-08)
+-------------------
+
+1.12.1 (2014-04-06)
+-------------------
+* replace tf usage by tf2 usage
+
+1.12.0 (2014-04-04)
+-------------------
+* remove PCL dependency
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/CMakeLists.txt
@@ -0,0 +1,56 @@
+cmake_minimum_required(VERSION 3.0.2)
+project(depth_image_proc)
+
+find_package(catkin REQUIRED
+  cmake_modules
+  cv_bridge
+  eigen_conversions
+  image_geometry
+  image_transport
+  message_filters
+  nodelet
+  sensor_msgs
+  stereo_msgs
+  tf2
+  tf2_ros
+)
+
+catkin_package(
+    INCLUDE_DIRS include
+    CATKIN_DEPENDS image_geometry sensor_msgs
+    LIBRARIES ${PROJECT_NAME})
+
+find_package(Boost REQUIRED)
+find_package(Eigen3 QUIET)
+if(NOT EIGEN3_FOUND)
+  find_package(Eigen REQUIRED)
+  set(EIGEN3_INCLUDE_DIRS ${EIGEN_INCLUDE_DIRS})
+endif()
+find_package(OpenCV REQUIRED)
+include_directories(include ${BOOST_INCLUDE_DIRS} ${catkin_INCLUDE_DIRS} ${EIGEN3_INCLUDE_DIRS})
+
+add_library(${PROJECT_NAME} src/nodelets/convert_metric.cpp
+                             src/nodelets/crop_foremost.cpp
+                             src/nodelets/disparity.cpp
+                             src/nodelets/point_cloud_xyz.cpp
+                             src/nodelets/point_cloud_xyzrgb.cpp
+                             src/nodelets/point_cloud_xyzi.cpp
+                             src/nodelets/point_cloud_xyz_radial.cpp
+                             src/nodelets/point_cloud_xyzi_radial.cpp
+                             src/nodelets/point_cloud_xyzrgb_radial.cpp
+                             src/nodelets/register.cpp
+)
+target_link_libraries(${PROJECT_NAME} ${catkin_LIBRARIES} ${OpenCV_LIBRARIES})
+
+install(DIRECTORY include/${PROJECT_NAME}/
+    DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
+    FILES_MATCHING PATTERN "*.h")
+
+install(TARGETS ${PROJECT_NAME}
+        ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+        LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+        RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION}
+)
+install(FILES nodelet_plugins.xml
+        DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}
+)
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/include/depth_image_proc/depth_conversions.h
@@ -0,0 +1,101 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#ifndef DEPTH_IMAGE_PROC_DEPTH_CONVERSIONS
+#define DEPTH_IMAGE_PROC_DEPTH_CONVERSIONS
+
+#include <sensor_msgs/Image.h>
+#include <sensor_msgs/point_cloud2_iterator.h>
+#include <image_geometry/pinhole_camera_model.h>
+#include <depth_image_proc/depth_traits.h>
+
+#include <limits>
+
+namespace depth_image_proc {
+
+typedef sensor_msgs::PointCloud2 PointCloud;
+
+// Handles float or uint16 depths
+template<typename T>
+void convert(
+    const sensor_msgs::ImageConstPtr& depth_msg,
+    PointCloud::Ptr& cloud_msg,
+    const image_geometry::PinholeCameraModel& model,
+    double range_max = 0.0)
+{
+  // Use correct principal point from calibration
+  float center_x = model.cx();
+  float center_y = model.cy();
+
+  // Combine unit conversion (if necessary) with scaling by focal length for computing (X,Y)
+  double unit_scaling = DepthTraits<T>::toMeters( T(1) );
+  float constant_x = unit_scaling / model.fx();
+  float constant_y = unit_scaling / model.fy();
+  float bad_point = std::numeric_limits<float>::quiet_NaN();
+
+  sensor_msgs::PointCloud2Iterator<float> iter_x(*cloud_msg, "x");
+  sensor_msgs::PointCloud2Iterator<float> iter_y(*cloud_msg, "y");
+  sensor_msgs::PointCloud2Iterator<float> iter_z(*cloud_msg, "z");
+  const T* depth_row = reinterpret_cast<const T*>(&depth_msg->data[0]);
+  int row_step = depth_msg->step / sizeof(T);
+  for (int v = 0; v < (int)cloud_msg->height; ++v, depth_row += row_step)
+  {
+    for (int u = 0; u < (int)cloud_msg->width; ++u, ++iter_x, ++iter_y, ++iter_z)
+    {
+      T depth = depth_row[u];
+
+      // Missing points denoted by NaNs
+      if (!DepthTraits<T>::valid(depth))
+      {
+        if (range_max != 0.0)
+        {
+          depth = DepthTraits<T>::fromMeters(range_max);
+        }
+        else
+        {
+          *iter_x = *iter_y = *iter_z = bad_point;
+          continue;
+        }
+      }
+
+      // Fill in XYZ
+      *iter_x = (u - center_x) * depth * constant_x;
+      *iter_y = (v - center_y) * depth * constant_y;
+      *iter_z = DepthTraits<T>::toMeters(depth);
+    }
+  }
+}
+
+} // namespace depth_image_proc
+
+#endif
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/include/depth_image_proc/depth_traits.h
@@ -0,0 +1,74 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#ifndef DEPTH_IMAGE_PROC_DEPTH_TRAITS
+#define DEPTH_IMAGE_PROC_DEPTH_TRAITS
+
+#include <algorithm>
+#include <cmath>
+#include <cstdint>
+#include <limits>
+#include <vector>
+
+namespace depth_image_proc {
+
+// Encapsulate differences between processing float and uint16_t depths
+template<typename T> struct DepthTraits {};
+
+template<>
+struct DepthTraits<uint16_t>
+{
+  static inline bool valid(uint16_t depth) { return depth != 0; }
+  static inline float toMeters(uint16_t depth) { return depth * 0.001f; } // originally mm
+  static inline uint16_t fromMeters(float depth) { return (depth * 1000.0f) + 0.5f; }
+  static inline void initializeBuffer(std::vector<uint8_t>& buffer) {} // Do nothing - already zero-filled
+};
+
+template<>
+struct DepthTraits<float>
+{
+  static inline bool valid(float depth) { return std::isfinite(depth); }
+  static inline float toMeters(float depth) { return depth; }
+  static inline float fromMeters(float depth) { return depth; }
+
+  static inline void initializeBuffer(std::vector<uint8_t>& buffer)
+  {
+    float* start = reinterpret_cast<float*>(&buffer[0]);
+    float* end = reinterpret_cast<float*>(&buffer[0] + buffer.size());
+    std::fill(start, end, std::numeric_limits<float>::quiet_NaN());
+  }
+};
+
+} // namespace depth_image_proc
+
+#endif
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/launch/point_cloud_xyzrgb.launch
@@ -0,0 +1,32 @@
+<!-- -->
+<!-- Convert the depth image and the rgb image into a xyzrgb Point Cloud -->
+<launch>
+
+    <node name="update_frame_id" pkg="depth_image_proc" type="update_frame_id.py" output="screen" />
+
+    <!-- Nodelet manager for this pipeline -->
+    <node pkg="nodelet" type="nodelet" args="manager" name="standalone_nodelet" output="screen"/>
+
+
+    <!-- Convert to point cloud -->
+    <node pkg="nodelet" type="nodelet" name="depth_image_proc" args="load depth_image_proc/point_cloud_xyzrgb standalone_nodelet --no-bond">
+   
+        <!--remap from your specific sensors-->         
+
+        <!-- Input: Camera calibration and metadata.  (sensor_msgs/CameraInfo) -->
+        <!--remap from="rgb/camera_info" to="/carla/ego_vehicle/rgb_front/camera_info"/-->
+
+        <!-- Input: Rectified color image. (sensor_msgs/Image) -->
+        <!--remap from="rgb/image_rect_color" to="/carla/ego_vehicle/rgb_front/image"/-->
+
+        <!-- Input: Rectified depth image, registered to the RGB camera. (sensor_msgs/Image) -->
+        <remap from="depth_registered/image_rect" to="/carla/ego_vehicle/depth_front/image"/>
+
+        <!-- Output: XYZ point cloud. If using PCL, subscribe as PointCloud<PointXYZ>.  (sensor_msgs/PointCloud2)  -->
+        <remap from="depth_registered/points" to="/point_cloud/points"/>
+
+    </node>
+
+</launch>
+
+<!-- -->
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/mainpage.dox
@@ -0,0 +1,26 @@
+/**
+\mainpage
+\htmlinclude manifest.html
+
+\b depth_image_proc is ... 
+
+<!-- 
+Provide an overview of your package.
+-->
+
+
+\section codeapi Code API
+
+<!--
+Provide links to specific auto-generated API documentation within your
+package that is of particular interest to a reader. Doxygen will
+document pretty much every part of your code, so do your best here to
+point the reader to the actual API.
+
+If your codebase is fairly large or has different sets of APIs, you
+should use the doxygen 'group' tag to keep these APIs together. For
+example, the roscpp documentation has 'libros' group.
+-->
+
+
+*/
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/nodelet_plugins.xml
@@ -0,0 +1,82 @@
+<library path="lib/libdepth_image_proc">
+
+  <class name="depth_image_proc/convert_metric"
+	 type="depth_image_proc::ConvertMetricNodelet"
+	 base_class_type="nodelet::Nodelet">
+    <description>
+      Nodelet to convert raw uint16 depth image in mm to float depth image in m.
+    </description>
+  </class>
+
+  <class name="depth_image_proc/disparity"
+	 type="depth_image_proc::DisparityNodelet"
+	 base_class_type="nodelet::Nodelet">
+    <description>
+      Nodelet to convert depth image to disparity image.
+    </description>
+  </class>
+
+  <class name="depth_image_proc/point_cloud_xyz"
+	 type="depth_image_proc::PointCloudXyzNodelet"
+	 base_class_type="nodelet::Nodelet">
+    <description>
+      Nodelet to convert depth image to XYZ point cloud.
+    </description>
+  </class>
+
+  <class name="depth_image_proc/point_cloud_xyzrgb"
+	 type="depth_image_proc::PointCloudXyzrgbNodelet"
+	 base_class_type="nodelet::Nodelet">
+    <description>
+      Nodelet to combine registered depth image and RGB image into XYZRGB point cloud.
+    </description>
+  </class>
+
+  <class name="depth_image_proc/point_cloud_xyzi"
+         type="depth_image_proc::PointCloudXyziNodelet"
+         base_class_type="nodelet::Nodelet">
+    <description>
+      Nodelet to combine registered depth image and intensity image into XYZI point cloud.
+    </description>
+  </class>
+  <class name="depth_image_proc/point_cloud_xyz_radial"
+         type="depth_image_proc::PointCloudXyzRadialNodelet"
+         base_class_type="nodelet::Nodelet">
+    <description>
+      Nodelet to convert an Radial depth map to a point.
+    </description>
+  </class>
+
+  <class name="depth_image_proc/point_cloud_xyzi_radial"
+         type="depth_image_proc::PointCloudXyziRadialNodelet"
+         base_class_type="nodelet::Nodelet">
+    <description>
+      Nodelet to convert an Radial depth and intensity map to a point.
+    </description>
+  </class>
+
+  <class name="depth_image_proc/point_cloud_xyzrgb_radial"
+	 type="depth_image_proc::PointCloudXyzRgbRadialNodelet"
+	 base_class_type="nodelet::Nodelet">
+    <description>
+      Nodelet to combine registered Radial depth image and RGB image into XYZRGB point cloud.
+    </description>
+  </class>
+  
+  <class name="depth_image_proc/register"
+	 type="depth_image_proc::RegisterNodelet"
+	 base_class_type="nodelet::Nodelet">
+    <description>
+      Nodelet to create a depth image registered to another camera frame.
+    </description>
+  </class>
+
+  <class name="depth_image_proc/crop_foremost"
+	 type="depth_image_proc::CropForemostNodelet"
+	 base_class_type="nodelet::Nodelet">
+    <description>
+      Nodelet to crop a depth image from foremost depth to a specific range.
+    </description>
+  </class>
+
+</library>
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/package.xml
@@ -0,0 +1,48 @@
+<package>
+  <name>depth_image_proc</name>
+  <version>1.17.0</version>
+  <description>
+
+     Contains nodelets for processing depth images such as those
+     produced by OpenNI camera. Functions include creating disparity
+     images and point clouds, as well as registering (reprojecting)
+     a depth image into another camera frame.
+
+  </description>
+  <author>Patrick Mihelich</author>
+  <maintainer email="vincent.rabaud@gmail.com">Vincent Rabaud</maintainer>
+  <maintainer email="software@autonomoustuff.com">Autonomoustuff team</maintainer>
+  <license>BSD</license>
+  <url>http://ros.org/wiki/depth_image_proc</url>
+
+  <export>
+    <nodelet plugin="${prefix}/nodelet_plugins.xml" />
+  </export>
+
+  <buildtool_depend>catkin</buildtool_depend>
+
+  <test_depend>rostest</test_depend>
+
+  <build_depend>boost</build_depend>
+  <build_depend>cmake_modules</build_depend>
+  <build_depend>cv_bridge</build_depend>
+  <build_depend>eigen_conversions</build_depend>
+  <build_depend>image_geometry</build_depend>
+  <build_depend>image_transport</build_depend>
+  <build_depend>message_filters</build_depend>
+  <build_depend>nodelet</build_depend>
+  <build_depend>sensor_msgs</build_depend>
+  <build_depend>stereo_msgs</build_depend>
+  <build_depend>tf2</build_depend>
+  <build_depend>tf2_ros</build_depend>
+
+  <run_depend>boost</run_depend>
+  <run_depend>cv_bridge</run_depend>
+  <run_depend>eigen_conversions</run_depend>
+  <run_depend>image_geometry</run_depend>
+  <run_depend>image_transport</run_depend>
+  <run_depend>nodelet</run_depend>
+  <run_depend>tf2</run_depend>
+  <run_depend>tf2_ros</run_depend>
+  <run_depend>sensor_msgs</run_depend>
+</package>
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/script/update_frame_id.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python 
+
+import rospy
+from sensor_msgs.msg import Image 
+from sensor_msgs.msg import CameraInfo
+
+rospy.init_node("update_frame_id")
+
+#Updating frame id for the error depth_front frame id does not match rgb_front frame id
+class update_frame_id:
+    def __init__(self):
+        self.image = Image()
+        #subscribe to your specific sensors
+        self.sub_raw = rospy.Subscriber("/carla/ego_vehicle/rgb_front/image", Image, self.callback_raw)
+        self.sub_info = rospy.Subscriber("/carla/ego_vehicle/rgb_front/camera_info", CameraInfo, self.callback_info)
+        self.pub_raw = rospy.Publisher("/rgb/image_rect_color", Image, queue_size = 1)
+        self.pub_info = rospy.Publisher("/rgb/camera_info", CameraInfo, queue_size = 1)
+    def callback_raw(self, message):
+        message.header.frame_id = "ego_vehicle/depth_front"
+        self.pub_raw.publish(message)
+    def callback_info(self, message):
+        message.header.frame_id = "ego_vehicle/depth_front"
+        self.pub_info.publish(message)
+
+update_frame_id = update_frame_id()
+rospy.spin()
+
+print("\nNode shutdown\n")
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/src/nodelets/convert_metric.cpp
@@ -0,0 +1,140 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#include <ros/ros.h>
+#include <nodelet/nodelet.h>
+#include <image_transport/image_transport.h>
+#include <sensor_msgs/image_encodings.h>
+#include <boost/thread.hpp>
+
+namespace depth_image_proc {
+
+namespace enc = sensor_msgs::image_encodings;
+
+class ConvertMetricNodelet : public nodelet::Nodelet
+{
+  // Subscriptions
+  boost::shared_ptr<image_transport::ImageTransport> it_;
+  image_transport::Subscriber sub_raw_;
+
+  // Publications
+  boost::mutex connect_mutex_;
+  image_transport::Publisher pub_depth_;
+
+  virtual void onInit();
+
+  void connectCb();
+
+  void depthCb(const sensor_msgs::ImageConstPtr& raw_msg);
+};
+
+void ConvertMetricNodelet::onInit()
+{
+  ros::NodeHandle& nh = getNodeHandle();
+  it_.reset(new image_transport::ImageTransport(nh));
+
+  // Monitor whether anyone is subscribed to the output
+  image_transport::SubscriberStatusCallback connect_cb = boost::bind(&ConvertMetricNodelet::connectCb, this);
+  // Make sure we don't enter connectCb() between advertising and assigning to pub_depth_
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  pub_depth_ = it_->advertise("image", 1, connect_cb, connect_cb);
+}
+
+// Handles (un)subscribing when clients (un)subscribe
+void ConvertMetricNodelet::connectCb()
+{
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  if (pub_depth_.getNumSubscribers() == 0)
+  {
+    sub_raw_.shutdown();
+  }
+  else if (!sub_raw_)
+  {
+    image_transport::TransportHints hints("raw", ros::TransportHints(), getPrivateNodeHandle());
+    sub_raw_ = it_->subscribe("image_raw", 1, &ConvertMetricNodelet::depthCb, this, hints);
+  }
+}
+
+void ConvertMetricNodelet::depthCb(const sensor_msgs::ImageConstPtr& raw_msg)
+{
+  // Allocate new Image message
+  sensor_msgs::ImagePtr depth_msg( new sensor_msgs::Image );
+  depth_msg->header   = raw_msg->header;
+  depth_msg->height   = raw_msg->height;
+  depth_msg->width    = raw_msg->width;
+
+  // Set data, encoding and step after converting the metric.
+  if (raw_msg->encoding == enc::TYPE_16UC1)
+  {
+    depth_msg->encoding = enc::TYPE_32FC1;
+    depth_msg->step     = raw_msg->width * (enc::bitDepth(depth_msg->encoding) / 8);
+    depth_msg->data.resize(depth_msg->height * depth_msg->step);
+    // Fill in the depth image data, converting mm to m
+    float bad_point = std::numeric_limits<float>::quiet_NaN ();
+    const uint16_t* raw_data = reinterpret_cast<const uint16_t*>(&raw_msg->data[0]);
+    float* depth_data = reinterpret_cast<float*>(&depth_msg->data[0]);
+    for (unsigned index = 0; index < depth_msg->height * depth_msg->width; ++index)
+    {
+      uint16_t raw = raw_data[index];
+      depth_data[index] = (raw == 0) ? bad_point : (float)raw * 0.001f;
+    }
+  }
+  else if (raw_msg->encoding == enc::TYPE_32FC1)
+  {
+    depth_msg->encoding = enc::TYPE_16UC1;
+    depth_msg->step     = raw_msg->width * (enc::bitDepth(depth_msg->encoding) / 8);
+    depth_msg->data.resize(depth_msg->height * depth_msg->step);
+    // Fill in the depth image data, converting m to mm
+    uint16_t bad_point = 0;
+    const float* raw_data = reinterpret_cast<const float*>(&raw_msg->data[0]);
+    uint16_t* depth_data = reinterpret_cast<uint16_t*>(&depth_msg->data[0]);
+    for (unsigned index = 0; index < depth_msg->height * depth_msg->width; ++index)
+    {
+      float raw = raw_data[index];
+      depth_data[index] = std::isnan(raw) ? bad_point : (uint16_t)(raw * 1000);
+    }
+  }
+  else
+  {
+    ROS_ERROR("Unsupported image conversion from %s.", raw_msg->encoding.c_str());
+    return;
+  }
+
+  pub_depth_.publish(depth_msg);
+}
+
+} // namespace depth_image_proc
+
+// Register as nodelet
+#include <pluginlib/class_list_macros.hpp>
+PLUGINLIB_EXPORT_CLASS(depth_image_proc::ConvertMetricNodelet,nodelet::Nodelet);
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/src/nodelets/crop_foremost.cpp
@@ -0,0 +1,142 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+//#include <ros/ros.h>
+#include <nodelet/nodelet.h>
+#include <image_transport/image_transport.h>
+#include <boost/thread.hpp>
+#include <cv_bridge/cv_bridge.h>
+#include <opencv2/imgproc/imgproc.hpp>
+
+namespace depth_image_proc {
+
+namespace enc = sensor_msgs::image_encodings;
+
+class CropForemostNodelet : public nodelet::Nodelet
+{
+  // Subscriptions
+  boost::shared_ptr<image_transport::ImageTransport> it_;
+  image_transport::Subscriber sub_raw_;
+
+  // Publications
+  boost::mutex connect_mutex_;
+  image_transport::Publisher pub_depth_;
+
+  virtual void onInit();
+
+  void connectCb();
+
+  void depthCb(const sensor_msgs::ImageConstPtr& raw_msg);
+
+  double distance_;
+};
+
+void CropForemostNodelet::onInit()
+{
+  ros::NodeHandle& nh = getNodeHandle();
+  ros::NodeHandle& private_nh = getPrivateNodeHandle();
+  private_nh.getParam("distance", distance_);
+  it_.reset(new image_transport::ImageTransport(nh));
+
+  // Monitor whether anyone is subscribed to the output
+  image_transport::SubscriberStatusCallback connect_cb = boost::bind(&CropForemostNodelet::connectCb, this);
+  // Make sure we don't enter connectCb() between advertising and assigning to pub_depth_
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  pub_depth_ = it_->advertise("image", 1, connect_cb, connect_cb);
+}
+
+// Handles (un)subscribing when clients (un)subscribe
+void CropForemostNodelet::connectCb()
+{
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  if (pub_depth_.getNumSubscribers() == 0)
+  {
+    sub_raw_.shutdown();
+  }
+  else if (!sub_raw_)
+  {
+    image_transport::TransportHints hints("raw", ros::TransportHints(), getPrivateNodeHandle());
+    sub_raw_ = it_->subscribe("image_raw", 1, &CropForemostNodelet::depthCb, this, hints);
+  }
+}
+
+void CropForemostNodelet::depthCb(const sensor_msgs::ImageConstPtr& raw_msg)
+{
+  cv_bridge::CvImagePtr cv_ptr;
+  try
+  {
+    cv_ptr = cv_bridge::toCvCopy(raw_msg);
+  }
+  catch (cv_bridge::Exception& e)
+  {
+    ROS_ERROR("cv_bridge exception: %s", e.what());
+    return;
+  }
+
+  // Check the number of channels
+  if(sensor_msgs::image_encodings::numChannels(raw_msg->encoding) != 1){
+    NODELET_ERROR_THROTTLE(2, "Only grayscale image is acceptable, got [%s]", raw_msg->encoding.c_str());
+    return;
+  }
+
+  // search the min value without invalid value "0"
+  double minVal;
+  cv::minMaxIdx(cv_ptr->image, &minVal, 0, 0, 0, cv_ptr->image != 0);
+
+  int imtype = cv_bridge::getCvType(raw_msg->encoding);
+  switch (imtype){
+    case CV_8UC1:
+    case CV_8SC1:
+    case CV_32F:
+      cv::threshold(cv_ptr->image, cv_ptr->image, minVal + distance_, 0, CV_THRESH_TOZERO_INV);
+      break;
+    case CV_16UC1:
+    case CV_16SC1:
+    case CV_32SC1:
+    case CV_64F:
+      // 8 bit or 32 bit floating array is required to use cv::threshold
+      cv_ptr->image.convertTo(cv_ptr->image, CV_32F);
+      cv::threshold(cv_ptr->image, cv_ptr->image, minVal + distance_, 1, CV_THRESH_TOZERO_INV);
+
+      cv_ptr->image.convertTo(cv_ptr->image, imtype);
+      break;
+  }
+
+  pub_depth_.publish(cv_ptr->toImageMsg());
+}
+
+} // namespace depth_image_proc
+
+// Register as nodelet
+#include <pluginlib/class_list_macros.hpp>
+PLUGINLIB_EXPORT_CLASS(depth_image_proc::CropForemostNodelet,nodelet::Nodelet);
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/src/nodelets/disparity.cpp
@@ -0,0 +1,189 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#include <boost/version.hpp>
+#if ((BOOST_VERSION / 100) % 1000) >= 53
+#include <boost/thread/lock_guard.hpp>
+#endif
+
+#include <ros/ros.h>
+#include <nodelet/nodelet.h>
+#include <image_transport/image_transport.h>
+#include <image_transport/subscriber_filter.h>
+#include <message_filters/subscriber.h>
+#include <message_filters/time_synchronizer.h>
+#include <sensor_msgs/image_encodings.h>
+#include <stereo_msgs/DisparityImage.h>
+#include <depth_image_proc/depth_traits.h>
+
+namespace depth_image_proc {
+
+namespace enc = sensor_msgs::image_encodings;
+
+class DisparityNodelet : public nodelet::Nodelet
+{
+  boost::shared_ptr<image_transport::ImageTransport> left_it_;
+  ros::NodeHandlePtr right_nh_;
+  image_transport::SubscriberFilter sub_depth_image_;
+  message_filters::Subscriber<sensor_msgs::CameraInfo> sub_info_;
+  typedef message_filters::TimeSynchronizer<sensor_msgs::Image, sensor_msgs::CameraInfo> Sync;
+  boost::shared_ptr<Sync> sync_;
+  
+  boost::mutex connect_mutex_;
+  ros::Publisher pub_disparity_;
+  double min_range_;
+  double max_range_;
+  double delta_d_;
+
+  virtual void onInit();
+
+  void connectCb();
+
+  void depthCb(const sensor_msgs::ImageConstPtr& depth_msg,
+               const sensor_msgs::CameraInfoConstPtr& info_msg);
+
+  template<typename T>
+  void convert(const sensor_msgs::ImageConstPtr& depth_msg,
+               stereo_msgs::DisparityImagePtr& disp_msg);
+};
+
+void DisparityNodelet::onInit()
+{
+  ros::NodeHandle &nh         = getNodeHandle();
+  ros::NodeHandle &private_nh = getPrivateNodeHandle();
+  ros::NodeHandle left_nh(nh, "left");
+  left_it_.reset(new image_transport::ImageTransport(left_nh));
+  right_nh_.reset( new ros::NodeHandle(nh, "right") );
+
+  // Read parameters
+  int queue_size;
+  private_nh.param("queue_size", queue_size, 5);
+  private_nh.param("min_range", min_range_, 0.0);
+  private_nh.param("max_range", max_range_, std::numeric_limits<double>::infinity());
+  private_nh.param("delta_d", delta_d_, 0.125);
+
+  // Synchronize inputs. Topic subscriptions happen on demand in the connection callback.
+  sync_.reset( new Sync(sub_depth_image_, sub_info_, queue_size) );
+  sync_->registerCallback(boost::bind(&DisparityNodelet::depthCb, this, boost::placeholders::_1, boost::placeholders::_2));
+
+  // Monitor whether anyone is subscribed to the output
+  ros::SubscriberStatusCallback connect_cb = boost::bind(&DisparityNodelet::connectCb, this);
+  // Make sure we don't enter connectCb() between advertising and assigning to pub_disparity_
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  pub_disparity_ = left_nh.advertise<stereo_msgs::DisparityImage>("disparity", 1, connect_cb, connect_cb);
+}
+
+// Handles (un)subscribing when clients (un)subscribe
+void DisparityNodelet::connectCb()
+{
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  if (pub_disparity_.getNumSubscribers() == 0)
+  {
+    sub_depth_image_.unsubscribe();
+    sub_info_ .unsubscribe();
+  }
+  else if (!sub_depth_image_.getSubscriber())
+  {
+    image_transport::TransportHints hints("raw", ros::TransportHints(), getPrivateNodeHandle());
+    sub_depth_image_.subscribe(*left_it_, "image_rect", 1, hints);
+    sub_info_.subscribe(*right_nh_, "camera_info", 1);
+  }
+}
+
+void DisparityNodelet::depthCb(const sensor_msgs::ImageConstPtr& depth_msg,
+                               const sensor_msgs::CameraInfoConstPtr& info_msg)
+{
+  // Allocate new DisparityImage message
+  stereo_msgs::DisparityImagePtr disp_msg( new stereo_msgs::DisparityImage );
+  disp_msg->header         = depth_msg->header;
+  disp_msg->image.header   = disp_msg->header;
+  disp_msg->image.encoding = enc::TYPE_32FC1;
+  disp_msg->image.height   = depth_msg->height;
+  disp_msg->image.width    = depth_msg->width;
+  disp_msg->image.step     = disp_msg->image.width * sizeof (float);
+  disp_msg->image.data.resize( disp_msg->image.height * disp_msg->image.step, 0.0f );
+  double fx = info_msg->P[0];
+  disp_msg->T = -info_msg->P[3] / fx;
+  disp_msg->f = fx;
+  // Remaining fields depend on device characteristics, so rely on user input
+  disp_msg->min_disparity = disp_msg->f * disp_msg->T / max_range_;
+  disp_msg->max_disparity = disp_msg->f * disp_msg->T / min_range_;
+  disp_msg->delta_d = delta_d_;
+
+  if (depth_msg->encoding == enc::TYPE_16UC1)
+  {
+    convert<uint16_t>(depth_msg, disp_msg);
+  }
+  else if (depth_msg->encoding == enc::TYPE_32FC1)
+  {
+    convert<float>(depth_msg, disp_msg);
+  }
+  else
+  {
+    NODELET_ERROR_THROTTLE(5, "Depth image has unsupported encoding [%s]", depth_msg->encoding.c_str());
+    return;
+  }
+
+  pub_disparity_.publish(disp_msg);
+}
+
+template<typename T>
+void DisparityNodelet::convert(const sensor_msgs::ImageConstPtr& depth_msg,
+                               stereo_msgs::DisparityImagePtr& disp_msg)
+{
+  // For each depth Z, disparity d = fT / Z
+  float unit_scaling = DepthTraits<T>::toMeters( T(1) );
+  float constant = disp_msg->f * disp_msg->T / unit_scaling;
+
+  const T* depth_row = reinterpret_cast<const T*>(&depth_msg->data[0]);
+  int row_step = depth_msg->step / sizeof(T);
+  float* disp_data = reinterpret_cast<float*>(&disp_msg->image.data[0]);
+  for (int v = 0; v < (int)depth_msg->height; ++v)
+  {
+    for (int u = 0; u < (int)depth_msg->width; ++u)
+    {
+      T depth = depth_row[u];
+      if (DepthTraits<T>::valid(depth))
+        *disp_data = constant / depth;
+      ++disp_data;
+    }
+
+    depth_row += row_step;
+  }
+}
+
+} // namespace depth_image_proc
+
+// Register as nodelet
+#include <pluginlib/class_list_macros.hpp>
+PLUGINLIB_EXPORT_CLASS(depth_image_proc::DisparityNodelet,nodelet::Nodelet);
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/src/nodelets/point_cloud_xyz.cpp
@@ -0,0 +1,138 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#include <ros/ros.h>
+#include <nodelet/nodelet.h>
+#include <image_transport/image_transport.h>
+#include <sensor_msgs/image_encodings.h>
+#include <image_geometry/pinhole_camera_model.h>
+#include <boost/thread.hpp>
+#include <depth_image_proc/depth_conversions.h>
+
+#include <sensor_msgs/point_cloud2_iterator.h>
+
+namespace depth_image_proc {
+
+namespace enc = sensor_msgs::image_encodings;
+
+class PointCloudXyzNodelet : public nodelet::Nodelet
+{
+  // Subscriptions
+  boost::shared_ptr<image_transport::ImageTransport> it_;
+  image_transport::CameraSubscriber sub_depth_;
+  int queue_size_;
+
+  // Publications
+  boost::mutex connect_mutex_;
+  typedef sensor_msgs::PointCloud2 PointCloud;
+  ros::Publisher pub_point_cloud_;
+
+  image_geometry::PinholeCameraModel model_;
+
+  virtual void onInit();
+
+  void connectCb();
+
+  void depthCb(const sensor_msgs::ImageConstPtr& depth_msg,
+               const sensor_msgs::CameraInfoConstPtr& info_msg);
+};
+
+void PointCloudXyzNodelet::onInit()
+{
+  ros::NodeHandle& nh         = getNodeHandle();
+  ros::NodeHandle& private_nh = getPrivateNodeHandle();
+  it_.reset(new image_transport::ImageTransport(nh));
+
+  // Read parameters
+  private_nh.param("queue_size", queue_size_, 5);
+
+  // Monitor whether anyone is subscribed to the output
+  ros::SubscriberStatusCallback connect_cb = boost::bind(&PointCloudXyzNodelet::connectCb, this);
+  // Make sure we don't enter connectCb() between advertising and assigning to pub_point_cloud_
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  pub_point_cloud_ = nh.advertise<PointCloud>("points", 1, connect_cb, connect_cb);
+}
+
+// Handles (un)subscribing when clients (un)subscribe
+void PointCloudXyzNodelet::connectCb()
+{
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  if (pub_point_cloud_.getNumSubscribers() == 0)
+  {
+    sub_depth_.shutdown();
+  }
+  else if (!sub_depth_)
+  {
+    image_transport::TransportHints hints("raw", ros::TransportHints(), getPrivateNodeHandle());
+    sub_depth_ = it_->subscribeCamera("image_rect", queue_size_, &PointCloudXyzNodelet::depthCb, this, hints);
+  }
+}
+
+void PointCloudXyzNodelet::depthCb(const sensor_msgs::ImageConstPtr& depth_msg,
+                                   const sensor_msgs::CameraInfoConstPtr& info_msg)
+{
+  PointCloud::Ptr cloud_msg(new PointCloud);
+  cloud_msg->header = depth_msg->header;
+  cloud_msg->height = depth_msg->height;
+  cloud_msg->width  = depth_msg->width;
+  cloud_msg->is_dense = false;
+  cloud_msg->is_bigendian = false;
+
+  sensor_msgs::PointCloud2Modifier pcd_modifier(*cloud_msg);
+  pcd_modifier.setPointCloud2FieldsByString(1, "xyz");
+
+  // Update camera model
+  model_.fromCameraInfo(info_msg);
+
+  if (depth_msg->encoding == enc::TYPE_16UC1 || depth_msg->encoding == enc::MONO16)
+  {
+    convert<uint16_t>(depth_msg, cloud_msg, model_);
+  }
+  else if (depth_msg->encoding == enc::TYPE_32FC1)
+  {
+    convert<float>(depth_msg, cloud_msg, model_);
+  }
+  else
+  {
+    NODELET_ERROR_THROTTLE(5, "Depth image has unsupported encoding [%s]", depth_msg->encoding.c_str());
+    return;
+  }
+
+  pub_point_cloud_.publish (cloud_msg);
+}
+
+} // namespace depth_image_proc
+
+// Register as nodelet
+#include <pluginlib/class_list_macros.hpp>
+PLUGINLIB_EXPORT_CLASS(depth_image_proc::PointCloudXyzNodelet,nodelet::Nodelet);
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/src/nodelets/point_cloud_xyz_radial.cpp
@@ -0,0 +1,236 @@
+/*********************************************************************
+ * Software License Agreement (BSD License)
+ * 
+ *  Copyright (c) 2008, Willow Garage, Inc.
+ *  All rights reserved.
+ * 
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ * 
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the Willow Garage nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ * 
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *********************************************************************/
+#include <ros/ros.h>
+#include <nodelet/nodelet.h>
+#include <image_transport/image_transport.h>
+#include <sensor_msgs/image_encodings.h>
+#include <image_geometry/pinhole_camera_model.h>
+#include <opencv2/calib3d/calib3d.hpp>
+#include <boost/thread.hpp>
+#include <depth_image_proc/depth_traits.h>
+
+#include <sensor_msgs/point_cloud2_iterator.h>
+
+namespace depth_image_proc {
+
+    namespace enc = sensor_msgs::image_encodings;
+
+    class PointCloudXyzRadialNodelet : public nodelet::Nodelet
+    {
+	// Subscriptions
+	boost::shared_ptr<image_transport::ImageTransport> it_;
+	image_transport::CameraSubscriber sub_depth_;
+	int queue_size_;
+
+	// Publications
+	boost::mutex connect_mutex_;
+	typedef sensor_msgs::PointCloud2 PointCloud;
+	ros::Publisher pub_point_cloud_;
+
+	
+	std::vector<double> D_;
+	boost::array<double, 9> K_;
+  
+	int width_;
+	int height_;
+
+	cv::Mat binned;
+  
+	virtual void onInit();
+
+	void connectCb();
+
+	void depthCb(const sensor_msgs::ImageConstPtr& depth_msg,
+		     const sensor_msgs::CameraInfoConstPtr& info_msg);
+
+	// Handles float or uint16 depths
+	template<typename T>
+	void convert(const sensor_msgs::ImageConstPtr& depth_msg, PointCloud::Ptr& cloud_msg);
+    };
+
+    cv::Mat initMatrix(cv::Mat cameraMatrix, cv::Mat distCoeffs, int width, int height, bool radial)
+    {
+	int i,j;
+	int totalsize = width*height;
+	cv::Mat pixelVectors(1,totalsize,CV_32FC3);
+	cv::Mat dst(1,totalsize,CV_32FC3);
+
+	cv::Mat sensorPoints(cv::Size(height,width), CV_32FC2);
+	cv::Mat undistortedSensorPoints(1,totalsize, CV_32FC2);
+
+	std::vector<cv::Mat> ch;
+	for(j = 0; j < height; j++)
+	{
+	    for(i = 0; i < width; i++)
+	    {
+		cv::Vec2f &p = sensorPoints.at<cv::Vec2f>(i,j);
+		p[0] = i;
+		p[1] = j;
+	    }
+	}
+
+	sensorPoints = sensorPoints.reshape(2,1);
+
+	cv::undistortPoints(sensorPoints, undistortedSensorPoints, cameraMatrix, distCoeffs);
+
+	ch.push_back(undistortedSensorPoints);
+	ch.push_back(cv::Mat::ones(1,totalsize,CV_32FC1));
+	cv::merge(ch,pixelVectors);
+
+	if(radial)
+	{
+	    for(i = 0; i < totalsize; i++)
+	    {
+		normalize(pixelVectors.at<cv::Vec3f>(i),
+			  dst.at<cv::Vec3f>(i));
+	    }
+	    pixelVectors = dst;
+	}
+	return pixelVectors.reshape(3,width);
+    }
+  
+
+    void PointCloudXyzRadialNodelet::onInit()
+    {
+	ros::NodeHandle& nh         = getNodeHandle();
+	ros::NodeHandle& private_nh = getPrivateNodeHandle();
+	it_.reset(new image_transport::ImageTransport(nh));
+
+	// Read parameters
+	private_nh.param("queue_size", queue_size_, 5);
+
+	// Monitor whether anyone is subscribed to the output
+	ros::SubscriberStatusCallback connect_cb = 
+	    boost::bind(&PointCloudXyzRadialNodelet::connectCb, this);
+	// Make sure we don't enter connectCb() between advertising and assigning to pub_point_cloud_
+	boost::lock_guard<boost::mutex> lock(connect_mutex_);
+	pub_point_cloud_ = nh.advertise<PointCloud>("points", 1, connect_cb, connect_cb);
+    }
+
+    // Handles (un)subscribing when clients (un)subscribe
+    void PointCloudXyzRadialNodelet::connectCb()
+    {
+	boost::lock_guard<boost::mutex> lock(connect_mutex_);
+	if (pub_point_cloud_.getNumSubscribers() == 0)
+	{
+	    sub_depth_.shutdown();
+	}
+	else if (!sub_depth_)
+	{
+	    image_transport::TransportHints hints("raw", ros::TransportHints(), getPrivateNodeHandle());
+	    sub_depth_ = it_->subscribeCamera("image_raw",
+					      queue_size_,
+					      &PointCloudXyzRadialNodelet::depthCb,
+					      this, hints);
+	}
+    }
+
+    void PointCloudXyzRadialNodelet::depthCb(const sensor_msgs::ImageConstPtr& depth_msg,
+					     const sensor_msgs::CameraInfoConstPtr& info_msg)
+    {
+	PointCloud::Ptr cloud_msg(new PointCloud);
+	cloud_msg->header = depth_msg->header;
+	cloud_msg->height = depth_msg->height;
+	cloud_msg->width  = depth_msg->width;
+	cloud_msg->is_dense = false;
+	cloud_msg->is_bigendian = false;
+
+	sensor_msgs::PointCloud2Modifier pcd_modifier(*cloud_msg);
+	pcd_modifier.setPointCloud2FieldsByString(1, "xyz");
+
+	if(info_msg->D != D_ || info_msg->K != K_ || width_ != info_msg->width ||
+	   height_ != info_msg->height)
+	{
+	    D_ = info_msg->D;
+	    K_ = info_msg->K;
+	    width_ = info_msg->width;
+	    height_ = info_msg->height;
+	    binned = initMatrix(cv::Mat_<double>(3, 3, &K_[0]),cv::Mat(D_),width_,height_,true);
+	}
+
+	if (depth_msg->encoding == enc::TYPE_16UC1)
+	{
+	    convert<uint16_t>(depth_msg, cloud_msg);
+	}
+	else if (depth_msg->encoding == enc::TYPE_32FC1)
+	{
+	    convert<float>(depth_msg, cloud_msg);
+	}
+	else
+	{
+	    NODELET_ERROR_THROTTLE(5, "Depth image has unsupported encoding [%s]", depth_msg->encoding.c_str());
+	    return;
+	}
+
+	pub_point_cloud_.publish (cloud_msg);
+    }
+
+    template<typename T>
+    void PointCloudXyzRadialNodelet::convert(const sensor_msgs::ImageConstPtr& depth_msg, PointCloud::Ptr& cloud_msg)
+    {
+	// Combine unit conversion (if necessary) with scaling by focal length for computing (X,Y)
+	double unit_scaling = DepthTraits<T>::toMeters( T(1) );
+	float bad_point = std::numeric_limits<float>::quiet_NaN();
+
+	sensor_msgs::PointCloud2Iterator<float> iter_x(*cloud_msg, "x");
+	sensor_msgs::PointCloud2Iterator<float> iter_y(*cloud_msg, "y");
+	sensor_msgs::PointCloud2Iterator<float> iter_z(*cloud_msg, "z");
+	const T* depth_row = reinterpret_cast<const T*>(&depth_msg->data[0]);
+	int row_step = depth_msg->step / sizeof(T);
+	for (int v = 0; v < (int)cloud_msg->height; ++v, depth_row += row_step)
+	{
+	    for (int u = 0; u < (int)cloud_msg->width; ++u, ++iter_x, ++iter_y, ++iter_z)
+	    {
+		T depth = depth_row[u];
+
+		// Missing points denoted by NaNs
+		if (!DepthTraits<T>::valid(depth))
+		{
+		    *iter_x = *iter_y = *iter_z = bad_point;
+		    continue;
+		}
+		const cv::Vec3f &cvPoint = binned.at<cv::Vec3f>(u,v) * DepthTraits<T>::toMeters(depth);
+		// Fill in XYZ
+		*iter_x = cvPoint(0);
+		*iter_y = cvPoint(1);
+		*iter_z = cvPoint(2);
+	    }
+	}
+    }
+
+} // namespace depth_image_proc
+
+// Register as nodelet
+#include <pluginlib/class_list_macros.hpp>
+PLUGINLIB_EXPORT_CLASS(depth_image_proc::PointCloudXyzRadialNodelet,nodelet::Nodelet);
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/src/nodelets/point_cloud_xyzi.cpp
@@ -0,0 +1,326 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#include <boost/version.hpp>
+#if ((BOOST_VERSION / 100) % 1000) >= 53
+#include <boost/thread/lock_guard.hpp>
+#endif
+
+#include <ros/ros.h>
+#include <nodelet/nodelet.h>
+#include <image_transport/image_transport.h>
+#include <image_transport/subscriber_filter.h>
+#include <message_filters/subscriber.h>
+#include <message_filters/synchronizer.h>
+#include <message_filters/sync_policies/approximate_time.h>
+#include <sensor_msgs/image_encodings.h>
+#include <sensor_msgs/point_cloud2_iterator.h>
+#include <sensor_msgs/PointCloud2.h>
+#include <image_geometry/pinhole_camera_model.h>
+#include <depth_image_proc/depth_traits.h>
+#include <cv_bridge/cv_bridge.h>
+#include <opencv2/imgproc/imgproc.hpp>
+
+namespace depth_image_proc {
+
+using namespace message_filters::sync_policies;
+namespace enc = sensor_msgs::image_encodings;
+
+class PointCloudXyziNodelet : public nodelet::Nodelet
+{
+  ros::NodeHandlePtr intensity_nh_;
+  boost::shared_ptr<image_transport::ImageTransport> intensity_it_, depth_it_;
+  
+  // Subscriptions
+  image_transport::SubscriberFilter sub_depth_, sub_intensity_;
+  message_filters::Subscriber<sensor_msgs::CameraInfo> sub_info_;
+  typedef ApproximateTime<sensor_msgs::Image, sensor_msgs::Image, sensor_msgs::CameraInfo> SyncPolicy;
+  typedef message_filters::Synchronizer<SyncPolicy> Synchronizer;
+  boost::shared_ptr<Synchronizer> sync_;
+
+  // Publications
+  boost::mutex connect_mutex_;
+  typedef sensor_msgs::PointCloud2 PointCloud;
+  ros::Publisher pub_point_cloud_;
+
+  image_geometry::PinholeCameraModel model_;
+
+  virtual void onInit();
+
+  void connectCb();
+
+  void imageCb(const sensor_msgs::ImageConstPtr& depth_msg,
+               const sensor_msgs::ImageConstPtr& intensity_msg,
+               const sensor_msgs::CameraInfoConstPtr& info_msg);
+
+  template<typename T, typename T2>
+  void convert(const sensor_msgs::ImageConstPtr& depth_msg,
+               const sensor_msgs::ImageConstPtr& intensity_msg,
+               const PointCloud::Ptr& cloud_msg);
+};
+
+void PointCloudXyziNodelet::onInit()
+{
+  ros::NodeHandle& nh         = getNodeHandle();
+  ros::NodeHandle& private_nh = getPrivateNodeHandle();
+  intensity_nh_.reset( new ros::NodeHandle(nh, "intensity") );
+  ros::NodeHandle depth_nh(nh, "depth");
+  intensity_it_  .reset( new image_transport::ImageTransport(*intensity_nh_) );
+  depth_it_.reset( new image_transport::ImageTransport(depth_nh) );
+
+  // Read parameters
+  int queue_size;
+  private_nh.param("queue_size", queue_size, 5);
+
+  // Synchronize inputs. Topic subscriptions happen on demand in the connection callback.
+  sync_.reset( new Synchronizer(SyncPolicy(queue_size), sub_depth_, sub_intensity_, sub_info_) );
+  sync_->registerCallback(boost::bind(&PointCloudXyziNodelet::imageCb, this, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3));
+  
+  // Monitor whether anyone is subscribed to the output
+  ros::SubscriberStatusCallback connect_cb = boost::bind(&PointCloudXyziNodelet::connectCb, this);
+  // Make sure we don't enter connectCb() between advertising and assigning to pub_point_cloud_
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  pub_point_cloud_ = depth_nh.advertise<PointCloud>("points", 1, connect_cb, connect_cb);
+}
+
+// Handles (un)subscribing when clients (un)subscribe
+void PointCloudXyziNodelet::connectCb()
+{
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  if (pub_point_cloud_.getNumSubscribers() == 0)
+  {
+    sub_depth_.unsubscribe();
+    sub_intensity_  .unsubscribe();
+    sub_info_ .unsubscribe();
+  }
+  else if (!sub_depth_.getSubscriber())
+  {
+    ros::NodeHandle& private_nh = getPrivateNodeHandle();
+    // parameter for depth_image_transport hint
+    std::string depth_image_transport_param = "depth_image_transport";
+
+    // depth image can use different transport.(e.g. compressedDepth)
+    image_transport::TransportHints depth_hints("raw",ros::TransportHints(), private_nh, depth_image_transport_param);
+    sub_depth_.subscribe(*depth_it_, "image_rect",       1, depth_hints);
+
+    // intensity uses normal ros transport hints.
+    image_transport::TransportHints hints("raw", ros::TransportHints(), private_nh);
+    sub_intensity_.subscribe(*intensity_it_,   "image_rect", 1, hints);
+    sub_info_.subscribe(*intensity_nh_,   "camera_info",      1);
+  }
+}
+
+void PointCloudXyziNodelet::imageCb(const sensor_msgs::ImageConstPtr& depth_msg,
+                                      const sensor_msgs::ImageConstPtr& intensity_msg_in,
+                                      const sensor_msgs::CameraInfoConstPtr& info_msg)
+{
+  // Check for bad inputs
+  if (depth_msg->header.frame_id != intensity_msg_in->header.frame_id)
+  {
+    NODELET_ERROR_THROTTLE(5, "Depth image frame id [%s] doesn't match image frame id [%s]",
+                           depth_msg->header.frame_id.c_str(), intensity_msg_in->header.frame_id.c_str());
+    return;
+  }
+
+  // Update camera model
+  model_.fromCameraInfo(info_msg);
+
+  // Check if the input image has to be resized
+  sensor_msgs::ImageConstPtr intensity_msg = intensity_msg_in;
+  if (depth_msg->width != intensity_msg->width || depth_msg->height != intensity_msg->height)
+  {
+    sensor_msgs::CameraInfo info_msg_tmp = *info_msg;
+    info_msg_tmp.width = depth_msg->width;
+    info_msg_tmp.height = depth_msg->height;
+    float ratio = float(depth_msg->width)/float(intensity_msg->width);
+    info_msg_tmp.K[0] *= ratio;
+    info_msg_tmp.K[2] *= ratio;
+    info_msg_tmp.K[4] *= ratio;
+    info_msg_tmp.K[5] *= ratio;
+    info_msg_tmp.P[0] *= ratio;
+    info_msg_tmp.P[2] *= ratio;
+    info_msg_tmp.P[5] *= ratio;
+    info_msg_tmp.P[6] *= ratio;
+    model_.fromCameraInfo(info_msg_tmp);
+
+    cv_bridge::CvImageConstPtr cv_ptr;
+    try
+    {
+      cv_ptr = cv_bridge::toCvShare(intensity_msg, intensity_msg->encoding);
+    }
+    catch (cv_bridge::Exception& e)
+    {
+      ROS_ERROR("cv_bridge exception: %s", e.what());
+      return;
+    }
+    cv_bridge::CvImage cv_rsz;
+    cv_rsz.header = cv_ptr->header;
+    cv_rsz.encoding = cv_ptr->encoding;
+    cv::resize(cv_ptr->image.rowRange(0,depth_msg->height/ratio), cv_rsz.image, cv::Size(depth_msg->width, depth_msg->height));
+    if ((intensity_msg->encoding == enc::MONO8) || (intensity_msg->encoding == enc::MONO16))
+      intensity_msg = cv_rsz.toImageMsg();
+    else
+      intensity_msg = cv_bridge::toCvCopy(cv_rsz.toImageMsg(), enc::MONO8)->toImageMsg();
+
+    //NODELET_ERROR_THROTTLE(5, "Depth resolution (%ux%u) does not match resolution (%ux%u)",
+    //                       depth_msg->width, depth_msg->height, rgb_msg->width, rgb_msg->height);
+    //return;
+  } else
+    intensity_msg = intensity_msg_in;
+
+  // Supported color encodings: MONO8, MONO16
+  if (intensity_msg->encoding != enc::MONO8 && intensity_msg->encoding != enc::MONO16)
+  {
+    try
+    {
+      intensity_msg = cv_bridge::toCvCopy(intensity_msg, enc::MONO8)->toImageMsg();
+    }
+    catch (cv_bridge::Exception& e)
+    {
+      NODELET_ERROR_THROTTLE(5, "Unsupported encoding [%s]: %s", intensity_msg->encoding.c_str(), e.what());
+      return;
+    }
+  }
+
+  // Allocate new point cloud message
+  PointCloud::Ptr cloud_msg (new PointCloud);
+  cloud_msg->header = depth_msg->header; // Use depth image time stamp
+  cloud_msg->height = depth_msg->height;
+  cloud_msg->width  = depth_msg->width;
+  cloud_msg->is_dense = false;
+  cloud_msg->is_bigendian = false;
+
+  sensor_msgs::PointCloud2Modifier pcd_modifier(*cloud_msg);
+//  pcd_modifier.setPointCloud2FieldsByString(2, "xyz", "i");
+  pcd_modifier.setPointCloud2Fields(4,
+   "x", 1, sensor_msgs::PointField::FLOAT32,
+   "y", 1, sensor_msgs::PointField::FLOAT32,
+   "z", 1, sensor_msgs::PointField::FLOAT32,
+   "intensity", 1, sensor_msgs::PointField::FLOAT32);
+
+
+  if (depth_msg->encoding == enc::TYPE_16UC1 && 
+      intensity_msg->encoding == enc::MONO8)
+  {
+    convert<uint16_t, uint8_t>(depth_msg, intensity_msg, cloud_msg);
+  }
+  else if (depth_msg->encoding == enc::TYPE_16UC1 && 
+      intensity_msg->encoding == enc::MONO16)
+  {
+    convert<uint16_t, uint16_t>(depth_msg, intensity_msg, cloud_msg);
+  }
+  else if (depth_msg->encoding == enc::TYPE_16UC1 &&
+      intensity_msg->encoding == enc::TYPE_32FC1)
+  {
+    convert<uint16_t,float>(depth_msg, intensity_msg, cloud_msg);
+  }
+  else if (depth_msg->encoding == enc::TYPE_32FC1 &&
+      intensity_msg->encoding == enc::MONO8)
+  {
+    convert<float, uint8_t>(depth_msg, intensity_msg, cloud_msg);
+  }
+  else if (depth_msg->encoding == enc::TYPE_32FC1 &&
+      intensity_msg->encoding == enc::MONO16)
+  {
+    convert<float, uint16_t>(depth_msg, intensity_msg, cloud_msg);
+  }
+  else if (depth_msg->encoding == enc::TYPE_32FC1 &&
+      intensity_msg->encoding == enc::TYPE_32FC1)
+  {
+    convert<float,float>(depth_msg, intensity_msg, cloud_msg);
+  }
+  else
+  {
+    NODELET_ERROR_THROTTLE(5, "Depth image has unsupported encoding [%s]", depth_msg->encoding.c_str());
+    return;
+  }
+
+  pub_point_cloud_.publish (cloud_msg);
+}
+
+template<typename T, typename T2>
+void PointCloudXyziNodelet::convert(const sensor_msgs::ImageConstPtr& depth_msg,
+                                      const sensor_msgs::ImageConstPtr& intensity_msg,
+                                      const PointCloud::Ptr& cloud_msg)
+{
+  // Use correct principal point from calibration
+  float center_x = model_.cx();
+  float center_y = model_.cy();
+
+  // Combine unit conversion (if necessary) with scaling by focal length for computing (X,Y)
+  double unit_scaling = DepthTraits<T>::toMeters( T(1) );
+  float constant_x = unit_scaling / model_.fx();
+  float constant_y = unit_scaling / model_.fy();
+  float bad_point = std::numeric_limits<float>::quiet_NaN ();
+  
+  const T* depth_row = reinterpret_cast<const T*>(&depth_msg->data[0]);
+  int row_step = depth_msg->step / sizeof(T);
+
+  const T2* inten_row = reinterpret_cast<const T2*>(&intensity_msg->data[0]);
+  int inten_row_step  = intensity_msg->step / sizeof(T2);
+
+  sensor_msgs::PointCloud2Iterator<float> iter_x(*cloud_msg, "x");
+  sensor_msgs::PointCloud2Iterator<float> iter_y(*cloud_msg, "y");
+  sensor_msgs::PointCloud2Iterator<float> iter_z(*cloud_msg, "z");
+  sensor_msgs::PointCloud2Iterator<float> iter_i(*cloud_msg, "intensity");
+
+  for (int v = 0; v < int(cloud_msg->height); ++v, depth_row += row_step, inten_row += inten_row_step)
+  {
+    for (int u = 0; u < int(cloud_msg->width); ++u, ++iter_x, ++iter_y, ++iter_z, ++iter_i)
+    {
+      T depth = depth_row[u];
+      T2 inten = inten_row[u];
+      // Check for invalid measurements
+      if (!DepthTraits<T>::valid(depth))
+      {
+        *iter_x = *iter_y = *iter_z = bad_point;
+      }
+      else
+      {
+        // Fill in XYZ
+        *iter_x = (u - center_x) * depth * constant_x;
+        *iter_y = (v - center_y) * depth * constant_y;
+        *iter_z = DepthTraits<T>::toMeters(depth);
+      }
+
+      // Fill in intensity
+      *iter_i = inten;
+    }
+  }
+}
+
+} // namespace depth_image_proc
+
+// Register as nodelet
+#include <pluginlib/class_list_macros.hpp>
+PLUGINLIB_EXPORT_CLASS(depth_image_proc::PointCloudXyziNodelet,nodelet::Nodelet);
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/src/nodelets/point_cloud_xyzi_radial.cpp
@@ -0,0 +1,318 @@
+/*********************************************************************
+ * Software License Agreement (BSD License)
+ * 
+ *  Copyright (c) 2008, Willow Garage, Inc.
+ *  All rights reserved.
+ * 
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ * 
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the Willow Garage nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ * 
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *********************************************************************/
+#include <ros/ros.h>
+#include <nodelet/nodelet.h>
+#include <image_transport/image_transport.h>
+#include <sensor_msgs/image_encodings.h>
+#include <image_transport/subscriber_filter.h>
+#include <message_filters/subscriber.h>
+#include <message_filters/synchronizer.h>
+#include <message_filters/sync_policies/exact_time.h>
+#include <image_geometry/pinhole_camera_model.h>
+#include <opencv2/calib3d/calib3d.hpp>
+#include <boost/thread.hpp>
+#include <depth_image_proc/depth_traits.h>
+
+#include <sensor_msgs/point_cloud2_iterator.h>
+
+namespace depth_image_proc {
+
+    using namespace message_filters::sync_policies;
+    namespace enc = sensor_msgs::image_encodings;
+    typedef ExactTime<sensor_msgs::Image, sensor_msgs::Image, sensor_msgs::CameraInfo> SyncPolicy;
+
+    class PointCloudXyziRadialNodelet : public nodelet::Nodelet
+    {
+	ros::NodeHandlePtr intensity_nh_;
+
+	// Subscriptions
+	boost::shared_ptr<image_transport::ImageTransport> intensity_it_, depth_it_;
+	image_transport::SubscriberFilter sub_depth_, sub_intensity_;
+	message_filters::Subscriber<sensor_msgs::CameraInfo> sub_info_;
+
+	int queue_size_;
+
+	// Publications
+	boost::mutex connect_mutex_;
+	typedef sensor_msgs::PointCloud2 PointCloud;
+	ros::Publisher pub_point_cloud_;
+
+	
+	typedef message_filters::Synchronizer<SyncPolicy> Synchronizer;
+	boost::shared_ptr<Synchronizer> sync_;
+
+	std::vector<double> D_;
+	boost::array<double, 9> K_;
+  
+	int width_;
+	int height_;
+
+	cv::Mat transform_;
+  
+	virtual void onInit();
+
+	void connectCb();
+
+	void imageCb(const sensor_msgs::ImageConstPtr& depth_msg,
+		     const sensor_msgs::ImageConstPtr& intensity_msg_in,
+		     const sensor_msgs::CameraInfoConstPtr& info_msg);
+
+	// Handles float or uint16 depths
+	template<typename T>
+	void convert_depth(const sensor_msgs::ImageConstPtr& depth_msg, PointCloud::Ptr& cloud_msg);
+
+	template<typename T>
+	void convert_intensity(const sensor_msgs::ImageConstPtr &inten_msg, PointCloud::Ptr& cloud_msg);
+
+	cv::Mat initMatrix(cv::Mat cameraMatrix, cv::Mat distCoeffs, int width, int height, bool radial);
+
+    };
+
+    cv::Mat PointCloudXyziRadialNodelet::initMatrix(cv::Mat cameraMatrix, cv::Mat distCoeffs, int width, int height, bool radial)
+    {
+	int i,j;
+	int totalsize = width*height;
+	cv::Mat pixelVectors(1,totalsize,CV_32FC3);
+	cv::Mat dst(1,totalsize,CV_32FC3);
+
+	cv::Mat sensorPoints(cv::Size(height,width), CV_32FC2);
+	cv::Mat undistortedSensorPoints(1,totalsize, CV_32FC2);
+
+	std::vector<cv::Mat> ch;
+	for(j = 0; j < height; j++)
+	{
+	    for(i = 0; i < width; i++)
+	    {
+		cv::Vec2f &p = sensorPoints.at<cv::Vec2f>(i,j);
+		p[0] = i;
+		p[1] = j;
+	    }
+	}
+
+	sensorPoints = sensorPoints.reshape(2,1);
+
+	cv::undistortPoints(sensorPoints, undistortedSensorPoints, cameraMatrix, distCoeffs);
+
+	ch.push_back(undistortedSensorPoints);
+	ch.push_back(cv::Mat::ones(1,totalsize,CV_32FC1));
+	cv::merge(ch,pixelVectors);
+
+	if(radial)
+	{
+	    for(i = 0; i < totalsize; i++)
+	    {
+		normalize(pixelVectors.at<cv::Vec3f>(i),
+			  dst.at<cv::Vec3f>(i));
+	    }
+	    pixelVectors = dst;
+	}
+	return pixelVectors.reshape(3,width);
+    }
+  
+
+    void PointCloudXyziRadialNodelet::onInit()
+    {
+	ros::NodeHandle& nh         = getNodeHandle();
+	ros::NodeHandle& private_nh = getPrivateNodeHandle();
+
+	intensity_nh_.reset( new ros::NodeHandle(nh, "intensity") );
+	ros::NodeHandle depth_nh(nh, "depth");
+	intensity_it_  .reset( new image_transport::ImageTransport(*intensity_nh_) );
+	depth_it_.reset( new image_transport::ImageTransport(depth_nh) );
+
+	// Read parameters
+	private_nh.param("queue_size", queue_size_, 5);
+
+	// Synchronize inputs. Topic subscriptions happen on demand in the connection callback.
+	sync_.reset( new Synchronizer(SyncPolicy(queue_size_), sub_depth_, sub_intensity_, sub_info_) );
+	sync_->registerCallback(boost::bind(&PointCloudXyziRadialNodelet::imageCb, this, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3));
+    
+	// Monitor whether anyone is subscribed to the output
+	ros::SubscriberStatusCallback connect_cb = 
+	    boost::bind(&PointCloudXyziRadialNodelet::connectCb, this);
+	// Make sure we don't enter connectCb() between advertising and assigning to pub_point_cloud_
+	boost::lock_guard<boost::mutex> lock(connect_mutex_);
+	pub_point_cloud_ = nh.advertise<PointCloud>("points", 20, connect_cb, connect_cb);
+    }
+
+    // Handles (un)subscribing when clients (un)subscribe
+    void PointCloudXyziRadialNodelet::connectCb()
+    {
+	boost::lock_guard<boost::mutex> lock(connect_mutex_);
+
+	if (pub_point_cloud_.getNumSubscribers() == 0)
+	{
+	    sub_depth_.unsubscribe();
+	    sub_intensity_.unsubscribe();
+	    sub_info_.unsubscribe();
+	}
+	else if (!sub_depth_.getSubscriber())
+	{
+	    ros::NodeHandle& private_nh = getPrivateNodeHandle();
+	    // parameter for depth_image_transport hint
+	    std::string depth_image_transport_param = "depth_image_transport";
+	
+	    // depth image can use different transport.(e.g. compressedDepth)
+	    image_transport::TransportHints depth_hints("raw",ros::TransportHints(), private_nh, depth_image_transport_param);
+	    sub_depth_.subscribe(*depth_it_, "image_raw",       5, depth_hints);
+	
+	    // intensity uses normal ros transport hints.
+	    image_transport::TransportHints hints("raw", ros::TransportHints(), private_nh);
+	    sub_intensity_.subscribe(*intensity_it_,   "image_raw", 5, hints);
+	    sub_info_.subscribe(*intensity_nh_,   "camera_info",      5);
+	}
+    }
+
+    void PointCloudXyziRadialNodelet::imageCb(const sensor_msgs::ImageConstPtr& depth_msg,
+					      const sensor_msgs::ImageConstPtr& intensity_msg,
+					      const sensor_msgs::CameraInfoConstPtr& info_msg)
+    {
+	PointCloud::Ptr cloud_msg(new PointCloud);
+	cloud_msg->header = depth_msg->header;
+	cloud_msg->height = depth_msg->height;
+	cloud_msg->width  = depth_msg->width;
+	cloud_msg->is_dense = false;
+	cloud_msg->is_bigendian = false;
+
+	sensor_msgs::PointCloud2Modifier pcd_modifier(*cloud_msg);
+	pcd_modifier.setPointCloud2Fields(4,
+					  "x", 1, sensor_msgs::PointField::FLOAT32,
+					  "y", 1, sensor_msgs::PointField::FLOAT32,
+					  "z", 1, sensor_msgs::PointField::FLOAT32,
+					  "intensity", 1, sensor_msgs::PointField::FLOAT32);
+
+
+	if(info_msg->D != D_ || info_msg->K != K_ || width_ != info_msg->width ||
+	   height_ != info_msg->height)
+	{
+	    D_ = info_msg->D;
+	    K_ = info_msg->K;
+	    width_ = info_msg->width;
+	    height_ = info_msg->height;
+	    transform_ = initMatrix(cv::Mat_<double>(3, 3, &K_[0]),cv::Mat(D_),width_,height_,true);
+	}
+
+	if (depth_msg->encoding == enc::TYPE_16UC1)
+	{
+	    convert_depth<uint16_t>(depth_msg, cloud_msg);
+	}
+	else if (depth_msg->encoding == enc::TYPE_32FC1)
+	{
+	    convert_depth<float>(depth_msg, cloud_msg);
+	}
+	else
+	{
+	    NODELET_ERROR_THROTTLE(5, "Depth image has unsupported encoding [%s]", depth_msg->encoding.c_str());
+	    return;
+	}
+
+	if(intensity_msg->encoding == enc::TYPE_16UC1)
+	{
+	    convert_intensity<uint16_t>(intensity_msg, cloud_msg);
+
+	}
+	else if(intensity_msg->encoding == enc::MONO8)
+	{
+	    convert_intensity<uint8_t>(intensity_msg, cloud_msg);
+	}
+	else if(intensity_msg->encoding == enc::TYPE_32FC1)
+	{
+	    convert_intensity<float>(intensity_msg, cloud_msg);
+	}
+	else
+	{
+	    NODELET_ERROR_THROTTLE(5, "Intensity image has unsupported encoding [%s]", intensity_msg->encoding.c_str());
+	    return;
+	}
+
+	pub_point_cloud_.publish (cloud_msg);
+    }
+
+    template<typename T>
+    void PointCloudXyziRadialNodelet::convert_depth(const sensor_msgs::ImageConstPtr& depth_msg,
+						    PointCloud::Ptr& cloud_msg)
+    {
+	// Combine unit conversion (if necessary) with scaling by focal length for computing (X,Y)
+	double unit_scaling = DepthTraits<T>::toMeters( T(1) );
+	float bad_point = std::numeric_limits<float>::quiet_NaN();
+
+	sensor_msgs::PointCloud2Iterator<float> iter_x(*cloud_msg, "x");
+	sensor_msgs::PointCloud2Iterator<float> iter_y(*cloud_msg, "y");
+	sensor_msgs::PointCloud2Iterator<float> iter_z(*cloud_msg, "z");
+	const T* depth_row = reinterpret_cast<const T*>(&depth_msg->data[0]);
+    
+	int row_step   = depth_msg->step / sizeof(T);
+	for (int v = 0; v < (int)cloud_msg->height; ++v, depth_row += row_step)
+	{
+	    for (int u = 0; u < (int)cloud_msg->width; ++u, ++iter_x, ++iter_y, ++iter_z)
+	    {
+		T depth = depth_row[u];
+
+		// Missing points denoted by NaNs
+		if (!DepthTraits<T>::valid(depth))
+		{
+		    *iter_x = *iter_y = *iter_z = bad_point;
+		    continue;
+		}
+		const cv::Vec3f &cvPoint = transform_.at<cv::Vec3f>(u,v) * DepthTraits<T>::toMeters(depth);
+		// Fill in XYZ
+		*iter_x = cvPoint(0);
+		*iter_y = cvPoint(1);
+		*iter_z = cvPoint(2);
+	    }
+	}
+    }
+
+    template<typename T>
+    void PointCloudXyziRadialNodelet::convert_intensity(const sensor_msgs::ImageConstPtr& intensity_msg,
+							PointCloud::Ptr& cloud_msg)
+    {
+	sensor_msgs::PointCloud2Iterator<float> iter_i(*cloud_msg, "intensity");
+	const T* inten_row = reinterpret_cast<const T*>(&intensity_msg->data[0]);
+
+	const int i_row_step = intensity_msg->step/sizeof(T);
+	for (int v = 0; v < (int)cloud_msg->height; ++v, inten_row += i_row_step)
+	{
+	    for (int u = 0; u < (int)cloud_msg->width; ++u, ++iter_i)
+	    {
+		*iter_i = inten_row[u];
+	    }
+	}
+    }
+
+} // namespace depth_image_proc
+
+// Register as nodelet
+#include <pluginlib/class_list_macros.hpp>
+PLUGINLIB_EXPORT_CLASS(depth_image_proc::PointCloudXyziRadialNodelet,nodelet::Nodelet);
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/src/nodelets/point_cloud_xyzrgb.cpp
@@ -0,0 +1,359 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#include <boost/version.hpp>
+#if ((BOOST_VERSION / 100) % 1000) >= 53
+#include <boost/thread/lock_guard.hpp>
+#endif
+
+#include <ros/ros.h>
+#include <nodelet/nodelet.h>
+#include <image_transport/image_transport.h>
+#include <image_transport/subscriber_filter.h>
+#include <message_filters/subscriber.h>
+#include <message_filters/synchronizer.h>
+#include <message_filters/sync_policies/exact_time.h>
+#include <message_filters/sync_policies/approximate_time.h>
+#include <sensor_msgs/image_encodings.h>
+#include <sensor_msgs/point_cloud2_iterator.h>
+#include <sensor_msgs/PointCloud2.h>
+#include <image_geometry/pinhole_camera_model.h>
+#include <depth_image_proc/depth_traits.h>
+#include <cv_bridge/cv_bridge.h>
+#include <opencv2/imgproc/imgproc.hpp>
+
+namespace depth_image_proc {
+
+using namespace message_filters::sync_policies;
+namespace enc = sensor_msgs::image_encodings;
+
+class PointCloudXyzrgbNodelet : public nodelet::Nodelet
+{
+  ros::NodeHandlePtr rgb_nh_;
+  boost::shared_ptr<image_transport::ImageTransport> rgb_it_, depth_it_;
+  
+  // Subscriptions
+  image_transport::SubscriberFilter sub_depth_, sub_rgb_;
+  message_filters::Subscriber<sensor_msgs::CameraInfo> sub_info_;
+  typedef ApproximateTime<sensor_msgs::Image, sensor_msgs::Image, sensor_msgs::CameraInfo> SyncPolicy;
+  typedef ExactTime<sensor_msgs::Image, sensor_msgs::Image, sensor_msgs::CameraInfo> ExactSyncPolicy;
+  typedef message_filters::Synchronizer<SyncPolicy> Synchronizer;
+  typedef message_filters::Synchronizer<ExactSyncPolicy> ExactSynchronizer;
+  boost::shared_ptr<Synchronizer> sync_;
+  boost::shared_ptr<ExactSynchronizer> exact_sync_;
+
+  // Publications
+  boost::mutex connect_mutex_;
+  typedef sensor_msgs::PointCloud2 PointCloud;
+  ros::Publisher pub_point_cloud_;
+
+  image_geometry::PinholeCameraModel model_;
+
+  virtual void onInit();
+
+  void connectCb();
+
+  void imageCb(const sensor_msgs::ImageConstPtr& depth_msg,
+               const sensor_msgs::ImageConstPtr& rgb_msg,
+               const sensor_msgs::CameraInfoConstPtr& info_msg);
+
+  template<typename T>
+  void convert(const sensor_msgs::ImageConstPtr& depth_msg,
+               const sensor_msgs::ImageConstPtr& rgb_msg,
+               const PointCloud::Ptr& cloud_msg,
+               int red_offset, int green_offset, int blue_offset, int color_step);
+};
+
+void PointCloudXyzrgbNodelet::onInit()
+{
+  ros::NodeHandle& nh         = getNodeHandle();
+  ros::NodeHandle& private_nh = getPrivateNodeHandle();
+  rgb_nh_.reset( new ros::NodeHandle(nh, "rgb") );
+  ros::NodeHandle depth_nh(nh, "depth_registered");
+  rgb_it_  .reset( new image_transport::ImageTransport(*rgb_nh_) );
+  depth_it_.reset( new image_transport::ImageTransport(depth_nh) );
+
+  // Read parameters
+  int queue_size;
+  private_nh.param("queue_size", queue_size, 5);
+  bool use_exact_sync;
+  private_nh.param("exact_sync", use_exact_sync, false);
+
+  // Synchronize inputs. Topic subscriptions happen on demand in the connection callback.
+  if (use_exact_sync)
+  {
+    exact_sync_.reset( new ExactSynchronizer(ExactSyncPolicy(queue_size), sub_depth_, sub_rgb_, sub_info_) );
+    exact_sync_->registerCallback(boost::bind(&PointCloudXyzrgbNodelet::imageCb, this, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3));
+  }
+  else
+  {
+    sync_.reset( new Synchronizer(SyncPolicy(queue_size), sub_depth_, sub_rgb_, sub_info_) );
+    sync_->registerCallback(boost::bind(&PointCloudXyzrgbNodelet::imageCb, this, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3));
+  }
+  
+  // Monitor whether anyone is subscribed to the output
+  ros::SubscriberStatusCallback connect_cb = boost::bind(&PointCloudXyzrgbNodelet::connectCb, this);
+  // Make sure we don't enter connectCb() between advertising and assigning to pub_point_cloud_
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  pub_point_cloud_ = depth_nh.advertise<PointCloud>("points", 1, connect_cb, connect_cb);
+}
+
+// Handles (un)subscribing when clients (un)subscribe
+void PointCloudXyzrgbNodelet::connectCb()
+{
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  if (pub_point_cloud_.getNumSubscribers() == 0)
+  {
+    sub_depth_.unsubscribe();
+    sub_rgb_  .unsubscribe();
+    sub_info_ .unsubscribe();
+  }
+  else if (!sub_depth_.getSubscriber())
+  {
+    ros::NodeHandle& private_nh = getPrivateNodeHandle();
+    // parameter for depth_image_transport hint
+    std::string depth_image_transport_param = "depth_image_transport";
+
+    // depth image can use different transport.(e.g. compressedDepth)
+    image_transport::TransportHints depth_hints("raw",ros::TransportHints(), private_nh, depth_image_transport_param);
+    sub_depth_.subscribe(*depth_it_, "image_rect",       1, depth_hints);
+
+    // rgb uses normal ros transport hints.
+    image_transport::TransportHints hints("raw", ros::TransportHints(), private_nh);
+    sub_rgb_  .subscribe(*rgb_it_,   "image_rect_color", 1, hints);
+    sub_info_ .subscribe(*rgb_nh_,   "camera_info",      1);
+  }
+}
+
+void PointCloudXyzrgbNodelet::imageCb(const sensor_msgs::ImageConstPtr& depth_msg,
+                                      const sensor_msgs::ImageConstPtr& rgb_msg_in,
+                                      const sensor_msgs::CameraInfoConstPtr& info_msg)
+{
+  // Check for bad inputs
+  if (depth_msg->header.frame_id != rgb_msg_in->header.frame_id)
+  {
+    NODELET_ERROR_THROTTLE(5, "Depth image frame id [%s] doesn't match RGB image frame id [%s]",
+                           depth_msg->header.frame_id.c_str(), rgb_msg_in->header.frame_id.c_str());
+    return;
+  }
+
+  // Update camera model
+  model_.fromCameraInfo(info_msg);
+
+  // Check if the input image has to be resized
+  sensor_msgs::ImageConstPtr rgb_msg = rgb_msg_in;
+  if (depth_msg->width != rgb_msg->width || depth_msg->height != rgb_msg->height)
+  {
+    sensor_msgs::CameraInfo info_msg_tmp = *info_msg;
+    info_msg_tmp.width = depth_msg->width;
+    info_msg_tmp.height = depth_msg->height;
+    float ratio = float(depth_msg->width)/float(rgb_msg->width);
+    info_msg_tmp.K[0] *= ratio;
+    info_msg_tmp.K[2] *= ratio;
+    info_msg_tmp.K[4] *= ratio;
+    info_msg_tmp.K[5] *= ratio;
+    info_msg_tmp.P[0] *= ratio;
+    info_msg_tmp.P[2] *= ratio;
+    info_msg_tmp.P[5] *= ratio;
+    info_msg_tmp.P[6] *= ratio;
+    model_.fromCameraInfo(info_msg_tmp);
+
+    cv_bridge::CvImageConstPtr cv_ptr;
+    try
+    {
+      cv_ptr = cv_bridge::toCvShare(rgb_msg, rgb_msg->encoding);
+    }
+    catch (cv_bridge::Exception& e)
+    {
+      ROS_ERROR("cv_bridge exception: %s", e.what());
+      return;
+    }
+    cv_bridge::CvImage cv_rsz;
+    cv_rsz.header = cv_ptr->header;
+    cv_rsz.encoding = cv_ptr->encoding;
+    cv::resize(cv_ptr->image.rowRange(0,depth_msg->height/ratio), cv_rsz.image, cv::Size(depth_msg->width, depth_msg->height));
+    if ((rgb_msg->encoding == enc::RGB8) || (rgb_msg->encoding == enc::BGR8) || (rgb_msg->encoding == enc::MONO8))
+      rgb_msg = cv_rsz.toImageMsg();
+    else
+      rgb_msg = cv_bridge::toCvCopy(cv_rsz.toImageMsg(), enc::RGB8)->toImageMsg();
+
+    //NODELET_ERROR_THROTTLE(5, "Depth resolution (%ux%u) does not match RGB resolution (%ux%u)",
+    //                       depth_msg->width, depth_msg->height, rgb_msg->width, rgb_msg->height);
+    //return;
+  } else
+    rgb_msg = rgb_msg_in;
+
+  // Supported color encodings: RGB8, BGR8, MONO8
+  int red_offset, green_offset, blue_offset, color_step;
+  if (rgb_msg->encoding == enc::RGB8)
+  {
+    red_offset   = 0;
+    green_offset = 1;
+    blue_offset  = 2;
+    color_step   = 3;
+  }
+  if (rgb_msg->encoding == enc::RGBA8)
+  {
+    red_offset   = 0;
+    green_offset = 1;
+    blue_offset  = 2;
+    color_step   = 4;
+  }
+  else if (rgb_msg->encoding == enc::BGR8)
+  {
+    red_offset   = 2;
+    green_offset = 1;
+    blue_offset  = 0;
+    color_step   = 3;
+  }
+  else if (rgb_msg->encoding == enc::BGRA8)
+  {
+    red_offset   = 2;
+    green_offset = 1;
+    blue_offset  = 0;
+    color_step   = 4;
+  }
+  else if (rgb_msg->encoding == enc::MONO8)
+  {
+    red_offset   = 0;
+    green_offset = 0;
+    blue_offset  = 0;
+    color_step   = 1;
+  }
+  else
+  {
+    try
+    {
+      rgb_msg = cv_bridge::toCvCopy(rgb_msg, enc::RGB8)->toImageMsg();
+    }
+    catch (cv_bridge::Exception& e)
+    {
+      NODELET_ERROR_THROTTLE(5, "Unsupported encoding [%s]: %s", rgb_msg->encoding.c_str(), e.what());
+      return;
+    }
+    red_offset   = 0;
+    green_offset = 1;
+    blue_offset  = 2;
+    color_step   = 3;
+  }
+
+  // Allocate new point cloud message
+  PointCloud::Ptr cloud_msg (new PointCloud);
+  cloud_msg->header = depth_msg->header; // Use depth image time stamp
+  cloud_msg->height = depth_msg->height;
+  cloud_msg->width  = depth_msg->width;
+  cloud_msg->is_dense = false;
+  cloud_msg->is_bigendian = false;
+
+  sensor_msgs::PointCloud2Modifier pcd_modifier(*cloud_msg);
+  pcd_modifier.setPointCloud2FieldsByString(2, "xyz", "rgb");
+
+  if (depth_msg->encoding == enc::TYPE_16UC1)
+  {
+    convert<uint16_t>(depth_msg, rgb_msg, cloud_msg, red_offset, green_offset, blue_offset, color_step);
+  }
+  else if (depth_msg->encoding == enc::TYPE_32FC1)
+  {
+    convert<float>(depth_msg, rgb_msg, cloud_msg, red_offset, green_offset, blue_offset, color_step);
+  }
+  else
+  {
+    NODELET_ERROR_THROTTLE(5, "Depth image has unsupported encoding [%s]", depth_msg->encoding.c_str());
+    return;
+  }
+
+  pub_point_cloud_.publish (cloud_msg);
+}
+
+template<typename T>
+void PointCloudXyzrgbNodelet::convert(const sensor_msgs::ImageConstPtr& depth_msg,
+                                      const sensor_msgs::ImageConstPtr& rgb_msg,
+                                      const PointCloud::Ptr& cloud_msg,
+                                      int red_offset, int green_offset, int blue_offset, int color_step)
+{
+  // Use correct principal point from calibration
+  float center_x = model_.cx();
+  float center_y = model_.cy();
+
+  // Combine unit conversion (if necessary) with scaling by focal length for computing (X,Y)
+  double unit_scaling = DepthTraits<T>::toMeters( T(1) );
+  float constant_x = unit_scaling / model_.fx();
+  float constant_y = unit_scaling / model_.fy();
+  float bad_point = std::numeric_limits<float>::quiet_NaN ();
+  
+  const T* depth_row = reinterpret_cast<const T*>(&depth_msg->data[0]);
+  int row_step = depth_msg->step / sizeof(T);
+  const uint8_t* rgb = &rgb_msg->data[0];
+  int rgb_skip = rgb_msg->step - rgb_msg->width * color_step;
+
+  sensor_msgs::PointCloud2Iterator<float> iter_x(*cloud_msg, "x");
+  sensor_msgs::PointCloud2Iterator<float> iter_y(*cloud_msg, "y");
+  sensor_msgs::PointCloud2Iterator<float> iter_z(*cloud_msg, "z");
+  sensor_msgs::PointCloud2Iterator<uint8_t> iter_r(*cloud_msg, "r");
+  sensor_msgs::PointCloud2Iterator<uint8_t> iter_g(*cloud_msg, "g");
+  sensor_msgs::PointCloud2Iterator<uint8_t> iter_b(*cloud_msg, "b");
+  sensor_msgs::PointCloud2Iterator<uint8_t> iter_a(*cloud_msg, "a");
+
+  for (int v = 0; v < int(cloud_msg->height); ++v, depth_row += row_step, rgb += rgb_skip)
+  {
+    for (int u = 0; u < int(cloud_msg->width); ++u, rgb += color_step, ++iter_x, ++iter_y, ++iter_z, ++iter_a, ++iter_r, ++iter_g, ++iter_b)
+    {
+      T depth = depth_row[u];
+
+      // Check for invalid measurements
+      if (!DepthTraits<T>::valid(depth))
+      {
+        *iter_x = *iter_y = *iter_z = bad_point;
+      }
+      else
+      {
+        // Fill in XYZ
+        *iter_x = (u - center_x) * depth * constant_x;
+        *iter_y = (v - center_y) * depth * constant_y;
+        *iter_z = DepthTraits<T>::toMeters(depth);
+      }
+
+      // Fill in color
+      *iter_a = 255;
+      *iter_r = rgb[red_offset];
+      *iter_g = rgb[green_offset];
+      *iter_b = rgb[blue_offset];
+    }
+  }
+}
+
+} // namespace depth_image_proc
+
+// Register as nodelet
+#include <pluginlib/class_list_macros.hpp>
+PLUGINLIB_EXPORT_CLASS(depth_image_proc::PointCloudXyzrgbNodelet,nodelet::Nodelet);
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/src/nodelets/point_cloud_xyzrgb_radial.cpp
@@ -0,0 +1,429 @@
+/*********************************************************************
+ * Software License Agreement (BSD License)
+ * 
+ *  Copyright (c) 2008, Willow Garage, Inc.
+ *  All rights reserved.
+ * 
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ * 
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the Willow Garage nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ * 
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *********************************************************************/
+#include <ros/ros.h>
+#include <nodelet/nodelet.h>
+#include <cv_bridge/cv_bridge.h>
+#include <image_transport/image_transport.h>
+#include <sensor_msgs/image_encodings.h>
+#include <image_transport/subscriber_filter.h>
+#include <message_filters/subscriber.h>
+#include <message_filters/synchronizer.h>
+#include <message_filters/sync_policies/exact_time.h>
+#include <message_filters/sync_policies/approximate_time.h>
+#include <image_geometry/pinhole_camera_model.h>
+#include <opencv2/calib3d/calib3d.hpp>
+#include <boost/thread.hpp>
+#include <depth_image_proc/depth_traits.h>
+
+#include <sensor_msgs/point_cloud2_iterator.h>
+
+namespace depth_image_proc {
+
+    using namespace message_filters::sync_policies;
+    namespace enc = sensor_msgs::image_encodings;
+    typedef ApproximateTime<sensor_msgs::Image, sensor_msgs::Image, sensor_msgs::CameraInfo> SyncPolicy;
+    typedef ExactTime<sensor_msgs::Image, sensor_msgs::Image, sensor_msgs::CameraInfo> ExactSyncPolicy;
+
+    class PointCloudXyzRgbRadialNodelet : public nodelet::Nodelet
+    {
+	ros::NodeHandlePtr rgb_nh_;
+
+	// Subscriptions
+	boost::shared_ptr<image_transport::ImageTransport> rgb_it_, depth_it_;
+	image_transport::SubscriberFilter sub_depth_, sub_rgb_;
+	message_filters::Subscriber<sensor_msgs::CameraInfo> sub_info_;
+
+	int queue_size_;
+
+	// Publications
+	boost::mutex connect_mutex_;
+	typedef sensor_msgs::PointCloud2 PointCloud;
+	ros::Publisher pub_point_cloud_;
+
+	
+	typedef message_filters::Synchronizer<SyncPolicy> Synchronizer;
+	typedef message_filters::Synchronizer<ExactSyncPolicy> ExactSynchronizer;
+	boost::shared_ptr<Synchronizer> sync_;
+	boost::shared_ptr<ExactSynchronizer> exact_sync_;
+
+	std::vector<double> D_;
+	boost::array<double, 9> K_;
+  
+	int width_;
+	int height_;
+
+	cv::Mat transform_;
+        image_geometry::PinholeCameraModel model_;
+	
+	virtual void onInit();
+
+	void connectCb();
+
+	void imageCb(const sensor_msgs::ImageConstPtr& depth_msg,
+		     const sensor_msgs::ImageConstPtr& rgb_msg_in,
+		     const sensor_msgs::CameraInfoConstPtr& info_msg);
+
+	// Handles float or uint16 depths
+	template<typename T>
+	void convert_depth(const sensor_msgs::ImageConstPtr& depth_msg, PointCloud::Ptr& cloud_msg);
+
+	void convert_rgb(const sensor_msgs::ImageConstPtr &rgb_msg, PointCloud::Ptr& cloud_msg,
+	  int red_offset, int green_offset, int blue_offset, int color_step);
+
+	cv::Mat initMatrix(cv::Mat cameraMatrix, cv::Mat distCoeffs, int width, int height, bool radial);
+
+    };
+
+    cv::Mat PointCloudXyzRgbRadialNodelet::initMatrix(cv::Mat cameraMatrix, cv::Mat distCoeffs, int width, int height, bool radial)
+    {
+	int i,j;
+	int totalsize = width*height;
+	cv::Mat pixelVectors(1,totalsize,CV_32FC3);
+	cv::Mat dst(1,totalsize,CV_32FC3);
+
+	cv::Mat sensorPoints(cv::Size(height,width), CV_32FC2);
+	cv::Mat undistortedSensorPoints(1,totalsize, CV_32FC2);
+
+	std::vector<cv::Mat> ch;
+	for(j = 0; j < height; j++)
+	{
+	    for(i = 0; i < width; i++)
+	    {
+		cv::Vec2f &p = sensorPoints.at<cv::Vec2f>(i,j);
+		p[0] = i;
+		p[1] = j;
+	    }
+	}
+
+	sensorPoints = sensorPoints.reshape(2,1);
+
+	cv::undistortPoints(sensorPoints, undistortedSensorPoints, cameraMatrix, distCoeffs);
+
+	ch.push_back(undistortedSensorPoints);
+	ch.push_back(cv::Mat::ones(1,totalsize,CV_32FC1));
+	cv::merge(ch,pixelVectors);
+
+	if(radial)
+	{
+	    for(i = 0; i < totalsize; i++)
+	    {
+		normalize(pixelVectors.at<cv::Vec3f>(i),
+			  dst.at<cv::Vec3f>(i));
+	    }
+	    pixelVectors = dst;
+	}
+	return pixelVectors.reshape(3,width);
+    }
+  
+
+    void PointCloudXyzRgbRadialNodelet::onInit()
+    {
+	NODELET_INFO("INIT XYZRGB RADIAL");
+	ros::NodeHandle& nh         = getNodeHandle();
+	ros::NodeHandle& private_nh = getPrivateNodeHandle();
+
+	rgb_nh_.reset( new ros::NodeHandle(nh, "rgb") );
+	ros::NodeHandle depth_nh(nh, "depth_registered");
+	rgb_it_  .reset( new image_transport::ImageTransport(*rgb_nh_) );
+	depth_it_.reset( new image_transport::ImageTransport(depth_nh) );
+
+	// Read parameters
+	private_nh.param("queue_size", queue_size_, 5);
+	bool use_exact_sync;
+	private_nh.param("exact_sync", use_exact_sync, false);
+
+	// Synchronize inputs. Topic subscriptions happen on demand in the connection callback.
+	if(use_exact_sync) {
+  	  exact_sync_.reset( new ExactSynchronizer(ExactSyncPolicy(queue_size_), sub_depth_, sub_rgb_, sub_info_) );
+  	  exact_sync_->registerCallback(
+            boost::bind(&PointCloudXyzRgbRadialNodelet::imageCb, this, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3));
+	} else {
+  	  sync_.reset( new Synchronizer(SyncPolicy(queue_size_), sub_depth_, sub_rgb_, sub_info_) );
+  	  sync_->registerCallback(
+            boost::bind(&PointCloudXyzRgbRadialNodelet::imageCb, this, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3));
+	}
+	// Monitor whether anyone is subscribed to the output
+	ros::SubscriberStatusCallback connect_cb = 
+	    boost::bind(&PointCloudXyzRgbRadialNodelet::connectCb, this);
+	// Make sure we don't enter connectCb() between advertising and assigning to pub_point_cloud_
+	boost::lock_guard<boost::mutex> lock(connect_mutex_);
+	pub_point_cloud_ = depth_nh.advertise<PointCloud>("points", 20, connect_cb, connect_cb);
+    }
+
+    // Handles (un)subscribing when clients (un)subscribe
+    void PointCloudXyzRgbRadialNodelet::connectCb()
+    {
+	boost::lock_guard<boost::mutex> lock(connect_mutex_);
+
+	if (pub_point_cloud_.getNumSubscribers() == 0)
+	{
+	    sub_depth_.unsubscribe();
+	    sub_rgb_.unsubscribe();
+	    sub_info_.unsubscribe();
+	}
+	else if (!sub_depth_.getSubscriber())
+	{
+	    ros::NodeHandle& private_nh = getPrivateNodeHandle();
+	    // parameter for depth_image_transport hint
+	    std::string depth_image_transport_param = "depth_image_transport";
+	
+	    // depth image can use different transport.(e.g. compressedDepth)
+	    image_transport::TransportHints depth_hints("raw",ros::TransportHints(), private_nh, depth_image_transport_param);
+	    sub_depth_.subscribe(*depth_it_, "image_rect",       1, depth_hints);
+	
+	    // intensity uses normal ros transport hints.
+	    image_transport::TransportHints hints("raw", ros::TransportHints(), private_nh);
+	    sub_rgb_.subscribe(*rgb_it_,   "image_rect_color", 1, hints);
+	    sub_info_.subscribe(*rgb_nh_,   "camera_info",      1);
+	
+	    NODELET_INFO("  subscribed to: %s", sub_rgb_.getTopic().c_str());
+	    NODELET_INFO("  subscribed to: %s", sub_depth_.getTopic().c_str());
+	    NODELET_INFO("  subscribed to: %s", sub_info_.getTopic().c_str());
+	}
+    }
+
+    void PointCloudXyzRgbRadialNodelet::imageCb(const sensor_msgs::ImageConstPtr& depth_msg,
+					      const sensor_msgs::ImageConstPtr& rgb_msg_in,
+					      const sensor_msgs::CameraInfoConstPtr& info_msg)
+    {
+	PointCloud::Ptr cloud_msg(new PointCloud);
+	cloud_msg->header = depth_msg->header;
+	cloud_msg->height = depth_msg->height;
+	cloud_msg->width  = depth_msg->width;
+	cloud_msg->is_dense = false;
+	cloud_msg->is_bigendian = false;
+
+	sensor_msgs::PointCloud2Modifier pcd_modifier(*cloud_msg);
+        pcd_modifier.setPointCloud2FieldsByString(2, "xyz", "rgb");
+//	pcd_modifier.setPointCloud2Fields(6,
+//          "x", 1, sensor_msgs::PointField::FLOAT32,
+//          "y", 1, sensor_msgs::PointField::FLOAT32,
+//          "z", 1, sensor_msgs::PointField::FLOAT32,
+//          "r", 1, sensor_msgs::PointField::UINT8,
+//          "g", 1, sensor_msgs::PointField::UINT8,
+//          "b", 1, sensor_msgs::PointField::UINT8);
+	  // Check for bad inputs
+  if (depth_msg->header.frame_id != rgb_msg_in->header.frame_id)
+  {
+    NODELET_ERROR_THROTTLE(5, "Depth image frame id [%s] doesn't match RGB image frame id [%s]",
+                           depth_msg->header.frame_id.c_str(), rgb_msg_in->header.frame_id.c_str());
+    return;
+  }
+
+  // Update camera model
+  model_.fromCameraInfo(info_msg);
+
+  // Check if the input image has to be resized
+  sensor_msgs::ImageConstPtr rgb_msg = rgb_msg_in;
+  if (depth_msg->width != rgb_msg->width || depth_msg->height != rgb_msg->height)
+  {
+    sensor_msgs::CameraInfo info_msg_tmp = *info_msg;
+    info_msg_tmp.width = depth_msg->width;
+    info_msg_tmp.height = depth_msg->height;
+    float ratio = float(depth_msg->width)/float(rgb_msg->width);
+    info_msg_tmp.K[0] *= ratio;
+    info_msg_tmp.K[2] *= ratio;
+    info_msg_tmp.K[4] *= ratio;
+    info_msg_tmp.K[5] *= ratio;
+    info_msg_tmp.P[0] *= ratio;
+    info_msg_tmp.P[2] *= ratio;
+    info_msg_tmp.P[5] *= ratio;
+    info_msg_tmp.P[6] *= ratio;
+    model_.fromCameraInfo(info_msg_tmp);
+
+
+	    cv_bridge::CvImageConstPtr cv_ptr;
+    try
+    {
+      cv_ptr = cv_bridge::toCvShare(rgb_msg, rgb_msg->encoding);
+    }
+    catch (cv_bridge::Exception& e)
+    {
+      ROS_ERROR("cv_bridge exception: %s", e.what());
+      return;
+    }
+    cv_bridge::CvImage cv_rsz;
+    cv_rsz.header = cv_ptr->header;
+    cv_rsz.encoding = cv_ptr->encoding;
+    cv::resize(cv_ptr->image.rowRange(0,depth_msg->height/ratio), cv_rsz.image, cv::Size(depth_msg->width, depth_msg->height));
+    if ((rgb_msg->encoding == enc::RGB8) || (rgb_msg->encoding == enc::BGR8) || (rgb_msg->encoding == enc::MONO8))
+      rgb_msg = cv_rsz.toImageMsg();
+    else
+      rgb_msg = cv_bridge::toCvCopy(cv_rsz.toImageMsg(), enc::RGB8)->toImageMsg();
+
+    //NODELET_ERROR_THROTTLE(5, "Depth resolution (%ux%u) does not match RGB resolution (%ux%u)",
+    //                       depth_msg->width, depth_msg->height, rgb_msg->width, rgb_msg->height);
+    //return;
+  } else {
+    rgb_msg = rgb_msg;
+  }
+
+
+	if(info_msg->D != D_ || info_msg->K != K_ || width_ != info_msg->width ||
+	   height_ != info_msg->height)
+	{
+	    D_ = info_msg->D;
+	    K_ = info_msg->K;
+	    width_ = info_msg->width;
+	    height_ = info_msg->height;
+	    transform_ = initMatrix(cv::Mat_<double>(3, 3, &K_[0]),cv::Mat(D_),width_,height_,true);
+	}
+
+	if (depth_msg->encoding == enc::TYPE_16UC1)
+	{
+	    convert_depth<uint16_t>(depth_msg, cloud_msg);
+	}
+	else if (depth_msg->encoding == enc::TYPE_32FC1)
+	{
+	    convert_depth<float>(depth_msg, cloud_msg);
+	}
+	else
+	{
+	    NODELET_ERROR_THROTTLE(5, "Depth image has unsupported encoding [%s]", depth_msg->encoding.c_str());
+	    return;
+	}
+
+        int red_offset, green_offset, blue_offset, color_step;
+	if(rgb_msg->encoding == enc::RGB8)
+	{
+		red_offset = 0;
+		green_offset = 1;
+		blue_offset = 2;
+		color_step = 3;
+	    convert_rgb(rgb_msg, cloud_msg, red_offset, green_offset, blue_offset, color_step);
+
+	}
+	if(rgb_msg->encoding == enc::RGBA8)
+	{
+		red_offset = 0;
+		green_offset = 1;
+		blue_offset = 2;
+		color_step = 4;
+	    convert_rgb(rgb_msg, cloud_msg, red_offset, green_offset, blue_offset, color_step);
+	}
+	else if(rgb_msg->encoding == enc::BGR8)
+	{
+		red_offset = 2;
+		green_offset = 1;
+		blue_offset = 0;
+		color_step = 3;
+	    convert_rgb(rgb_msg, cloud_msg, red_offset, green_offset, blue_offset, color_step);
+	}
+	else if(rgb_msg->encoding == enc::BGRA8)
+	{
+		red_offset = 2;
+		green_offset = 1;
+		blue_offset = 0;
+		color_step = 4;
+	    convert_rgb(rgb_msg, cloud_msg, red_offset, green_offset, blue_offset, color_step);
+	}
+	else if(rgb_msg->encoding == enc::MONO8)
+	{
+		red_offset = 0;
+		green_offset = 0;
+		blue_offset = 0;
+		color_step = 1;
+	    convert_rgb(rgb_msg, cloud_msg, red_offset, green_offset, blue_offset, color_step);
+	}
+	else
+	{
+	    NODELET_ERROR_THROTTLE(5, "RGB image has unsupported encoding [%s]", rgb_msg->encoding.c_str());
+	    return;
+	}
+
+	pub_point_cloud_.publish (cloud_msg);
+    }
+
+    template<typename T>
+    void PointCloudXyzRgbRadialNodelet::convert_depth(const sensor_msgs::ImageConstPtr& depth_msg,
+						    PointCloud::Ptr& cloud_msg)
+    {
+	// Combine unit conversion (if necessary) with scaling by focal length for computing (X,Y)
+	double unit_scaling = DepthTraits<T>::toMeters( T(1) );
+	float bad_point = std::numeric_limits<float>::quiet_NaN();
+
+	sensor_msgs::PointCloud2Iterator<float> iter_x(*cloud_msg, "x");
+	sensor_msgs::PointCloud2Iterator<float> iter_y(*cloud_msg, "y");
+	sensor_msgs::PointCloud2Iterator<float> iter_z(*cloud_msg, "z");
+	const T* depth_row = reinterpret_cast<const T*>(&depth_msg->data[0]);
+    
+	int row_step   = depth_msg->step / sizeof(T);
+	for (int v = 0; v < (int)cloud_msg->height; ++v, depth_row += row_step)
+	{
+	    for (int u = 0; u < (int)cloud_msg->width; ++u, ++iter_x, ++iter_y, ++iter_z)
+	    {
+		T depth = depth_row[u];
+
+		// Missing points denoted by NaNs
+		if (!DepthTraits<T>::valid(depth))
+		{
+		    *iter_x = *iter_y = *iter_z = bad_point;
+		    continue;
+		}
+		const cv::Vec3f &cvPoint = transform_.at<cv::Vec3f>(u,v) * DepthTraits<T>::toMeters(depth);
+		// Fill in XYZ
+		*iter_x = cvPoint(0);
+		*iter_y = cvPoint(1);
+		*iter_z = cvPoint(2);
+	    }
+	}
+    }
+
+    void PointCloudXyzRgbRadialNodelet::convert_rgb(const sensor_msgs::ImageConstPtr& rgb_msg,
+							PointCloud::Ptr& cloud_msg,
+							int red_offset, int green_offset, int blue_offset, int color_step)
+    {
+	sensor_msgs::PointCloud2Iterator<uint8_t> iter_r(*cloud_msg, "r");
+	sensor_msgs::PointCloud2Iterator<uint8_t> iter_g(*cloud_msg, "g");
+        sensor_msgs::PointCloud2Iterator<uint8_t> iter_b(*cloud_msg, "b");
+
+	const uint8_t* rgb = &rgb_msg->data[0];
+	int rgb_skip = rgb_msg->step - rgb_msg->width * color_step;
+	
+	for (int v = 0; v < (int)cloud_msg->height; ++v, rgb += rgb_skip)
+	{
+	    for (int u = 0; u < (int)cloud_msg->width; ++u, rgb += color_step, ++iter_r, ++iter_g, ++iter_b)
+	    {
+		*iter_r = rgb[red_offset];
+		*iter_g = rgb[green_offset];
+		*iter_b = rgb[blue_offset];
+	    }
+	}
+    }
+
+} // namespace depth_image_proc
+
+// Register as nodelet
+#include <pluginlib/class_list_macros.hpp>
+PLUGINLIB_EXPORT_CLASS(depth_image_proc::PointCloudXyzRgbRadialNodelet,nodelet::Nodelet);
--- /dev/null
+++ ros-noetic-depth-image-proc-1.17.0/src/nodelets/register.cpp
@@ -0,0 +1,311 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#include <ros/ros.h>
+#include <nodelet/nodelet.h>
+#include <image_transport/image_transport.h>
+#include <image_transport/subscriber_filter.h>
+#include <message_filters/subscriber.h>
+#include <message_filters/synchronizer.h>
+#include <message_filters/sync_policies/approximate_time.h>
+#include <tf2_ros/buffer.h>
+#include <tf2_ros/transform_listener.h>
+#include <sensor_msgs/image_encodings.h>
+#include <image_geometry/pinhole_camera_model.h>
+#include <Eigen/Geometry>
+#include <eigen_conversions/eigen_msg.h>
+#include <depth_image_proc/depth_traits.h>
+
+namespace depth_image_proc {
+
+using namespace message_filters::sync_policies;
+namespace enc = sensor_msgs::image_encodings;
+
+class RegisterNodelet : public nodelet::Nodelet
+{
+  ros::NodeHandlePtr nh_depth_, nh_rgb_;
+  boost::shared_ptr<image_transport::ImageTransport> it_depth_;
+  
+  // Subscriptions
+  image_transport::SubscriberFilter sub_depth_image_;
+  message_filters::Subscriber<sensor_msgs::CameraInfo> sub_depth_info_, sub_rgb_info_;
+  boost::shared_ptr<tf2_ros::Buffer> tf_buffer_;
+  boost::shared_ptr<tf2_ros::TransformListener> tf_;
+  typedef ApproximateTime<sensor_msgs::Image, sensor_msgs::CameraInfo, sensor_msgs::CameraInfo> SyncPolicy;
+  typedef message_filters::Synchronizer<SyncPolicy> Synchronizer;
+  boost::shared_ptr<Synchronizer> sync_;
+
+  // Publications
+  boost::mutex connect_mutex_;
+  image_transport::CameraPublisher pub_registered_;
+
+  image_geometry::PinholeCameraModel depth_model_, rgb_model_;
+
+  // Parameters
+  bool fill_upsampling_holes_;	// fills holes which occur due to upsampling by scaling each pixel to the target image scale (only takes effect on upsampling)
+
+  virtual void onInit();
+
+  void connectCb();
+
+  void imageCb(const sensor_msgs::ImageConstPtr& depth_image_msg,
+               const sensor_msgs::CameraInfoConstPtr& depth_info_msg,
+               const sensor_msgs::CameraInfoConstPtr& rgb_info_msg);
+
+  template<typename T>
+  void convert(const sensor_msgs::ImageConstPtr& depth_msg,
+               const sensor_msgs::ImagePtr& registered_msg,
+               const Eigen::Affine3d& depth_to_rgb);
+};
+
+void RegisterNodelet::onInit()
+{
+  ros::NodeHandle& nh         = getNodeHandle();
+  ros::NodeHandle& private_nh = getPrivateNodeHandle();
+  nh_depth_.reset( new ros::NodeHandle(nh, "depth") );
+  nh_rgb_.reset( new ros::NodeHandle(nh, "rgb") );
+  it_depth_.reset( new image_transport::ImageTransport(*nh_depth_) );
+  tf_buffer_.reset( new tf2_ros::Buffer );
+  tf_.reset( new tf2_ros::TransformListener(*tf_buffer_) );
+
+  // Read parameters
+  int queue_size;
+  private_nh.param("queue_size", queue_size, 5);
+  private_nh.param("fill_upsampling_holes", fill_upsampling_holes_, false);
+
+  // Synchronize inputs. Topic subscriptions happen on demand in the connection callback.
+  sync_.reset( new Synchronizer(SyncPolicy(queue_size), sub_depth_image_, sub_depth_info_, sub_rgb_info_) );
+  sync_->registerCallback(boost::bind(&RegisterNodelet::imageCb, this, boost::placeholders::_1, boost::placeholders::_2, boost::placeholders::_3));
+
+  // Monitor whether anyone is subscribed to the output
+  image_transport::ImageTransport it_depth_reg(ros::NodeHandle(nh, "depth_registered"));
+  image_transport::SubscriberStatusCallback image_connect_cb = boost::bind(&RegisterNodelet::connectCb, this);
+  ros::SubscriberStatusCallback info_connect_cb = boost::bind(&RegisterNodelet::connectCb, this);
+  // Make sure we don't enter connectCb() between advertising and assigning to pub_registered_
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  pub_registered_ = it_depth_reg.advertiseCamera("image_rect", 1,
+                                                 image_connect_cb, image_connect_cb,
+                                                 info_connect_cb, info_connect_cb);
+}
+
+// Handles (un)subscribing when clients (un)subscribe
+void RegisterNodelet::connectCb()
+{
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  if (pub_registered_.getNumSubscribers() == 0)
+  {
+    sub_depth_image_.unsubscribe();
+    sub_depth_info_ .unsubscribe();
+    sub_rgb_info_   .unsubscribe();
+  }
+  else if (!sub_depth_image_.getSubscriber())
+  {
+    image_transport::TransportHints hints("raw", ros::TransportHints(), getPrivateNodeHandle());
+    sub_depth_image_.subscribe(*it_depth_, "image_rect",  1, hints);
+    sub_depth_info_ .subscribe(*nh_depth_, "camera_info", 1);
+    sub_rgb_info_   .subscribe(*nh_rgb_,   "camera_info", 1);
+  }
+}
+
+void RegisterNodelet::imageCb(const sensor_msgs::ImageConstPtr& depth_image_msg,
+                              const sensor_msgs::CameraInfoConstPtr& depth_info_msg,
+                              const sensor_msgs::CameraInfoConstPtr& rgb_info_msg)
+{
+  // Update camera models - these take binning & ROI into account
+  depth_model_.fromCameraInfo(depth_info_msg);
+  rgb_model_  .fromCameraInfo(rgb_info_msg);
+
+  // Query tf2 for transform from (X,Y,Z) in depth camera frame to RGB camera frame
+  Eigen::Affine3d depth_to_rgb;
+  try
+  {
+    geometry_msgs::TransformStamped transform = tf_buffer_->lookupTransform (
+                          rgb_info_msg->header.frame_id, depth_info_msg->header.frame_id,
+                          depth_info_msg->header.stamp);
+
+    tf::transformMsgToEigen(transform.transform, depth_to_rgb);
+  }
+  catch (tf2::TransformException& ex)
+  {
+    NODELET_WARN_THROTTLE(2, "TF2 exception:\n%s", ex.what());
+    return;
+    /// @todo Can take on order of a minute to register a disconnect callback when we
+    /// don't call publish() in this cb. What's going on roscpp?
+  }
+
+  // Allocate registered depth image
+  sensor_msgs::ImagePtr registered_msg( new sensor_msgs::Image );
+  registered_msg->header.stamp    = depth_image_msg->header.stamp;
+  registered_msg->header.frame_id = rgb_info_msg->header.frame_id;
+  registered_msg->encoding        = depth_image_msg->encoding;
+  
+  cv::Size resolution = rgb_model_.reducedResolution();
+  registered_msg->height = resolution.height;
+  registered_msg->width  = resolution.width;
+  // step and data set in convert(), depend on depth data type
+
+  if (depth_image_msg->encoding == enc::TYPE_16UC1)
+  {
+    convert<uint16_t>(depth_image_msg, registered_msg, depth_to_rgb);
+  }
+  else if (depth_image_msg->encoding == enc::TYPE_32FC1)
+  {
+    convert<float>(depth_image_msg, registered_msg, depth_to_rgb);
+  }
+  else
+  {
+    NODELET_ERROR_THROTTLE(5, "Depth image has unsupported encoding [%s]", depth_image_msg->encoding.c_str());
+    return;
+  }
+
+  // Registered camera info is the same as the RGB info, but uses the depth timestamp
+  sensor_msgs::CameraInfoPtr registered_info_msg( new sensor_msgs::CameraInfo(*rgb_info_msg) );
+  registered_info_msg->header.stamp = registered_msg->header.stamp;
+
+  pub_registered_.publish(registered_msg, registered_info_msg);
+}
+
+template<typename T>
+void RegisterNodelet::convert(const sensor_msgs::ImageConstPtr& depth_msg,
+                              const sensor_msgs::ImagePtr& registered_msg,
+                              const Eigen::Affine3d& depth_to_rgb)
+{
+  // Allocate memory for registered depth image
+  registered_msg->step = registered_msg->width * sizeof(T);
+  registered_msg->data.resize( registered_msg->height * registered_msg->step );
+  // data is already zero-filled in the uint16 case, but for floats we want to initialize everything to NaN.
+  DepthTraits<T>::initializeBuffer(registered_msg->data);
+
+  // Extract all the parameters we need
+  double inv_depth_fx = 1.0 / depth_model_.fx();
+  double inv_depth_fy = 1.0 / depth_model_.fy();
+  double depth_cx = depth_model_.cx(), depth_cy = depth_model_.cy();
+  double depth_Tx = depth_model_.Tx(), depth_Ty = depth_model_.Ty();
+  double rgb_fx = rgb_model_.fx(), rgb_fy = rgb_model_.fy();
+  double rgb_cx = rgb_model_.cx(), rgb_cy = rgb_model_.cy();
+  double rgb_Tx = rgb_model_.Tx(), rgb_Ty = rgb_model_.Ty();
+  
+  // Transform the depth values into the RGB frame
+  /// @todo When RGB is higher res, interpolate by rasterizing depth triangles onto the registered image  
+  const T* depth_row = reinterpret_cast<const T*>(&depth_msg->data[0]);
+  int row_step = depth_msg->step / sizeof(T);
+  T* registered_data = reinterpret_cast<T*>(&registered_msg->data[0]);
+  int raw_index = 0;
+  for (unsigned v = 0; v < depth_msg->height; ++v, depth_row += row_step)
+  {
+    for (unsigned u = 0; u < depth_msg->width; ++u, ++raw_index)
+    {
+      T raw_depth = depth_row[u];
+      if (!DepthTraits<T>::valid(raw_depth))
+        continue;
+      
+      double depth = DepthTraits<T>::toMeters(raw_depth);
+
+      if (fill_upsampling_holes_ == false)
+      {
+        /// @todo Combine all operations into one matrix multiply on (u,v,d)
+        // Reproject (u,v,Z) to (X,Y,Z,1) in depth camera frame
+        Eigen::Vector4d xyz_depth;
+        xyz_depth << ((u - depth_cx)*depth - depth_Tx) * inv_depth_fx,
+                     ((v - depth_cy)*depth - depth_Ty) * inv_depth_fy,
+                     depth,
+                     1;
+
+        // Transform to RGB camera frame
+        Eigen::Vector4d xyz_rgb = depth_to_rgb * xyz_depth;
+
+        // Project to (u,v) in RGB image
+        double inv_Z = 1.0 / xyz_rgb.z();
+        int u_rgb = (rgb_fx*xyz_rgb.x() + rgb_Tx)*inv_Z + rgb_cx + 0.5;
+        int v_rgb = (rgb_fy*xyz_rgb.y() + rgb_Ty)*inv_Z + rgb_cy + 0.5;
+      
+        if (u_rgb < 0 || u_rgb >= (int)registered_msg->width ||
+            v_rgb < 0 || v_rgb >= (int)registered_msg->height)
+          continue;
+      
+        T& reg_depth = registered_data[v_rgb*registered_msg->width + u_rgb];
+        T  new_depth = DepthTraits<T>::fromMeters(xyz_rgb.z());
+        // Validity and Z-buffer checks
+        if (!DepthTraits<T>::valid(reg_depth) || reg_depth > new_depth)
+          reg_depth = new_depth;
+      }
+      else
+      {
+        // Reproject (u,v,Z) to (X,Y,Z,1) in depth camera frame
+        Eigen::Vector4d xyz_depth_1, xyz_depth_2;
+        xyz_depth_1 << ((u-0.5f - depth_cx)*depth - depth_Tx) * inv_depth_fx,
+                       ((v-0.5f - depth_cy)*depth - depth_Ty) * inv_depth_fy,
+                       depth,
+                       1;
+        xyz_depth_2 << ((u+0.5f - depth_cx)*depth - depth_Tx) * inv_depth_fx,
+                       ((v+0.5f - depth_cy)*depth - depth_Ty) * inv_depth_fy,
+                       depth,
+                       1;
+
+        // Transform to RGB camera frame
+        Eigen::Vector4d xyz_rgb_1 = depth_to_rgb * xyz_depth_1;
+        Eigen::Vector4d xyz_rgb_2 = depth_to_rgb * xyz_depth_2;
+
+        // Project to (u,v) in RGB image
+        double inv_Z = 1.0 / xyz_rgb_1.z();
+        int u_rgb_1 = (rgb_fx*xyz_rgb_1.x() + rgb_Tx)*inv_Z + rgb_cx + 0.5;
+        int v_rgb_1 = (rgb_fy*xyz_rgb_1.y() + rgb_Ty)*inv_Z + rgb_cy + 0.5;
+        inv_Z = 1.0 / xyz_rgb_2.z();
+        int u_rgb_2 = (rgb_fx*xyz_rgb_2.x() + rgb_Tx)*inv_Z + rgb_cx + 0.5;
+        int v_rgb_2 = (rgb_fy*xyz_rgb_2.y() + rgb_Ty)*inv_Z + rgb_cy + 0.5;
+
+        if (u_rgb_1 < 0 || u_rgb_2 >= (int)registered_msg->width ||
+            v_rgb_1 < 0 || v_rgb_2 >= (int)registered_msg->height)
+          continue;
+
+        for (int nv=v_rgb_1; nv<=v_rgb_2; ++nv)
+        {
+          for (int nu=u_rgb_1; nu<=u_rgb_2; ++nu)
+          {
+            T& reg_depth = registered_data[nv*registered_msg->width + nu];
+            T  new_depth = DepthTraits<T>::fromMeters(0.5*(xyz_rgb_1.z()+xyz_rgb_2.z()));
+            // Validity and Z-buffer checks
+            if (!DepthTraits<T>::valid(reg_depth) || reg_depth > new_depth)
+              reg_depth = new_depth;
+          }
+        }
+      }
+    }
+  }
+}
+
+} // namespace depth_image_proc
+
+// Register as nodelet
+#include <pluginlib/class_list_macros.hpp>
+PLUGINLIB_EXPORT_CLASS(depth_image_proc::RegisterNodelet,nodelet::Nodelet);
