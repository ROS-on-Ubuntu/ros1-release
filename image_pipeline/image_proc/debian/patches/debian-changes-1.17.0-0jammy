Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ros-noetic-image-proc (1.17.0-0jammy) jammy; urgency=high
 .
   * Switch to hpp headers of pluginlib
   * Drop old C++ standard compiler flag
   * Switch to new boost/bind/bind.hpp
   * Update ROI parameters on resize
   * Contributors: Jochen Sprickerhof, Yuki Furuta
Author: Vincent Rabaud <vincent.rabaud@gmail.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2024-08-18

--- /dev/null
+++ ros-noetic-image-proc-1.17.0/CHANGELOG.rst
@@ -0,0 +1,179 @@
+1.17.0 (2022-10-17)
+-------------------
+* Switch to hpp headers of pluginlib
+* Drop old C++ standard compiler flag
+* Switch to new boost/bind/bind.hpp
+* Update ROI parameters on resize
+* Contributors: Jochen Sprickerhof, Yuki Furuta
+
+1.16.0 (2021-11-12)
+-------------------
+
+1.15.3 (2020-12-11)
+-------------------
+* remove email blasts from steve macenski (`#595 <https://github.com/ros-perception/image_pipeline/issues/595>`_)
+* Contributors: Steve Macenski
+
+1.15.2 (2020-05-19)
+-------------------
+
+1.15.1 (2020-05-18)
+-------------------
+
+1.15.0 (2020-05-14)
+-------------------
+* Python 3 compatibility (`#530 <https://github.com/ros-perception/image_pipeline/issues/530>`_)
+* cmake_minimum_required to 3.0.2
+* Adapted to OpenCV4
+* import setup from setuptools instead of distutils-core
+* updated install locations for better portability. (`#500 <https://github.com/ros-perception/image_pipeline/issues/500>`_)
+* Contributors: Joshua Whitley, Sean Yen
+
+1.14.0 (2020-01-12)
+-------------------
+* resize.cpp: fix memory leak (`#489 <https://github.com/ros-perception/image_pipeline/issues/489>`_)
+* Try catch around cvtColor to avoid demosaicing src.empty() error (`#463 <https://github.com/ros-perception/image_pipeline/issues/463>`_)
+* Merge pull request `#436 <https://github.com/ros-perception/image_pipeline/issues/436>`_ from ros-perception/throttle_warnings
+* adding throttled warnings to not blast the users
+* Merge pull request `#423 <https://github.com/ros-perception/image_pipeline/issues/423>`_ from lucasw/crop_decimate_resolution_change
+  Avoid crashing when the x or y offset is too large
+* Merge pull request `#435 <https://github.com/ros-perception/image_pipeline/issues/435>`_ from ros-perception/patch_resize_copy
+* patch extra copy for nodelet users of resize
+* Merge pull request `#411 <https://github.com/ros-perception/image_pipeline/issues/411>`_ from Tuebel/fix_409
+  Fix 409 based on melodic branch
+* Need to look at x and y offset
+* Simplified copying of the camera_info message.
+* Independent resize of image and camera_info
+* removed unused infoCb
+* Rename infoCb to cameraCb matching subscribeCamera
+* replaced boost mutex & shared_ptr with std
+* Removed hard coded image encoding.
+  Using toCvCopy instead of toCvShared (copy is needed anyway).
+* Contributors: Joshua Whitley, Lucas Walter, Tim Übelhör, Yuki Furuta, stevemacenski
+
+1.13.0 (2019-06-12)
+-------------------
+* Merge pull request `#395 <https://github.com/ros-perception/image_pipeline/issues/395>`_ from ros-perception/steve_maintain
+* adding autonomoustuff mainainer
+* adding stevemacenski as maintainer to get emails
+* Contributors: Joshua Whitley, Yoshito Okada, stevemacenski
+
+1.12.23 (2018-05-10)
+--------------------
+
+1.12.22 (2017-12-08)
+--------------------
+* Merge pull request `#311 <https://github.com/ros-perception/image_pipeline/issues/311>`_ from knorth55/revert-299
+  Revert "Fix image_resize nodelet (`#299 <https://github.com/ros-perception/image_pipeline/issues/299>`_)"
+  This reverts commit 32e19697ebce47101b063c6a02b95dfa2c5dbc52.
+* Contributors: Shingo Kitagawa, Tully Foote
+
+1.12.21 (2017-11-05)
+--------------------
+* Fix image_resize nodelet (`#299 <https://github.com/ros-perception/image_pipeline/issues/299>`_)
+  Update interpolation types
+  Add arguments to enable disable each nodelet
+  Add default arguments for image_resize and image_rect
+  Use toCVShare instead of toCVCopy
+  Include image_resize in image_proc
+* Updated fix for traits change. (`#303 <https://github.com/ros-perception/image_pipeline/issues/303>`_)
+* Fix C++11 compilation
+  This fixes `#292 <https://github.com/ros-perception/image_pipeline/issues/292>`_ and `#291 <https://github.com/ros-perception/image_pipeline/issues/291>`_
+* [image_proc][crop_decimate] support changing target image frame_id (`#276 <https://github.com/ros-perception/image_pipeline/issues/276>`_)
+* Contributors: Furushchev, Mike Purvis, Vincent Rabaud, bikramak
+
+1.12.20 (2017-04-30)
+--------------------
+* Add nodelet to resize image and camera_info (`#273 <https://github.com/ros-perception/image_pipeline/issues/273>`_)
+  * Add nodelet to resize image and camera_info
+  * Depends on nodelet_topic_tools
+  * Use recursive_mutex for mutex guard for dynamic reconfiguring
+* Fix nodelet name: crop_nonZero ->  crop_non_zero (`#269 <https://github.com/ros-perception/image_pipeline/issues/269>`_)
+  Fix https://github.com/ros-perception/image_pipeline/issues/217
+* Fix permission of executable files unexpectedly (`#260 <https://github.com/ros-perception/image_pipeline/issues/260>`_)
+* address gcc6 build error
+  With gcc6, compiling fails with `stdlib.h: No such file or directory`,
+  as including '-isystem /usr/include' breaks with gcc6, cf.,
+  https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70129.
+  This commit addresses this issue for this package in the same way
+  it was addressed in various other ROS packages. A list of related
+  commits and pull requests is at:
+  https://github.com/ros/rosdistro/issues/12783
+  Signed-off-by: Lukas Bulwahn <lukas.bulwahn@oss.bmw-carit.de>
+* Contributors: Kentaro Wada, Lukas Bulwahn
+
+1.12.19 (2016-07-24)
+--------------------
+
+1.12.18 (2016-07-12)
+--------------------
+
+1.12.17 (2016-07-11)
+--------------------
+
+1.12.16 (2016-03-19)
+--------------------
+* clean OpenCV dependency in package.xml
+* issue `#180 <https://github.com/ros-perception/image_pipeline/issues/180>`_ Check if all distortion coefficients are zero.
+  Test with:
+  rostest --reuse-master --text image_proc test_rectify.xml
+  Can also test interactively with vimjay image_rect.launch, which brings up an rqt gui and camera info distortion coefficients can be dynamically reconfigured.
+* Add a feature to crop the largest valid (non zero) area
+  Remove unnecessary headers
+  change a filename to fit for the ROS convention
+* Contributors: Kenta Yonekura, Lucas Walter, Vincent Rabaud
+
+1.12.15 (2016-01-17)
+--------------------
+* simplify OpenCV3 conversion
+* Contributors: Vincent Rabaud
+
+1.12.14 (2015-07-22)
+--------------------
+
+1.12.13 (2015-04-06)
+--------------------
+* fix dependencies
+* Contributors: Vincent Rabaud
+
+1.12.12 (2014-12-31)
+--------------------
+
+1.12.11 (2014-10-26)
+--------------------
+
+1.12.10 (2014-09-28)
+--------------------
+
+1.12.9 (2014-09-21)
+-------------------
+* get code to compile with OpenCV3
+  fixes `#96 <https://github.com/ros-perception/image_pipeline/issues/96>`_
+* Contributors: Vincent Rabaud
+
+1.12.8 (2014-08-19)
+-------------------
+
+1.12.6 (2014-07-27)
+-------------------
+
+1.12.4 (2014-04-28)
+-------------------
+
+1.12.3 (2014-04-12)
+-------------------
+
+1.12.2 (2014-04-08)
+-------------------
+
+1.12.1 (2014-04-06)
+-------------------
+* get proper opencv dependency
+* Contributors: Vincent Rabaud
+
+1.11.7 (2014-03-28)
+-------------------
+
+1.11.6 (2014-01-29 00:38:55 +0100)
+----------------------------------
+- fix bad OpenCV linkage (#53)
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/CMakeLists.txt
@@ -0,0 +1,66 @@
+cmake_minimum_required(VERSION 3.0.2)
+project(image_proc)
+
+find_package(catkin REQUIRED)
+
+find_package(catkin REQUIRED cv_bridge dynamic_reconfigure image_geometry image_transport nodelet nodelet_topic_tools roscpp sensor_msgs)
+find_package(OpenCV REQUIRED)
+find_package(Boost REQUIRED COMPONENTS thread)
+
+# Dynamic reconfigure support
+generate_dynamic_reconfigure_options(cfg/CropDecimate.cfg cfg/Debayer.cfg cfg/Rectify.cfg cfg/Resize.cfg)
+
+catkin_package(
+  CATKIN_DEPENDS image_geometry roscpp sensor_msgs
+  DEPENDS OpenCV
+  INCLUDE_DIRS include
+  LIBRARIES ${PROJECT_NAME}
+)
+
+include_directories(include ${catkin_INCLUDE_DIRS} ${OpenCV_INCLUDE_DIRS})
+
+# Temporary fix for DataType deprecation in OpenCV 3.3.1. We continue to use the deprecated form for now because
+# the new one is not available in OpenCV 2.4 (on Trusty).
+add_definitions(-DOPENCV_TRAITS_ENABLE_DEPRECATED)
+
+# Nodelet library
+add_library(${PROJECT_NAME} src/libimage_proc/processor.cpp
+                                src/nodelets/debayer.cpp
+                                src/nodelets/rectify.cpp
+                                src/nodelets/resize.cpp
+                                src/nodelets/crop_decimate.cpp
+                                src/libimage_proc/advertisement_checker.cpp
+                                src/nodelets/edge_aware.cpp
+                                src/nodelets/crop_non_zero.cpp
+)
+add_dependencies(${PROJECT_NAME} ${PROJECT_NAME}_gencfg)
+target_link_libraries(${PROJECT_NAME} ${catkin_LIBRARIES} ${Boost_LIBRARIES} ${OpenCV_LIBRARIES})
+
+install(TARGETS ${PROJECT_NAME}
+        ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+        LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+        RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION}
+)
+install(DIRECTORY include/${PROJECT_NAME}/
+        DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
+)
+install(FILES nodelet_plugins.xml
+        DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}
+)
+
+# Standalone node
+add_executable(image_proc_exe src/nodes/image_proc.cpp)
+target_link_libraries(image_proc_exe ${PROJECT_NAME}  ${Boost_LIBRARIES} ${OpenCV_LIBRARIES})
+SET_TARGET_PROPERTIES(image_proc_exe PROPERTIES OUTPUT_NAME image_proc)
+install(TARGETS image_proc_exe
+        DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
+)
+
+# install the launch file
+install(DIRECTORY launch
+        DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}/
+)
+
+if(CATKIN_ENABLE_TESTING)
+  add_subdirectory(test)
+endif()
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/cfg/CropDecimate.cfg
@@ -0,0 +1,35 @@
+#! /usr/bin/env python
+
+PACKAGE='image_proc'
+
+from dynamic_reconfigure.parameter_generator_catkin import *
+
+gen = ParameterGenerator()
+
+# Decimation parameters
+gen.add("decimation_x", int_t, 0, "Number of pixels to decimate to one horizontally", 1, 1, 16)
+gen.add("decimation_y", int_t, 0, "Number of pixels to decimate to one vertically", 1, 1, 16)
+
+# ROI parameters
+# Maximums are arbitrary set to the resolution of a 5Mp Prosilica, since we can't set
+# the dynamically.
+gen.add("x_offset",     int_t, 0, "X offset of the region of interest", 0, 0, 2447)
+gen.add("y_offset",     int_t, 0, "Y offset of the region of interest", 0, 0, 2049)
+gen.add("width",        int_t, 0, "Width of the region of interest", 0, 0, 2448)
+gen.add("height",       int_t, 0, "Height of the region of interest", 0, 0, 2050)
+
+interpolate_enum = gen.enum([ gen.const("NN",       int_t, 0, "Nearest-neighbor sampling"),
+                              gen.const("Linear",   int_t, 1, "Bilinear interpolation"),
+                              gen.const("Cubic",    int_t, 2, "Bicubic interpolation over 4x4 neighborhood"),
+                              gen.const("Area",     int_t, 3, "Resampling using pixel area relation"),
+                              gen.const("Lanczos4", int_t, 4, "Lanczos interpolation over 8x8 neighborhood")],
+                            "interpolation type")
+
+gen.add("interpolation", int_t, 0,
+        "Sampling algorithm",
+        0, 0, 4, edit_method = interpolate_enum)
+
+# First string value is node name, used only for generating documentation
+# Second string value ("CropDecimate") is name of class and generated
+#    .h file, with "Config" added, so class CropDecimateConfig
+exit(gen.generate(PACKAGE, "image_proc", "CropDecimate"))
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/cfg/Debayer.cfg
@@ -0,0 +1,26 @@
+#! /usr/bin/env python
+
+PACKAGE='image_proc'
+
+from dynamic_reconfigure.parameter_generator_catkin import *
+
+gen = ParameterGenerator()
+
+debayer_enum = gen.enum([ gen.const("Bilinear", int_t, 0,
+                                    "Fast algorithm using bilinear interpolation"),
+                          gen.const("EdgeAware", int_t, 1,
+                                    "Edge-aware algorithm"),
+                          gen.const("EdgeAwareWeighted", int_t, 2,
+                                    "Weighted edge-aware algorithm"),
+                          gen.const("VNG", int_t, 3,
+                                    "Slow but high quality Variable Number of Gradients algorithm")],
+                        "Debayering algorithm")
+
+gen.add("debayer", int_t, 0,
+        "Debayering algorithm",
+        0, 0, 3, edit_method = debayer_enum)
+
+# First string value is node name, used only for generating documentation
+# Second string value ("Debayer") is name of class and generated
+#    .h file, with "Config" added, so class DebayerConfig
+exit(gen.generate(PACKAGE, "image_proc", "Debayer"))
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/cfg/Rectify.cfg
@@ -0,0 +1,22 @@
+#! /usr/bin/env python
+
+PACKAGE='image_proc'
+
+from dynamic_reconfigure.parameter_generator_catkin import *
+
+gen = ParameterGenerator()
+
+interpolate_enum = gen.enum([ gen.const("NN", int_t, 0, "Nearest neighbor"),
+                              gen.const("Linear", int_t, 1, "Linear"),
+                              gen.const("Cubic", int_t, 2, "Cubic"),
+                              gen.const("Lanczos4", int_t, 4, "Lanczos4")],
+                            "interpolation type")
+
+gen.add("interpolation", int_t, 0,
+        "Interpolation algorithm between source image pixels",
+        1, 0, 4, edit_method = interpolate_enum)
+
+# First string value is node name, used only for generating documentation
+# Second string value ("Rectify") is name of class and generated
+#    .h file, with "Config" added, so class RectifyConfig
+exit(gen.generate(PACKAGE, "image_proc", "Rectify"))
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/cfg/Resize.cfg
@@ -0,0 +1,37 @@
+#! /usr/bin/env python
+
+from dynamic_reconfigure.parameter_generator_catkin import *
+
+
+PACKAGE = 'image_proc'
+ID = 'Resize'
+
+gen = ParameterGenerator()
+
+interpolate_enum = gen.enum([gen.const('NN', int_t, 0, 'Nearest neighbor'),
+                             gen.const('Linear', int_t, 1, 'Linear'),
+                             gen.const('Cubic', int_t, 2, 'Cubic'),
+                             gen.const('Lanczos4', int_t, 4, 'Lanczos4')],
+                            'interpolation type')
+gen.add('interpolation', int_t, level=0,
+        description='Interpolation algorithm between source image pixels',
+        default=1, min=0, max=4, edit_method=interpolate_enum)
+
+gen.add('use_scale', bool_t, level=0,
+        description='Flag to use scale instead of static size.',
+        default=True)
+gen.add('scale_height', double_t, level=0,
+        description='Scale of height.',
+        default=1, min=0, max=10)
+gen.add('scale_width', double_t, level=0,
+        description='Scale of width',
+        default=1, min=0, max=10)
+
+gen.add('height', int_t, level=0,
+        description='Destination height. Ignored if negative.',
+        default=-1, min=-1)
+gen.add('width', int_t, level=0,
+        description='Destination width. Ignored if negative.',
+        default=-1, min=-1)
+
+exit(gen.generate(PACKAGE, PACKAGE, ID))
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/include/image_proc/advertisement_checker.h
@@ -0,0 +1,61 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#ifndef IMAGE_PROC_ADVERTISEMENT_CHECKER_H
+#define IMAGE_PROC_ADVERTISEMENT_CHECKER_H
+
+#include <ros/ros.h>
+
+namespace image_proc {
+
+class AdvertisementChecker
+{
+  ros::NodeHandle nh_;
+  std::string name_;
+  ros::WallTimer timer_;
+  ros::V_string topics_;
+
+  void timerCb();
+
+public:
+  AdvertisementChecker(const ros::NodeHandle& nh = ros::NodeHandle(),
+                       const std::string& name = std::string());
+  
+  void start(const ros::V_string& topics, double duration);
+
+  void stop();
+};
+
+} // namespace image_proc
+
+#endif
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/include/image_proc/processor.h
@@ -0,0 +1,77 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#ifndef IMAGE_PROC_PROCESSOR_H
+#define IMAGE_PROC_PROCESSOR_H
+
+#include <opencv2/core/core.hpp>
+#include <image_geometry/pinhole_camera_model.h>
+#include <sensor_msgs/Image.h>
+
+namespace image_proc {
+
+struct ImageSet
+{
+  std::string color_encoding;
+  cv::Mat mono;
+  cv::Mat rect;
+  cv::Mat color;
+  cv::Mat rect_color;
+};
+
+class Processor
+{
+public:
+  Processor()
+    : interpolation_(cv::INTER_LINEAR)
+  {
+  }
+  
+  int interpolation_;
+
+  enum {
+    MONO       = 1 << 0,
+    RECT       = 1 << 1,
+    COLOR      = 1 << 2,
+    RECT_COLOR = 1 << 3,
+    ALL = MONO | RECT | COLOR | RECT_COLOR
+  };
+  
+  bool process(const sensor_msgs::ImageConstPtr& raw_image,
+               const image_geometry::PinholeCameraModel& model,
+               ImageSet& output, int flags = ALL) const;
+};
+
+} //namespace image_proc
+
+#endif
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/launch/image_proc.launch
@@ -0,0 +1,29 @@
+<!-- Launch in the camera namespace containing "image_raw" and "camera_info" -->
+<launch>
+
+  <arg name="manager" /> <!-- Must be globally qualified -->
+  <arg name="respawn" default="false" />
+  <!-- TODO Arguments for debayer, interpolation methods? -->
+
+  <arg     if="$(arg respawn)" name="bond" value="" />
+  <arg unless="$(arg respawn)" name="bond" value="--no-bond" />
+
+  <!-- Debayered images -->
+  <node pkg="nodelet" type="nodelet" name="debayer"
+        args="load image_proc/debayer $(arg manager) $(arg bond)"
+	respawn="$(arg respawn)" />
+
+  <!-- Monochrome rectified image -->
+  <node pkg="nodelet" type="nodelet" name="rectify_mono"
+        args="load image_proc/rectify $(arg manager) $(arg bond)"
+	respawn="$(arg respawn)" />
+
+  <!-- Color rectified image -->
+  <node pkg="nodelet" type="nodelet" name="rectify_color"
+        args="load image_proc/rectify $(arg manager) $(arg bond)"
+	respawn="$(arg respawn)">
+    <remap from="image_mono" to="image_color" />
+    <remap from="image_rect" to="image_rect_color" />
+  </node>  
+
+</launch>
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/mainpage.dox
@@ -0,0 +1,12 @@
+/**
+@mainpage
+@htmlinclude manifest.html
+
+@b image_proc provides a node for performing single image rectification and
+color processing on the raw images produced by a camera. The outputs of
+image_proc are suitable for visual processing by other nodes. See
+http://www.ros.org/wiki/image_proc for documentation.
+
+Currently this package has no public code API.
+
+*/
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/nodelet_plugins.xml
@@ -0,0 +1,48 @@
+<library path="lib/libimage_proc">
+
+  <class name="image_proc/debayer"
+	 type="image_proc::DebayerNodelet"
+	 base_class_type="nodelet::Nodelet">
+    <description>
+      Nodelet to debayer (if needed) a raw camera image stream.
+    </description>
+  </class>
+
+  <class name="image_proc/rectify"
+	 type="image_proc::RectifyNodelet"
+	 base_class_type="nodelet::Nodelet">
+    <description>
+      Nodelet to rectify an unrectified camera image stream.
+    </description>
+  </class>
+
+  <class name="image_proc/resize"
+         type="image_proc::ResizeNodelet"
+         base_class_type="nodelet::Nodelet">
+    <description>
+      Nodelet to resize image and camera_info.
+    </description>
+  </class>
+
+  <class name="image_proc/crop_decimate"
+	 type="image_proc::CropDecimateNodelet"
+	 base_class_type="nodelet::Nodelet">
+    <description>
+      Nodelet to apply decimation (software binning) and ROI to a raw camera
+      image post-capture.
+    </description>
+  </class>
+
+  <!-- Deprecated Nodelet API -->
+  <class name="image_proc/crop_nonZero"
+	 type="image_proc::CropNonZeroNodelet"
+	 base_class_type="nodelet::Nodelet" />
+  <class name="image_proc/crop_non_zero"
+	 type="image_proc::CropNonZeroNodelet"
+	 base_class_type="nodelet::Nodelet">
+    <description>
+      Nodelet to crop the largest valid (Non Zero) area of the image.
+    </description>
+  </class>
+
+</library>
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/package.xml
@@ -0,0 +1,40 @@
+<package>
+  <name>image_proc</name>
+  <version>1.17.0</version>
+  <description>Single image rectification and color processing.</description>
+  <author>Patrick Mihelich</author>
+  <author>Kurt Konolige</author>
+  <author>Jeremy Leibs</author>
+  <maintainer email="vincent.rabaud@gmail.com">Vincent Rabaud</maintainer>
+  <maintainer email="software@autonomoustuff.com">Autonomoustuff team</maintainer>
+  <license>BSD</license>
+  <url>http://www.ros.org/wiki/image_proc</url>
+
+  <export>
+    <nodelet plugin="${prefix}/nodelet_plugins.xml" />
+  </export>
+
+  <buildtool_depend version_gte="0.5.68">catkin</buildtool_depend>
+
+  <test_depend>rostest</test_depend>
+  <test_depend>camera_calibration_parsers</test_depend>
+  
+  <build_depend>boost</build_depend>
+  <build_depend>cv_bridge</build_depend>
+  <build_depend>dynamic_reconfigure</build_depend>
+  <build_depend>image_geometry</build_depend>
+  <build_depend>image_transport</build_depend>
+  <build_depend>nodelet</build_depend>
+  <build_depend>nodelet_topic_tools</build_depend>
+  <build_depend>roscpp</build_depend>
+  <build_depend>sensor_msgs</build_depend>
+
+  <run_depend>cv_bridge</run_depend>
+  <run_depend>dynamic_reconfigure</run_depend>
+  <run_depend>image_geometry</run_depend>
+  <run_depend>image_transport</run_depend>
+  <run_depend>nodelet</run_depend>
+  <run_depend>nodelet_topic_tools</run_depend>
+  <run_depend>roscpp</run_depend>
+  <run_depend>sensor_msgs</run_depend>
+</package>
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/src/libimage_proc/advertisement_checker.cpp
@@ -0,0 +1,92 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#include "image_proc/advertisement_checker.h"
+#include <boost/foreach.hpp>
+
+namespace image_proc {
+
+AdvertisementChecker::AdvertisementChecker(const ros::NodeHandle& nh,
+                                           const std::string& name)
+  : nh_(nh),
+    name_(name)
+{
+}
+
+void AdvertisementChecker::timerCb()
+{
+  ros::master::V_TopicInfo topic_info;
+  if (!ros::master::getTopics(topic_info)) return;
+
+  ros::V_string::iterator topic_it = topics_.begin();
+  while (topic_it != topics_.end())
+  {
+    // Should use std::find_if
+    bool found = false;
+    ros::master::V_TopicInfo::iterator info_it = topic_info.begin();
+    while (!found && info_it != topic_info.end())
+    {
+      found = (*topic_it == info_it->name);
+      ++info_it;
+    }
+    if (found)
+      topic_it = topics_.erase(topic_it);
+    else
+    {
+      ROS_WARN_NAMED(name_, "The input topic '%s' is not yet advertised", topic_it->c_str());
+      ++topic_it;
+    }
+  }
+
+  if (topics_.empty())
+    stop();
+}
+
+void AdvertisementChecker::start(const ros::V_string& topics, double duration)
+{
+  topics_.clear();
+  BOOST_FOREACH(const std::string& topic, topics)
+    topics_.push_back(nh_.resolveName(topic));
+
+  ros::NodeHandle nh;
+  timer_ = nh.createWallTimer(ros::WallDuration(duration),
+                              boost::bind(&AdvertisementChecker::timerCb, this));
+  timerCb();
+}
+
+void AdvertisementChecker::stop()
+{
+  timer_.stop();
+}
+
+} // namespace image_proc
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/src/libimage_proc/processor.cpp
@@ -0,0 +1,130 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#include "image_proc/processor.h"
+#include <sensor_msgs/image_encodings.h>
+#include <ros/console.h>
+
+namespace image_proc {
+
+namespace enc = sensor_msgs::image_encodings;
+
+bool Processor::process(const sensor_msgs::ImageConstPtr& raw_image,
+                        const image_geometry::PinholeCameraModel& model,
+                        ImageSet& output, int flags) const
+{
+  static const int MONO_EITHER = MONO | RECT;
+  static const int COLOR_EITHER = COLOR | RECT_COLOR;
+  if (!(flags & ALL)) return true;
+  
+  // Check if raw_image is color
+  const std::string& raw_encoding = raw_image->encoding;
+  int raw_type = CV_8UC1;
+  if (raw_encoding == enc::BGR8 || raw_encoding == enc::RGB8) {
+    raw_type = CV_8UC3;
+    output.color_encoding = raw_encoding;
+  }
+  // Construct cv::Mat pointing to raw_image data
+  const cv::Mat raw(raw_image->height, raw_image->width, raw_type,
+                    const_cast<uint8_t*>(&raw_image->data[0]), raw_image->step);
+
+  ///////////////////////////////////////////////////////
+  // Construct colorized (unrectified) images from raw //
+  ///////////////////////////////////////////////////////
+  
+  // Bayer case
+  if (raw_encoding.find("bayer") != std::string::npos) {
+    // Convert to color BGR
+    /// @todo Faster to convert directly to mono when color is not requested, but OpenCV doesn't support
+    int code = 0;
+    if (raw_encoding == enc::BAYER_RGGB8)
+      code = cv::COLOR_BayerBG2BGR;
+    else if (raw_encoding == enc::BAYER_BGGR8)
+      code = cv::COLOR_BayerRG2BGR;
+    else if (raw_encoding == enc::BAYER_GBRG8)
+      code = cv::COLOR_BayerGR2BGR;
+    else if (raw_encoding == enc::BAYER_GRBG8)
+      code = cv::COLOR_BayerGB2BGR;
+    else {
+      ROS_ERROR("[image_proc] Unsupported encoding '%s'", raw_encoding.c_str());
+      return false;
+    }
+    cv::cvtColor(raw, output.color, code);
+    output.color_encoding = enc::BGR8;
+    
+    if (flags & MONO_EITHER)
+      cv::cvtColor(output.color, output.mono, cv::COLOR_BGR2GRAY);
+  }
+  // Color case
+  else if (raw_type == CV_8UC3) {
+    output.color = raw;
+    if (flags & MONO_EITHER) {
+      int code = (raw_encoding == enc::BGR8) ? cv::COLOR_BGR2GRAY : cv::COLOR_RGB2GRAY;
+      cv::cvtColor(output.color, output.mono, code);
+    }
+  }
+  // Mono case
+  else if (raw_encoding == enc::MONO8) {
+    output.mono = raw;
+    if (flags & COLOR_EITHER) {
+      output.color_encoding = enc::MONO8;
+      output.color = raw;
+    }
+  }
+  // 8UC3 does not specify a color encoding. Is it BGR, RGB, HSV, XYZ, LUV...?
+  else if (raw_encoding == enc::TYPE_8UC3) {
+    ROS_ERROR("[image_proc] Ambiguous encoding '8UC3'. The camera driver "
+              "should set the encoding to 'bgr8' or 'rgb8'.");
+    return false;
+  }
+  // Something else we can't handle
+  else {
+    ROS_ERROR("[image_proc] Unsupported encoding '%s'", raw_encoding.c_str());
+    return false;
+  }
+
+  //////////////////////////////////////////////////////
+  // Construct rectified images from colorized images //
+  //////////////////////////////////////////////////////
+  
+  /// @todo If no distortion, could just point to the colorized data. But copy is
+  /// already way faster than remap.
+  if (flags & RECT)
+    model.rectifyImage(output.mono, output.rect, interpolation_);
+  if (flags & RECT_COLOR)
+    model.rectifyImage(output.color, output.rect_color, interpolation_);
+
+  return true;
+}
+
+} //namespace image_proc
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/src/nodelets/crop_decimate.cpp
@@ -0,0 +1,365 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#include <boost/version.hpp>
+#if ((BOOST_VERSION / 100) % 1000) >= 53
+#include <boost/thread/lock_guard.hpp>
+#endif
+
+#include <ros/ros.h>
+#include <nodelet/nodelet.h>
+#include <image_transport/image_transport.h>
+#include <sensor_msgs/image_encodings.h>
+#include <dynamic_reconfigure/server.h>
+#include <cv_bridge/cv_bridge.h>
+#include <image_proc/CropDecimateConfig.h>
+#include <opencv2/imgproc/imgproc.hpp>
+
+namespace image_proc {
+
+using namespace cv_bridge; // CvImage, toCvShare
+
+class CropDecimateNodelet : public nodelet::Nodelet
+{
+  // ROS communication
+  boost::shared_ptr<image_transport::ImageTransport> it_in_, it_out_;
+  image_transport::CameraSubscriber sub_;
+  int queue_size_;
+  std::string target_frame_id_;
+
+  boost::mutex connect_mutex_;
+  image_transport::CameraPublisher pub_;
+
+  // Dynamic reconfigure
+  boost::recursive_mutex config_mutex_;
+  typedef image_proc::CropDecimateConfig Config;
+  typedef dynamic_reconfigure::Server<Config> ReconfigureServer;
+  boost::shared_ptr<ReconfigureServer> reconfigure_server_;
+  Config config_;
+
+  virtual void onInit();
+
+  void connectCb();
+
+  void imageCb(const sensor_msgs::ImageConstPtr& image_msg,
+               const sensor_msgs::CameraInfoConstPtr& info_msg);
+
+  void configCb(Config &config, uint32_t level);
+};
+
+void CropDecimateNodelet::onInit()
+{
+  ros::NodeHandle& nh         = getNodeHandle();
+  ros::NodeHandle& private_nh = getPrivateNodeHandle();
+  ros::NodeHandle nh_in (nh, "camera");
+  ros::NodeHandle nh_out(nh, "camera_out");
+  it_in_ .reset(new image_transport::ImageTransport(nh_in));
+  it_out_.reset(new image_transport::ImageTransport(nh_out));
+
+  // Read parameters
+  private_nh.param("queue_size", queue_size_, 5);
+  private_nh.param("target_frame_id", target_frame_id_, std::string());
+
+  // Set up dynamic reconfigure
+  reconfigure_server_.reset(new ReconfigureServer(config_mutex_, private_nh));
+  ReconfigureServer::CallbackType f = boost::bind(&CropDecimateNodelet::configCb, this, boost::placeholders::_1, boost::placeholders::_2);
+  reconfigure_server_->setCallback(f);
+
+  // Monitor whether anyone is subscribed to the output
+  image_transport::SubscriberStatusCallback connect_cb = boost::bind(&CropDecimateNodelet::connectCb, this);
+  ros::SubscriberStatusCallback connect_cb_info = boost::bind(&CropDecimateNodelet::connectCb, this);
+  // Make sure we don't enter connectCb() between advertising and assigning to pub_
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  pub_ = it_out_->advertiseCamera("image_raw",  1, connect_cb, connect_cb, connect_cb_info, connect_cb_info);
+}
+
+// Handles (un)subscribing when clients (un)subscribe
+void CropDecimateNodelet::connectCb()
+{
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  if (pub_.getNumSubscribers() == 0)
+    sub_.shutdown();
+  else if (!sub_)
+  {
+    image_transport::TransportHints hints("raw", ros::TransportHints(), getPrivateNodeHandle());
+    sub_ = it_in_->subscribeCamera("image_raw", queue_size_, &CropDecimateNodelet::imageCb, this, hints);
+  }
+}
+
+template <typename T>
+void debayer2x2toBGR(const cv::Mat& src, cv::Mat& dst, int R, int G1, int G2, int B)
+{
+  typedef cv::Vec<T, 3> DstPixel; // 8- or 16-bit BGR
+  dst.create(src.rows / 2, src.cols / 2, cv::DataType<DstPixel>::type);
+
+  int src_row_step = src.step1();
+  int dst_row_step = dst.step1();
+  const T* src_row = src.ptr<T>();
+  T* dst_row = dst.ptr<T>();
+
+  // 2x2 downsample and debayer at once
+  for (int y = 0; y < dst.rows; ++y)
+  {
+    for (int x = 0; x < dst.cols; ++x)
+    {
+      dst_row[x*3 + 0] = src_row[x*2 + B];
+      dst_row[x*3 + 1] = (src_row[x*2 + G1] + src_row[x*2 + G2]) / 2;
+      dst_row[x*3 + 2] = src_row[x*2 + R];
+    }
+    src_row += src_row_step * 2;
+    dst_row += dst_row_step;
+  }
+}
+
+// Templated on pixel size, in bytes (MONO8 = 1, BGR8 = 3, RGBA16 = 8, ...)
+template <int N>
+void decimate(const cv::Mat& src, cv::Mat& dst, int decimation_x, int decimation_y)
+{
+  dst.create(src.rows / decimation_y, src.cols / decimation_x, src.type());
+
+  int src_row_step = src.step[0] * decimation_y;
+  int src_pixel_step = N * decimation_x;
+  int dst_row_step = dst.step[0];
+
+  const uint8_t* src_row = src.ptr();
+  uint8_t* dst_row = dst.ptr();
+  
+  for (int y = 0; y < dst.rows; ++y)
+  {
+    const uint8_t* src_pixel = src_row;
+    uint8_t* dst_pixel = dst_row;
+    for (int x = 0; x < dst.cols; ++x)
+    {
+      memcpy(dst_pixel, src_pixel, N); // Should inline with small, fixed N
+      src_pixel += src_pixel_step;
+      dst_pixel += N;
+    }
+    src_row += src_row_step;
+    dst_row += dst_row_step;
+  }
+}
+
+void CropDecimateNodelet::imageCb(const sensor_msgs::ImageConstPtr& image_msg,
+                                  const sensor_msgs::CameraInfoConstPtr& info_msg)
+{
+  /// @todo Check image dimensions match info_msg
+  /// @todo Publish tweaks to config_ so they appear in reconfigure_gui
+
+  Config config;
+  {
+    boost::lock_guard<boost::recursive_mutex> lock(config_mutex_);
+    config = config_;
+  }
+  int decimation_x = config.decimation_x;
+  int decimation_y = config.decimation_y;
+
+  // Compute the ROI we'll actually use
+  bool is_bayer = sensor_msgs::image_encodings::isBayer(image_msg->encoding);
+  if (is_bayer)
+  {
+    // Odd offsets for Bayer images basically change the Bayer pattern, but that's
+    // unnecessarily complicated to support
+    config.x_offset &= ~0x1;
+    config.y_offset &= ~0x1;
+    config.width &= ~0x1;
+    config.height &= ~0x1;    
+  }
+
+  int max_width = image_msg->width - config.x_offset;
+  if (max_width <= 0)
+  {
+    ROS_WARN_THROTTLE(30., "x offset is outside the input image width: "
+      "%i, x offset: %i.", image_msg->width, config.x_offset);
+    return;
+  }
+  int max_height = image_msg->height - config.y_offset;
+  if (max_height <= 0)
+  {
+    ROS_WARN_THROTTLE(30., "y offset is outside the input image height: "
+      "%i, y offset: %i", image_msg->height, config.y_offset);
+    return;
+  }
+  int width = config.width;
+  int height = config.height;
+  if (width == 0 || width > max_width)
+    width = max_width;
+  if (height == 0 || height > max_height)
+    height = max_height;
+
+  // On no-op, just pass the messages along
+  if (decimation_x == 1               &&
+      decimation_y == 1               &&
+      config.x_offset == 0            &&
+      config.y_offset == 0            &&
+      width  == (int)image_msg->width &&
+      height == (int)image_msg->height)
+  {
+    pub_.publish(image_msg, info_msg);
+    return;
+  }
+
+  // Get a cv::Mat view of the source data
+  CvImageConstPtr source = toCvShare(image_msg);
+
+  // Except in Bayer downsampling case, output has same encoding as the input
+  CvImage output(source->header, source->encoding);
+  // Apply ROI (no copy, still a view of the image_msg data)
+  output.image = source->image(cv::Rect(config.x_offset, config.y_offset, width, height));
+
+  // Special case: when decimating Bayer images, we first do a 2x2 decimation to BGR
+  if (is_bayer && (decimation_x > 1 || decimation_y > 1))
+  {
+    if (decimation_x % 2 != 0 || decimation_y % 2 != 0)
+    {
+      NODELET_ERROR_THROTTLE(2, "Odd decimation not supported for Bayer images");
+      return;
+    }
+
+    cv::Mat bgr;
+    int step = output.image.step1();
+    if (image_msg->encoding == sensor_msgs::image_encodings::BAYER_RGGB8)
+      debayer2x2toBGR<uint8_t>(output.image, bgr, 0, 1, step, step + 1);
+    else if (image_msg->encoding == sensor_msgs::image_encodings::BAYER_BGGR8)
+      debayer2x2toBGR<uint8_t>(output.image, bgr, step + 1, 1, step, 0);
+    else if (image_msg->encoding == sensor_msgs::image_encodings::BAYER_GBRG8)
+      debayer2x2toBGR<uint8_t>(output.image, bgr, step, 0, step + 1, 1);
+    else if (image_msg->encoding == sensor_msgs::image_encodings::BAYER_GRBG8)
+      debayer2x2toBGR<uint8_t>(output.image, bgr, 1, 0, step + 1, step);
+    else if (image_msg->encoding == sensor_msgs::image_encodings::BAYER_RGGB16)
+      debayer2x2toBGR<uint16_t>(output.image, bgr, 0, 1, step, step + 1);
+    else if (image_msg->encoding == sensor_msgs::image_encodings::BAYER_BGGR16)
+      debayer2x2toBGR<uint16_t>(output.image, bgr, step + 1, 1, step, 0);
+    else if (image_msg->encoding == sensor_msgs::image_encodings::BAYER_GBRG16)
+      debayer2x2toBGR<uint16_t>(output.image, bgr, step, 0, step + 1, 1);
+    else if (image_msg->encoding == sensor_msgs::image_encodings::BAYER_GRBG16)
+      debayer2x2toBGR<uint16_t>(output.image, bgr, 1, 0, step + 1, step);
+    else
+    {
+      NODELET_ERROR_THROTTLE(2, "Unrecognized Bayer encoding '%s'", image_msg->encoding.c_str());
+      return;
+    }
+
+    output.image = bgr;
+    output.encoding = (bgr.depth() == CV_8U) ? sensor_msgs::image_encodings::BGR8
+                                             : sensor_msgs::image_encodings::BGR16;
+    decimation_x /= 2;
+    decimation_y /= 2;
+  }
+
+  // Apply further downsampling, if necessary
+  if (decimation_x > 1 || decimation_y > 1)
+  {
+    cv::Mat decimated;
+
+    if (config.interpolation == image_proc::CropDecimate_NN)
+    {
+      // Use optimized method instead of OpenCV's more general NN resize
+      int pixel_size = output.image.elemSize();
+      switch (pixel_size)
+      {
+        // Currently support up through 4-channel float
+        case 1:
+          decimate<1>(output.image, decimated, decimation_x, decimation_y);
+          break;
+        case 2:
+          decimate<2>(output.image, decimated, decimation_x, decimation_y);
+          break;
+        case 3:
+          decimate<3>(output.image, decimated, decimation_x, decimation_y);
+          break;
+        case 4:
+          decimate<4>(output.image, decimated, decimation_x, decimation_y);
+          break;
+        case 6:
+          decimate<6>(output.image, decimated, decimation_x, decimation_y);
+          break;
+        case 8:
+          decimate<8>(output.image, decimated, decimation_x, decimation_y);
+          break;
+        case 12:
+          decimate<12>(output.image, decimated, decimation_x, decimation_y);
+          break;
+        case 16:
+          decimate<16>(output.image, decimated, decimation_x, decimation_y);
+          break;
+        default:
+          NODELET_ERROR_THROTTLE(2, "Unsupported pixel size, %d bytes", pixel_size);
+          return;
+      }
+    }
+    else
+    {
+      // Linear, cubic, area, ...
+      cv::Size size(output.image.cols / decimation_x, output.image.rows / decimation_y);
+      cv::resize(output.image, decimated, size, 0.0, 0.0, config.interpolation);
+    }
+
+    output.image = decimated;
+  }
+
+  // Create output Image message
+  /// @todo Could save copies by allocating this above and having output.image alias it
+  sensor_msgs::ImagePtr out_image = output.toImageMsg();
+
+  // Create updated CameraInfo message
+  sensor_msgs::CameraInfoPtr out_info = boost::make_shared<sensor_msgs::CameraInfo>(*info_msg);
+  int binning_x = std::max((int)info_msg->binning_x, 1);
+  int binning_y = std::max((int)info_msg->binning_y, 1);
+  out_info->binning_x = binning_x * config.decimation_x;
+  out_info->binning_y = binning_y * config.decimation_y;
+  out_info->roi.x_offset += config.x_offset * binning_x;
+  out_info->roi.y_offset += config.y_offset * binning_y;
+  out_info->roi.height = height * binning_y;
+  out_info->roi.width = width * binning_x;
+  // If no ROI specified, leave do_rectify as-is. If ROI specified, set do_rectify = true.
+  if (width != (int)image_msg->width || height != (int)image_msg->height)
+    out_info->roi.do_rectify = true;
+
+  if (!target_frame_id_.empty()) {
+    out_image->header.frame_id = target_frame_id_;
+    out_info->header.frame_id = target_frame_id_;
+  }
+
+  pub_.publish(out_image, out_info);
+}
+
+void CropDecimateNodelet::configCb(Config &config, uint32_t level)
+{
+  config_ = config;
+}
+
+} // namespace image_proc
+
+// Register nodelet
+#include <pluginlib/class_list_macros.hpp>
+PLUGINLIB_EXPORT_CLASS( image_proc::CropDecimateNodelet, nodelet::Nodelet)
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/src/nodelets/crop_non_zero.cpp
@@ -0,0 +1,146 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#include <nodelet/nodelet.h>
+#include <image_transport/image_transport.h>
+#include <boost/thread.hpp>
+#include <cv_bridge/cv_bridge.h>
+//#include <algorithm> // for std::max_element
+
+namespace image_proc {
+
+namespace enc = sensor_msgs::image_encodings;
+
+class CropNonZeroNodelet : public nodelet::Nodelet
+{
+  // Subscriptions
+  boost::shared_ptr<image_transport::ImageTransport> it_;
+  image_transport::Subscriber sub_raw_;
+
+  // Publications
+  boost::mutex connect_mutex_;
+  image_transport::Publisher pub_;
+
+  virtual void onInit();
+
+  void connectCb();
+
+  void imageCb(const sensor_msgs::ImageConstPtr& raw_msg);
+};
+
+void CropNonZeroNodelet::onInit()
+{
+  ros::NodeHandle& nh = getNodeHandle();
+  it_.reset(new image_transport::ImageTransport(nh));
+
+  // Monitor whether anyone is subscribed to the output
+  image_transport::SubscriberStatusCallback connect_cb = boost::bind(&CropNonZeroNodelet::connectCb, this);
+  // Make sure we don't enter connectCb() between advertising and assigning to pub_depth_
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  pub_ = it_->advertise("image", 1, connect_cb, connect_cb);
+}
+
+// Handles (un)subscribing when clients (un)subscribe
+void CropNonZeroNodelet::connectCb()
+{
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  if (pub_.getNumSubscribers() == 0)
+  {
+    sub_raw_.shutdown();
+  }
+  else if (!sub_raw_)
+  {
+    image_transport::TransportHints hints("raw", ros::TransportHints(), getPrivateNodeHandle());
+    sub_raw_ = it_->subscribe("image_raw", 1, &CropNonZeroNodelet::imageCb, this, hints);
+  }
+}
+
+void CropNonZeroNodelet::imageCb(const sensor_msgs::ImageConstPtr& raw_msg)
+{
+  cv_bridge::CvImagePtr cv_ptr;
+  try
+  {
+    cv_ptr = cv_bridge::toCvCopy(raw_msg);
+  }
+  catch (cv_bridge::Exception& e)
+  {
+    ROS_ERROR("cv_bridge exception: %s", e.what());
+    return;
+  }
+
+  // Check the number of channels
+  if(sensor_msgs::image_encodings::numChannels(raw_msg->encoding) != 1){
+    NODELET_ERROR_THROTTLE(2, "Only grayscale image is acceptable, got [%s]", raw_msg->encoding.c_str());
+    return;
+  }
+
+  std::vector<std::vector<cv::Point> >cnt;
+  cv::Mat1b m(raw_msg->width, raw_msg->height);
+
+  if (raw_msg->encoding == enc::TYPE_8UC1){
+    m = cv_ptr->image;
+  }else{
+    double minVal, maxVal;
+    cv::minMaxIdx(cv_ptr->image, &minVal, &maxVal, 0, 0, cv_ptr->image != 0.);
+    double ra = maxVal - minVal;
+
+    cv_ptr->image.convertTo(m, CV_8U, 255./ra, -minVal*255./ra);
+  }
+
+  cv::findContours(m, cnt, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);
+
+  // search the largest area
+  /* // -std=c++11
+  std::vector<std::vector<cv::Point> >::iterator it = std::max_element(cnt.begin(), cnt.end(), [](std::vector<cv::Point> a, std::vector<cv::Point> b) {
+    return a.size() < b.size();
+  });
+  */
+  std::vector<std::vector<cv::Point> >::iterator it = cnt.begin();
+  for(std::vector<std::vector<cv::Point> >::iterator i=cnt.begin();i!=cnt.end();++i){
+    it = (*it).size() < (*i).size() ? i : it;
+  }
+  cv::Rect r = cv::boundingRect(cnt[std::distance(cnt.begin(), it)]);
+
+  cv_bridge::CvImage out_msg;
+  out_msg.header   = raw_msg->header;
+  out_msg.encoding = raw_msg->encoding;
+  out_msg.image    = cv_ptr->image(r);
+
+  pub_.publish(out_msg.toImageMsg());
+}
+
+} // namespace image_proc
+
+// Register as nodelet
+#include <pluginlib/class_list_macros.hpp>
+PLUGINLIB_EXPORT_CLASS(image_proc::CropNonZeroNodelet,nodelet::Nodelet);
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/src/nodelets/debayer.cpp
@@ -0,0 +1,285 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#include <boost/make_shared.hpp>
+#include <boost/version.hpp>
+#if ((BOOST_VERSION / 100) % 1000) >= 53
+#include <boost/thread/lock_guard.hpp>
+#endif
+
+#include <ros/ros.h>
+#include <nodelet/nodelet.h>
+#include <image_transport/image_transport.h>
+#include <sensor_msgs/image_encodings.h>
+#include <dynamic_reconfigure/server.h>
+#include <image_proc/DebayerConfig.h>
+
+#include <opencv2/imgproc/imgproc.hpp>
+// Until merged into OpenCV
+#include "edge_aware.h"
+
+#include <cv_bridge/cv_bridge.h>
+
+namespace image_proc {
+
+namespace enc = sensor_msgs::image_encodings;
+
+class DebayerNodelet : public nodelet::Nodelet
+{
+  // ROS communication
+  boost::shared_ptr<image_transport::ImageTransport> it_;
+  image_transport::Subscriber sub_raw_;
+  
+  boost::mutex connect_mutex_;
+  image_transport::Publisher pub_mono_;
+  image_transport::Publisher pub_color_;
+
+  // Dynamic reconfigure
+  boost::recursive_mutex config_mutex_;
+  typedef image_proc::DebayerConfig Config;
+  typedef dynamic_reconfigure::Server<Config> ReconfigureServer;
+  boost::shared_ptr<ReconfigureServer> reconfigure_server_;
+  Config config_;
+
+  virtual void onInit();
+
+  void connectCb();
+
+  void imageCb(const sensor_msgs::ImageConstPtr& raw_msg);
+
+  void configCb(Config &config, uint32_t level);
+};
+
+void DebayerNodelet::onInit()
+{
+  ros::NodeHandle &nh         = getNodeHandle();
+  ros::NodeHandle &private_nh = getPrivateNodeHandle();
+  it_.reset(new image_transport::ImageTransport(nh));
+
+  // Set up dynamic reconfigure
+  reconfigure_server_.reset(new ReconfigureServer(config_mutex_, private_nh));
+  ReconfigureServer::CallbackType f = boost::bind(&DebayerNodelet::configCb, this, boost::placeholders::_1, boost::placeholders::_2);
+  reconfigure_server_->setCallback(f);
+
+  // Monitor whether anyone is subscribed to the output
+  typedef image_transport::SubscriberStatusCallback ConnectCB;
+  ConnectCB connect_cb = boost::bind(&DebayerNodelet::connectCb, this);
+  // Make sure we don't enter connectCb() between advertising and assigning to pub_XXX
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  pub_mono_  = it_->advertise("image_mono",  1, connect_cb, connect_cb);
+  pub_color_ = it_->advertise("image_color", 1, connect_cb, connect_cb);
+}
+
+// Handles (un)subscribing when clients (un)subscribe
+void DebayerNodelet::connectCb()
+{
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  if (pub_mono_.getNumSubscribers() == 0 && pub_color_.getNumSubscribers() == 0)
+    sub_raw_.shutdown();
+  else if (!sub_raw_)
+  {
+    image_transport::TransportHints hints("raw", ros::TransportHints(), getPrivateNodeHandle());
+    sub_raw_ = it_->subscribe("image_raw", 1, &DebayerNodelet::imageCb, this, hints);
+  }
+}
+
+void DebayerNodelet::imageCb(const sensor_msgs::ImageConstPtr& raw_msg)
+{
+  int bit_depth = enc::bitDepth(raw_msg->encoding);
+  //@todo Fix as soon as bitDepth fixes it
+  if (raw_msg->encoding == enc::YUV422)
+    bit_depth = 8;
+
+  // First publish to mono if needed
+  if (pub_mono_.getNumSubscribers())
+  {
+    if (enc::isMono(raw_msg->encoding))
+      pub_mono_.publish(raw_msg);
+    else
+    {
+      if ((bit_depth != 8) && (bit_depth != 16))
+      {
+        NODELET_WARN_THROTTLE(30,
+                            "Raw image data from topic '%s' has unsupported depth: %d",
+                            sub_raw_.getTopic().c_str(), bit_depth);
+      } else {
+        // Use cv_bridge to convert to Mono. If a type is not supported,
+        // it will error out there
+        sensor_msgs::ImagePtr gray_msg;
+        try
+        {
+          if (bit_depth == 8)
+            gray_msg = cv_bridge::toCvCopy(raw_msg, enc::MONO8)->toImageMsg();
+          else
+            gray_msg = cv_bridge::toCvCopy(raw_msg, enc::MONO16)->toImageMsg();
+          pub_mono_.publish(gray_msg);
+        }
+        catch (cv_bridge::Exception &e)
+        {
+          NODELET_WARN_THROTTLE(30, "cv_bridge conversion error: '%s'", e.what());
+        }
+      }
+    }
+  }
+
+  // Next, publish to color
+  if (!pub_color_.getNumSubscribers())
+    return;
+
+  if (enc::isMono(raw_msg->encoding))
+  {
+    // For monochrome, no processing needed!
+    pub_color_.publish(raw_msg);
+
+    // Warn if the user asked for color
+    NODELET_WARN_THROTTLE(30,
+                            "Color topic '%s' requested, but raw image data from topic '%s' is grayscale",
+                            pub_color_.getTopic().c_str(), sub_raw_.getTopic().c_str());
+  }
+  else if (enc::isColor(raw_msg->encoding))
+  {
+    pub_color_.publish(raw_msg);
+  }
+  else if (enc::isBayer(raw_msg->encoding)) {
+    int type = bit_depth == 8 ? CV_8U : CV_16U;
+    const cv::Mat bayer(raw_msg->height, raw_msg->width, CV_MAKETYPE(type, 1),
+                        const_cast<uint8_t*>(&raw_msg->data[0]), raw_msg->step);
+
+      sensor_msgs::ImagePtr color_msg = boost::make_shared<sensor_msgs::Image>();
+      color_msg->header   = raw_msg->header;
+      color_msg->height   = raw_msg->height;
+      color_msg->width    = raw_msg->width;
+      color_msg->encoding = bit_depth == 8? enc::BGR8 : enc::BGR16;
+      color_msg->step     = color_msg->width * 3 * (bit_depth / 8);
+      color_msg->data.resize(color_msg->height * color_msg->step);
+
+      cv::Mat color(color_msg->height, color_msg->width, CV_MAKETYPE(type, 3),
+                    &color_msg->data[0], color_msg->step);
+
+      int algorithm;
+      {
+        boost::lock_guard<boost::recursive_mutex> lock(config_mutex_);
+        algorithm = config_.debayer;
+      }
+      
+      if (algorithm == Debayer_EdgeAware ||
+          algorithm == Debayer_EdgeAwareWeighted)
+      {
+        // These algorithms are not in OpenCV yet
+        if (raw_msg->encoding != enc::BAYER_GRBG8)
+        {
+          NODELET_WARN_THROTTLE(30, "Edge aware algorithms currently only support GRBG8 Bayer. "
+                                "Falling back to bilinear interpolation.");
+          algorithm = Debayer_Bilinear;
+        }
+        else
+        {
+          if (algorithm == Debayer_EdgeAware)
+            debayerEdgeAware(bayer, color);
+          else
+            debayerEdgeAwareWeighted(bayer, color);
+        }
+      }
+      if (algorithm == Debayer_Bilinear ||
+          algorithm == Debayer_VNG)
+      {
+        int code = -1;
+        if (raw_msg->encoding == enc::BAYER_RGGB8 ||
+            raw_msg->encoding == enc::BAYER_RGGB16)
+          code = cv::COLOR_BayerBG2BGR;
+        else if (raw_msg->encoding == enc::BAYER_BGGR8 ||
+                 raw_msg->encoding == enc::BAYER_BGGR16)
+          code = cv::COLOR_BayerRG2BGR;
+        else if (raw_msg->encoding == enc::BAYER_GBRG8 ||
+                 raw_msg->encoding == enc::BAYER_GBRG16)
+          code = cv::COLOR_BayerGR2BGR;
+        else if (raw_msg->encoding == enc::BAYER_GRBG8 ||
+                 raw_msg->encoding == enc::BAYER_GRBG16)
+          code = cv::COLOR_BayerGB2BGR;
+
+        if (algorithm == Debayer_VNG)
+          code += cv::COLOR_BayerBG2BGR_VNG - cv::COLOR_BayerBG2BGR;
+
+        try
+        {
+          cv::cvtColor(bayer, color, code);
+        }
+        catch (cv::Exception &e)
+        {
+          NODELET_WARN_THROTTLE(30, "cvtColor error: '%s', bayer code: %d, width %d, height %d",
+                       e.what(), code, bayer.cols, bayer.rows);
+          return;
+        }
+      }
+      
+      pub_color_.publish(color_msg);
+  }
+  else if (raw_msg->encoding == enc::YUV422)
+  {
+    // Use cv_bridge to convert to BGR8
+    sensor_msgs::ImagePtr color_msg;
+    try
+    {
+      color_msg = cv_bridge::toCvCopy(raw_msg, enc::BGR8)->toImageMsg();
+      pub_color_.publish(color_msg);
+    }
+    catch (cv_bridge::Exception &e)
+    {
+      NODELET_WARN_THROTTLE(30, "cv_bridge conversion error: '%s'", e.what());
+    }
+  }
+  else if (raw_msg->encoding == enc::TYPE_8UC3)
+  {
+    // 8UC3 does not specify a color encoding. Is it BGR, RGB, HSV, XYZ, LUV...?
+    NODELET_ERROR_THROTTLE(10,
+                           "Raw image topic '%s' has ambiguous encoding '8UC3'. The "
+                           "source should set the encoding to 'bgr8' or 'rgb8'.",
+                           sub_raw_.getTopic().c_str());
+  }
+  else
+  {
+    NODELET_ERROR_THROTTLE(10, "Raw image topic '%s' has unsupported encoding '%s'",
+                           sub_raw_.getTopic().c_str(), raw_msg->encoding.c_str());
+  }
+}
+
+void DebayerNodelet::configCb(Config &config, uint32_t level)
+{
+  config_ = config;
+}
+
+} // namespace image_proc
+
+// Register nodelet
+#include <pluginlib/class_list_macros.hpp>
+PLUGINLIB_EXPORT_CLASS( image_proc::DebayerNodelet, nodelet::Nodelet)
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/src/nodelets/edge_aware.cpp
@@ -0,0 +1,804 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#include "edge_aware.h"
+
+#define AVG(a,b) (((int)(a) + (int)(b)) >> 1)
+#define AVG3(a,b,c) (((int)(a) + (int)(b) + (int)(c)) / 3)
+#define AVG4(a,b,c,d) (((int)(a) + (int)(b) + (int)(c) + (int)(d)) >> 2)
+#define WAVG4(a,b,c,d,x,y)  ( ( ((int)(a) + (int)(b)) * (int)(x) + ((int)(c) + (int)(d)) * (int)(y) ) / ( 2 * ((int)(x) + (int(y))) ) )
+using namespace std;
+
+namespace image_proc {
+
+void debayerEdgeAware(const cv::Mat& bayer, cv::Mat& color)
+{
+  unsigned width = bayer.cols;
+  unsigned height = bayer.rows;
+  unsigned rgb_line_step = color.step[0];
+  unsigned rgb_line_skip = rgb_line_step - width * 3;
+  int bayer_line_step = bayer.step[0];
+  int bayer_line_step2 = bayer_line_step * 2;
+
+  unsigned char* rgb_buffer = color.data;
+  unsigned char* bayer_pixel = bayer.data;
+  unsigned yIdx, xIdx;
+
+  int dh, dv;
+
+  // first two pixel values for first two lines
+  // Bayer         0 1 2
+  //         0     G r g
+  // line_step     b g b
+  // line_step2    g r g
+
+  rgb_buffer[3] = rgb_buffer[0] = bayer_pixel[1]; // red pixel
+  rgb_buffer[1] = bayer_pixel[0]; // green pixel
+  rgb_buffer[rgb_line_step + 2] = rgb_buffer[2] = bayer_pixel[bayer_line_step]; // blue;
+
+  // Bayer         0 1 2
+  //         0     g R g
+  // line_step     b g b
+  // line_step2    g r g
+  //rgb_pixel[3] = bayer_pixel[1];
+  rgb_buffer[4] = AVG3 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1]);
+  rgb_buffer[rgb_line_step + 5] = rgb_buffer[5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+
+  // BGBG line
+  // Bayer         0 1 2
+  //         0     g r g
+  // line_step     B g b
+  // line_step2    g r g
+  rgb_buffer[rgb_line_step + 3] = rgb_buffer[rgb_line_step ] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+  rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step + 1], bayer_pixel[bayer_line_step2]);
+  //rgb_pixel[rgb_line_step + 2] = bayer_pixel[line_step];
+
+  // pixel (1, 1)  0 1 2
+  //         0     g r g
+  // line_step     b G b
+  // line_step2    g r g
+  //rgb_pixel[rgb_line_step + 3] = AVG( bayer_pixel[1] , bayer_pixel[line_step2+1] );
+  rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+  //rgb_pixel[rgb_line_step + 5] = AVG( bayer_pixel[line_step] , bayer_pixel[line_step+2] );
+
+  rgb_buffer += 6;
+  bayer_pixel += 2;
+  // rest of the first two lines
+  for (xIdx = 2; xIdx < width - 2; xIdx += 2, rgb_buffer += 6, bayer_pixel += 2)
+  {
+    // GRGR line
+    // Bayer        -1 0 1 2
+    //           0   r G r g
+    //   line_step   g b g b
+    // line_step2    r g r g
+    rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+    rgb_buffer[1] = bayer_pixel[0];
+    rgb_buffer[2] = bayer_pixel[bayer_line_step + 1];
+
+    // Bayer        -1 0 1 2
+    //          0    r g R g
+    //  line_step    g b g b
+    // line_step2    r g r g
+    rgb_buffer[3] = bayer_pixel[1];
+    rgb_buffer[4] = AVG3 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1]);
+    rgb_buffer[rgb_line_step + 5] = rgb_buffer[5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+
+    // BGBG line
+    // Bayer         -1 0 1 2
+    //         0      r g r g
+    // line_step      g B g b
+    // line_step2     r g r g
+    rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+    rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+    rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+    // Bayer         -1 0 1 2
+    //         0      r g r g
+    // line_step      g b G b
+    // line_step2     r g r g
+    rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+    rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+    //rgb_pixel[rgb_line_step + 5] = AVG( bayer_pixel[line_step] , bayer_pixel[line_step+2] );
+  }
+
+  // last two pixel values for first two lines
+  // GRGR line
+  // Bayer        -1 0 1
+  //           0   r G r
+  //   line_step   g b g
+  // line_step2    r g r
+  rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+  rgb_buffer[1] = bayer_pixel[0];
+  rgb_buffer[rgb_line_step + 5] = rgb_buffer[rgb_line_step + 2] = rgb_buffer[5] = rgb_buffer[2] = bayer_pixel[bayer_line_step];
+
+  // Bayer        -1 0 1
+  //          0    r g R
+  //  line_step    g b g
+  // line_step2    r g r
+  rgb_buffer[3] = bayer_pixel[1];
+  rgb_buffer[4] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step + 1]);
+  //rgb_pixel[5] = bayer_pixel[line_step];
+
+  // BGBG line
+  // Bayer        -1 0 1
+  //          0    r g r
+  //  line_step    g B g
+  // line_step2    r g r
+  rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+  rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+  //rgb_pixel[rgb_line_step + 2] = bayer_pixel[line_step];
+
+  // Bayer         -1 0 1
+  //         0      r g r
+  // line_step      g b G
+  // line_step2     r g r
+  rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+  rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+  //rgb_pixel[rgb_line_step + 5] = bayer_pixel[line_step];
+
+  bayer_pixel += bayer_line_step + 2;
+  rgb_buffer += rgb_line_step + 6 + rgb_line_skip;
+  // main processing
+  for (yIdx = 2; yIdx < height - 2; yIdx += 2)
+  {
+    // first two pixel values
+    // Bayer         0 1 2
+    //        -1     b g b
+    //         0     G r g
+    // line_step     b g b
+    // line_step2    g r g
+    
+    rgb_buffer[3] = rgb_buffer[0] = bayer_pixel[1]; // red pixel
+    rgb_buffer[1] = bayer_pixel[0]; // green pixel
+    rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]); // blue;
+    
+    // Bayer         0 1 2
+    //        -1     b g b
+    //         0     g R g
+    // line_step     b g b
+    // line_step2    g r g
+    //rgb_pixel[3] = bayer_pixel[1];
+    rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+    rgb_buffer[5] = AVG4 (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2], bayer_pixel[-bayer_line_step], bayer_pixel[2 - bayer_line_step]);
+    
+    // BGBG line
+    // Bayer         0 1 2
+    //         0     g r g
+    // line_step     B g b
+    // line_step2    g r g
+    rgb_buffer[rgb_line_step + 3] = rgb_buffer[rgb_line_step ] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+    rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step + 1], bayer_pixel[bayer_line_step2]);
+    rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+    
+    // pixel (1, 1)  0 1 2
+    //         0     g r g
+    // line_step     b G b
+    // line_step2    g r g
+    //rgb_pixel[rgb_line_step + 3] = AVG( bayer_pixel[1] , bayer_pixel[line_step2+1] );
+    rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+    rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+    
+    rgb_buffer += 6;
+    bayer_pixel += 2;
+    // continue with rest of the line
+    for (xIdx = 2; xIdx < width - 2; xIdx += 2, rgb_buffer += 6, bayer_pixel += 2)
+    {
+      // GRGR line
+      // Bayer        -1 0 1 2
+      //          -1   g b g b
+      //           0   r G r g
+      //   line_step   g b g b
+      // line_step2    r g r g
+      rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+      rgb_buffer[1] = bayer_pixel[0];
+      rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]);
+      
+      // Bayer        -1 0 1 2
+      //          -1   g b g b
+      //          0    r g R g
+      //  line_step    g b g b
+      // line_step2    r g r g
+      
+      dh = abs (bayer_pixel[0] - bayer_pixel[2]);
+      dv = abs (bayer_pixel[-bayer_line_step + 1] - bayer_pixel[bayer_line_step + 1]);
+      
+      if (dh > dv)
+        rgb_buffer[4] = AVG (bayer_pixel[-bayer_line_step + 1], bayer_pixel[bayer_line_step + 1]);
+      else if (dv > dh)
+        rgb_buffer[4] = AVG (bayer_pixel[0], bayer_pixel[2]);
+      else
+        rgb_buffer[4] = AVG4 (bayer_pixel[-bayer_line_step + 1], bayer_pixel[bayer_line_step + 1], bayer_pixel[0], bayer_pixel[2]);
+      
+      rgb_buffer[3] = bayer_pixel[1];
+      rgb_buffer[5] = AVG4 (bayer_pixel[-bayer_line_step], bayer_pixel[2 - bayer_line_step], bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+      
+      // BGBG line
+      // Bayer         -1 0 1 2
+      //         -1     g b g b
+      //          0     r g r g
+      // line_step      g B g b
+      // line_step2     r g r g
+      rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+      rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+      
+      dv = abs (bayer_pixel[0] - bayer_pixel[bayer_line_step2]);
+      dh = abs (bayer_pixel[bayer_line_step - 1] - bayer_pixel[bayer_line_step + 1]);
+      
+      if (dv > dh)
+        rgb_buffer[rgb_line_step + 1] = AVG (bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+      else if (dh > dv)
+        rgb_buffer[rgb_line_step + 1] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step2]);
+      else
+        rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+      
+      // Bayer         -1 0 1 2
+      //         -1     g b g b
+      //          0     r g r g
+      // line_step      g b G b
+      // line_step2     r g r g
+      rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+      rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+      rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+    }
+    
+    // last two pixels of the line
+    // last two pixel values for first two lines
+    // GRGR line
+    // Bayer        -1 0 1
+    //           0   r G r
+    //   line_step   g b g
+    // line_step2    r g r
+    rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+    rgb_buffer[1] = bayer_pixel[0];
+    rgb_buffer[rgb_line_step + 5] = rgb_buffer[rgb_line_step + 2] = rgb_buffer[5] = rgb_buffer[2] = bayer_pixel[bayer_line_step];
+    
+    // Bayer        -1 0 1
+    //          0    r g R
+    //  line_step    g b g
+    // line_step2    r g r
+    rgb_buffer[3] = bayer_pixel[1];
+    rgb_buffer[4] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step + 1]);
+    //rgb_pixel[5] = bayer_pixel[line_step];
+    
+    // BGBG line
+    // Bayer        -1 0 1
+    //          0    r g r
+    //  line_step    g B g
+    // line_step2    r g r
+    rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+    rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+    //rgb_pixel[rgb_line_step + 2] = bayer_pixel[line_step];
+    
+    // Bayer         -1 0 1
+    //         0      r g r
+    // line_step      g b G
+    // line_step2     r g r
+    rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+    rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+    //rgb_pixel[rgb_line_step + 5] = bayer_pixel[line_step];
+    
+    bayer_pixel += bayer_line_step + 2;
+    rgb_buffer += rgb_line_step + 6 + rgb_line_skip;
+  }
+  
+  //last two lines
+  // Bayer         0 1 2
+  //        -1     b g b
+  //         0     G r g
+  // line_step     b g b
+  
+  rgb_buffer[rgb_line_step + 3] = rgb_buffer[rgb_line_step ] = rgb_buffer[3] = rgb_buffer[0] = bayer_pixel[1]; // red pixel
+  rgb_buffer[1] = bayer_pixel[0]; // green pixel
+  rgb_buffer[rgb_line_step + 2] = rgb_buffer[2] = bayer_pixel[bayer_line_step]; // blue;
+  
+  // Bayer         0 1 2
+  //        -1     b g b
+  //         0     g R g
+  // line_step     b g b
+  //rgb_pixel[3] = bayer_pixel[1];
+  rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+  rgb_buffer[5] = AVG4 (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2], bayer_pixel[-bayer_line_step], bayer_pixel[2 - bayer_line_step]);
+  
+  // BGBG line
+  // Bayer         0 1 2
+  //        -1     b g b
+  //         0     g r g
+  // line_step     B g b
+  //rgb_pixel[rgb_line_step    ] = bayer_pixel[1];
+  rgb_buffer[rgb_line_step + 1] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step + 1]);
+  rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+  
+  // Bayer         0 1 2
+  //        -1     b g b
+  //         0     g r g
+  // line_step     b G b
+  //rgb_pixel[rgb_line_step + 3] = AVG( bayer_pixel[1] , bayer_pixel[line_step2+1] );
+  rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+  rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+  
+  rgb_buffer += 6;
+  bayer_pixel += 2;
+  // rest of the last two lines
+  for (xIdx = 2; xIdx < width - 2; xIdx += 2, rgb_buffer += 6, bayer_pixel += 2)
+  {
+    // GRGR line
+    // Bayer       -1 0 1 2
+    //        -1    g b g b
+    //         0    r G r g
+    // line_step    g b g b
+    rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+    rgb_buffer[1] = bayer_pixel[0];
+    rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]);
+    
+    // Bayer       -1 0 1 2
+    //        -1    g b g b
+    //         0    r g R g
+    // line_step    g b g b
+    rgb_buffer[rgb_line_step + 3] = rgb_buffer[3] = bayer_pixel[1];
+    rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+    rgb_buffer[5] = AVG4 (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2], bayer_pixel[-bayer_line_step], bayer_pixel[-bayer_line_step + 2]);
+    
+    // BGBG line
+    // Bayer       -1 0 1 2
+    //        -1    g b g b
+    //         0    r g r g
+    // line_step    g B g b
+    rgb_buffer[rgb_line_step ] = AVG (bayer_pixel[-1], bayer_pixel[1]);
+    rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+    rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+    
+    
+    // Bayer       -1 0 1 2
+    //        -1    g b g b
+    //         0    r g r g
+    // line_step    g b G b
+    //rgb_pixel[rgb_line_step + 3] = bayer_pixel[1];
+    rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+    rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+  }
+  
+  // last two pixel values for first two lines
+  // GRGR line
+  // Bayer       -1 0 1
+  //        -1    g b g
+  //         0    r G r
+  // line_step    g b g
+  rgb_buffer[rgb_line_step ] = rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+  rgb_buffer[1] = bayer_pixel[0];
+  rgb_buffer[5] = rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]);
+  
+  // Bayer       -1 0 1
+  //        -1    g b g
+  //         0    r g R
+  // line_step    g b g
+  rgb_buffer[rgb_line_step + 3] = rgb_buffer[3] = bayer_pixel[1];
+  rgb_buffer[4] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step + 1], bayer_pixel[-bayer_line_step + 1]);
+  //rgb_pixel[5] = AVG( bayer_pixel[line_step], bayer_pixel[-line_step] );
+  
+  // BGBG line
+  // Bayer       -1 0 1
+  //        -1    g b g
+  //         0    r g r
+  // line_step    g B g
+  //rgb_pixel[rgb_line_step    ] = AVG2( bayer_pixel[-1], bayer_pixel[1] );
+  rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+  rgb_buffer[rgb_line_step + 5] = rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+  
+  // Bayer       -1 0 1
+  //        -1    g b g
+  //         0    r g r
+  // line_step    g b G
+  //rgb_pixel[rgb_line_step + 3] = bayer_pixel[1];
+  rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+  //rgb_pixel[rgb_line_step + 5] = bayer_pixel[line_step];
+}
+
+void debayerEdgeAwareWeighted(const cv::Mat& bayer, cv::Mat& color)
+{
+  unsigned width = bayer.cols;
+  unsigned height = bayer.rows;
+  unsigned rgb_line_step = color.step[0];
+  unsigned rgb_line_skip = rgb_line_step - width * 3;
+  int bayer_line_step = bayer.step[0];
+  int bayer_line_step2 = bayer_line_step * 2;
+
+  unsigned char* rgb_buffer = color.data;
+  unsigned char* bayer_pixel = bayer.data;
+  unsigned yIdx, xIdx;
+
+  int dh, dv;
+
+  // first two pixel values for first two lines
+  // Bayer         0 1 2
+  //         0     G r g
+  // line_step     b g b
+  // line_step2    g r g
+
+  rgb_buffer[3] = rgb_buffer[0] = bayer_pixel[1]; // red pixel
+  rgb_buffer[1] = bayer_pixel[0]; // green pixel
+  rgb_buffer[rgb_line_step + 2] = rgb_buffer[2] = bayer_pixel[bayer_line_step]; // blue;
+  
+  // Bayer         0 1 2
+  //         0     g R g
+  // line_step     b g b
+  // line_step2    g r g
+  //rgb_pixel[3] = bayer_pixel[1];
+  rgb_buffer[4] = AVG3 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1]);
+  rgb_buffer[rgb_line_step + 5] = rgb_buffer[5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+  
+  // BGBG line
+  // Bayer         0 1 2
+  //         0     g r g
+  // line_step     B g b
+  // line_step2    g r g
+  rgb_buffer[rgb_line_step + 3] = rgb_buffer[rgb_line_step ] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+  rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step + 1], bayer_pixel[bayer_line_step2]);
+  //rgb_pixel[rgb_line_step + 2] = bayer_pixel[line_step];
+  
+  // pixel (1, 1)  0 1 2
+  //         0     g r g
+  // line_step     b G b
+  // line_step2    g r g
+  //rgb_pixel[rgb_line_step + 3] = AVG( bayer_pixel[1] , bayer_pixel[line_step2+1] );
+  rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+  //rgb_pixel[rgb_line_step + 5] = AVG( bayer_pixel[line_step] , bayer_pixel[line_step+2] );
+  
+  rgb_buffer += 6;
+  bayer_pixel += 2;
+  // rest of the first two lines
+  for (xIdx = 2; xIdx < width - 2; xIdx += 2, rgb_buffer += 6, bayer_pixel += 2)
+  {
+    // GRGR line
+    // Bayer        -1 0 1 2
+    //           0   r G r g
+    //   line_step   g b g b
+    // line_step2    r g r g
+    rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+    rgb_buffer[1] = bayer_pixel[0];
+    rgb_buffer[2] = bayer_pixel[bayer_line_step + 1];
+    
+    // Bayer        -1 0 1 2
+    //          0    r g R g
+    //  line_step    g b g b
+    // line_step2    r g r g
+    rgb_buffer[3] = bayer_pixel[1];
+    rgb_buffer[4] = AVG3 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1]);
+    rgb_buffer[rgb_line_step + 5] = rgb_buffer[5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+    
+    // BGBG line
+    // Bayer         -1 0 1 2
+    //         0      r g r g
+    // line_step      g B g b
+    // line_step2     r g r g
+    rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+    rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+    rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+    
+    // Bayer         -1 0 1 2
+    //         0      r g r g
+    // line_step      g b G b
+    // line_step2     r g r g
+    rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+    rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+    //rgb_pixel[rgb_line_step + 5] = AVG( bayer_pixel[line_step] , bayer_pixel[line_step+2] );
+  }
+  
+  // last two pixel values for first two lines
+  // GRGR line
+  // Bayer        -1 0 1
+  //           0   r G r
+  //   line_step   g b g
+  // line_step2    r g r
+  rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+  rgb_buffer[1] = bayer_pixel[0];
+  rgb_buffer[rgb_line_step + 5] = rgb_buffer[rgb_line_step + 2] = rgb_buffer[5] = rgb_buffer[2] = bayer_pixel[bayer_line_step];
+  
+  // Bayer        -1 0 1
+  //          0    r g R
+  //  line_step    g b g
+  // line_step2    r g r
+  rgb_buffer[3] = bayer_pixel[1];
+  rgb_buffer[4] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step + 1]);
+  //rgb_pixel[5] = bayer_pixel[line_step];
+  
+  // BGBG line
+  // Bayer        -1 0 1
+  //          0    r g r
+  //  line_step    g B g
+  // line_step2    r g r
+  rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+  rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+  //rgb_pixel[rgb_line_step + 2] = bayer_pixel[line_step];
+  
+  // Bayer         -1 0 1
+  //         0      r g r
+  // line_step      g b G
+  // line_step2     r g r
+  rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+  rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+  //rgb_pixel[rgb_line_step + 5] = bayer_pixel[line_step];
+  
+  bayer_pixel += bayer_line_step + 2;
+  rgb_buffer += rgb_line_step + 6 + rgb_line_skip;
+  // main processing
+  for (yIdx = 2; yIdx < height - 2; yIdx += 2)
+  {
+    // first two pixel values
+    // Bayer         0 1 2
+    //        -1     b g b
+    //         0     G r g
+    // line_step     b g b
+    // line_step2    g r g
+    
+    rgb_buffer[3] = rgb_buffer[0] = bayer_pixel[1]; // red pixel
+    rgb_buffer[1] = bayer_pixel[0]; // green pixel
+    rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]); // blue;
+    
+    // Bayer         0 1 2
+    //        -1     b g b
+    //         0     g R g
+    // line_step     b g b
+    // line_step2    g r g
+    //rgb_pixel[3] = bayer_pixel[1];
+    rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+    rgb_buffer[5] = AVG4 (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2], bayer_pixel[-bayer_line_step], bayer_pixel[2 - bayer_line_step]);
+    
+    // BGBG line
+    // Bayer         0 1 2
+    //         0     g r g
+    // line_step     B g b
+    // line_step2    g r g
+    rgb_buffer[rgb_line_step + 3] = rgb_buffer[rgb_line_step ] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+    rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step + 1], bayer_pixel[bayer_line_step2]);
+    rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+    
+    // pixel (1, 1)  0 1 2
+    //         0     g r g
+    // line_step     b G b
+    // line_step2    g r g
+    //rgb_pixel[rgb_line_step + 3] = AVG( bayer_pixel[1] , bayer_pixel[line_step2+1] );
+    rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+    rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+    
+    rgb_buffer += 6;
+    bayer_pixel += 2;
+    // continue with rest of the line
+    for (xIdx = 2; xIdx < width - 2; xIdx += 2, rgb_buffer += 6, bayer_pixel += 2)
+    {
+      // GRGR line
+      // Bayer        -1 0 1 2
+      //          -1   g b g b
+      //           0   r G r g
+      //   line_step   g b g b
+      // line_step2    r g r g
+      rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+      rgb_buffer[1] = bayer_pixel[0];
+      rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]);
+      
+      // Bayer        -1 0 1 2
+      //          -1   g b g b
+      //          0    r g R g
+      //  line_step    g b g b
+      // line_step2    r g r g
+      
+      dh = abs (bayer_pixel[0] - bayer_pixel[2]);
+      dv = abs (bayer_pixel[-bayer_line_step + 1] - bayer_pixel[bayer_line_step + 1]);
+      
+      if (dv == 0 && dh == 0)
+        rgb_buffer[4] = AVG4 (bayer_pixel[1 - bayer_line_step], bayer_pixel[1 + bayer_line_step], bayer_pixel[0], bayer_pixel[2]);
+      else
+        rgb_buffer[4] = WAVG4 (bayer_pixel[1 - bayer_line_step], bayer_pixel[1 + bayer_line_step], bayer_pixel[0], bayer_pixel[2], dh, dv);
+      rgb_buffer[3] = bayer_pixel[1];
+      rgb_buffer[5] = AVG4 (bayer_pixel[-bayer_line_step], bayer_pixel[2 - bayer_line_step], bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+      
+      // BGBG line
+      // Bayer         -1 0 1 2
+      //         -1     g b g b
+      //          0     r g r g
+      // line_step      g B g b
+      // line_step2     r g r g
+      rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+      rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+      
+      dv = abs (bayer_pixel[0] - bayer_pixel[bayer_line_step2]);
+      dh = abs (bayer_pixel[bayer_line_step - 1] - bayer_pixel[bayer_line_step + 1]);
+      
+      if (dv == 0 && dh == 0)
+        rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+      else
+        rgb_buffer[rgb_line_step + 1] = WAVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1], dh, dv);
+      
+      // Bayer         -1 0 1 2
+      //         -1     g b g b
+      //          0     r g r g
+      // line_step      g b G b
+      // line_step2     r g r g
+      rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+      rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+      rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+    }
+    
+    // last two pixels of the line
+    // last two pixel values for first two lines
+    // GRGR line
+    // Bayer        -1 0 1
+    //           0   r G r
+    //   line_step   g b g
+    // line_step2    r g r
+    rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+    rgb_buffer[1] = bayer_pixel[0];
+    rgb_buffer[rgb_line_step + 5] = rgb_buffer[rgb_line_step + 2] = rgb_buffer[5] = rgb_buffer[2] = bayer_pixel[bayer_line_step];
+    
+    // Bayer        -1 0 1
+    //          0    r g R
+    //  line_step    g b g
+    // line_step2    r g r
+    rgb_buffer[3] = bayer_pixel[1];
+    rgb_buffer[4] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step + 1]);
+    //rgb_pixel[5] = bayer_pixel[line_step];
+    
+    // BGBG line
+    // Bayer        -1 0 1
+    //          0    r g r
+    //  line_step    g B g
+    // line_step2    r g r
+    rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+    rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+    //rgb_pixel[rgb_line_step + 2] = bayer_pixel[line_step];
+    
+    // Bayer         -1 0 1
+    //         0      r g r
+    // line_step      g b G
+    // line_step2     r g r
+    rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+    rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+    //rgb_pixel[rgb_line_step + 5] = bayer_pixel[line_step];
+    
+    bayer_pixel += bayer_line_step + 2;
+    rgb_buffer += rgb_line_step + 6 + rgb_line_skip;
+  }
+  
+  //last two lines
+  // Bayer         0 1 2
+  //        -1     b g b
+  //         0     G r g
+  // line_step     b g b
+  
+  rgb_buffer[rgb_line_step + 3] = rgb_buffer[rgb_line_step ] = rgb_buffer[3] = rgb_buffer[0] = bayer_pixel[1]; // red pixel
+  rgb_buffer[1] = bayer_pixel[0]; // green pixel
+  rgb_buffer[rgb_line_step + 2] = rgb_buffer[2] = bayer_pixel[bayer_line_step]; // blue;
+  
+  // Bayer         0 1 2
+  //        -1     b g b
+  //         0     g R g
+  // line_step     b g b
+  //rgb_pixel[3] = bayer_pixel[1];
+  rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+  rgb_buffer[5] = AVG4 (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2], bayer_pixel[-bayer_line_step], bayer_pixel[2 - bayer_line_step]);
+  
+  // BGBG line
+  // Bayer         0 1 2
+  //        -1     b g b
+  //         0     g r g
+  // line_step     B g b
+  //rgb_pixel[rgb_line_step    ] = bayer_pixel[1];
+  rgb_buffer[rgb_line_step + 1] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step + 1]);
+  rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+  // Bayer         0 1 2
+  //        -1     b g b
+  //         0     g r g
+  // line_step     b G b
+  //rgb_pixel[rgb_line_step + 3] = AVG( bayer_pixel[1] , bayer_pixel[line_step2+1] );
+  rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+  rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+  
+  rgb_buffer += 6;
+  bayer_pixel += 2;
+  // rest of the last two lines
+  for (xIdx = 2; xIdx < width - 2; xIdx += 2, rgb_buffer += 6, bayer_pixel += 2)
+  {
+    // GRGR line
+    // Bayer       -1 0 1 2
+    //        -1    g b g b
+    //         0    r G r g
+    // line_step    g b g b
+    rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+    rgb_buffer[1] = bayer_pixel[0];
+    rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]);
+    
+    // Bayer       -1 0 1 2
+    //        -1    g b g b
+    //         0    r g R g
+    // line_step    g b g b
+    rgb_buffer[rgb_line_step + 3] = rgb_buffer[3] = bayer_pixel[1];
+    rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+    rgb_buffer[5] = AVG4 (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2], bayer_pixel[-bayer_line_step], bayer_pixel[-bayer_line_step + 2]);
+
+    // BGBG line
+    // Bayer       -1 0 1 2
+    //        -1    g b g b
+    //         0    r g r g
+    // line_step    g B g b
+    rgb_buffer[rgb_line_step ] = AVG (bayer_pixel[-1], bayer_pixel[1]);
+    rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+    rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+    
+    
+    // Bayer       -1 0 1 2
+    //        -1    g b g b
+    //         0    r g r g
+    // line_step    g b G b
+    //rgb_pixel[rgb_line_step + 3] = bayer_pixel[1];
+    rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+    rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+  }
+  
+  // last two pixel values for first two lines
+  // GRGR line
+  // Bayer       -1 0 1
+  //        -1    g b g
+  //         0    r G r
+  // line_step    g b g
+  rgb_buffer[rgb_line_step ] = rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+  rgb_buffer[1] = bayer_pixel[0];
+  rgb_buffer[5] = rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]);
+  
+  // Bayer       -1 0 1
+  //        -1    g b g
+  //         0    r g R
+  // line_step    g b g
+  rgb_buffer[rgb_line_step + 3] = rgb_buffer[3] = bayer_pixel[1];
+  rgb_buffer[4] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step + 1], bayer_pixel[-bayer_line_step + 1]);
+  //rgb_pixel[5] = AVG( bayer_pixel[line_step], bayer_pixel[-line_step] );
+  
+  // BGBG line
+  // Bayer       -1 0 1
+  //        -1    g b g
+  //         0    r g r
+  // line_step    g B g
+  //rgb_pixel[rgb_line_step    ] = AVG2( bayer_pixel[-1], bayer_pixel[1] );
+  rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+  rgb_buffer[rgb_line_step + 5] = rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+  
+  // Bayer       -1 0 1
+  //        -1    g b g
+  //         0    r g r
+  // line_step    g b G
+  //rgb_pixel[rgb_line_step + 3] = bayer_pixel[1];
+  rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+  //rgb_pixel[rgb_line_step + 5] = bayer_pixel[line_step];
+
+}
+
+} // namespace image_proc
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/src/nodelets/edge_aware.h
@@ -0,0 +1,49 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#ifndef IMAGE_PROC_EDGE_AWARE
+#define IMAGE_PROC_EDGE_AWARE
+
+#include <opencv2/core/core.hpp>
+
+// Edge-aware debayering algorithms, intended for eventual inclusion in OpenCV.
+
+namespace image_proc {
+
+void debayerEdgeAware(const cv::Mat& bayer, cv::Mat& color);
+
+void debayerEdgeAwareWeighted(const cv::Mat& bayer, cv::Mat& color);
+
+} // namespace image_proc
+
+#endif
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/src/nodelets/rectify.cpp
@@ -0,0 +1,170 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#include <boost/version.hpp>
+#if ((BOOST_VERSION / 100) % 1000) >= 53
+#include <boost/thread/lock_guard.hpp>
+#endif
+
+#include <ros/ros.h>
+#include <nodelet/nodelet.h>
+#include <image_transport/image_transport.h>
+#include <image_geometry/pinhole_camera_model.h>
+#include <cv_bridge/cv_bridge.h>
+#include <dynamic_reconfigure/server.h>
+#include <image_proc/RectifyConfig.h>
+
+namespace image_proc {
+
+class RectifyNodelet : public nodelet::Nodelet
+{
+  // ROS communication
+  boost::shared_ptr<image_transport::ImageTransport> it_;
+  image_transport::CameraSubscriber sub_camera_;
+  int queue_size_;
+  
+  boost::mutex connect_mutex_;
+  image_transport::Publisher pub_rect_;
+
+  // Dynamic reconfigure
+  boost::recursive_mutex config_mutex_;
+  typedef image_proc::RectifyConfig Config;
+  typedef dynamic_reconfigure::Server<Config> ReconfigureServer;
+  boost::shared_ptr<ReconfigureServer> reconfigure_server_;
+  Config config_;
+
+  // Processing state (note: only safe because we're using single-threaded NodeHandle!)
+  image_geometry::PinholeCameraModel model_;
+
+  virtual void onInit();
+
+  void connectCb();
+
+  void imageCb(const sensor_msgs::ImageConstPtr& image_msg,
+               const sensor_msgs::CameraInfoConstPtr& info_msg);
+
+  void configCb(Config &config, uint32_t level);
+};
+
+void RectifyNodelet::onInit()
+{
+  ros::NodeHandle &nh         = getNodeHandle();
+  ros::NodeHandle &private_nh = getPrivateNodeHandle();
+  it_.reset(new image_transport::ImageTransport(nh));
+
+  // Read parameters
+  private_nh.param("queue_size", queue_size_, 5);
+
+  // Set up dynamic reconfigure
+  reconfigure_server_.reset(new ReconfigureServer(config_mutex_, private_nh));
+  ReconfigureServer::CallbackType f = boost::bind(&RectifyNodelet::configCb, this, boost::placeholders::_1, boost::placeholders::_2);
+  reconfigure_server_->setCallback(f);
+
+  // Monitor whether anyone is subscribed to the output
+  image_transport::SubscriberStatusCallback connect_cb = boost::bind(&RectifyNodelet::connectCb, this);
+  // Make sure we don't enter connectCb() between advertising and assigning to pub_rect_
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  pub_rect_  = it_->advertise("image_rect",  1, connect_cb, connect_cb);
+}
+
+// Handles (un)subscribing when clients (un)subscribe
+void RectifyNodelet::connectCb()
+{
+  boost::lock_guard<boost::mutex> lock(connect_mutex_);
+  if (pub_rect_.getNumSubscribers() == 0)
+    sub_camera_.shutdown();
+  else if (!sub_camera_)
+  {
+    image_transport::TransportHints hints("raw", ros::TransportHints(), getPrivateNodeHandle());
+    sub_camera_ = it_->subscribeCamera("image_mono", queue_size_, &RectifyNodelet::imageCb, this, hints);
+  }
+}
+
+void RectifyNodelet::imageCb(const sensor_msgs::ImageConstPtr& image_msg,
+                             const sensor_msgs::CameraInfoConstPtr& info_msg)
+{
+  // Verify camera is actually calibrated
+  if (info_msg->K[0] == 0.0) {
+    NODELET_ERROR_THROTTLE(30, "Rectified topic '%s' requested but camera publishing '%s' "
+                           "is uncalibrated", pub_rect_.getTopic().c_str(),
+                           sub_camera_.getInfoTopic().c_str());
+    return;
+  }
+
+  // If zero distortion, just pass the message along
+  bool zero_distortion = true;
+  for (size_t i = 0; i < info_msg->D.size(); ++i)
+  {
+    if (info_msg->D[i] != 0.0)
+    {
+      zero_distortion = false;
+      break;
+    }
+  }
+  // This will be true if D is empty/zero sized
+  if (zero_distortion)
+  {
+    pub_rect_.publish(image_msg);
+    return;
+  }
+
+  // Update the camera model
+  model_.fromCameraInfo(info_msg);
+  
+  // Create cv::Mat views onto both buffers
+  const cv::Mat image = cv_bridge::toCvShare(image_msg)->image;
+  cv::Mat rect;
+
+  // Rectify and publish
+  int interpolation;
+  {
+    boost::lock_guard<boost::recursive_mutex> lock(config_mutex_);
+    interpolation = config_.interpolation;
+  }
+  model_.rectifyImage(image, rect, interpolation);
+
+  // Allocate new rectified image message
+  sensor_msgs::ImagePtr rect_msg = cv_bridge::CvImage(image_msg->header, image_msg->encoding, rect).toImageMsg();
+  pub_rect_.publish(rect_msg);
+}
+
+void RectifyNodelet::configCb(Config &config, uint32_t level)
+{
+  config_ = config;
+}
+
+} // namespace image_proc
+
+// Register nodelet
+#include <pluginlib/class_list_macros.hpp>
+PLUGINLIB_EXPORT_CLASS( image_proc::RectifyNodelet, nodelet::Nodelet)
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/src/nodelets/resize.cpp
@@ -0,0 +1,213 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2017, Kentaro Wada.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Kentaro Wada nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+#include <mutex>
+#include <cv_bridge/cv_bridge.h>
+#include <dynamic_reconfigure/server.h>
+#include <nodelet/nodelet.h>
+#include <ros/ros.h>
+#include <sensor_msgs/CameraInfo.h>
+#include <sensor_msgs/Image.h>
+#include <image_transport/image_transport.h>
+
+#include "image_proc/ResizeConfig.h"
+
+namespace image_proc
+{
+class ResizeNodelet : public nodelet::Nodelet
+{
+protected:
+  // ROS communication
+  std::shared_ptr<ros::NodeHandle> nh_;
+  std::shared_ptr<ros::NodeHandle> pnh_;
+  image_transport::Publisher pub_image_;
+  ros::Publisher pub_info_;
+  image_transport::Subscriber sub_image_;
+  ros::Subscriber sub_info_;
+
+  std::shared_ptr<image_transport::ImageTransport> it_, private_it_;
+  std::mutex connect_mutex_;
+
+  // Dynamic reconfigure
+  std::mutex config_mutex_;
+  typedef image_proc::ResizeConfig Config;
+  typedef dynamic_reconfigure::Server<Config> ReconfigureServer;
+  std::shared_ptr<ReconfigureServer> reconfigure_server_;
+  Config config_;
+  cv_bridge::CvImage scaled_cv_;
+
+  virtual void onInit();
+  void connectCb();
+
+  void imageCb(const sensor_msgs::ImageConstPtr& image_msg);
+  void infoCb(const sensor_msgs::CameraInfoConstPtr& info_msg);
+
+  void configCb(Config& config, uint32_t level);
+};
+
+void ResizeNodelet::onInit()
+{
+  nh_.reset(new ros::NodeHandle(getNodeHandle()));
+  pnh_.reset(new ros::NodeHandle(getPrivateNodeHandle()));
+  it_.reset(new image_transport::ImageTransport(*nh_));
+  private_it_.reset(new image_transport::ImageTransport(*pnh_));
+
+  // Set up dynamic reconfigure
+  reconfigure_server_.reset(new ReconfigureServer(*pnh_));
+  ReconfigureServer::CallbackType f =
+      std::bind(&ResizeNodelet::configCb, this, std::placeholders::_1, std::placeholders::_2);
+  reconfigure_server_->setCallback(f);
+
+  // Monitor whether anyone is subscribed to the output
+  auto connect_cb = std::bind(&ResizeNodelet::connectCb, this);
+  // Make sure we don't enter connectCb() between advertising and assigning to
+  // pub_XXX
+  std::lock_guard<std::mutex> lock(connect_mutex_);
+  pub_image_ = private_it_->advertise("image", 1, connect_cb, connect_cb);
+  pub_info_ = pnh_->advertise<sensor_msgs::CameraInfo>("camera_info", 1, connect_cb, connect_cb);
+}
+
+// Handles (un)subscribing when clients (un)subscribe
+void ResizeNodelet::connectCb()
+{
+  std::lock_guard<std::mutex> lock(connect_mutex_);
+  if (pub_image_.getNumSubscribers() == 0)
+  {
+    sub_image_.shutdown();
+  }
+  else if (!sub_image_)
+  {
+    sub_image_ = it_->subscribe("image", 1, &ResizeNodelet::imageCb, this);
+  }
+  if (pub_info_.getNumSubscribers() == 0)
+  {
+    sub_info_.shutdown();
+  }
+  else if (!sub_info_)
+  {
+    sub_info_ = nh_->subscribe<sensor_msgs::CameraInfo>("camera_info", 1, &ResizeNodelet::infoCb, this);
+  }
+}
+
+void ResizeNodelet::configCb(Config& config, uint32_t level)
+{
+  std::lock_guard<std::mutex> lock(config_mutex_);
+  config_ = config;
+}
+
+void ResizeNodelet::infoCb(const sensor_msgs::CameraInfoConstPtr& info_msg)
+{
+  Config config;
+  {
+    std::lock_guard<std::mutex> lock(config_mutex_);
+    config = config_;
+  }
+
+  sensor_msgs::CameraInfoPtr dst_info_msg(new sensor_msgs::CameraInfo(*info_msg));
+
+  double scale_y;
+  double scale_x;
+  if (config.use_scale)
+  {
+    scale_y = config.scale_height;
+    scale_x = config.scale_width;
+    dst_info_msg->height = static_cast<int>(info_msg->height * config.scale_height);
+    dst_info_msg->width = static_cast<int>(info_msg->width * config.scale_width);
+  }
+  else
+  {
+    scale_y = static_cast<double>(config.height) / info_msg->height;
+    scale_x = static_cast<double>(config.width) / info_msg->width;
+    dst_info_msg->height = config.height;
+    dst_info_msg->width = config.width;
+  }
+
+  dst_info_msg->K[0] = dst_info_msg->K[0] * scale_x;  // fx
+  dst_info_msg->K[2] = dst_info_msg->K[2] * scale_x;  // cx
+  dst_info_msg->K[4] = dst_info_msg->K[4] * scale_y;  // fy
+  dst_info_msg->K[5] = dst_info_msg->K[5] * scale_y;  // cy
+
+  dst_info_msg->P[0] = dst_info_msg->P[0] * scale_x;  // fx
+  dst_info_msg->P[2] = dst_info_msg->P[2] * scale_x;  // cx
+  dst_info_msg->P[3] = dst_info_msg->P[3] * scale_x;  // T
+  dst_info_msg->P[5] = dst_info_msg->P[5] * scale_y;  // fy
+  dst_info_msg->P[6] = dst_info_msg->P[6] * scale_y;  // cy
+
+  dst_info_msg->roi.x_offset = static_cast<int>(dst_info_msg->roi.x_offset * scale_x);
+  dst_info_msg->roi.y_offset = static_cast<int>(dst_info_msg->roi.y_offset * scale_y);
+  dst_info_msg->roi.width = static_cast<int>(dst_info_msg->roi.width * scale_x);
+  dst_info_msg->roi.height = static_cast<int>(dst_info_msg->roi.height * scale_y);
+
+  pub_info_.publish(dst_info_msg);
+}
+
+void ResizeNodelet::imageCb(const sensor_msgs::ImageConstPtr& image_msg)
+{
+  Config config;
+  {
+    std::lock_guard<std::mutex> lock(config_mutex_);
+    config = config_;
+  }
+
+  cv_bridge::CvImageConstPtr cv_ptr;
+  try
+  {
+    cv_ptr = cv_bridge::toCvShare(image_msg);
+  }
+  catch (cv_bridge::Exception& e)
+  {
+    ROS_ERROR("cv_bridge exception: %s", e.what());
+    return;
+  }
+
+  if (config.use_scale)
+  {
+    cv::resize(cv_ptr->image, scaled_cv_.image, cv::Size(0, 0), config.scale_width, config.scale_height,
+               config.interpolation);
+  }
+  else
+  {
+    int height = config.height == -1 ? image_msg->height : config.height;
+    int width = config.width == -1 ? image_msg->width : config.width;
+    cv::resize(cv_ptr->image, scaled_cv_.image, cv::Size(width, height), 0, 0, config.interpolation);
+  }
+
+  scaled_cv_.header = image_msg->header;
+  scaled_cv_.encoding = image_msg->encoding;
+  pub_image_.publish(scaled_cv_.toImageMsg());
+}
+
+}  // namespace image_proc
+
+#include <pluginlib/class_list_macros.hpp>
+PLUGINLIB_EXPORT_CLASS(image_proc::ResizeNodelet, nodelet::Nodelet)
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/src/nodes/image_proc.cpp
@@ -0,0 +1,97 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2008, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#include <ros/ros.h>
+#include <nodelet/loader.h>
+#include <image_proc/advertisement_checker.h>
+
+int main(int argc, char **argv)
+{
+  ros::init(argc, argv, "image_proc");
+
+  // Check for common user errors
+  if (ros::names::remap("camera") != "camera")
+  {
+    ROS_WARN("Remapping 'camera' has no effect! Start image_proc in the "
+             "camera namespace instead.\nExample command-line usage:\n"
+             "\t$ ROS_NAMESPACE=%s rosrun image_proc image_proc",
+             ros::names::remap("camera").c_str());
+  }
+  if (ros::this_node::getNamespace() == "/")
+  {
+    ROS_WARN("Started in the global namespace! This is probably wrong. Start image_proc "
+             "in the camera namespace.\nExample command-line usage:\n"
+             "\t$ ROS_NAMESPACE=my_camera rosrun image_proc image_proc");
+  }
+
+  // Shared parameters to be propagated to nodelet private namespaces
+  ros::NodeHandle private_nh("~");
+  XmlRpc::XmlRpcValue shared_params;
+  int queue_size;
+  if (private_nh.getParam("queue_size", queue_size))
+    shared_params["queue_size"] = queue_size;
+
+  nodelet::Loader manager(false); // Don't bring up the manager ROS API
+  nodelet::M_string remappings;
+  nodelet::V_string my_argv;
+
+  // Debayer nodelet, image_raw -> image_mono, image_color
+  std::string debayer_name = ros::this_node::getName() + "_debayer";
+  manager.load(debayer_name, "image_proc/debayer", remappings, my_argv);
+
+  // Rectify nodelet, image_mono -> image_rect
+  std::string rectify_mono_name = ros::this_node::getName() + "_rectify_mono";
+  if (shared_params.valid())
+    ros::param::set(rectify_mono_name, shared_params);
+  manager.load(rectify_mono_name, "image_proc/rectify", remappings, my_argv);
+
+  // Rectify nodelet, image_color -> image_rect_color
+  // NOTE: Explicitly resolve any global remappings here, so they don't get hidden.
+  remappings["image_mono"] = ros::names::resolve("image_color");
+  remappings["image_rect"] = ros::names::resolve("image_rect_color");
+  std::string rectify_color_name = ros::this_node::getName() + "_rectify_color";
+  if (shared_params.valid())
+    ros::param::set(rectify_color_name, shared_params);
+  manager.load(rectify_color_name, "image_proc/rectify", remappings, my_argv);
+
+  // Check for only the original camera topics
+  ros::V_string topics;
+  topics.push_back(ros::names::resolve("image_raw"));
+  topics.push_back(ros::names::resolve("camera_info"));
+  image_proc::AdvertisementChecker check_inputs(ros::NodeHandle(), ros::this_node::getName());
+  check_inputs.start(topics, 60.0);
+  
+  ros::spin();
+  return 0;
+}
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/test/CMakeLists.txt
@@ -0,0 +1,7 @@
+find_package(rostest REQUIRED)
+find_package(catkin REQUIRED camera_calibration_parsers image_transport cv_bridge)
+#catkin_add_gtest(image_proc_rostest rostest.cpp)
+#target_link_libraries(image_proc_rostest ${catkin_LIBRARIES}  ${Boost_LIBRARIES})
+include_directories(${catkin_INCLUDE_DIRS} ${OpenCV_INCLUDE_DIRS})
+add_rostest_gtest(image_proc_test_rectify test_rectify.xml test_rectify.cpp)
+target_link_libraries(image_proc_test_rectify ${catkin_LIBRARIES})
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/test/rostest.cpp
@@ -0,0 +1,99 @@
+#include <ros/ros.h>
+#include <gtest/gtest.h>
+#include <camera_calibration_parsers/parse.h>
+#include <cv_bridge/cv_bridge.h>
+#include <opencv2/highgui/highgui.hpp>
+#include <image_transport/image_transport.h>
+
+#include <boost/foreach.hpp>
+
+class ImageProcTest : public testing::Test
+{
+protected:
+  virtual void SetUp()
+  {
+    ros::NodeHandle local_nh("~");
+
+    // Determine topic names
+    std::string camera_ns = nh.resolveName("camera") + "/";
+    if (camera_ns == "/camera")
+      throw "Must remap 'camera' to the camera namespace.";
+    topic_raw        = camera_ns + "image_raw";
+    topic_mono       = camera_ns + "image_mono";
+    topic_rect       = camera_ns + "image_rect";
+    topic_color      = camera_ns + "image_color";
+    topic_rect_color = camera_ns + "image_rect_color";
+
+    // Load raw image and cam info
+    /// @todo Make these cmd-line args instead?
+    std::string raw_image_file, cam_info_file;
+    if (!local_nh.getParam("raw_image_file", raw_image_file))
+      throw "Must set parameter ~raw_image_file.";
+    if (!local_nh.getParam("camera_info_file", cam_info_file))
+      throw "Must set parameter ~camera_info_file.";
+
+    /// @todo Test variety of encodings for raw image (bayer, mono, color)
+    cv::Mat img = cv::imread(raw_image_file, 0);
+    raw_image = cv_bridge::CvImage(std_msgs::Header(), "mono8", img).toImageMsg();
+    std::string cam_name;
+    if (!camera_calibration_parsers::readCalibration(cam_info_file, cam_name, cam_info))
+      throw "Failed to read camera info file.";
+
+    // Create raw camera publisher
+    image_transport::ImageTransport it(nh);
+    cam_pub = it.advertiseCamera(topic_raw, 1);
+
+    // Wait for image_proc to be operational
+    ros::master::V_TopicInfo topics;
+    while (true) {
+      if (ros::master::getTopics(topics)) {
+        BOOST_FOREACH(ros::master::TopicInfo& topic, topics) {
+          if (topic.name == topic_rect_color)
+            return;
+        }
+      }
+      ros::Duration(0.5).sleep();
+    }
+  }
+
+  ros::NodeHandle nh;
+  std::string topic_raw;
+  std::string topic_mono;
+  std::string topic_rect;
+  std::string topic_color;
+  std::string topic_rect_color;
+
+  sensor_msgs::ImagePtr raw_image;
+  sensor_msgs::CameraInfo cam_info;
+  image_transport::CameraPublisher cam_pub;
+
+  void publishRaw()
+  {
+    cam_pub.publish(*raw_image, cam_info);
+  }
+};
+
+void callback(const sensor_msgs::ImageConstPtr& msg)
+{
+  ROS_FATAL("Got an image");
+  ros::shutdown();
+}
+
+TEST_F(ImageProcTest, monoSubscription)
+{
+  ROS_INFO("In test. Subscribing.");
+  ros::Subscriber mono_sub = nh.subscribe(topic_mono, 1, callback);
+  ROS_INFO("Publishing.");
+  publishRaw();
+
+  ROS_INFO("Spinning.");
+  ros::spin();
+  ROS_INFO("Done.");
+}
+
+int main(int argc, char** argv)
+{
+  ros::init(argc, argv, "imageproc_rostest");
+  testing::InitGoogleTest(&argc, argv);
+  return RUN_ALL_TESTS();
+}
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/test/test_bayer.xml
@@ -0,0 +1,10 @@
+<launch>
+  <node name="forearm_image_proc" pkg="image_proc" type="image_proc">
+    <remap from="camera" to="/forearm_camera_r"/>
+  </node>
+  <test test-name="test_bayer" pkg="image_proc" type="image_proc_rostest">
+    <remap from="camera" to="/forearm_camera_r"/>
+    <param name="raw_image_file" value="/u/mihelich/ros/vision_opencv/image_geometry/test/forearm_screenshot_3.png" />
+    <param name="camera_info_file" value="/u/mihelich/ros/vision_opencv/image_geometry/test/forearm.ini" />
+  </test>
+</launch>
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/test/test_rectify.cpp
@@ -0,0 +1,205 @@
+#include <ros/ros.h>
+#include <gtest/gtest.h>
+#include <camera_calibration_parsers/parse.h>
+#include <cv_bridge/cv_bridge.h>
+#include <opencv2/highgui/highgui.hpp>
+#include <image_transport/image_transport.h>
+#include <sensor_msgs/CameraInfo.h>
+#include <sensor_msgs/distortion_models.h>
+
+class ImageProcRectifyTest : public testing::Test
+{
+protected:
+  virtual void SetUp()
+  {
+    // Determine topic names
+    std::string camera_ns = nh_.resolveName("camera") + "/";
+    if (camera_ns == "/camera")
+      throw "Must remap 'camera' to the camera namespace.";
+    topic_raw_        = camera_ns + "image_raw";
+    topic_mono_       = camera_ns + "image_mono";
+    topic_rect_       = camera_ns + "image_rect";
+    topic_color_      = camera_ns + "image_color";
+    topic_rect_color_ = camera_ns + "image_rect_color";
+
+    // Taken from vision_opencv/image_geometry/test/utest.cpp
+    double D[] = {-0.363528858080088, 0.16117037733986861, -8.1109585007538829e-05, -0.00044776712298447841, 0.0};
+    double K[] = {430.15433020105519,                0.0, 311.71339830549732,
+                                 0.0, 430.60920415473657, 221.06824942698509,
+                                 0.0,                0.0,                1.0};
+    double R[] = {0.99806560714807102, 0.0068562422224214027, 0.061790256276695904,
+                  -0.0067522959054715113, 0.99997541519165112, -0.0018909025066874664,
+                  -0.061801701660692349, 0.0014700186639396652, 0.99808736527268516};
+    double P[] = {295.53402059708782, 0.0, 285.55760765075684, 0.0,
+                  0.0, 295.53402059708782, 223.29617881774902, 0.0,
+                  0.0, 0.0, 1.0, 0.0};
+
+    cam_info_.header.frame_id = "tf_frame";
+    cam_info_.height = 480;
+    cam_info_.width  = 640;
+    // No ROI
+    cam_info_.D.resize(5);
+    std::copy(D, D+5, cam_info_.D.begin());
+    std::copy(K, K+9, cam_info_.K.begin());
+    std::copy(R, R+9, cam_info_.R.begin());
+    std::copy(P, P+12, cam_info_.P.begin());
+    cam_info_.distortion_model = sensor_msgs::distortion_models::PLUMB_BOB;
+
+    distorted_image_ = cv::Mat(cv::Size(cam_info_.width, cam_info_.height), CV_8UC3);
+    // draw a grid
+    const cv::Scalar color = cv::Scalar(255, 255, 255);
+    // draw the lines thick so the proportion of error due to
+    // interpolation is reduced
+    const int thickness = 7;
+    const int type = 8;
+    for (size_t y = 0; y <= cam_info_.height; y += cam_info_.height/10)
+    {
+      cv::line(distorted_image_,
+               cv::Point(0, y), cv::Point(cam_info_.width, y),
+               color, type, thickness);
+    }
+    for (size_t x = 0; x <= cam_info_.width; x += cam_info_.width/10)
+    {
+      // draw the lines thick so the prorportion of interpolation error is reduced
+      cv::line(distorted_image_,
+               cv::Point(x, 0), cv::Point(x, cam_info_.height),
+               color, type, thickness);
+    }
+
+    raw_image_ = cv_bridge::CvImage(std_msgs::Header(), "bgr8",
+                                    distorted_image_).toImageMsg();
+
+    // Create raw camera subscriber and publisher
+    image_transport::ImageTransport it(nh_);
+    cam_pub_ = it.advertiseCamera(topic_raw_, 1);
+  }
+
+  ros::NodeHandle nh_;
+  std::string topic_raw_;
+  std::string topic_mono_;
+  std::string topic_rect_;
+  std::string topic_color_;
+  std::string topic_rect_color_;
+
+  cv::Mat distorted_image_;
+  sensor_msgs::ImagePtr raw_image_;
+  bool has_new_image_;
+  cv::Mat received_image_;
+  sensor_msgs::CameraInfo cam_info_;
+  image_transport::CameraPublisher cam_pub_;
+  image_transport::Subscriber cam_sub_;
+
+public:
+  void imageCallback(const sensor_msgs::ImageConstPtr& msg)
+  {
+    cv_bridge::CvImageConstPtr cv_ptr;
+    try
+    {
+      cv_ptr = cv_bridge::toCvShare(msg, sensor_msgs::image_encodings::BGR8);
+    }
+    catch (cv_bridge::Exception& e)
+    {
+      ROS_FATAL("cv_bridge exception: %s", e.what());
+      return;
+    }
+    received_image_ = cv_ptr->image.clone();
+    has_new_image_ = true;
+  }
+
+  void publishRaw()
+  {
+    has_new_image_ = false;
+    cam_pub_.publish(*raw_image_, cam_info_);
+  }
+};
+
+TEST_F(ImageProcRectifyTest, rectifyTest)
+{
+  ROS_INFO("In test. Subscribing.");
+  image_transport::ImageTransport it(nh_);
+  cam_sub_ = it.subscribe(topic_rect_, 1, &ImageProcRectifyTest::imageCallback,
+                          dynamic_cast<ImageProcRectifyTest*>(this));
+  // Wait for image_proc to be operational
+  bool wait_for_topic = true;
+  while (wait_for_topic)
+  {
+    // @todo this fails without the additional 0.5 second sleep after the
+    // publisher comes online, which means on a slower or more heavily
+    // loaded system it may take longer than 0.5 seconds, and the test
+    // would hang until the timeout is reached and fail.
+    if (cam_sub_.getNumPublishers() > 0)
+       wait_for_topic = false;
+    ros::Duration(0.5).sleep();
+  }
+
+  // All the tests are the same as from 
+  // vision_opencv/image_geometry/test/utest.cpp
+  // default cam info
+
+  // Just making this number up, maybe ought to be larger
+  // since a completely different image would be on the order of
+  // width * height * 255 = 78e6
+  const double diff_threshold = 10000.0;
+  double error;
+
+  // use original cam_info
+  publishRaw();
+  while (!has_new_image_)
+  {
+    ros::spinOnce();
+    ros::Duration(0.5).sleep();
+  }
+  // Test that rectified image is sufficiently different
+  // using default distortion
+  error = cv::norm(distorted_image_, received_image_, cv::NORM_L1);
+  // Just making this number up, maybe ought to be larger
+  EXPECT_GT(error, diff_threshold);
+
+  // Test that rectified image is sufficiently different
+  // using default distortion but with first element zeroed
+  // out.
+  sensor_msgs::CameraInfo cam_info_orig = cam_info_;
+  cam_info_.D[0] = 0.0;
+  publishRaw();
+  while (!has_new_image_)
+  {
+    ros::spinOnce();
+    ros::Duration(0.5).sleep();
+  }
+  error = cv::norm(distorted_image_, received_image_, cv::NORM_L1);
+  EXPECT_GT(error, diff_threshold);
+
+  // Test that rectified image is the same using zero distortion
+  cam_info_.D.assign(cam_info_.D.size(), 0);
+  publishRaw();
+  while (!has_new_image_)
+  {
+    ros::spinOnce();
+    ros::Duration(0.5).sleep();
+  }
+  error = cv::norm(distorted_image_, received_image_, cv::NORM_L1);
+  EXPECT_EQ(error, 0);
+
+
+  // Test that rectified image is the same using empty distortion
+  cam_info_.D.clear();
+  publishRaw();
+  while (!has_new_image_)
+  {
+    ros::spinOnce();
+    ros::Duration(0.5).sleep();
+  }
+  error = cv::norm(distorted_image_, received_image_, cv::NORM_L1);
+
+  EXPECT_EQ(error, 0);
+
+  // restore the original cam_info for other tests added in the future
+  cam_info_ = cam_info_orig;
+}
+
+int main(int argc, char** argv)
+{
+  ros::init(argc, argv, "image_proc_test_rectify");
+  testing::InitGoogleTest(&argc, argv);
+  return RUN_ALL_TESTS();
+}
--- /dev/null
+++ ros-noetic-image-proc-1.17.0/test/test_rectify.xml
@@ -0,0 +1,9 @@
+<launch>
+  <group ns="camera">
+  <node name="rectify_image_proc" pkg="image_proc" type="image_proc"
+      output="screen">
+  </node>
+  </group>
+  <test test-name="image_proc_test_rectify" pkg="image_proc" type="image_proc_test_rectify">
+  </test>
+</launch>
