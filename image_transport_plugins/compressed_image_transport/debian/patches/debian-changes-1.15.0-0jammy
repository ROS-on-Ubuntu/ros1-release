Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ros-noetic-compressed-image-transport (1.15.0-0jammy) jammy; urgency=high
 .
   * Update maintainer in ros1 branches (#132 <https://github.com/ros-perception/image_transport_plugins/issues/132>)
   * Fix number of elements in vector parameter to call cv::imencode for OpenCV 4.7 (#130 <https://github.com/ros-perception/image_transport_plugins/issues/130>)
   * Performance optimizations for JPEG decompression (#60 <https://github.com/ros-perception/image_transport_plugins/issues/60>)
   * Fix copyright year 20012 -> 2012 (#80 <https://github.com/ros-perception/image_transport_plugins/issues/80>)
   * Add a basic loopback unit test (#61 <https://github.com/ros-perception/image_transport_plugins/issues/61>)
   * Contributors: Johannes Meyer, Kenji Brameld, Lucas Walter, Max Schwarz, Michael Carroll, ijnek, v4hn
Author: Kenji Brameld <kenjibrameld@gmail.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2024-08-18

--- /dev/null
+++ ros-noetic-compressed-image-transport-1.15.0/CHANGELOG.rst
@@ -0,0 +1,173 @@
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Changelog for package compressed_image_transport
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+1.15.0 (2023-01-30)
+-------------------
+* Update maintainer in ros1 branches (`#132 <https://github.com/ros-perception/image_transport_plugins/issues/132>`_)
+* Fix number of elements in vector parameter to call cv::imencode for OpenCV 4.7 (`#130 <https://github.com/ros-perception/image_transport_plugins/issues/130>`_)
+* Performance optimizations for JPEG decompression (`#60 <https://github.com/ros-perception/image_transport_plugins/issues/60>`_)
+* Fix copyright year 20012 -> 2012 (`#80 <https://github.com/ros-perception/image_transport_plugins/issues/80>`_)
+* Add a basic loopback unit test (`#61 <https://github.com/ros-perception/image_transport_plugins/issues/61>`_)
+* Contributors: Johannes Meyer, Kenji Brameld, Lucas Walter, Max Schwarz, Michael Carroll, ijnek, v4hn
+
+1.14.0 (2020-05-14)
+-------------------
+* Bump CMake version to avoid CMP0048 warning (`#53 <https://github.com/ros-perception/image_transport_plugins/issues/53>`_)
+* add params for jpeg compression `#35 <https://github.com/ros-perception/image_transport_plugins/issues/35>`_
+* fixed warning when resubscribing `#25 <https://github.com/ros-perception/image_transport_plugins/issues/25>`_
+* Fix binary install locations for Windows build `#34 <https://github.com/ros-perception/image_transport_plugins/issues/34>`_
+* Add legacy constants when using opencv4 `#32 <https://github.com/ros-perception/image_transport_plugins/issues/32>`_
+* fixed warning 'Tried to advertise a service that is already advertised in this node'
+* Contributors: Alejandro Hernández Cordero, David Gossow, Hans Gaiser, Sean Yen, Till Grenzdörffer, Yuki Furuta
+
+1.9.5 (2016-10-03)
+------------------
+
+1.9.4 (2016-10-02)
+------------------
+* address gcc6 build error and tune
+  With gcc6, compiling fails with 'stdlib.h: No such file or directory',
+  as including '-isystem /usr/include' breaks with gcc6, cf.,
+  https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70129.
+  This commit addresses this issue for this package in the same way
+  it was addressed in various other ROS packages. A list of related
+  commits and pull requests is at:
+  https://github.com/ros/rosdistro/issues/12783
+  Signed-off-by: Lukas Bulwahn <lukas.bulwahn@oss.bmw-carit.de>
+* Contributors: Lukas Bulwahn
+
+1.9.3 (2016-01-17)
+------------------
+* remove useless tf dependencies
+* Using cfg-defined constants
+* Changed flag name, and corrected typo in flag use.
+* using IMREAD flags.
+* Updated for indigo-devel
+* Contributors: Cedric Pradalier, Vincent Rabaud
+
+1.9.2 (2015-04-25)
+------------------
+* get code to compile with OpenCV3
+* avoid yet another image copy
+* avoid copying data if it can be shared
+* Contributors: Vincent Rabaud
+
+1.9.1 (2014-07-18)
+------------------
+
+1.9.0 (2014-05-16)
+------------------
+
+1.8.21 (2013-06-27)
+-------------------
+* maintainer: david gossow
+* Contributors: David Gossow
+
+1.8.20 (2013-03-18)
+-------------------
+* 1.8.19 -> 1.8.20
+* Contributors: Julius Kammerl
+
+1.8.19 (2013-02-24)
+-------------------
+* 1.8.18 -> 1.8.19
+* Contributors: Julius Kammerl
+
+1.8.18 (2013-02-07 17:59)
+-------------------------
+* 1.8.17 -> 1.8.18
+* fixing input format checks (enabling rgba, bgra) + minor fixes
+* Contributors: Julius Kammerl
+
+1.8.17 (2013-01-18)
+-------------------
+* 1.8.16 -> 1.8.17
+* Contributors: Julius Kammerl
+
+1.8.16 (2013-01-17)
+-------------------
+* 1.8.15 -> 1.8.16
+* use the pluginlib script to remove some runtime warnings
+* Contributors: Julius Kammerl, Vincent Rabaud
+
+1.8.15 (2012-12-28 20:11)
+-------------------------
+* fix typo
+* Contributors: Vincent Rabaud
+
+1.8.14 (2012-12-28 20:02)
+-------------------------
+* fix the bad xml naming
+* Contributors: Vincent Rabaud
+
+1.8.13 (2012-12-28 19:06)
+-------------------------
+* fix the bad exports
+* make sure the plugins are visible by image_transport
+* added license headers to various cpp and h files
+* Contributors: Aaron Blasdel, Vincent Rabaud
+
+1.8.12 (2012-12-19 19:30)
+-------------------------
+* fix downstream stuff in cmake
+* Contributors: Dirk Thomas
+
+1.8.11 (2012-12-19 17:17)
+-------------------------
+* fix cmake order
+* Contributors: Dirk Thomas
+
+1.8.10 (2012-12-19 17:03)
+-------------------------
+* fix dyn reconf
+* Contributors: Dirk Thomas
+
+1.8.9 (2012-12-19 00:26)
+------------------------
+* switching to verion 1.8.9
+* fixing dynamic_reconfigure related catkin errors
+* Contributors: Julius Kammerl
+
+1.8.8 (2012-12-17)
+------------------
+* adding build_deb on message_generation & mrun_deb on message_runtime
+* Updated package.xml for new buildtool_depend tag for catkin requirement
+* Contributors: Julius Kammerl, mirzashah
+
+1.8.7 (2012-12-10 15:29)
+------------------------
+* adding missing tf build dependency
+* Contributors: Julius Kammerl
+
+1.8.6 (2012-12-10 15:08)
+------------------------
+* switching to version 1.8.6
+* Contributors: Julius Kammerl
+
+1.8.5 (2012-12-09)
+------------------
+* adding missing build debs
+* added class_loader_hide_library_symbols macros to CMakeList
+* switching to 1.8.5
+* fixing compressed color format to comply with opencv api
+* Contributors: Julius Kammerl
+
+1.8.4 (2012-11-30)
+------------------
+* switching to version 1.8.4
+* adding plugin.xml exports for pluginlib
+* catkinizing theora_image_transport
+* github migration from code.ros.org (r40053)
+* image_transport_plugins: Updated manifests to have better summaries, correct URLs.
+* compressed_image_transport: Some todos.
+* compressed_image_transport: Copy connection header to output Image, `#4250 <https://github.com/ros-perception/image_transport_plugins/issues/4250>`_.
+* Added Ubuntu platform tags to manifest
+* compressed_image_transport: Fixed swapping of R & B channels in data field.
+* compressed_image_transport: Fixed bug in lookup of format parameter.
+* getParam -> getParamCached
+* Switch to opencv2
+* compressed_image_transport: Renamed parameters, which are now searched up the parameter tree.
+* compressed_image_transport: Updated for compatibility with post-0.1 image_transport.
+* image_transport_plugins: Initial stack check-in. Includes theora_image_transport, compressed_image_transport and libtheora. Currently depends on opencv, but may excise this in the future.
+* Contributors: Julius Kammerl, gerkey, jamesb, mihelich, pmihelich
--- /dev/null
+++ ros-noetic-compressed-image-transport-1.15.0/CMakeLists.txt
@@ -0,0 +1,46 @@
+cmake_minimum_required(VERSION 3.0.2)
+project(compressed_image_transport)
+
+find_package(OpenCV REQUIRED)
+find_package(catkin REQUIRED COMPONENTS cv_bridge dynamic_reconfigure image_transport)
+
+find_package(PkgConfig REQUIRED)
+pkg_check_modules(TurboJPEG REQUIRED libturbojpeg)
+
+# generate the dynamic_reconfigure config file
+generate_dynamic_reconfigure_options(cfg/CompressedPublisher.cfg cfg/CompressedSubscriber.cfg)
+
+catkin_package(
+  INCLUDE_DIRS include
+  LIBRARIES ${PROJECT_NAME}
+  CATKIN_DEPENDS cv_bridge dynamic_reconfigure image_transport
+  DEPENDS OpenCV
+)
+
+include_directories(include ${catkin_INCLUDE_DIRS} ${OpenCV_INCLUDE_DIRS} ${TurboJPEG_INCLUDE_DIRS})
+
+add_library(${PROJECT_NAME} src/compressed_publisher.cpp src/compressed_subscriber.cpp src/manifest.cpp)
+add_dependencies(${PROJECT_NAME} ${PROJECT_NAME}_gencfg)
+target_link_libraries(${PROJECT_NAME} ${catkin_LIBRARIES} ${OpenCV_LIBRARIES} ${TurboJPEG_LIBRARIES})
+
+class_loader_hide_library_symbols(${PROJECT_NAME})
+
+install(TARGETS ${PROJECT_NAME}
+  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION}
+)
+install(DIRECTORY include/${PROJECT_NAME}/
+  DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
+)
+
+# add xml file
+install(FILES compressed_plugins.xml
+        DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}
+)
+
+if(CATKIN_ENABLE_TESTING)
+  find_package(rostest REQUIRED)
+  add_rostest_gtest(basic_test test/basic.test test/basic.cpp)
+  target_link_libraries(basic_test ${catkin_LIBRARIES})
+endif()
--- /dev/null
+++ ros-noetic-compressed-image-transport-1.15.0/cfg/CompressedPublisher.cfg
@@ -0,0 +1,19 @@
+#! /usr/bin/env python
+
+PACKAGE='compressed_image_transport'
+
+from dynamic_reconfigure.parameter_generator_catkin import *
+
+gen = ParameterGenerator()
+
+format_enum = gen.enum( [gen.const("jpeg", str_t, "jpeg", "JPEG lossy compression"),
+                         gen.const("png", str_t, "png", "PNG lossless compression")],
+                        "Enum to set the compression format" )
+gen.add("format", str_t, 0, "Compression format", "jpeg", edit_method = format_enum)
+gen.add("jpeg_quality", int_t, 0, "JPEG quality percentile", 80, 1, 100)
+gen.add("jpeg_progressive", bool_t, 0, "Enable compression to progressive JPEG", False)
+gen.add("jpeg_optimize", bool_t, 0, "Enable JPEG compress optimization", False)
+gen.add("jpeg_restart_interval", int_t, 0, "JPEG restart interval", 0, 0, 65535)
+gen.add("png_level", int_t, 0, "PNG compression level", 9, 1, 9)
+
+exit(gen.generate(PACKAGE, "CompressedPublisher", "CompressedPublisher"))
--- /dev/null
+++ ros-noetic-compressed-image-transport-1.15.0/cfg/CompressedSubscriber.cfg
@@ -0,0 +1,15 @@
+#! /usr/bin/env python
+
+PACKAGE='compressed_image_transport'
+
+from dynamic_reconfigure.parameter_generator_catkin import *
+
+gen = ParameterGenerator()
+
+mode_enum = gen.enum( [gen.const("unchanged", str_t, "unchanged", "keep image encoding"),
+                         gen.const("gray", str_t, "gray", "decode to gray"),
+                         gen.const("color", str_t, "color", "decode to color")],
+                        "Enum to set the decompression color mode" )
+gen.add("mode", str_t, 0, "Color Mode", "unchanged", edit_method = mode_enum)
+
+exit(gen.generate(PACKAGE, "CompressedSubscriber", "CompressedSubscriber"))
--- /dev/null
+++ ros-noetic-compressed-image-transport-1.15.0/compressed_plugins.xml
@@ -0,0 +1,13 @@
+<library path="lib/libcompressed_image_transport">
+  <class name="image_transport/compressed_pub" type="compressed_image_transport::CompressedPublisher" base_class_type="image_transport::PublisherPlugin">
+    <description>
+      This plugin publishes a CompressedImage using either JPEG or PNG compression.
+    </description>
+  </class>
+
+  <class name="image_transport/compressed_sub" type="compressed_image_transport::CompressedSubscriber" base_class_type="image_transport::SubscriberPlugin">
+    <description>
+      This plugin decompresses a CompressedImage topic.
+    </description>
+  </class>
+</library>
--- /dev/null
+++ ros-noetic-compressed-image-transport-1.15.0/include/compressed_image_transport/compressed_publisher.h
@@ -0,0 +1,70 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2012, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#include "image_transport/simple_publisher_plugin.h"
+#include <sensor_msgs/CompressedImage.h>
+#include <dynamic_reconfigure/server.h>
+#include <compressed_image_transport/CompressedPublisherConfig.h>
+
+namespace compressed_image_transport {
+
+class CompressedPublisher : public image_transport::SimplePublisherPlugin<sensor_msgs::CompressedImage>
+{
+public:
+  virtual ~CompressedPublisher() {}
+
+  virtual std::string getTransportName() const
+  {
+    return "compressed";
+  }
+
+protected:
+  // Overridden to set up reconfigure server
+  virtual void advertiseImpl(ros::NodeHandle &nh, const std::string &base_topic, uint32_t queue_size,
+                             const image_transport::SubscriberStatusCallback  &user_connect_cb,
+                             const image_transport::SubscriberStatusCallback  &user_disconnect_cb,
+                             const ros::VoidPtr &tracked_object, bool latch);
+  
+  virtual void publish(const sensor_msgs::Image& message,
+                       const PublishFn& publish_fn) const;
+
+  typedef compressed_image_transport::CompressedPublisherConfig Config;
+  typedef dynamic_reconfigure::Server<Config> ReconfigureServer;
+  boost::shared_ptr<ReconfigureServer> reconfigure_server_;
+  Config config_;
+
+  void configCb(Config& config, uint32_t level);
+};
+
+} //namespace compressed_image_transport
--- /dev/null
+++ ros-noetic-compressed-image-transport-1.15.0/include/compressed_image_transport/compressed_subscriber.h
@@ -0,0 +1,79 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2012, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#include "image_transport/simple_subscriber_plugin.h"
+#include <sensor_msgs/CompressedImage.h>
+#include <dynamic_reconfigure/server.h>
+#include <compressed_image_transport/CompressedSubscriberConfig.h>
+
+#include <turbojpeg.h>
+
+namespace compressed_image_transport {
+
+class CompressedSubscriber : public image_transport::SimpleSubscriberPlugin<sensor_msgs::CompressedImage>
+{
+public:
+  CompressedSubscriber();
+  virtual ~CompressedSubscriber();
+
+  virtual std::string getTransportName() const
+  {
+    return "compressed";
+  }
+
+  virtual void shutdown();
+
+protected:
+  // Overridden to set up reconfigure server
+  virtual void subscribeImpl(ros::NodeHandle& nh, const std::string& base_topic, uint32_t queue_size,
+          const Callback& callback, const ros::VoidPtr& tracked_object,
+          const image_transport::TransportHints& transport_hints);
+
+
+  virtual void internalCallback(const sensor_msgs::CompressedImageConstPtr& message,
+                                const Callback& user_cb);
+
+  sensor_msgs::ImagePtr decompressJPEG(const std::vector<uint8_t>& data, const std::string& source_encoding, const std_msgs::Header& header);
+
+  typedef compressed_image_transport::CompressedSubscriberConfig Config;
+  typedef dynamic_reconfigure::Server<Config> ReconfigureServer;
+  boost::shared_ptr<ReconfigureServer> reconfigure_server_;
+  Config config_;
+  int imdecode_flag_;
+  tjhandle tj_;
+
+  void configCb(Config& config, uint32_t level);
+};
+
+} //namespace image_transport
--- /dev/null
+++ ros-noetic-compressed-image-transport-1.15.0/include/compressed_image_transport/compression_common.h
@@ -0,0 +1,49 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2012, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#ifndef COMPRESSED_IMAGE_TRANSPORT_COMPRESSION_COMMON
+#define COMPRESSED_IMAGE_TRANSPORT_COMPRESSION_COMMON
+
+namespace compressed_image_transport
+{
+
+// Compression formats
+enum compressionFormat
+{
+  UNDEFINED = -1, JPEG, PNG
+};
+
+} //namespace compressed_image_transport
+
+#endif
--- /dev/null
+++ ros-noetic-compressed-image-transport-1.15.0/package.xml
@@ -0,0 +1,34 @@
+<package format="2">
+  <name>compressed_image_transport</name>
+  <version>1.15.0</version>
+  <description>
+    Compressed_image_transport provides a plugin to image_transport for transparently sending images
+    encoded as JPEG or PNG.
+  </description>
+  <maintainer email="kenjibrameld@gmail.com">Kenji Brameld</maintainer>
+  <license>BSD</license>
+
+  <url type="website">http://www.ros.org/wiki/image_transport_plugins</url>
+  <author>Patrick Mihelich</author>
+  <author>Julius Kammerl</author>
+  <author>David Gossow</author>
+
+  <buildtool_depend>catkin</buildtool_depend>
+
+  <depend>image_transport</depend>
+
+  <build_depend>cv_bridge</build_depend>
+  <build_depend>dynamic_reconfigure</build_depend>
+  <build_depend>libturbojpeg</build_depend>
+
+  <exec_depend>cv_bridge</exec_depend>
+  <exec_depend>dynamic_reconfigure</exec_depend>
+  <exec_depend>libturbojpeg</exec_depend>
+
+  <test_depend>rostest</test_depend>
+
+  <export>
+    <rviz plugin="${prefix}/plugin_description.xml"/>
+    <image_transport plugin="${prefix}/compressed_plugins.xml" />
+  </export>
+</package>
--- /dev/null
+++ ros-noetic-compressed-image-transport-1.15.0/src/compressed_publisher.cpp
@@ -0,0 +1,234 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2012, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#include "compressed_image_transport/compressed_publisher.h"
+#include <cv_bridge/cv_bridge.h>
+#include <sensor_msgs/image_encodings.h>
+#include <opencv2/highgui/highgui.hpp>
+#include <opencv2/imgcodecs.hpp>
+#include <boost/make_shared.hpp>
+
+#include "compressed_image_transport/compression_common.h"
+
+#include <vector>
+#include <sstream>
+
+// If OpenCV4
+#if CV_VERSION_MAJOR > 3
+#include <opencv2/imgcodecs/legacy/constants_c.h>
+#endif
+
+using namespace cv;
+using namespace std;
+
+namespace enc = sensor_msgs::image_encodings;
+
+namespace compressed_image_transport
+{
+
+void CompressedPublisher::advertiseImpl(ros::NodeHandle &nh, const std::string &base_topic, uint32_t queue_size,
+                                        const image_transport::SubscriberStatusCallback &user_connect_cb,
+                                        const image_transport::SubscriberStatusCallback &user_disconnect_cb,
+                                        const ros::VoidPtr &tracked_object, bool latch)
+{
+  typedef image_transport::SimplePublisherPlugin<sensor_msgs::CompressedImage> Base;
+  Base::advertiseImpl(nh, base_topic, queue_size, user_connect_cb, user_disconnect_cb, tracked_object, latch);
+
+  // Set up reconfigure server for this topic
+  reconfigure_server_ = boost::make_shared<ReconfigureServer>(this->nh());
+  ReconfigureServer::CallbackType f = boost::bind(&CompressedPublisher::configCb, this, boost::placeholders::_1, boost::placeholders::_2);
+  reconfigure_server_->setCallback(f);
+}
+
+void CompressedPublisher::configCb(Config& config, uint32_t level)
+{
+  config_ = config;
+}
+
+void CompressedPublisher::publish(const sensor_msgs::Image& message, const PublishFn& publish_fn) const
+{
+  // Compressed image message
+  sensor_msgs::CompressedImage compressed;
+  compressed.header = message.header;
+  compressed.format = message.encoding;
+
+  // Compression settings
+  std::vector<int> params;
+
+  // Get codec configuration
+  compressionFormat encodingFormat = UNDEFINED;
+  if (config_.format == compressed_image_transport::CompressedPublisher_jpeg)
+    encodingFormat = JPEG;
+  if (config_.format == compressed_image_transport::CompressedPublisher_png)
+    encodingFormat = PNG;
+
+  // Bit depth of image encoding
+  int bitDepth = enc::bitDepth(message.encoding);
+  int numChannels = enc::numChannels(message.encoding);
+
+  switch (encodingFormat)
+  {
+    // JPEG Compression
+    case JPEG:
+    {
+      params.reserve(8);
+      params.emplace_back(IMWRITE_JPEG_QUALITY);
+      params.emplace_back(config_.jpeg_quality);
+      params.emplace_back(IMWRITE_JPEG_PROGRESSIVE);
+      params.emplace_back(config_.jpeg_progressive ? 1 : 0);
+      params.emplace_back(IMWRITE_JPEG_OPTIMIZE);
+      params.emplace_back(config_.jpeg_optimize ? 1 : 0);
+      params.emplace_back(IMWRITE_JPEG_RST_INTERVAL);
+      params.emplace_back(config_.jpeg_restart_interval);
+
+      // Update ros message format header
+      compressed.format += "; jpeg compressed ";
+
+      // Check input format
+      if ((bitDepth == 8) || (bitDepth == 16))
+      {
+        // Target image format
+        std::string targetFormat;
+        if (enc::isColor(message.encoding))
+        {
+          // convert color images to BGR8 format
+          targetFormat = "bgr8";
+          compressed.format += targetFormat;
+        }
+
+        // OpenCV-ros bridge
+        try
+        {
+          boost::shared_ptr<CompressedPublisher> tracked_object;
+          cv_bridge::CvImageConstPtr cv_ptr = cv_bridge::toCvShare(message, tracked_object, targetFormat);
+
+          // Compress image
+          if (cv::imencode(".jpg", cv_ptr->image, compressed.data, params))
+          {
+
+            float cRatio = (float)(cv_ptr->image.rows * cv_ptr->image.cols * cv_ptr->image.elemSize())
+                / (float)compressed.data.size();
+            ROS_DEBUG("Compressed Image Transport - Codec: jpg, Compression Ratio: 1:%.2f (%lu bytes)", cRatio, compressed.data.size());
+          }
+          else
+          {
+            ROS_ERROR("cv::imencode (jpeg) failed on input image");
+          }
+        }
+        catch (cv_bridge::Exception& e)
+        {
+          ROS_ERROR("%s", e.what());
+        }
+        catch (cv::Exception& e)
+        {
+          ROS_ERROR("%s", e.what());
+        }
+
+        // Publish message
+        publish_fn(compressed);
+      }
+      else
+        ROS_ERROR("Compressed Image Transport - JPEG compression requires 8/16-bit color format (input format is: %s)", message.encoding.c_str());
+
+      break;
+    }
+      // PNG Compression
+    case PNG:
+    {
+      params.reserve(2);
+      params.emplace_back(IMWRITE_PNG_COMPRESSION);
+      params.emplace_back(config_.png_level);
+
+      // Update ros message format header
+      compressed.format += "; png compressed ";
+
+      // Check input format
+      if ((bitDepth == 8) || (bitDepth == 16))
+      {
+
+        // Target image format
+        stringstream targetFormat;
+        if (enc::isColor(message.encoding))
+        {
+          // convert color images to RGB domain
+          targetFormat << "bgr" << bitDepth;
+          compressed.format += targetFormat.str();
+        }
+
+        // OpenCV-ros bridge
+        try
+        {
+          boost::shared_ptr<CompressedPublisher> tracked_object;
+          cv_bridge::CvImageConstPtr cv_ptr = cv_bridge::toCvShare(message, tracked_object, targetFormat.str());
+
+          // Compress image
+          if (cv::imencode(".png", cv_ptr->image, compressed.data, params))
+          {
+
+            float cRatio = (float)(cv_ptr->image.rows * cv_ptr->image.cols * cv_ptr->image.elemSize())
+                / (float)compressed.data.size();
+            ROS_DEBUG("Compressed Image Transport - Codec: png, Compression Ratio: 1:%.2f (%lu bytes)", cRatio, compressed.data.size());
+          }
+          else
+          {
+            ROS_ERROR("cv::imencode (png) failed on input image");
+          }
+        }
+        catch (cv_bridge::Exception& e)
+        {
+          ROS_ERROR("%s", e.what());
+          return;
+        }
+        catch (cv::Exception& e)
+        {
+          ROS_ERROR("%s", e.what());
+          return;
+        }
+
+        // Publish message
+        publish_fn(compressed);
+      }
+      else
+        ROS_ERROR("Compressed Image Transport - PNG compression requires 8/16-bit encoded color format (input format is: %s)", message.encoding.c_str());
+      break;
+    }
+
+    default:
+      ROS_ERROR("Unknown compression type '%s', valid options are 'jpeg' and 'png'", config_.format.c_str());
+      break;
+  }
+
+}
+
+} //namespace compressed_image_transport
--- /dev/null
+++ ros-noetic-compressed-image-transport-1.15.0/src/compressed_subscriber.cpp
@@ -0,0 +1,282 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2012, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#include "compressed_image_transport/compressed_subscriber.h"
+#include <sensor_msgs/image_encodings.h>
+#include <cv_bridge/cv_bridge.h>
+#include <opencv2/highgui/highgui.hpp>
+#include <opencv2/imgproc/imgproc.hpp>
+#include <turbojpeg.h>
+
+#include "compressed_image_transport/compression_common.h"
+
+#include <limits>
+#include <vector>
+
+using namespace cv;
+
+namespace enc = sensor_msgs::image_encodings;
+
+namespace compressed_image_transport
+{
+
+CompressedSubscriber::CompressedSubscriber()
+ : tj_(0)
+{}
+
+CompressedSubscriber::~CompressedSubscriber()
+{
+  if (tj_)
+    tjDestroy(tj_);
+}
+
+void CompressedSubscriber::subscribeImpl(ros::NodeHandle& nh, const std::string& base_topic, uint32_t queue_size,
+                             const Callback& callback, const ros::VoidPtr& tracked_object,
+                             const image_transport::TransportHints& transport_hints)
+{
+    typedef image_transport::SimpleSubscriberPlugin<sensor_msgs::CompressedImage> Base;
+    Base::subscribeImpl(nh, base_topic, queue_size, callback, tracked_object, transport_hints);
+
+    // Set up reconfigure server for this topic
+    reconfigure_server_ = boost::make_shared<ReconfigureServer>(this->nh());
+    ReconfigureServer::CallbackType f = boost::bind(&CompressedSubscriber::configCb, this, boost::placeholders::_1, boost::placeholders::_2);
+    reconfigure_server_->setCallback(f);
+}
+
+
+void CompressedSubscriber::configCb(Config& config, uint32_t level)
+{
+  config_ = config;
+  if (config_.mode == compressed_image_transport::CompressedSubscriber_gray) {
+      imdecode_flag_ = cv::IMREAD_GRAYSCALE;
+  } else if (config_.mode == compressed_image_transport::CompressedSubscriber_color) {
+      imdecode_flag_ = cv::IMREAD_COLOR;
+  } else /*if (config_.mode == compressed_image_transport::CompressedSubscriber_unchanged)*/ {
+      imdecode_flag_ = cv::IMREAD_UNCHANGED;
+  } 
+}
+
+void CompressedSubscriber::shutdown()
+{
+  reconfigure_server_.reset();
+  image_transport::SimpleSubscriberPlugin<sensor_msgs::CompressedImage>::shutdown();
+}
+
+sensor_msgs::ImagePtr CompressedSubscriber::decompressJPEG(const std::vector<uint8_t>& data, const std::string& source_encoding, const std_msgs::Header& header)
+{
+  if (!tj_)
+    tj_ = tjInitDecompress();
+
+  int width, height, jpegSub, jpegColor;
+
+  // Old TurboJPEG require a const_cast here. This was fixed in TurboJPEG 1.5.
+  uint8_t* src = const_cast<uint8_t*>(data.data());
+
+  if (tjDecompressHeader3(tj_, src, data.size(), &width, &height, &jpegSub, &jpegColor) != 0)
+    return sensor_msgs::ImagePtr(); // If we cannot decode the JPEG header, silently fall back to OpenCV
+
+  sensor_msgs::ImagePtr ret(new sensor_msgs::Image);
+  ret->header = header;
+  ret->width = width;
+  ret->height = height;
+  ret->encoding = source_encoding;
+
+  int pixelFormat;
+
+  if (source_encoding == enc::MONO8)
+  {
+    ret->data.resize(height*width);
+    ret->step = ret->width;
+    pixelFormat = TJPF_GRAY;
+  }
+  else if (source_encoding == enc::RGB8)
+  {
+    ret->data.resize(height*width*3);
+    ret->step = width*3;
+    pixelFormat = TJPF_RGB;
+  }
+  else if (source_encoding == enc::BGR8)
+  {
+    ret->data.resize(height*width*3);
+    ret->step = width*3;
+    pixelFormat = TJPF_BGR;
+  }
+  else if (source_encoding == enc::RGBA8)
+  {
+    ret->data.resize(height*width*4);
+    ret->step = width*4;
+    pixelFormat = TJPF_RGBA;
+  }
+  else if (source_encoding == enc::BGRA8)
+  {
+    ret->data.resize(height*width*4);
+    ret->step = width*4;
+    pixelFormat = TJPF_BGRA;
+  }
+  else if (source_encoding.empty())
+  {
+    // Autodetect based on image
+    if(jpegColor == TJCS_GRAY)
+    {
+      ret->data.resize(height*width);
+      ret->step = width;
+      ret->encoding = enc::MONO8;
+      pixelFormat = TJPF_GRAY;
+    }
+    else
+    {
+      ret->data.resize(height*width*3);
+      ret->step = width*3;
+      ret->encoding = enc::RGB8;
+      pixelFormat = TJPF_RGB;
+    }
+  }
+  else
+  {
+    ROS_WARN_THROTTLE(10.0, "Encountered a source encoding that is not supported by TurboJPEG: '%s'", source_encoding.c_str());
+    return sensor_msgs::ImagePtr();
+  }
+
+  if (tjDecompress2(tj_, src, data.size(), ret->data.data(), width, 0, height, pixelFormat, 0) != 0)
+  {
+    ROS_WARN_THROTTLE(10.0, "Could not decompress data using TurboJPEG, falling back to OpenCV");
+    return sensor_msgs::ImagePtr();
+  }
+
+  return ret;
+}
+
+void CompressedSubscriber::internalCallback(const sensor_msgs::CompressedImageConstPtr& message,
+                                            const Callback& user_cb)
+
+{
+  // Parse format field
+  std::string image_encoding;
+  std::string compressed_encoding;
+  {
+    const size_t split_pos = message->format.find(';');
+    if (split_pos != std::string::npos)
+    {
+      image_encoding = message->format.substr(0, split_pos);
+      compressed_encoding = message->format.substr(split_pos);
+    }
+  }
+
+  // Try TurboJPEG first (if the first bytes look like JPEG)
+  if(message->data.size() > 4 && message->data[0] == 0xFF && message->data[1] == 0xD8)
+  {
+    sensor_msgs::ImagePtr decoded = decompressJPEG(message->data, image_encoding, message->header);
+    if(decoded)
+    {
+      user_cb(decoded);
+      return;
+    }
+  }
+
+  // Otherwise, try our luck with OpenCV.
+  cv_bridge::CvImagePtr cv_ptr(new cv_bridge::CvImage);
+
+  // Copy message header
+  cv_ptr->header = message->header;
+
+  // Decode color/mono image
+  try
+  {
+    cv_ptr->image = cv::imdecode(cv::Mat(message->data), imdecode_flag_);
+
+    // Assign image encoding string
+    if (image_encoding.empty())
+    {
+      // Older version of compressed_image_transport does not signal image format
+      switch (cv_ptr->image.channels())
+      {
+        case 1:
+          cv_ptr->encoding = enc::MONO8;
+          break;
+        case 3:
+          cv_ptr->encoding = enc::BGR8;
+          break;
+        default:
+          ROS_ERROR("Unsupported number of channels: %i", cv_ptr->image.channels());
+          break;
+      }
+    } else
+    {
+      cv_ptr->encoding = image_encoding;
+
+      if ( enc::isColor(image_encoding))
+      {
+        bool compressed_bgr_image = (compressed_encoding.find("compressed bgr") != std::string::npos);
+
+        // Revert color transformation
+        if (compressed_bgr_image)
+        {
+          // if necessary convert colors from bgr to rgb
+          if ((image_encoding == enc::RGB8) || (image_encoding == enc::RGB16))
+            cv::cvtColor(cv_ptr->image, cv_ptr->image, CV_BGR2RGB);
+
+          if ((image_encoding == enc::RGBA8) || (image_encoding == enc::RGBA16))
+            cv::cvtColor(cv_ptr->image, cv_ptr->image, CV_BGR2RGBA);
+
+          if ((image_encoding == enc::BGRA8) || (image_encoding == enc::BGRA16))
+            cv::cvtColor(cv_ptr->image, cv_ptr->image, CV_BGR2BGRA);
+        } else
+        {
+          // if necessary convert colors from rgb to bgr
+          if ((image_encoding == enc::BGR8) || (image_encoding == enc::BGR16))
+            cv::cvtColor(cv_ptr->image, cv_ptr->image, CV_RGB2BGR);
+
+          if ((image_encoding == enc::BGRA8) || (image_encoding == enc::BGRA16))
+            cv::cvtColor(cv_ptr->image, cv_ptr->image, CV_RGB2BGRA);
+
+          if ((image_encoding == enc::RGBA8) || (image_encoding == enc::RGBA16))
+            cv::cvtColor(cv_ptr->image, cv_ptr->image, CV_RGB2RGBA);
+        }
+      }
+    }
+  }
+  catch (cv::Exception& e)
+  {
+    ROS_ERROR("%s", e.what());
+  }
+
+  size_t rows = cv_ptr->image.rows;
+  size_t cols = cv_ptr->image.cols;
+
+  if ((rows > 0) && (cols > 0))
+    // Publish message to user callback
+    user_cb(cv_ptr->toImageMsg());
+}
+
+} //namespace compressed_image_transport
--- /dev/null
+++ ros-noetic-compressed-image-transport-1.15.0/src/manifest.cpp
@@ -0,0 +1,41 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+* 
+*  Copyright (c) 2012, Willow Garage, Inc.
+*  All rights reserved.
+* 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+* 
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+* 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#include <pluginlib/class_list_macros.hpp>
+#include "compressed_image_transport/compressed_publisher.h"
+#include "compressed_image_transport/compressed_subscriber.h"
+
+PLUGINLIB_EXPORT_CLASS( compressed_image_transport::CompressedPublisher, image_transport::PublisherPlugin)
+
+PLUGINLIB_EXPORT_CLASS( compressed_image_transport::CompressedSubscriber, image_transport::SubscriberPlugin)
--- /dev/null
+++ ros-noetic-compressed-image-transport-1.15.0/test/basic.cpp
@@ -0,0 +1,181 @@
+/*********************************************************************
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2012, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of the Willow Garage nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*********************************************************************/
+
+#include <image_transport/image_transport.h>
+
+#include <gtest/gtest.h>
+
+#include <cv_bridge/cv_bridge.h>
+
+static unsigned int receivedImages = 0;
+std::vector<std::string> receivedEncodings;
+
+void handleImage(const sensor_msgs::ImageConstPtr& img)
+{
+  cv_bridge::CvImagePtr cvImg = cv_bridge::toCvCopy(img, "bgr8");
+  receivedEncodings.push_back(img->encoding);
+
+  ASSERT_EQ(cvImg->image.rows, 400);
+  ASSERT_EQ(cvImg->image.cols, 400);
+
+  // Red corner
+  cv::Scalar upperLeft = cv::mean(cvImg->image(cv::Rect(0, 0, 200, 200)));
+  EXPECT_LT(upperLeft[0], 10);
+  EXPECT_LT(upperLeft[1], 10);
+  EXPECT_GT(upperLeft[2], 240);
+
+  // Green corner
+  cv::Scalar upperRight = cv::mean(cvImg->image(cv::Rect(200, 0, 200, 200)));
+  EXPECT_LT(upperRight[0], 10);
+  EXPECT_GT(upperRight[1], 240);
+  EXPECT_LT(upperRight[2], 10);
+
+  // Blue corner
+  cv::Scalar lowerRight = cv::mean(cvImg->image(cv::Rect(200, 200, 200, 200)));
+  EXPECT_GT(lowerRight[0], 240);
+  EXPECT_LT(lowerRight[1], 10);
+  EXPECT_LT(lowerRight[2], 10);
+
+  // White corner
+  cv::Scalar lowerLeft = cv::mean(cvImg->image(cv::Rect(0, 200, 200, 200)));
+  EXPECT_GT(lowerLeft[0], 240);
+  EXPECT_GT(lowerLeft[1], 240);
+  EXPECT_GT(lowerLeft[2], 240);
+
+  receivedImages++;
+}
+
+TEST(Basic, loop)
+{
+  ros::NodeHandle nh;
+  image_transport::ImageTransport it(nh);
+
+  image_transport::Publisher pub = it.advertise("img", 20);
+  image_transport::Subscriber sub = it.subscribe("img", 20, &handleImage, image_transport::TransportHints("compressed"));
+
+  // Create a nice test image. Corners will be red, green, blue, white in clock-wise order.
+  cv::Mat_<cv::Vec3b> testImage(400, 400); // This is BGR!
+  for(int y = 0; y < 200; ++y)
+  {
+    for(int x = 0; x < 200; ++x)
+      testImage(y,x) = cv::Vec3b(0, 0, 255);
+
+    for(int x = 200; x < 400; ++x)
+      testImage(y,x) = cv::Vec3b(0, 255, 0);
+  }
+  for(int y = 200; y < 400; ++y)
+  {
+    for(int x = 0; x < 200; ++x)
+      testImage(y,x) = cv::Vec3b(255, 255, 255);
+
+    for(int x = 200; x < 400; ++x)
+      testImage(y,x) = cv::Vec3b(255, 0, 0);
+  }
+
+  ros::spinOnce();
+
+  unsigned int expectedImages = 0;
+  std::vector<std::string> expectedEncodings;
+
+  // Try different formats
+  {
+    cv_bridge::CvImage cvImg;
+    testImage.copyTo(cvImg.image);
+    cvImg.encoding = sensor_msgs::image_encodings::BGR8;
+
+    sensor_msgs::ImagePtr msg = cvImg.toImageMsg();
+    EXPECT_EQ(msg->encoding, sensor_msgs::image_encodings::BGR8);
+
+    pub.publish(msg);
+    expectedImages++;
+    expectedEncodings.push_back(sensor_msgs::image_encodings::BGR8);
+  }
+  {
+    cv_bridge::CvImage cvImg;
+    cv::cvtColor(testImage, cvImg.image, CV_BGR2RGB);
+    cvImg.encoding = sensor_msgs::image_encodings::RGB8;
+
+    sensor_msgs::ImagePtr msg = cvImg.toImageMsg();
+    EXPECT_EQ(msg->encoding, sensor_msgs::image_encodings::RGB8);
+
+    pub.publish(msg);
+    expectedImages++;
+    expectedEncodings.push_back(sensor_msgs::image_encodings::RGB8);
+  }
+  {
+    cv_bridge::CvImage cvImg;
+    cv::cvtColor(testImage, cvImg.image, CV_BGR2RGBA);
+    cvImg.encoding = sensor_msgs::image_encodings::RGBA8;
+
+    sensor_msgs::ImagePtr msg = cvImg.toImageMsg();
+    EXPECT_EQ(msg->encoding, sensor_msgs::image_encodings::RGBA8);
+
+    pub.publish(msg);
+    expectedImages++;
+    expectedEncodings.push_back(sensor_msgs::image_encodings::RGBA8);
+  }
+  {
+    cv_bridge::CvImage cvImg;
+    cv::cvtColor(testImage, cvImg.image, CV_BGR2BGRA);
+    cvImg.encoding = sensor_msgs::image_encodings::BGRA8;
+
+    sensor_msgs::ImagePtr msg = cvImg.toImageMsg();
+    EXPECT_EQ(msg->encoding, sensor_msgs::image_encodings::BGRA8);
+
+    pub.publish(msg);
+    expectedImages++;
+    expectedEncodings.push_back(sensor_msgs::image_encodings::BGRA8);
+  }
+
+  ros::WallTime start = ros::WallTime::now();
+  while(receivedImages < expectedImages && (ros::WallTime::now() - start) < ros::WallDuration(3.0))
+  {
+    ros::spinOnce();
+    ros::WallDuration(0.1).sleep();
+  }
+  EXPECT_EQ(receivedImages, expectedImages);
+
+  ASSERT_EQ(receivedEncodings.size(), expectedEncodings.size());
+  for(std::size_t i = 0; i < receivedEncodings.size(); ++i)
+    EXPECT_EQ(receivedEncodings[i], expectedEncodings[i]);
+}
+
+
+int main(int argc, char **argv)
+{
+  testing::InitGoogleTest(&argc, argv);
+  ros::init(argc, argv, "basic");
+  ros::NodeHandle nh;
+  return RUN_ALL_TESTS();
+}
--- /dev/null
+++ ros-noetic-compressed-image-transport-1.15.0/test/basic.test
@@ -0,0 +1,3 @@
+<launch>
+  <test test-name="basic_test" pkg="compressed_image_transport" type="basic_test" />
+</launch>
