Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ros-noetic-gazebo-ros (2.9.2-0jammy) jammy; urgency=high
 .
   * Only subscribe to /gazebo/performance_metrics when necessary (#1202 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/1202>)
     We are currently subscribing to the /gazebo/performance_metrics topic
     even if there are no subscribers to the ROS topic forwarding this data.
     The link_states and model_states topics currently use an advertise
     mechanism with callbacks when a subscriber connects or disconnects,
     so I've used that same pattern for the performance_metrics topic.
     This also helps workaround the deadlock documented in #1175 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/1175> and
     osrf/gazebo#2902 <https://github.com/osrf/gazebo/issues/2902>.
     This also adds a GAZEBO_ROS_HAS_PERFORMANCE_METRICS
     macro that reduces duplication of the version checking logic for
     performance metrics in gazebo and adds fixes some doc-string and
     typos in existing code
   * [Noetic] Bridge to republish PerformanceMetrics in ROS (#1145 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/1145>)
     Co-authored-by: Ian Chen <mailto:ichen@osrfoundation.org>
   * delete request msgs (#1160 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/1160>)
   * gazebo_ros_api_plugin cleanup (#1137 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/1137>)
     Remove an unused overload of publishSimTime and add doxygen
     for the remaining publishSimTime function.
     * Remove duplicate code for /clock advertisement
     The /clock topic is advertised in both loadGazeboRosApiPlugin
     and advertiseServices. This removes the code from advertiseServices
     and moves it earlier in loadGazeboRosApiPlugin.
     Co-authored-by: Alejandro Hernández Cordero <mailto:ahcorde@gmail.com>
   * colcon.pkg: build gazebo first in colcon workspace (#1135 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/1135>)
     Add a colcon.pkg file to gazebo_dev with gazebo's cmake project
     name "Gazebo" listed as a dependency to support building
     gazebo from source in a colcon workspace.
     * Add colcon.pkg files for other packages
     Copy colcon.pkg to gazebo_ros, gazebo_plugins, and
     gazebo_ros_control so that --merge-install won't be required.
   * Contributors: Alejandro Hernández Cordero, Ian Chen, Steve Peters
Author: Jose Luis Rivero <jrivero@osrfoundation.org>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2024-08-18

--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/.idea/gazebo_ros.iml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module classpath="CMake" type="CPP_MODULE" version="4" />
\ No newline at end of file
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/CHANGELOG.rst
@@ -0,0 +1,522 @@
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Changelog for package gazebo_ros
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+2.9.2 (2021-04-21)
+------------------
+* Only subscribe to /gazebo/performance_metrics when necessary (`#1202 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/1202>`_)
+  We are currently subscribing to the /gazebo/performance_metrics topic
+  even if there are no subscribers to the ROS topic forwarding this data.
+  The link_states and model_states topics currently use an advertise
+  mechanism with callbacks when a subscriber connects or disconnects,
+  so I've used that same pattern for the performance_metrics topic.
+  This also helps workaround the deadlock documented in `#1175 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/1175>`_ and
+  `osrf/gazebo#2902 <https://github.com/osrf/gazebo/issues/2902>`_.
+  This also adds a GAZEBO_ROS_HAS_PERFORMANCE_METRICS
+  macro that reduces duplication of the version checking logic for
+  performance metrics in gazebo and adds fixes some doc-string and
+  typos in existing code
+* [Noetic] Bridge to republish PerformanceMetrics in ROS (`#1145 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/1145>`_)
+  Co-authored-by: Ian Chen <ichen@osrfoundation.org>
+* delete request msgs (`#1160 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/1160>`_)
+* gazebo_ros_api_plugin cleanup (`#1137 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/1137>`_)
+  Remove an unused overload of publishSimTime and add doxygen
+  for the remaining publishSimTime function.
+  * Remove duplicate code for /clock advertisement
+  The /clock topic is advertised in both loadGazeboRosApiPlugin
+  and advertiseServices. This removes the code from advertiseServices
+  and moves it earlier in loadGazeboRosApiPlugin.
+  Co-authored-by: Alejandro Hernández Cordero <ahcorde@gmail.com>
+* colcon.pkg: build gazebo first in colcon workspace (`#1135 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/1135>`_)
+  Add a colcon.pkg file to gazebo_dev with gazebo's cmake project
+  name "Gazebo" listed as a dependency to support building
+  gazebo from source in a colcon workspace.
+  * Add colcon.pkg files for other packages
+  Copy colcon.pkg to gazebo_ros, gazebo_plugins, and
+  gazebo_ros_control so that --merge-install won't be required.
+* Contributors: Alejandro Hernández Cordero, Ian Chen, Steve Peters
+
+2.9.1 (2020-05-20)
+------------------
+
+2.9.0 (2020-05-19)
+------------------
+* [Noetic] changes to make it work with Python3 (`#1069 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/1069>`_)
+  * Noetic - changes to make it work with Python3
+* add node required to noetic (`#1082 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/1082>`_)
+* add additional light options to 'set_light_properties' service (`#874 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/874>`_)
+  The optional 'Light' properties 'cast_shadows', 'specular', 'direction',
+  and 'pose' are not optional any more. These properties are now set via the
+  corresponding fields in the ROS message. By default, this will be 0.
+  https://github.com/ros-simulation/gazebo_ros_pkgs/pull/874
+* spawn_model: Fix urlparse imports for Python 3
+* spawn_model: Ensure that "model_xml" is a string, required for Python 3
+* catkin_find gazebo plugin from bin folder. (`#993 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/993>`_)
+* [Windows][melodic-devel] more Windows build break fix (`#975 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/975>`_)
+  * Fix CMake install error for Windows build.
+  * conditionally include <sys/time.h>
+* provide Windows implemenation for setenv. (`#879 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/879>`_)
+* implement basic gazebo scripts to support launch file on Windows build. (`#880 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/880>`_)
+* Contributors: Alejandro Hernández Cordero, Christian Rauch, Kartik Mohta, Mabel Zhang, Sean Yen
+
+2.8.5 (2019-06-04)
+------------------
+* Add output arg to launch files, plus some small fixes (melodic) (`#907 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/907>`_)
+  * Add output arg to empty_world
+  * add output arg to elevator_world
+  * add output arg to range_world
+  * don't set use_sim_time in range_world
+  Instead parse it to empty world, where it will be set.
+  * add xml prolog to all launch files
+  * Remove unnecessary arg in range_world.launch
+* use C++11 std sleep instead of usleep. (`#877 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/877>`_)
+* fix issue `#198 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/198>`_ (`#825 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/825>`_)
+* Lower minimum cmake version (`#817 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/817>`_)
+* Contributors: Matthijs van der Burgh, Paul Bovbel, Sean Yen [MSFT], Steven Peters
+
+2.8.4 (2018-07-06)
+------------------
+* Refactor spawn_model script
+  * more robust -package_to_model implementation (issue #449)
+  * add stdin as source option
+  * parse arguments with argparse
+  * remove deprecated/unused -gazebo and -trimesh options
+* Fix physics reconfigure within namespace (issue #507)
+* Contributors: Kevin Allen, Steven Peters
+
+2.8.3 (2018-06-04)
+------------------
+* Use generic SIGINT parameter in kill command for gazebo script (melodic-devel) (`#724 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/724>`_)
+  * Use generic SIGINT parameter in kill command for gazebo script
+  * redirect to kill command to std_err
+* Contributors: Jose Luis Rivero
+
+2.8.2 (2018-05-09)
+------------------
+* Fix the build on Ubuntu Artful. (`#715 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/715>`_)
+  Artful has some bugs in its cmake files for Simbody that
+  cause it to fail the build.  If we are on artful, remove
+  the problematic entries.
+  Signed-off-by: Chris Lalancette <clalancette@openrobotics.org>
+* Contributors: Chris Lalancette
+
+2.8.1 (2018-05-05)
+------------------
+* Parameter to disable ROS network interaction from/to Gazebo (lunar-devel) (`#704 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/704>`_)
+* Load the libgazebo_ros_api_plugin when starting gzclient so that the ROS event loop will turn over, which is required when you have a client-side Gazebo plugin that uses ROS. (`#676 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/676>`_)
+* Pass verbose argument to gzclient (`#677 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/677>`_)
+* strip comments from parsed urdf (`#698 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/698>`_)
+  Remove comments from urdf before trying to find packages. Otherwise non-existant packages will produce a fatal error, even though they are not used.
+* Contributors: Jose Luis Rivero
+
+2.7.4 (2018-02-12)
+------------------
+* Fix last gazebo8 warnings! (lunar-devel) (`#664 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/664>`_)
+* Fix for relative frame errors (lunar-devel) (`#663 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/663>`_)
+* Fix gazebo8 warnings part 7: retry `#642 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/642>`_ on lunar (`#660 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/660>`_)
+* Fix gazebo8 warnings part 10: ifdefs for GetModel, GetEntity, Light (lunar-devel) (`#657 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/657>`_)
+* gazebo8 warnings: ifdefs for Get.*Vel() (`#655 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/655>`_)
+* [gazebo_ros] don't overwrite parameter "use_sim_time" (lunar-devel) (`#607 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/607>`_)
+* Fix gazebo8 warnings part 8: ifdef's for GetWorldPose (lunar-devel) (`#652 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/652>`_)
+* Prevents GAZEBO_MODEL_DATABASE_URI from being overwritten (`#649 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/649>`_)
+* for gazebo8+, call functions without Get (`#640 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/640>`_)
+* Contributors: Jose Luis Rivero, Steven Peters
+
+2.7.3 (2017-12-11)
+------------------
+* gazebo_ros_api_plugin: improve plugin xml parsing (`#627 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/627>`_)
+* Fix gazebo8 warnings part 5: ignition math in gazebo_ros (lunar-devel) (`#636 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/636>`_)
+* Fix gazebo8 warnings part 4: convert remaining local variables in plugins to ign-math (lunar-devel) (`#634 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/634>`_)
+* gazebo_ros: fix support for python3 (`#629 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/629>`_)
+* Replace Events::Disconnect* with pointer reset (`#626 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/626>`_)
+* Install spawn_model using catkin_install_python (`#624 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/624>`_)
+* Quote arguments to echo in libcommon.sh (`#591 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/591>`_)
+* Contributors: Jose Luis Rivero
+
+2.7.2 (2017-05-21)
+------------------
+* Revert gazebo8 changes in Lunar and back to use gazebo7 (`#583 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/583>`_)
+* Contributors: Jose Luis Rivero
+
+2.7.1 (2017-04-28)
+------------------
+* Fixes for compilation and warnings in Lunar-devel  (`#573 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/573>`_)
+  Multiple fixes for compilation and warnings coming from Gazebo8 and ignition-math3
+* Add catkin package(s) to provide the default version of Gazebo - take II (kinetic-devel) (`#571 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/571>`_)
+* Contributors: Jose Luis Rivero
+
+2.5.12 (2017-04-25)
+-------------------
+
+2.5.11 (2017-04-18)
+-------------------
+* Changed the spawn model methods to spawn also lights. (`#511 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/511>`_)
+* Change build system to set DEPEND on Gazebo/SDFormat (fix catkin warning)
+  Added missing DEPEND clauses to catkin_package to fix gazebo catkin warning.
+  Note that after the change problems could appear related to -lpthreads
+  errors. This is an known issue related to catkin:
+  https://github.com/ros/catkin/issues/856.
+* Use correct logerr method (`#557 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/557>`_)
+* Contributors: Alessandro Ambrosano, Dave Coleman, Gary Servin
+
+2.5.10 (2017-03-03)
+-------------------
+* Revert catkin warnings to fix regressions (problems with catkin -lpthreads errors)
+  For reference and reasons, please check:
+  https://discourse.ros.org/t/need-to-sync-new-release-of-rqt-topic-indigo-jade-kinetic/1410/4
+  * Revert "Fix gazebo catkin warning, cleanup CMakeLists (`#537 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/537>`_)"
+  This reverts commit 5a0305fcb97864b66bc2e587fc0564435b4f2034.
+  * Revert "Fix gazebo and sdformat catkin warnings"
+  This reverts commit 11f95d25dcd32faccd2401d45c722f7794c7542c.
+* Contributors: Jose Luis Rivero
+
+2.5.9 (2017-02-20)
+------------------
+* Fix gazebo catkin warning, cleanup CMakeLists (`#537 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/537>`_)
+* Namespace console output (`#543 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/543>`_)
+* Removed all trailing whitespace
+* Contributors: Dave Coleman
+
+2.5.8 (2016-12-06)
+------------------
+* Workaround to support gazebo and ROS arguments in the command line
+* Fix ROS remapping by reverting "Remove ROS remapping arguments from gazebo_ros launch scripts.
+* Fixed getlinkstate service's angular velocity return
+* Honor GAZEBO_MASTER_URI in gzserver and gzclient
+* Contributors: Jared, Jon Binney, Jordan Liviero, Jose Luis Rivero, Martin Pecka
+
+2.5.7 (2016-06-10)
+------------------
+
+2.5.6 (2016-04-28)
+------------------
+* Remove deprecated spawn_gazebo_model service
+* Contributors: Steven Peters
+
+2.5.5 (2016-04-27)
+------------------
+* merge indigo, jade to kinetic-devel
+* Upgrade to gazebo 7 and remove deprecated driver_base dependency
+  * Upgrade to gazebo 7 and remove deprecated driver_base dependency
+  * disable gazebo_ros_control until dependencies are met
+  * Remove stray backslash
+* spawn_model: adding -b option to bond to the model and delete it on sigint
+* Update maintainer for Kinetic release
+* Allow respawning gazebo node.
+* Contributors: Hugo Boyer, Isaac IY Saito, Jackie Kay, Jonathan Bohren, Jose Luis Rivero, Steven Peters
+
+2.5.3 (2016-04-11)
+------------------
+* Include binary in runtime
+* Remove ROS remapping arguments from gazebo_ros launch scripts.
+* Contributors: Jose Luis Rivero, Martin Pecka
+
+2.5.2 (2016-02-25)
+------------------
+* merging from indigo-devel
+* Merge pull request `#302 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/302>`_ from maxbader/jade-devel-GetModelState
+  Header for GetModelState service request for jade-devel
+* Fix invalid signal name on OS X
+  scripts/gazebo: line 30: kill: SIGINT: invalid signal specification
+* Fix invalid signal name on OS X
+  scripts/gazebo: line 30: kill: SIGINT: invalid signal specification
+* Restart package resolving from last position, do not start all over.
+* 2.4.9
+* Generate changelog
+* Import changes from jade-branch
+* Add range world and launch file
+* fix crash
+* Set GAZEBO_CXX_FLAGS to fix c++11 compilation errors
+* GetModelState modification for jade
+* Contributors: Bence Magyar, Boris Gromov, Guillaume Walck, Ian Chen, John Hsu, Jose Luis Rivero, Markus Bader, Steven Peters, hsu
+
+2.5.1 (2015-08-16)
+------------------
+* Port of Pal Robotics range sensor plugin to Jade
+* Added a comment about the need of libgazebo5-dev in runtime
+* Added missing files
+* Added elevator plugin
+* Use c++11
+* run_depend on libgazebo5-dev (`#323 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/323>`_)
+  Declare the dependency.
+  It can be fixed later if we don't want it.
+* Contributors: Jose Luis Rivero, Nate Koenig, Steven Peters
+
+* Port of Pal Robotics range sensor plugin to Jade
+* Added a comment about the need of libgazebo5-dev in runtime
+* Added missing files
+* Added elevator plugin
+* Use c++11
+* run_depend on libgazebo5-dev
+* Contributors: Jose Luis Rivero, Nate Koenig, Steven Peters
+
+2.5.0 (2015-04-30)
+------------------
+* run_depend on libgazebo5-dev instead of gazebo5
+* Changed the rosdep key for gazebo to gazebo5, for Jade Gazebo5 will be used.
+* Contributors: Steven Peters, William Woodall
+
+2.4.10 (2016-02-25)
+-------------------
+* Fix invalid signal name on OS X
+  scripts/gazebo: line 30: kill: SIGINT: invalid signal specification
+* Restart package resolving from last position, do not start all over.
+* Contributors: Boris Gromov, Guillaume Walck
+
+2.4.9 (2015-08-16)
+------------------
+* Import changes from jade-branch
+* Add range world and launch file
+* fix crash
+* Set GAZEBO_CXX_FLAGS to fix c++11 compilation errors
+* Contributors: Bence Magyar, Ian Chen, Jose Luis Rivero, Steven Peters
+
+2.4.8 (2015-03-17)
+------------------
+* Specify physics engine in args to empty_world.launch
+* Contributors: Steven Peters
+
+2.4.7 (2014-12-15)
+------------------
+* temporary hack to **fix** the -J joint position option (issue `#93 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/93>`_), sleeping for 1 second to avoid race condition. this branch should only be used for debugging, merge only as a last resort.
+* Fixing set model state method and test
+* Extended the fix for `#246 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/246>`_ also to debug, gazebo, gzclient and perf scripts.
+* Update Gazebo/ROS tutorial URL
+* [gazebo_ros] Fix for `#246 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/246>`_
+  Fixing issue `#246 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/246>`_ in gzserver.
+* Fixing handling of non-world frame velocities in setModelState.
+* update headers to apache 2.0 license
+* update headers to apache 2.0 license
+* Contributors: John Hsu, Jose Luis Rivero, Martin Pecka, Tom Moore, ayrton04
+
+2.4.6 (2014-09-01)
+------------------
+* Merge pull request `#232 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/232>`_ from ros-simulation/fix_get_physics_properties_non_ode
+  Fix get physics properties non ode
+* Merge pull request `#183 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/183>`_ from ros-simulation/issue_182
+  Fix STL iterator errors, misc. cppcheck (`#182 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/182>`_)
+* check physics engine type before calling set_physics_properties and get_physics_properteis
+* check physics engine type before calling set_physics_properties and get_physics_properteis
+* Fixes for calling GetParam() with different physic engines.
+* 2.3.6
+* Update changelogs for the upcoming release
+* Fixed boost any cast
+* Removed a few warnings
+* Update for hydro + gazebo 1.9
+* Fix build with gazebo4 and indigo
+* Fix STL iterator errors, misc. cppcheck (`#182 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/182>`_)
+  There were some errors in STL iterators.
+  Initialized values of member variables in constructor.
+  Removed an unused variable (model_name).
+* Contributors: Carlos Aguero, John Hsu, Jose Luis Rivero, Nate Koenig, Steven Peters, hsu, osrf
+
+2.4.5 (2014-08-18)
+------------------
+* Port fix_build branch for indigo-devel
+  See pull request `#221 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/221>`_
+* Contributors: Jose Luis Rivero
+
+2.4.4 (2014-07-18)
+------------------
+* Fix repo names in package.xml's
+* fix issue `#198 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/198>`_
+  Operator ``==`` is not recognized by sh scripts.
+* Add verbose parameter
+  Add verbose parameter for --verbose gazebo flag
+* added osx support for gazebo start scripts
+* Contributors: Arn-O, Jon Binney, Markus Achtelik, Vincenzo Comito
+
+2.4.3 (2014-05-12)
+------------------
+* added osx support for gazebo start scripts
+* Remove gazebo_ros dependency on gazebo_plugins
+* Contributors: Markus Achtelik, Steven Peters
+
+2.4.2 (2014-03-27)
+------------------
+* merging from hydro-devel
+* bump patch version for indigo-devel to 2.4.1
+* merging from indigo-devel after 2.3.4 release
+* "2.4.0"
+* catkin_generate_changelog
+* Contributors: John Hsu
+
+2.4.1 (2013-11-13)
+------------------
+
+2.3.5 (2014-03-26)
+------------------
+* gazebo_ros: [less-than-minor] fix newlines
+* gazebo_ros: remove assignment to self
+  If this is needed for any twisted reason, it should be made clear
+  anyway. Assuming this line is harmless and removing it because it
+  generates cppcheck warnings.
+* Contributors: Paul Mathieu
+
+2.3.4 (2013-11-13)
+------------------
+* rerelease because sdformat became libsdformat, but we also based change on 2.3.4 in hydro-devel.
+* remove debug statement
+* fix sdf spawn with initial pose
+* fix sdf spawn with initial pose
+* Merge branch 'hydro-devel' into ``spawn_model_pose_fix``
+* fix indentation
+* Merge pull request `#142 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/142>`_ from hsu/hydro-devel
+  fix issue `#38 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/38>`_, gui segfault on model deletion
+* Merge pull request `#140 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/140>`_ from ``v4hn/spawn_model_sleep``
+  replace time.sleep by rospy.Rate.sleep
+* fix spawn initial pose.  When model has a non-zero initial pose and user specified initial model spawn pose, add the two.
+* fix issue `#38 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/38>`_, gui segfault on model deletion by removing an obsolete call to set selected object state to "normal".
+* replace time.sleep by rospy.Rate.sleep
+  time was not even imported, so I don't know
+  why this could ever have worked...
+* Add time import
+  When using the -wait option the script fails because is missing the time import
+* Use pre-increment for iterators
+* Fix iterator erase() problems
+
+2.4.0 (2013-10-14)
+------------------
+
+2.3.3 (2013-10-10)
+------------------
+* Cleaned up unnecessary debug output that was recently added
+* Fixed issue where ``catkin_find`` returns more than one library if it is installed from both source and debian
+
+2.3.2 (2013-09-19)
+------------------
+* Make gazebo includes use full path
+  In the next release of gazebo, it will be required to use the
+  full path for include files. For example,
+  `include <physics/physics.hh>` will not be valid
+  `include <gazebo/physics/physics.hh>` must be done instead.
+* update gazebo includes
+* Fixed a minor typo in spawn_model error message when `-model` not specified
+
+2.3.1 (2013-08-27)
+------------------
+* Cleaned up template, fixes for header files
+
+2.3.0 (2013-08-12)
+------------------
+* gazebo_ros: fixed missing dependency on TinyXML
+* gazebo_plugins: replace deprecated boost function
+  This is related to `this gazebo issue <https://bitbucket.org/osrf/gazebo/issue/581/boost-shared_-_cast-are-deprecated-removed>`_
+
+2.2.1 (2013-07-29)
+------------------
+
+2.2.0 (2013-07-29)
+------------------
+* Switched to pcl_conversions
+* Remove find_package(SDF) from CMakeLists.txt
+  It is sufficient to find gazebo, which will export the information
+  about the SDFormat package.
+
+2.1.5 (2013-07-18)
+------------------
+* gazebo_ros: fixed variable names in gazebo_ros_paths_plugin
+
+2.1.4 (2013-07-14)
+------------------
+
+2.1.3 (2013-07-13)
+------------------
+
+2.1.2 (2013-07-12)
+------------------
+* Added author
+* Tweak to make SDFConfig.cmake
+* Cleaned up CMakeLists.txt for all gazebo_ros_pkgs
+* Cleaned up gazebo_ros_paths_plugin
+* 2.1.1
+
+2.1.1 (2013-07-10 19:11)
+------------------------
+* Merge branch 'hydro-devel' of github.com:ros-simulation/gazebo_ros_pkgs into hydro-devel
+* Reduced number of debug msgs
+* Fixed physics dynamic reconfigure namespace
+* gazebo_ros_api_plugin: set `plugin_loaded_` flag to true in
+  GazeboRosApiPlugin::Load() function
+* Actually we need `__init__.py`
+* Cleaning up code
+* Moved gazebo_interface.py from gazebo/ folder to gazebo_ros/ folder
+* Removed searching for plugins under 'gazebo' pkg because of rospack warnings
+* Minor print modification
+* Added dependency to prevent missing msg header, cleaned up CMakeLists
+
+2.1.0 (2013-06-27)
+------------------
+* gazebo_ros: added deprecated warning for packages that use gazebo as
+  package name for exported paths
+* Hiding some debug info
+* gazebo_ros: use rosrun in debug script, as rospack find gazebo_ros returns the wrong path in install space
+* Hide Model XML debut output to console
+* gazebo_ros_api_plugin.h is no longer exposed in the include folder
+* Added args to launch files, documentation
+* Merge pull request `#28 <https://github.com/ros-simulation/gazebo_ros_pkgs/issues/28>`_ from osrf/no_roscore_handling
+  Better handling of gazebo_ros run when no roscore started
+* gazebo_ros: also support gazebo instead of gazebo_ros as package name for plugin_path, gazebo_model_path or gazebo_media_path exports
+* gazebo_plugins/gazebo_ros: fixed install directories for include files and gazebo scripts
+* changed comment location
+* added block comments for walkChildAddRobotNamespace
+* SDF and URDF now set robotNamespace for plugins
+* Better handling of gazebo_ros run when no roscore started
+
+2.0.2 (2013-06-20)
+------------------
+* Added Gazebo dependency
+* changed the final kill to send a SIGINT and ensure only the last background process is killed.
+* modified script to work in bash correctly (tested on ubuntu 12.04 LTS)
+
+2.0.1 (2013-06-19)
+------------------
+* Incremented version to 2.0.1
+* Fixed circular dependency, removed deprecated pkgs since its a stand alone pkg
+* Shortened line lengths of function headers
+
+2.0.0 (2013-06-18)
+------------------
+* Changed version to 2.0.0 based on gazebo_simulator being 1.0.0
+* Updated package.xml files for ros.org documentation purposes
+* Combined updateSDFModelPose and updateSDFName, added ability to spawn SDFs from model database, updates SDF version to lastest in parts of code, updated the tests
+* Renamed Gazebo model to SDF model, added ability to spawn from online database
+* Fixed really obvious error checking bug
+* Deprecated -gazebo arg in favor of -sdf tag
+* Reordered services and messages to be organized and reflect documentation. No code change
+* Cleaned up file, addded debug info
+* Merged changes from Atlas ROS plugins, cleaned up headers
+* Small fixes per ffurrer's code review
+* Deprecated warnings fixes
+* Cleaned up comment blocks - removed from .cpp and added to .h
+* Merged branches and more small cleanups
+* Small compile error fix
+* Standardized function and variable naming convention, cleaned up function comments
+* Reduced debug output and refresh frequency of robot spawner
+* Converted all non-Gazebo pointers to boost shared_ptrs
+* Removed old Gazebo XML handling functions - has been replaced by SDF, various code cleanup
+* Removed the physics reconfigure node handle, switched to async ROS spinner, reduced required while loops
+* Fixed shutdown segfault, renamed `rosnode_` to `nh_`, made all member variables have `_` at end, formatted functions
+* Added small comment
+* adding install for gazebo_ros launchfiles
+* Formatted files to be double space indent per ROS standards
+* Started fixing thread issues
+* Fixing install script names and adding gzserver and gdbrun to install command
+* Fixed deprecated warnings, auto formatted file
+* Cleaned up status messages
+* Added -h -help --help arguemnts to spawn_model
+* Removed broken worlds
+* Removed deprecated namespace argument
+* Using pkg-config to find the script installation path.
+  Corrected a bash typo with client_final variable in gazebo script.
+* Cleaning up world files
+* Deprecated fix
+* Moved from gazebo_worlds
+* Cleaning up launch files
+* Moved from gazebo_worlds
+* Fixing renaming errors
+* Updated launch and world files and moved to gazebo_ros
+* Combined gzclient and gzserver
+* Added finished loading msg
+* All packages building in Groovy/Catkin
+* Imported from bitbucket.org
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/CMakeLists.txt
@@ -0,0 +1,145 @@
+cmake_minimum_required(VERSION 3.5.1)
+project(gazebo_ros)
+
+find_package(catkin REQUIRED COMPONENTS
+  gazebo_dev
+  cmake_modules
+  roslib
+  roscpp
+  geometry_msgs
+  std_srvs
+  tf
+  rosgraph_msgs
+  dynamic_reconfigure
+  std_msgs
+  gazebo_msgs
+)
+
+# Through transitive dependencies in the packages above, gazebo_ros depends
+# on Simbody.  There is a bug in the Ubuntu Artful (17.10) version of the
+# Simbody package where it includes /usr/lib/libblas.so and
+# /usr/lib/liblapack.so in the CMake list of libraries even though neither of
+# those two paths exist (they both really live in /usr/lib/<arch>-linux-gnu).
+# We remove these two during build-time on artful below; this works because
+# they both will get resolved to the proper paths during runtime linking.
+find_program(LSB_RELEASE_EXEC lsb_release)
+if(NOT LSB_RELEASE_EXEC STREQUAL "LSB_RELEASE_EXEC-NOTFOUND")
+  execute_process(COMMAND ${LSB_RELEASE_EXEC} -cs
+    OUTPUT_VARIABLE OS_CODENAME
+    OUTPUT_STRIP_TRAILING_WHITESPACE
+  )
+  if(OS_CODENAME STREQUAL "artful")
+    list(FILTER catkin_LIBRARIES EXCLUDE REGEX "/usr/lib/libblas.so")
+    list(FILTER catkin_LIBRARIES EXCLUDE REGEX "/usr/lib/liblapack.so")
+  endif()
+endif()
+
+include (FindPkgConfig)
+if (PKG_CONFIG_FOUND)
+  pkg_check_modules(XML libxml-2.0)
+else()
+  message(FATAL_ERROR "pkg-config is required; please install it")
+endif()
+
+find_package(Boost REQUIRED COMPONENTS thread)
+
+find_package(TinyXML REQUIRED)
+
+catkin_python_setup()
+
+generate_dynamic_reconfigure_options(cfg/Physics.cfg)
+
+catkin_package(
+  LIBRARIES
+    gazebo_ros_api_plugin
+    gazebo_ros_paths_plugin
+
+  CATKIN_DEPENDS
+    roslib
+    roscpp
+    geometry_msgs
+    std_srvs
+    tf
+    rosgraph_msgs
+    dynamic_reconfigure
+    std_msgs
+    gazebo_msgs
+
+  DEPENDS
+    TinyXML
+)
+
+include_directories(
+  include
+  ${Boost_INCLUDE_DIRS}
+  ${catkin_INCLUDE_DIRS}
+  ${TinyXML_INCLUDE_DIRS})
+
+link_directories(${catkin_LIBRARY_DIRS})
+
+set(cxx_flags)
+foreach (item ${GAZEBO_CFLAGS})
+  set(cxx_flags "${cxx_flags} ${item}")
+endforeach ()
+
+set(ld_flags)
+foreach (item ${GAZEBO_LDFLAGS})
+  set(ld_flags "${ld_flags} ${item}")
+endforeach ()
+
+## Plugins
+add_library(gazebo_ros_api_plugin src/gazebo_ros_api_plugin.cpp)
+add_dependencies(gazebo_ros_api_plugin ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
+set_target_properties(gazebo_ros_api_plugin PROPERTIES LINK_FLAGS "${ld_flags}")
+set_target_properties(gazebo_ros_api_plugin PROPERTIES COMPILE_FLAGS "${cxx_flags}")
+target_link_libraries(gazebo_ros_api_plugin ${catkin_LIBRARIES} ${Boost_LIBRARIES} ${TinyXML_LIBRARIES})
+
+add_library(gazebo_ros_paths_plugin src/gazebo_ros_paths_plugin.cpp)
+add_dependencies(gazebo_ros_paths_plugin ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
+set_target_properties(gazebo_ros_paths_plugin PROPERTIES COMPILE_FLAGS "${cxx_flags}")
+set_target_properties(gazebo_ros_paths_plugin PROPERTIES LINK_FLAGS "${ld_flags}")
+target_link_libraries(gazebo_ros_paths_plugin ${catkin_LIBRARIES} ${Boost_LIBRARIES})
+
+## Tests
+
+add_subdirectory(test)
+
+# Install Gazebo System Plugins
+install(TARGETS gazebo_ros_api_plugin gazebo_ros_paths_plugin
+  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION}
+  )
+
+# Install Gazebo Scripts
+if (WIN32)
+  install(PROGRAMS
+                  scripts/debug.bat
+                  scripts/gzclient.bat
+                  scripts/gzserver.bat
+          DESTINATION
+                  ${CATKIN_PACKAGE_BIN_DESTINATION}
+  )
+else ()
+  install(PROGRAMS
+                  scripts/gazebo
+                  scripts/debug
+                  scripts/gzclient
+                  scripts/gzserver
+                  scripts/gdbrun
+                  scripts/perf
+                  scripts/libcommon.sh
+          DESTINATION
+                  ${CATKIN_PACKAGE_BIN_DESTINATION}
+  )
+endif()
+
+# This one is a Python program, not a shell script, so install it separately
+catkin_install_python(PROGRAMS scripts/spawn_model
+  DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
+)
+
+# Install Gazebo launch files
+install(DIRECTORY launch/
+  DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}/launch
+)
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/cfg/Physics.cfg
@@ -0,0 +1,59 @@
+#! /usr/bin/env python
+#*  All rights reserved.
+#*
+#*  Redistribution and use in source and binary forms, with or without
+#*  modification, are permitted provided that the following conditions
+#*  are met:
+#*
+#*   * Redistributions of source code must retain the above copyright
+#*     notice, this list of conditions and the following disclaimer.
+#*   * Redistributions in binary form must reproduce the above
+#*     copyright notice, this list of conditions and the following
+#*     disclaimer in the documentation and/or other materials provided
+#*     with the distribution.
+#*   * Neither the name of the Willow Garage nor the names of its
+#*     contributors may be used to endorse or promote products derived
+#*     from this software without specific prior written permission.
+#*
+#*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+#*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+#*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+#*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+#*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+#*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+#*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+#*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+#*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+#*  POSSIBILITY OF SUCH DAMAGE.
+#***********************************************************
+
+# Author: John Hsu
+# Gazebo ode physics configuration
+
+PACKAGE='gazebo_ros'
+
+from math import pi
+
+from dynamic_reconfigure.parameter_generator_catkin import *
+
+gen = ParameterGenerator()
+#        Name                          Type      Reconfiguration level             Description                                                                                                 Default    Min   Max
+gen.add( "time_step"                 , double_t, 1                            ,    "Simulation world time step size in seconds, smaller time steps producesslower, more stable simulation."  , 0.001    , 0   , 10)
+gen.add( "max_update_rate"           , double_t, 1                            ,    "Simulator max update rate, -1 unlimited, 1 restricts to real-time if possible."                          , 60       , 0   , 1000)
+gen.add( "gravity_x"                 , double_t, 1                            ,    "Simulated gravity in the x direction."                                                                   , 0        , -100, 100)
+gen.add( "gravity_y"                 , double_t, 1                            ,    "Simulated gravity in the y direction."                                                                   , 0        , -100, 100)
+gen.add( "gravity_z"                 , double_t, 1                            ,    "Simulated gravity in the z direction."                                                                   , -9.8     , -100, 100)
+gen.add( "auto_disable_bodies"       , bool_t  , 1                            ,    "Auto disable of bodies in simulation if body it's not moving."                                           , False)
+gen.add( "sor_pgs_precon_iters"      , int_t   , 1                            ,    "Number of preconditioning iterations for SOR PGS LCP as implemented in quickstep."                       , 0        , 0   , 10000)
+gen.add( "sor_pgs_iters"             , int_t   , 1                            ,    "Number of iterations for SOR PGS LCP as implemented in quickstep."                                       , 20       , 0   , 10000)
+gen.add( "sor_pgs_w"                 , double_t, 1                            ,    "Relaxation parameter for SOR PGS LCP, usually set to 1.3, but reduce to stabilize simulation."           , 1.3      , 0   , 5)
+gen.add( "sor_pgs_rms_error_tol"     , double_t, 1                            ,    "The number of scans to skip between each measured scan"                                                  , -1       , -1  , 10000)
+gen.add( "cfm"                       , double_t, 1                            ,    "Constraint Force Mixing per ODE's users manual."                                                         , 0        , 0   , 10)
+gen.add( "erp"                       , double_t, 1                            ,    "Error Reduction Parameter per ODE's users manual."                                                       , 0.2      , 0   , 10)
+gen.add( "contact_surface_layer"     , double_t, 1                            ,    "Margin for penetration for which restorative forces are not applied."                                    , 0.001    , 0   , 10)
+gen.add( "contact_max_correcting_vel", double_t, 1                            ,    "Maximum contact penetration correction velocity."                                                        , 100      , 0   , 10000000)
+gen.add( "max_contacts"              , int_t   , 1                            ,    "Maximum number of contacts between any 2 bodies."                                                        , 100      , 0   , 10000000)
+
+exit(gen.generate(PACKAGE, "physics_node", "Physics"))
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/colcon.pkg
@@ -0,0 +1,8 @@
+# Configuration file for colcon (https://colcon.readthedocs.io).
+#
+# Please see the doc for the details of the spec:
+#   - https://colcon.readthedocs.io/en/released/user/configuration.html#colcon-pkg-files
+
+{
+  "dependencies": ["Gazebo"],
+}
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/include/gazebo_ros/gazebo_ros_api_plugin.h
@@ -0,0 +1,445 @@
+/*
+ * Copyright (C) 2012-2014 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+/*
+ * Desc: External interfaces for Gazebo
+ * Author: Nate Koenig, John Hsu, Dave Coleman
+ * Date: 25 Apr 2010
+ */
+
+#ifndef __GAZEBO_ROS_API_PLUGIN_HH__
+#define __GAZEBO_ROS_API_PLUGIN_HH__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <errno.h>
+#include <iostream>
+
+#include <tinyxml.h>
+
+#include <gazebo/physics/physics.hh>
+#include <gazebo/common/common.hh>
+#include <gazebo/transport/transport.hh>
+
+// ROS
+#include <ros/ros.h>
+#include <ros/callback_queue.h>
+#include <ros/subscribe_options.h>
+#include <ros/package.h>
+#include <rosgraph_msgs/Clock.h>
+
+// Services
+#include "std_srvs/Empty.h"
+
+#include "gazebo_msgs/JointRequest.h"
+#include "gazebo_msgs/BodyRequest.h"
+
+#include "gazebo_msgs/SpawnModel.h"
+#include "gazebo_msgs/DeleteModel.h"
+#include "gazebo_msgs/DeleteLight.h"
+
+#include "gazebo_msgs/ApplyBodyWrench.h"
+
+#include "gazebo_msgs/SetPhysicsProperties.h"
+#include "gazebo_msgs/GetPhysicsProperties.h"
+
+#include "gazebo_msgs/SetJointProperties.h"
+
+#include "gazebo_msgs/GetWorldProperties.h"
+
+#include "gazebo_msgs/GetModelProperties.h"
+#include "gazebo_msgs/GetModelState.h"
+#include "gazebo_msgs/SetModelState.h"
+
+#include "gazebo_msgs/GetJointProperties.h"
+#include "gazebo_msgs/ApplyJointEffort.h"
+
+#include "gazebo_msgs/GetLinkProperties.h"
+#include "gazebo_msgs/SetLinkProperties.h"
+#include "gazebo_msgs/SetLinkState.h"
+#include "gazebo_msgs/GetLinkState.h"
+
+#include "gazebo_msgs/GetLightProperties.h"
+#include "gazebo_msgs/SetLightProperties.h"
+
+// Topics
+#include "gazebo_msgs/ModelState.h"
+#include "gazebo_msgs/LinkState.h"
+#include "gazebo_msgs/ModelStates.h"
+#include "gazebo_msgs/LinkStates.h"
+#include "gazebo_msgs/PerformanceMetrics.h"
+
+#include "geometry_msgs/Vector3.h"
+#include "geometry_msgs/Wrench.h"
+#include "geometry_msgs/Pose.h"
+#include "geometry_msgs/Twist.h"
+
+// For model pose transform to set custom joint angles
+#include <ros/ros.h>
+#include <gazebo_msgs/SetModelConfiguration.h>
+#include <boost/shared_ptr.hpp>
+
+// For physics dynamics reconfigure
+#include <dynamic_reconfigure/server.h>
+#include <gazebo_ros/PhysicsConfig.h>
+#include "gazebo_msgs/SetPhysicsProperties.h"
+#include "gazebo_msgs/GetPhysicsProperties.h"
+
+#include <boost/algorithm/string.hpp>
+
+#ifndef GAZEBO_ROS_HAS_PERFORMANCE_METRICS
+#if (GAZEBO_MAJOR_VERSION == 11 && GAZEBO_MINOR_VERSION > 1) || \
+    (GAZEBO_MAJOR_VERSION == 9 && GAZEBO_MINOR_VERSION > 14)
+#define GAZEBO_ROS_HAS_PERFORMANCE_METRICS
+#endif
+#endif  // ifndef GAZEBO_ROS_HAS_PERFORMANCE_METRICS
+
+namespace gazebo
+{
+
+/// \brief A plugin loaded within the gzserver on startup.
+class GazeboRosApiPlugin : public SystemPlugin
+{
+public:
+  /// \brief Constructor
+  GazeboRosApiPlugin();
+
+  /// \brief Destructor
+  ~GazeboRosApiPlugin();
+
+  /// \bried Detect if sig-int shutdown signal is recieved
+  void shutdownSignal();
+
+  /// \brief Gazebo-inherited load function
+  ///
+  /// Called before Gazebo is loaded. Must not block.
+  /// Capitalized per Gazebo cpp style guidelines
+  /// \param _argc Number of command line arguments.
+  /// \param _argv Array of command line arguments.
+  void Load(int argc, char** argv);
+
+  /// \brief ros queue thread for this node
+  void gazeboQueueThread();
+
+  /// \brief advertise services
+  void advertiseServices();
+
+  /// \brief Callback for a subscriber connecting to LinkStates ros topic.
+  void onLinkStatesConnect();
+
+  /// \brief Callback for a subscriber connecting to ModelStates ros topic.
+  void onModelStatesConnect();
+
+  /// \brief Callback for a subscriber disconnecting from LinkStates ros topic.
+  void onLinkStatesDisconnect();
+
+  /// \brief Callback for a subscriber disconnecting from ModelStates ros topic.
+  void onModelStatesDisconnect();
+
+#ifdef GAZEBO_ROS_HAS_PERFORMANCE_METRICS
+  /// \brief Callback for a subscriber connecting to PerformanceMetrics ros topic.
+  void onPerformanceMetricsConnect();
+
+  /// \brief Callback for a subscriber disconnecting from PerformanceMetrics ros topic.
+  void onPerformanceMetricsDisconnect();
+#endif
+
+  /// \brief Function for inserting a URDF into Gazebo from ROS Service Call
+  bool spawnURDFModel(gazebo_msgs::SpawnModel::Request &req,
+                      gazebo_msgs::SpawnModel::Response &res);
+
+  /// \brief Both SDFs and converted URDFs get sent to this function for further manipulation from a ROS Service call
+  bool spawnSDFModel(gazebo_msgs::SpawnModel::Request &req,
+                     gazebo_msgs::SpawnModel::Response &res);
+
+  /// \brief delete model given name
+  bool deleteModel(gazebo_msgs::DeleteModel::Request &req,gazebo_msgs::DeleteModel::Response &res);
+
+  /// \brief delete a given light by name
+  bool deleteLight(gazebo_msgs::DeleteLight::Request &req,gazebo_msgs::DeleteLight::Response &res);
+
+  /// \brief
+  bool getModelState(gazebo_msgs::GetModelState::Request &req,gazebo_msgs::GetModelState::Response &res);
+
+  /// \brief
+  bool getModelProperties(gazebo_msgs::GetModelProperties::Request &req,gazebo_msgs::GetModelProperties::Response &res);
+
+  /// \brief
+  bool getWorldProperties(gazebo_msgs::GetWorldProperties::Request &req,gazebo_msgs::GetWorldProperties::Response &res);
+
+  /// \brief
+  bool getJointProperties(gazebo_msgs::GetJointProperties::Request &req,gazebo_msgs::GetJointProperties::Response &res);
+
+  /// \brief
+  bool getLinkProperties(gazebo_msgs::GetLinkProperties::Request &req,gazebo_msgs::GetLinkProperties::Response &res);
+
+  /// \brief
+  bool getLinkState(gazebo_msgs::GetLinkState::Request &req,gazebo_msgs::GetLinkState::Response &res);
+
+  /// \brief
+  bool getLightProperties(gazebo_msgs::GetLightProperties::Request &req,gazebo_msgs::GetLightProperties::Response &res);
+
+  /// \brief
+  bool setLightProperties(gazebo_msgs::SetLightProperties::Request &req,gazebo_msgs::SetLightProperties::Response &res);
+
+  /// \brief
+  bool setLinkProperties(gazebo_msgs::SetLinkProperties::Request &req,gazebo_msgs::SetLinkProperties::Response &res);
+
+  /// \brief
+  bool setPhysicsProperties(gazebo_msgs::SetPhysicsProperties::Request &req,gazebo_msgs::SetPhysicsProperties::Response &res);
+
+  /// \brief
+  bool getPhysicsProperties(gazebo_msgs::GetPhysicsProperties::Request &req,gazebo_msgs::GetPhysicsProperties::Response &res);
+
+  /// \brief
+  bool setJointProperties(gazebo_msgs::SetJointProperties::Request &req,gazebo_msgs::SetJointProperties::Response &res);
+
+  /// \brief
+  bool setModelState(gazebo_msgs::SetModelState::Request &req,gazebo_msgs::SetModelState::Response &res);
+
+  /// \brief
+  void updateModelState(const gazebo_msgs::ModelState::ConstPtr& model_state);
+
+  /// \brief
+  bool applyJointEffort(gazebo_msgs::ApplyJointEffort::Request &req,gazebo_msgs::ApplyJointEffort::Response &res);
+
+  /// \brief
+  bool resetSimulation(std_srvs::Empty::Request &req,std_srvs::Empty::Response &res);
+
+  /// \brief
+  bool resetWorld(std_srvs::Empty::Request &req,std_srvs::Empty::Response &res);
+
+  /// \brief
+  bool pausePhysics(std_srvs::Empty::Request &req,std_srvs::Empty::Response &res);
+
+  /// \brief
+  bool unpausePhysics(std_srvs::Empty::Request &req,std_srvs::Empty::Response &res);
+
+  /// \brief
+  bool clearJointForces(gazebo_msgs::JointRequest::Request &req,gazebo_msgs::JointRequest::Response &res);
+  bool clearJointForces(std::string joint_name);
+
+  /// \brief
+  bool clearBodyWrenches(gazebo_msgs::BodyRequest::Request &req,gazebo_msgs::BodyRequest::Response &res);
+  bool clearBodyWrenches(std::string body_name);
+
+  /// \brief
+  bool setModelConfiguration(gazebo_msgs::SetModelConfiguration::Request &req,gazebo_msgs::SetModelConfiguration::Response &res);
+
+  /// \brief
+  bool setLinkState(gazebo_msgs::SetLinkState::Request &req,gazebo_msgs::SetLinkState::Response &res);
+
+  /// \brief
+  void updateLinkState(const gazebo_msgs::LinkState::ConstPtr& link_state);
+
+  /// \brief
+  bool applyBodyWrench(gazebo_msgs::ApplyBodyWrench::Request &req,gazebo_msgs::ApplyBodyWrench::Response &res);
+
+private:
+
+  /// \brief
+  void wrenchBodySchedulerSlot();
+
+  /// \brief
+  void forceJointSchedulerSlot();
+
+  /// \brief Callback to WorldUpdateBegin that publishes /clock.
+  /// If pub_clock_frequency_ <= 0 (default behavior), it publishes every time step.
+  /// Otherwise, it attempts to publish at that frequency in Hz.
+  void publishSimTime();
+
+  /// \brief
+  void publishLinkStates();
+
+  /// \brief
+  void publishModelStates();
+
+  /// \brief
+  void stripXmlDeclaration(std::string &model_xml);
+
+  /// \brief Update the model name and pose of the SDF file before sending to Gazebo
+  void updateSDFAttributes(TiXmlDocument &gazebo_model_xml,
+                           const std::string &model_name,
+                           const ignition::math::Vector3d &initial_xyz,
+                           const ignition::math::Quaterniond &initial_q);
+
+  /// \brief Update the model pose of the URDF file before sending to Gazebo
+  void updateURDFModelPose(TiXmlDocument &gazebo_model_xml,
+                           const ignition::math::Vector3d &initial_xyz,
+                           const ignition::math::Quaterniond &initial_q);
+
+  /// \brief Update the model name of the URDF file before sending to Gazebo
+  void updateURDFName(TiXmlDocument &gazebo_model_xml, const std::string &model_name);
+
+  /// \brief
+  void walkChildAddRobotNamespace(TiXmlNode* model_xml);
+
+  /// \brief
+  bool spawnAndConform(TiXmlDocument &gazebo_model_xml, const std::string &model_name,
+                       gazebo_msgs::SpawnModel::Response &res);
+
+  /// \brief helper function for applyBodyWrench
+  ///        shift wrench from reference frame to target frame
+  void transformWrench(ignition::math::Vector3d &target_force, ignition::math::Vector3d &target_torque,
+                       const ignition::math::Vector3d &reference_force,
+                       const ignition::math::Vector3d &reference_torque,
+                       const ignition::math::Pose3d &target_to_reference );
+
+  /// \brief Used for the dynamic reconfigure callback function template
+  void physicsReconfigureCallback(gazebo_ros::PhysicsConfig &config, uint32_t level);
+
+  /// \brief waits for the rest of Gazebo to be ready before initializing the dynamic reconfigure services
+  void physicsReconfigureThread();
+
+  /// \brief Unused
+  void onResponse(ConstResponsePtr &response);
+
+#ifdef GAZEBO_ROS_HAS_PERFORMANCE_METRICS
+  /// \brief Subscriber callback for performance metrics. This will be send in the ROS network
+  void onPerformanceMetrics(const boost::shared_ptr<gazebo::msgs::PerformanceMetrics const> &msg);
+#endif
+  /// \brief utility for checking if string is in URDF format
+  bool isURDF(std::string model_xml);
+
+  /// \brief utility for checking if string is in SDF format
+  bool isSDF(std::string model_xml);
+
+  /// \brief Connect to Gazebo via its plugin interface, get a pointer to the world, start events
+  void loadGazeboRosApiPlugin(std::string world_name);
+
+  /// \brief convert xml to Pose
+  ignition::math::Pose3d parsePose(const std::string &str);
+
+  /// \brief convert xml to Pose
+  ignition::math::Vector3d parseVector3(const std::string &str);
+
+  // track if the desconstructor event needs to occur
+  bool plugin_loaded_;
+
+  // detect if sigint event occurs
+  bool stop_;
+  gazebo::event::ConnectionPtr sigint_event_;
+
+  std::string robot_namespace_;
+
+  gazebo::transport::NodePtr gazebonode_;
+  gazebo::transport::SubscriberPtr stat_sub_;
+  gazebo::transport::PublisherPtr factory_pub_;
+  gazebo::transport::PublisherPtr factory_light_pub_;
+  gazebo::transport::PublisherPtr light_modify_pub_;
+  gazebo::transport::SubscriberPtr performance_metric_sub_;
+  gazebo::transport::PublisherPtr request_pub_;
+  gazebo::transport::SubscriberPtr response_sub_;
+
+  boost::shared_ptr<ros::NodeHandle> nh_;
+  ros::CallbackQueue gazebo_queue_;
+  boost::shared_ptr<boost::thread> gazebo_callback_queue_thread_;
+
+  gazebo::physics::WorldPtr world_;
+  gazebo::event::ConnectionPtr wrench_update_event_;
+  gazebo::event::ConnectionPtr force_update_event_;
+  gazebo::event::ConnectionPtr time_update_event_;
+  gazebo::event::ConnectionPtr pub_link_states_event_;
+  gazebo::event::ConnectionPtr pub_model_states_event_;
+  gazebo::event::ConnectionPtr load_gazebo_ros_api_plugin_event_;
+
+  ros::ServiceServer spawn_sdf_model_service_;
+  ros::ServiceServer spawn_urdf_model_service_;
+  ros::ServiceServer delete_model_service_;
+  ros::ServiceServer delete_light_service_;
+  ros::ServiceServer get_model_state_service_;
+  ros::ServiceServer get_model_properties_service_;
+  ros::ServiceServer get_world_properties_service_;
+  ros::ServiceServer get_joint_properties_service_;
+  ros::ServiceServer get_link_properties_service_;
+  ros::ServiceServer get_link_state_service_;
+  ros::ServiceServer get_light_properties_service_;
+  ros::ServiceServer set_light_properties_service_;
+  ros::ServiceServer set_link_properties_service_;
+  ros::ServiceServer set_physics_properties_service_;
+  ros::ServiceServer get_physics_properties_service_;
+  ros::ServiceServer apply_body_wrench_service_;
+  ros::ServiceServer set_joint_properties_service_;
+  ros::ServiceServer set_model_state_service_;
+  ros::ServiceServer apply_joint_effort_service_;
+  ros::ServiceServer set_model_configuration_service_;
+  ros::ServiceServer set_link_state_service_;
+  ros::ServiceServer reset_simulation_service_;
+  ros::ServiceServer reset_world_service_;
+  ros::ServiceServer pause_physics_service_;
+  ros::ServiceServer unpause_physics_service_;
+  ros::ServiceServer clear_joint_forces_service_;
+  ros::ServiceServer clear_body_wrenches_service_;
+  ros::Subscriber    set_link_state_topic_;
+  ros::Subscriber    set_model_state_topic_;
+  ros::Publisher     pub_link_states_;
+  ros::Publisher     pub_model_states_;
+  ros::Publisher     pub_performance_metrics_;
+  int                pub_link_states_connection_count_;
+  int                pub_model_states_connection_count_;
+  int                pub_performance_metrics_connection_count_;
+
+  // ROS comm
+  boost::shared_ptr<ros::AsyncSpinner> async_ros_spin_;
+
+  // physics dynamic reconfigure
+  boost::shared_ptr<boost::thread> physics_reconfigure_thread_;
+  bool physics_reconfigure_initialized_;
+  ros::ServiceClient physics_reconfigure_set_client_;
+  ros::ServiceClient physics_reconfigure_get_client_;
+  boost::shared_ptr< dynamic_reconfigure::Server<gazebo_ros::PhysicsConfig> > physics_reconfigure_srv_;
+  dynamic_reconfigure::Server<gazebo_ros::PhysicsConfig>::CallbackType physics_reconfigure_callback_;
+
+  ros::Publisher     pub_clock_;
+  int pub_clock_frequency_;
+  gazebo::common::Time last_pub_clock_time_;
+
+  /// \brief A mutex to lock access to fields that are used in ROS message callbacks
+  boost::mutex lock_;
+
+  bool world_created_;
+
+  class WrenchBodyJob
+  {
+  public:
+    gazebo::physics::LinkPtr body;
+    ignition::math::Vector3d force;
+    ignition::math::Vector3d torque;
+    ros::Time start_time;
+    ros::Duration duration;
+  };
+
+  class ForceJointJob
+  {
+  public:
+    gazebo::physics::JointPtr joint;
+    double force; // should this be a array?
+    ros::Time start_time;
+    ros::Duration duration;
+  };
+
+  std::vector<GazeboRosApiPlugin::WrenchBodyJob*> wrench_body_jobs_;
+  std::vector<GazeboRosApiPlugin::ForceJointJob*> force_joint_jobs_;
+
+  /// \brief index counters to count the accesses on models via GetModelState
+  std::map<std::string, unsigned int> access_count_get_model_state_;
+
+  /// \brief enable the communication of gazebo information using ROS service/topics
+  bool enable_ros_network_;
+};
+}
+#endif
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/launch/elevator_world.launch
@@ -0,0 +1,44 @@
+<?xml version="1.0"?>
+<launch>
+
+  <!-- these are the arguments you can pass this launch file, for example paused:=true -->
+  <arg name="paused" default="false"/>
+  <arg name="use_sim_time" default="true"/>
+  <arg name="extra_gazebo_args" default=""/>
+  <arg name="gui" default="true"/>
+  <arg name="recording" default="false"/>
+  <!-- Note that 'headless' is currently non-functional.  See gazebo_ros_pkgs issue #491 (-r arg does not disable
+       rendering, but instead enables recording). The arg definition has been left here to prevent breaking downstream
+       launch files, but it does nothing. -->
+  <arg name="headless" default="false"/>
+  <arg name="debug" default="false"/>
+  <arg name="physics" default="ode"/>
+  <arg name="verbose" default="true"/>
+  <arg name="output" default="screen"/>
+  <arg name="world_name" default="worlds/elevator_ros.world"/> <!-- Note: the world_name is with respect to GAZEBO_RESOURCE_PATH environmental variable -->
+
+  <!-- set use_sim_time flag -->
+  <group if="$(arg use_sim_time)">
+    <param name="/use_sim_time" value="true" />
+  </group>
+
+  <!-- set command arguments -->
+  <arg unless="$(arg paused)" name="command_arg1" value=""/>
+  <arg     if="$(arg paused)" name="command_arg1" value="-u"/>
+  <arg unless="$(arg recording)" name="command_arg2" value=""/>
+  <arg     if="$(arg recording)" name="command_arg2" value="-r"/>
+  <arg unless="$(arg verbose)" name="command_arg3" value=""/>
+  <arg     if="$(arg verbose)" name="command_arg3" value="--verbose"/>
+  <arg unless="$(arg debug)" name="script_type" value="gzserver"/>
+  <arg     if="$(arg debug)" name="script_type" value="debug"/>
+
+  <!-- start gazebo server-->
+  <node name="gazebo" pkg="gazebo_ros" type="$(arg script_type)" respawn="false" output="$(arg output)"
+  args="$(arg command_arg1) $(arg command_arg2) $(arg command_arg3) -e $(arg physics) $(arg extra_gazebo_args) $(arg world_name)" />
+
+  <!-- start gazebo client -->
+  <group if="$(arg gui)">
+    <node name="gazebo_gui" pkg="gazebo_ros" type="gzclient" respawn="false" output="$(arg output)"/>
+  </group>
+
+</launch>
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/launch/empty_world.launch
@@ -0,0 +1,56 @@
+<?xml version="1.0"?>
+<launch>
+
+  <!-- these are the arguments you can pass this launch file, for example paused:=true -->
+  <arg name="paused" default="false"/>
+  <arg name="use_sim_time" default="true"/>
+  <arg name="extra_gazebo_args" default=""/>
+  <arg name="gui" default="true"/>
+  <arg name="recording" default="false"/>
+  <!-- Note that 'headless' is currently non-functional.  See gazebo_ros_pkgs issue #491 (-r arg does not disable
+       rendering, but instead enables recording). The arg definition has been left here to prevent breaking downstream
+       launch files, but it does nothing. -->
+  <arg name="headless" default="false"/>
+  <arg name="debug" default="false"/>
+  <arg name="physics" default="ode"/>
+  <arg name="verbose" default="false"/>
+  <arg name="output" default="screen"/>
+  <arg name="world_name" default="worlds/empty.world"/> <!-- Note: the world_name is with respect to GAZEBO_RESOURCE_PATH environmental variable -->
+  <arg name="respawn_gazebo" default="false"/>
+  <arg name="use_clock_frequency" default="false"/>
+  <arg name="pub_clock_frequency" default="100"/>
+  <arg name="enable_ros_network" default="true" />
+  <arg name="server_required" default="false"/>
+  <arg name="gui_required" default="false"/>
+
+  <!-- set use_sim_time flag -->
+  <param name="/use_sim_time" value="$(arg use_sim_time)"/>
+
+  <!-- set command arguments -->
+  <arg unless="$(arg paused)" name="command_arg1" value=""/>
+  <arg     if="$(arg paused)" name="command_arg1" value="-u"/>
+  <arg unless="$(arg recording)" name="command_arg2" value=""/>
+  <arg     if="$(arg recording)" name="command_arg2" value="-r"/>
+  <arg unless="$(arg verbose)" name="command_arg3" value=""/>
+  <arg     if="$(arg verbose)" name="command_arg3" value="--verbose"/>
+  <arg unless="$(arg debug)" name="script_type" value="gzserver"/>
+  <arg     if="$(arg debug)" name="script_type" value="debug"/>
+
+  <!-- start gazebo server-->
+  <group if="$(arg use_clock_frequency)">
+    <param name="gazebo/pub_clock_frequency" value="$(arg pub_clock_frequency)" />
+  </group>
+  <group>
+    <param name="gazebo/enable_ros_network" value="$(arg enable_ros_network)" />
+  </group>
+  <node name="gazebo" pkg="gazebo_ros" type="$(arg script_type)" respawn="$(arg respawn_gazebo)" output="$(arg output)"
+	args="$(arg command_arg1) $(arg command_arg2) $(arg command_arg3) -e $(arg physics) $(arg extra_gazebo_args) $(arg world_name)"
+  required="$(arg server_required)" />
+
+  <!-- start gazebo client -->
+  <group if="$(arg gui)">
+    <node name="gazebo_gui" pkg="gazebo_ros" type="gzclient" respawn="false" output="$(arg output)" args="$(arg command_arg3)"
+    required="$(arg gui_required)"/>
+  </group>
+
+</launch>
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/launch/mud_world.launch
@@ -0,0 +1,15 @@
+<?xml version="1.0"?>
+<launch>
+
+  <!-- We resume the logic in empty_world.launch, changing only the name of the world to be launched -->
+  <include file="$(find gazebo_ros)/launch/empty_world.launch">
+    <arg name="world_name" value="worlds/mud.world"/> <!-- Note: the world_name is with respect to GAZEBO_RESOURCE_PATH environmental variable -->
+    <arg name="paused" value="false"/>
+    <arg name="use_sim_time" value="true"/>
+    <arg name="gui" value="true"/>
+    <arg name="headless" value="false"/> <!-- Inert - see gazebo_ros_pkgs issue #491 -->
+    <arg name="recording" value="false"/>
+    <arg name="debug" value="false"/>
+  </include>
+
+</launch>
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/launch/range_world.launch
@@ -0,0 +1,28 @@
+<?xml version="1.0"?>
+<launch>
+
+  <!-- these are the arguments you can pass this launch file, for example paused:=true -->
+  <arg name="paused" default="false"/>
+  <arg name="use_sim_time" default="true"/>
+  <arg name="extra_gazebo_args" default=""/>
+  <arg name="gui" default="true"/>
+  <arg name="debug" default="false"/>
+  <arg name="physics" default="ode"/>
+  <arg name="verbose" default="true"/>
+  <arg name="output" default="screen"/>
+  <arg name="world" default="gazebo_ros_range"/>
+
+  <include file="$(find gazebo_ros)/launch/empty_world.launch">
+    <arg name="world_name" value="$(find gazebo_plugins)/test/test_worlds/$(arg world).world"/>
+    <arg name="paused" value="$(arg paused)"/>
+    <arg name="use_sim_time" value="$(arg use_sim_time)"/>
+    <arg name="extra_gazebo_args" value="$(arg extra_gazebo_args)"/>
+    <arg name="gui" value="$(arg gui)"/>
+    <arg name="debug" value="$(arg debug)"/>
+    <arg name="physics" value="$(arg physics)"/>
+    <arg name="verbose" value="$(arg verbose)"/>
+    <arg name="output" value="$(arg output)"/>
+  </include>
+
+</launch>
+
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/launch/rubble_world.launch
@@ -0,0 +1,15 @@
+<?xml version="1.0"?>
+<launch>
+
+  <!-- We resume the logic in empty_world.launch, changing only the name of the world to be launched -->
+  <include file="$(find gazebo_ros)/launch/empty_world.launch">
+    <arg name="world_name" value="worlds/rubble.world"/> <!-- Note: the world_name is with respect to GAZEBO_RESOURCE_PATH environmental variable -->
+    <arg name="paused" value="false"/>
+    <arg name="use_sim_time" value="true"/>
+    <arg name="gui" value="true"/>
+    <arg name="headless" value="false"/> <!-- Inert - see gazebo_ros_pkgs issue #491 -->
+    <arg name="recording" value="false"/>
+    <arg name="debug" value="false"/>
+  </include>
+
+</launch>
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/launch/shapes_world.launch
@@ -0,0 +1,15 @@
+<?xml version="1.0"?>
+<launch>
+
+  <!-- We resume the logic in empty_world.launch, changing only the name of the world to be launched -->
+  <include file="$(find gazebo_ros)/launch/empty_world.launch">
+    <arg name="world_name" value="worlds/shapes.world"/> <!-- Note: the world_name is with respect to GAZEBO_RESOURCE_PATH environmental variable -->
+    <arg name="paused" value="false"/>
+    <arg name="use_sim_time" value="true"/>
+    <arg name="gui" value="true"/>
+    <arg name="headless" value="false"/> <!-- Inert - see gazebo_ros_pkgs issue #491 -->
+    <arg name="recording" value="false"/>
+    <arg name="debug" value="false"/>
+  </include>
+
+</launch>
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/launch/willowgarage_world.launch
@@ -0,0 +1,15 @@
+<?xml version="1.0"?>
+<launch>
+
+  <!-- We resume the logic in empty_world.launch, changing only the name of the world to be launched -->
+  <include file="$(find gazebo_ros)/launch/empty_world.launch">
+    <arg name="world_name" value="worlds/willowgarage.world"/> <!-- Note: the world_name is with respect to GAZEBO_RESOURCE_PATH environmental variable -->
+    <arg name="paused" value="false"/>
+    <arg name="use_sim_time" value="true"/>
+    <arg name="gui" value="true"/>
+    <arg name="headless" value="false"/> <!-- Inert - see gazebo_ros_pkgs issue #491 -->
+    <arg name="recording" value="false"/>
+    <arg name="debug" value="false"/>
+  </include>
+
+</launch>
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/package.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0"?>
+<package format="2">
+  <name>gazebo_ros</name>
+  <version>2.9.2</version>
+  <description>
+    Provides ROS plugins that offer message and service publishers for interfacing with <a href="http://gazebosim.org">Gazebo</a> through ROS.
+    Formally simulator_gazebo/gazebo
+  </description>
+
+  <maintainer email="jrivero@osrfoundation.org">Jose Luis Rivero</maintainer>
+
+  <license>Apache 2.0</license>
+
+  <url type="website">http://gazebosim.org/tutorials?cat=connect_ros</url>
+  <url type="bugtracker">https://github.com/ros-simulation/gazebo_ros_pkgs/issues</url>
+  <url type="repository">https://github.com/ros-simulation/gazebo_ros_pkgs</url>
+
+  <author>John Hsu</author>
+  <author>Nate Koenig</author>
+  <author>Dave Coleman</author>
+
+  <buildtool_depend>catkin</buildtool_depend>
+
+  <build_depend>cmake_modules</build_depend>
+  <build_depend>gazebo_dev</build_depend>
+  <!--
+    Need to use gazebo_dev since run script needs pkg-config
+    See: https://github.com/ros-simulation/gazebo_ros_pkgs/issues/323 for more info
+  -->
+  <exec_depend>gazebo_dev</exec_depend>
+  <depend>gazebo_msgs</depend>
+  <depend>roslib</depend>
+  <depend>roscpp</depend>
+  <depend>tf</depend>
+  <depend>std_srvs</depend>
+  <depend>rosgraph_msgs</depend>
+  <depend>dynamic_reconfigure</depend>
+  <depend>std_msgs</depend>
+  <depend>geometry_msgs</depend>
+  <depend>tinyxml</depend>
+  <exec_depend>python-argparse</exec_depend>
+
+</package>
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/scripts/debug
@@ -0,0 +1,22 @@
+#!/bin/sh
+final="$@"
+
+EXT=so
+if [ $(uname) = "Darwin" ]; then
+    EXT=dylib
+fi
+
+# add ros path plugin if it does not already exist in the passed in arguments
+if [ `expr "$final" : ".*libgazebo_ros_paths_plugin\.$EXT.*"` -eq 0 ]
+then
+    final="$final -s `catkin_find --first-only libgazebo_ros_paths_plugin.$EXT`"
+fi
+
+# add ros api plugin if it does not already exist in the passed in arguments
+if [ `expr "$final" : ".*libgazebo_ros_api_plugin\.$EXT.*"` -eq 0 ]
+then
+    final="$final -s `catkin_find --first-only libgazebo_ros_api_plugin.$EXT`"
+fi
+
+setup_path=$(pkg-config --variable=prefix gazebo)/share/gazebo/
+. $setup_path/setup.sh && rosrun gazebo_ros gdbrun gzserver $final
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/scripts/debug.bat
@@ -0,0 +1,53 @@
+@echo off
+SETLOCAL EnableDelayedExpansion
+
+SET "DESIRED_MASTER_URI=%GAZEBO_MASTER_URI%"
+SET "DESIRED_MODEL_DATABASE_URI=%GAZEBO_MODEL_DATABASE_URI%"
+
+SET "FINAL=%*"
+
+call :FIND_IN_WORKSPACES gazebo_ros_paths_plugin.dll
+SET "FINAL=%FINAL% -g %FIND_IN_WORKSPACES_OUTPUT%"
+
+call :FIND_IN_WORKSPACES gazebo_ros_api_plugin.dll
+SET "FINAL=%FINAL% -g %FIND_IN_WORKSPACES_OUTPUT%"
+
+SET GAZEBO_SETUP=
+FOR /F "tokens=* USEBACKQ" %%F IN (`pkg-config --variable=prefix gazebo`) DO (
+SET "GAZEBO_SETUP=%%F/share/gazebo/setup.bat"
+)
+
+SET REMAPPINGS_OUTPUT=
+SET OPTIONS_OUTPUT=
+call :RELOCATE_REMAPPINGS %FINAL%
+
+ENDLOCAL & SET "GAZEBO_OPTIONS=%OPTIONS_OUTPUT%%REMAPPINGS_OUTPUT%" & SET "GAZEBO_SETUP=%GAZEBO_SETUP%" & SET "DESIRED_MASTER_URI=%DESIRED_MASTER_URI%" & SET "DESIRED_MODEL_DATABASE_URI=%DESIRED_MODEL_DATABASE_URI%"
+
+CALL %GAZEBO_SETUP%
+SET "GAZEBO_MASTER_URI=%DESIRED_MASTER_URI%"
+SET "GAZEBO_MODEL_DATABASE_URI=%DESIRED_MODEL_DATABASE_URI%"
+gzserver %GAZEBO_OPTIONS%
+
+GOTO :EOF
+
+:RELOCATE_REMAPPINGS
+FOR /F "tokens=1*" %%A IN ("%*") DO (
+    SET _REMAPPING=0
+    SET _TEMP_VAR=%%A
+    FOR %%A IN (!_TEMP_VAR!) DO (
+        IF NOT "%%A"=="!_TEMP_VAR!" SET _REMAPPING=1
+    )
+    IF !_REMAPPING!==1 (
+        SET "REMAPPINGS_OUTPUT=!REMAPPINGS_OUTPUT! !_TEMP_VAR!"
+    ) ELSE (
+        SET "OPTIONS_OUTPUT=!OPTIONS_OUTPUT! !_TEMP_VAR!"
+    )
+    IF NOT "%%B"=="" call :RELOCATE_REMAPPINGS %%B
+)
+EXIT /B
+
+:FIND_IN_WORKSPACES
+FOR /F "tokens=* USEBACKQ" %%F IN (`python -c "from catkin.find_in_workspaces import find_in_workspaces as catkin_find; print(catkin_find(path='%*')[0])"`) DO (
+SET "FIND_IN_WORKSPACES_OUTPUT="%%F""
+)
+EXIT /B
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/scripts/gazebo
@@ -0,0 +1,55 @@
+#!/bin/sh
+[ -L ${0} ] && SCRIPT_DIR=$(readlink ${0}) || SCRIPT_DIR=${0}
+SCRIPT_DIR=$(dirname ${SCRIPT_DIR})
+
+. ${SCRIPT_DIR}/libcommon.sh
+
+final="$@"
+
+EXT=so
+if [ $(uname) = "Darwin" ]; then
+    EXT=dylib
+fi
+
+# add ros path plugin if it does not already exist in the passed in arguments
+if [ `expr "$final" : ".*libgazebo_ros_paths_plugin\.$EXT.*"` -eq 0 ]
+then
+    final="$final -s `catkin_find --first-only libgazebo_ros_paths_plugin.$EXT`"
+fi
+
+# add ros api plugin if it does not already exist in the passed in arguments
+if [ `expr "$final" : ".*libgazebo_ros_api_plugin\.$EXT.*"` -eq 0 ]
+then
+    final="$final -s `catkin_find --first-only libgazebo_ros_api_plugin.$EXT`"
+fi
+
+client_final="-g `catkin_find --first-only libgazebo_ros_paths_plugin.$EXT`"
+
+setup_path=$(pkg-config --variable=prefix gazebo)/share/gazebo/
+
+# source setup.sh, but keep local modifications to GAZEBO_MASTER_URI and GAZEBO_MODEL_DATABASE_URI
+desired_master_uri="$GAZEBO_MASTER_URI"
+desired_model_database_uri="$GAZEBO_MODEL_DATABASE_URI"
+. $setup_path/setup.sh
+if [ "$desired_master_uri" = "" ]; then
+	desired_master_uri="$GAZEBO_MASTER_URI"
+fi
+if [ "$desired_model_database_uri" = "" ]; then
+	desired_model_database_uri="$GAZEBO_MODEL_DATABASE_URI"
+fi
+
+final=$(relocate_remappings "${final}")
+
+# Combine the commands
+GAZEBO_MASTER_URI="$desired_master_uri" GAZEBO_MODEL_DATABASE_URI="$desired_model_database_uri" gzserver $final &
+gzserver_pid="$!"
+# Use kill -0 to check if the process is running
+if $(kill -0 $! 2> /dev/null); then
+  GAZEBO_MASTER_URI="$desired_master_uri" GAZEBO_MODEL_DATABASE_URI="$desired_model_database_uri" gzclient $client_final
+fi
+
+# Kill the server if it is alive
+if $(kill -0 $! 2> /dev/null); then
+  # -2 SIGINT valid for Linux and Mac
+  kill -2 $!
+fi
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/scripts/gdbrun
@@ -0,0 +1,25 @@
+#!/bin/bash
+extra_text=""
+if [ "$1" = "--break-main" ]; then
+  extra_text="break main"
+  shift
+fi
+
+EXEC="$1"
+
+shift
+
+run_text="run"
+for a in "$@"; do
+  run_text="${run_text} \"$a\""
+done
+
+TMPFILE=/tmp/gdbrun.$$.$#.tmp
+cat > ${TMPFILE} <<EOF
+${extra_text}
+${run_text}
+EOF
+
+gdb -x ${TMPFILE} "${EXEC}"
+rm -f "${TMPFILE}"
+
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/scripts/gzclient
@@ -0,0 +1,42 @@
+#!/bin/sh
+[ -L ${0} ] && SCRIPT_DIR=$(readlink ${0}) || SCRIPT_DIR=${0}
+SCRIPT_DIR=$(dirname ${SCRIPT_DIR})
+
+. ${SCRIPT_DIR}/libcommon.sh
+
+final="$@"
+
+EXT=so
+if [ $(uname) = "Darwin" ]; then
+    EXT=dylib
+fi
+
+# add ros plugin if does not exist
+if [ `expr "$final" : ".*libgazebo_ros_paths_plugin\.$EXT.*"` -eq 0 ]
+then
+    final="$final -g `catkin_find --first-only libgazebo_ros_paths_plugin.$EXT`"
+fi
+
+# add ros api plugin if it does not already exist in the passed in arguments
+if [ `expr "$final" : ".*libgazebo_ros_api_plugin\.$EXT.*"` -eq 0 ]
+then
+    final="$final -g `catkin_find --first-only libgazebo_ros_api_plugin.$EXT`"
+fi
+
+setup_path=$(pkg-config --variable=prefix gazebo)/share/gazebo/
+
+# source setup.sh, but keep local modifications to GAZEBO_MASTER_URI and GAZEBO_MODEL_DATABASE_URI
+desired_master_uri="$GAZEBO_MASTER_URI"
+desired_model_database_uri="$GAZEBO_MODEL_DATABASE_URI"
+. $setup_path/setup.sh
+if [ "$desired_master_uri" = "" ]; then
+	desired_master_uri="$GAZEBO_MASTER_URI"
+fi
+if [ "$desired_model_database_uri" = "" ]; then
+	desired_model_database_uri="$GAZEBO_MODEL_DATABASE_URI"
+fi
+
+final=$(relocate_remappings "${final}")
+
+# Combine the commands
+GAZEBO_MASTER_URI="$desired_master_uri" GAZEBO_MODEL_DATABASE_URI="$desired_model_database_uri" gzclient $final
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/scripts/gzclient.bat
@@ -0,0 +1,53 @@
+@echo off
+SETLOCAL EnableDelayedExpansion
+
+SET "DESIRED_MASTER_URI=%GAZEBO_MASTER_URI%"
+SET "DESIRED_MODEL_DATABASE_URI=%GAZEBO_MODEL_DATABASE_URI%"
+
+SET "FINAL=%*"
+
+call :FIND_IN_WORKSPACES gazebo_ros_paths_plugin.dll
+SET "FINAL=%FINAL% -g %FIND_IN_WORKSPACES_OUTPUT%"
+
+call :FIND_IN_WORKSPACES gazebo_ros_api_plugin.dll
+SET "FINAL=%FINAL% -g %FIND_IN_WORKSPACES_OUTPUT%"
+
+SET GAZEBO_SETUP=
+FOR /F "tokens=* USEBACKQ" %%F IN (`pkg-config --variable=prefix gazebo`) DO (
+SET "GAZEBO_SETUP=%%F/share/gazebo/setup.bat"
+)
+
+SET REMAPPINGS_OUTPUT=
+SET OPTIONS_OUTPUT=
+call :RELOCATE_REMAPPINGS %FINAL%
+
+ENDLOCAL & SET "GAZEBO_OPTIONS=%OPTIONS_OUTPUT%%REMAPPINGS_OUTPUT%" & SET "GAZEBO_SETUP=%GAZEBO_SETUP%" & SET "DESIRED_MASTER_URI=%DESIRED_MASTER_URI%" & SET "DESIRED_MODEL_DATABASE_URI=%DESIRED_MODEL_DATABASE_URI%"
+
+CALL %GAZEBO_SETUP%
+SET "GAZEBO_MASTER_URI=%DESIRED_MASTER_URI%"
+SET "GAZEBO_MODEL_DATABASE_URI=%DESIRED_MODEL_DATABASE_URI%"
+gzclient %GAZEBO_OPTIONS%
+
+GOTO :EOF
+
+:RELOCATE_REMAPPINGS
+FOR /F "tokens=1*" %%A IN ("%*") DO (
+    SET _REMAPPING=0
+    SET _TEMP_VAR=%%A
+    FOR %%A IN (!_TEMP_VAR!) DO (
+        IF NOT "%%A"=="!_TEMP_VAR!" SET _REMAPPING=1
+    )
+    IF !_REMAPPING!==1 (
+        SET "REMAPPINGS_OUTPUT=!REMAPPINGS_OUTPUT! !_TEMP_VAR!"
+    ) ELSE (
+        SET "OPTIONS_OUTPUT=!OPTIONS_OUTPUT! !_TEMP_VAR!"
+    )
+    IF NOT "%%B"=="" call :RELOCATE_REMAPPINGS %%B
+)
+EXIT /B
+
+:FIND_IN_WORKSPACES
+FOR /F "tokens=* USEBACKQ" %%F IN (`python -c "from catkin.find_in_workspaces import find_in_workspaces as catkin_find; print(catkin_find(path='%*')[0])"`) DO (
+SET "FIND_IN_WORKSPACES_OUTPUT="%%F""
+)
+EXIT /B
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/scripts/gzserver
@@ -0,0 +1,41 @@
+#!/bin/sh
+[ -L ${0} ] && SCRIPT_DIR=$(readlink ${0}) || SCRIPT_DIR=${0}
+SCRIPT_DIR=$(dirname ${SCRIPT_DIR})
+
+. ${SCRIPT_DIR}/libcommon.sh
+
+final="$@"
+
+EXT=so
+if [ $(uname) = "Darwin" ]; then
+    EXT=dylib
+fi
+
+# add ros path plugin if it does not already exist in the passed in arguments
+if [ `expr "$final" : ".*libgazebo_ros_paths_plugin\.$EXT.*"` -eq 0 ]
+then
+    final="$final -s `catkin_find --first-only libgazebo_ros_paths_plugin.$EXT`"
+fi
+
+# add ros api plugin if it does not already exist in the passed in arguments
+if [ `expr "$final" : ".*libgazebo_ros_api_plugin\.$EXT.*"` -eq 0 ]
+then
+    final="$final -s `catkin_find --first-only libgazebo_ros_api_plugin.$EXT`"
+fi
+
+setup_path=$(pkg-config --variable=prefix gazebo)/share/gazebo/
+
+# source setup.sh, but keep local modifications to GAZEBO_MASTER_URI and GAZEBO_MODEL_DATABASE_URI
+desired_master_uri="$GAZEBO_MASTER_URI"
+desired_model_database_uri="$GAZEBO_MODEL_DATABASE_URI"
+. $setup_path/setup.sh
+if [ "$desired_master_uri" = "" ]; then
+	desired_master_uri="$GAZEBO_MASTER_URI"
+fi
+if [ "$desired_model_database_uri" = "" ]; then
+	desired_model_database_uri="$GAZEBO_MODEL_DATABASE_URI"
+fi
+
+final=$(relocate_remappings "${final}")
+
+GAZEBO_MASTER_URI="$desired_master_uri" GAZEBO_MODEL_DATABASE_URI="$desired_model_database_uri" gzserver $final
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/scripts/gzserver.bat
@@ -0,0 +1,53 @@
+@echo off
+SETLOCAL EnableDelayedExpansion
+
+SET "DESIRED_MASTER_URI=%GAZEBO_MASTER_URI%"
+SET "DESIRED_MODEL_DATABASE_URI=%GAZEBO_MODEL_DATABASE_URI%"
+
+SET "FINAL=%*"
+
+call :FIND_IN_WORKSPACES gazebo_ros_paths_plugin.dll
+SET "FINAL=%FINAL% -s %FIND_IN_WORKSPACES_OUTPUT%"
+
+call :FIND_IN_WORKSPACES gazebo_ros_api_plugin.dll
+SET "FINAL=%FINAL% -s %FIND_IN_WORKSPACES_OUTPUT%"
+
+SET GAZEBO_SETUP=
+FOR /F "tokens=* USEBACKQ" %%F IN (`pkg-config --variable=prefix gazebo`) DO (
+SET "GAZEBO_SETUP=%%F/share/gazebo/setup.bat"
+)
+
+SET REMAPPINGS_OUTPUT=
+SET OPTIONS_OUTPUT=
+call :RELOCATE_REMAPPINGS %FINAL%
+
+ENDLOCAL & SET "GAZEBO_OPTIONS=%OPTIONS_OUTPUT%%REMAPPINGS_OUTPUT%" & SET "GAZEBO_SETUP=%GAZEBO_SETUP%" & SET "DESIRED_MASTER_URI=%DESIRED_MASTER_URI%" & SET "DESIRED_MODEL_DATABASE_URI=%DESIRED_MODEL_DATABASE_URI%"
+
+CALL %GAZEBO_SETUP%
+SET "GAZEBO_MASTER_URI=%DESIRED_MASTER_URI%"
+SET "GAZEBO_MODEL_DATABASE_URI=%DESIRED_MODEL_DATABASE_URI%"
+gzserver %GAZEBO_OPTIONS%
+
+GOTO :EOF
+
+:RELOCATE_REMAPPINGS
+FOR /F "tokens=1*" %%A IN ("%*") DO (
+    SET _REMAPPING=0
+    SET _TEMP_VAR=%%A
+    FOR %%A IN (!_TEMP_VAR!) DO (
+        IF NOT "%%A"=="!_TEMP_VAR!" SET _REMAPPING=1
+    )
+    IF !_REMAPPING!==1 (
+        SET "REMAPPINGS_OUTPUT=!REMAPPINGS_OUTPUT! !_TEMP_VAR!"
+    ) ELSE (
+        SET "OPTIONS_OUTPUT=!OPTIONS_OUTPUT! !_TEMP_VAR!"
+    )
+    IF NOT "%%B"=="" call :RELOCATE_REMAPPINGS %%B
+)
+EXIT /B
+
+:FIND_IN_WORKSPACES
+FOR /F "tokens=* USEBACKQ" %%F IN (`python -c "from catkin.find_in_workspaces import find_in_workspaces as catkin_find; print(catkin_find(path='%*')[0])"`) DO (
+SET "FIND_IN_WORKSPACES_OUTPUT="%%F""
+)
+EXIT /B
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/scripts/libcommon.sh
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+# the function relocates all the ROS remappings in the command at the end of the
+# string this allows some punky uses of rosrun, for more information see:
+# https://github.com/ros-simulation/gazebo_ros_pkgs/issues/387
+relocate_remappings()
+{
+  command_line=${1}
+
+  for w in $command_line; do
+    if $(echo "$w" | grep -q ':='); then
+      ros_remaps="$ros_remaps $w"
+    else
+      gazebo_args="$gazebo_args $w"
+    fi
+  done
+
+  echo "$gazebo_args$ros_remaps" | cut -c 1-
+}
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/scripts/perf
@@ -0,0 +1,21 @@
+#!/bin/sh
+final="$@"
+
+EXT=so
+if [ $(uname) = "Darwin" ]; then
+    EXT=dylib
+fi
+
+# add ros plugin if does not exist
+if [ `expr "$final" : ".*libgazebo_ros_paths_plugin\.$EXT.*"` -eq 0 ]
+then
+    final="$final -s `catkin_find --first-only libgazebo_ros_paths_plugin.$EXT`"
+fi
+
+if [ `expr "$final" : ".*libgazebo_ros_api_plugin\.$EXT.*"` -eq 0 ]
+then
+    final="$final -s `catkin_find --first-only libgazebo_ros_api_plugin.$EXT`"
+fi
+
+setup_path=$(pkg-config --variable=prefix gazebo)/share/gazebo/
+. $setup_path/setup.sh && /usr/bin/valgrind --tool=callgrind gzserver $final
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/scripts/spawn_model
@@ -0,0 +1,240 @@
+#!/usr/bin/env python
+#
+# Copyright 2018 Open Source Robotics Foundation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Desc: helper script for spawning models in gazebo
+# Author: John Hsu, Dave Coleman
+#
+import rospy
+import sys
+import os
+import argparse
+import xml
+try: # Python 3.x
+    from urllib.parse import urlsplit, SplitResult
+except ImportError: # Python 2.x
+    from urlparse import urlsplit, SplitResult
+from gazebo_ros import gazebo_interface
+from gazebo_msgs.msg import ModelStates
+from gazebo_msgs.srv import DeleteModel
+from std_srvs.srv import Empty
+from geometry_msgs.msg import Pose, Quaternion
+from tf.transformations import quaternion_from_euler
+
+
+class SpawnModelNode():
+    '''
+    Node to spawn a model in Gazebo using the ROS API
+    '''
+    MODEL_DATABASE_TEMPLATE = """\
+<sdf version="1.4">
+    <world name="default">
+        <include>
+            <uri>model://{}</uri>
+        </include>
+    </world>
+</sdf>"""
+
+    def __init__(self):
+        parser = argparse.ArgumentParser(description='Spawn a model in gazebo using the ROS API')
+        xmlformat = parser.add_mutually_exclusive_group(required=True)
+        xmlformat.add_argument('-urdf', action='store_true', help='Incoming xml is in urdf format')
+        xmlformat.add_argument('-sdf', action='store_true', help='Incoming xml is in sdf format')
+        source = parser.add_mutually_exclusive_group(required=True)
+        source.add_argument('-file', type=str, metavar='FILE_NAME', help='Load model xml from file')
+        source.add_argument('-param', type=str, metavar='PARAM_NAME', help='Load model xml from ROS parameter')
+        source.add_argument('-database', type=str, metavar='MODEL_NAME',
+                            help='Load model XML from specified model in Gazebo Model Database')
+        source.add_argument('-stdin', action='store_true', help='Load model from stdin')
+        parser.add_argument('-model', required=True, type=str, metavar='MODEL_NAME', help='Name of model to spawn')
+        parser.add_argument('-reference_frame', type=str, default='',
+                            help='Name of the model/body where initial pose is defined.\
+                                  If left empty or specified as "world", gazebo world frame is used')
+        parser.add_argument('-gazebo_namespace', type=str, default='/gazebo',
+                            help='ROS namespace of gazebo offered ROS interfaces.  Defaults to /gazebo/')
+        parser.add_argument('-robot_namespace', type=str, default=rospy.get_namespace(),
+                            help='change ROS namespace of gazebo-plugins')
+        parser.add_argument('-unpause', action='store_true',
+                            help='!!!Experimental!!! unpause physics after spawning model')
+        parser.add_argument('-wait', type=str, metavar='MODEL_NAME', help='!!!Experimental!!! wait for model to exist')
+        parser.add_argument('-x', type=float, default=0, help='x component of initial position, meters')
+        parser.add_argument('-y', type=float, default=0, help='y component of initial position, meters')
+        parser.add_argument('-z', type=float, default=0, help='z component of initial position, meters')
+        parser.add_argument('-R', type=float, default=0, help='roll angle of initial orientation, radians')
+        parser.add_argument('-P', type=float, default=0, help='pitch angle of initial orientation, radians')
+        parser.add_argument('-Y', type=float, default=0, help='yaw angle of initial orientation, radians')
+        parser.add_argument('-J', dest='joints', default=[], action='append', metavar=('JOINT_NAME', 'JOINT_POSITION'),
+                            type=str, nargs=2, help='initialize the specified joint at the specified position')
+        parser.add_argument('-package_to_model', action='store_true',
+                            help='convert urdf <mesh filename="package://..." to <mesh filename="model://..."')
+        parser.add_argument('-b', dest='bond', action='store_true',
+                            help='bond to gazebo and delete the model when this program is interrupted')
+        args = rospy.myargv()
+        self.args = parser.parse_args(args[1:])
+        # Convert position of joints to floats
+        for i in range(len(self.args.joints)):
+            self.args.joints[i][1] = float(self.args.joints[i][1])
+
+    def run(self):
+        '''
+        Run node, spawning model and doing other actions as configured in program arguments.
+        Returns exit code, 1 for failure, 0 for success
+        '''
+        # Wait for model to exist if wait flag is enabled
+        if self.args.wait:
+            self.model_exists = False
+
+            def models_cb(models):
+                self.model_exists = self.args.wait in models.name
+
+            rospy.Subscriber("%s/model_states" % self.args.gazebo_namespace, ModelStates, models_cb)
+            r = rospy.Rate(10)
+            rospy.loginfo('Waiting for model {} before proceeding.'.format(self.args.wait))
+            while not rospy.is_shutdown() and not self.model_exists:
+                r.sleep()
+            if rospy.is_shutdown():
+                return 0
+
+        # Load model XML from file
+        if self.args.file:
+            rospy.loginfo("Loading model XML from file %s" % self.args.file)
+            if not os.path.exists(self.args.file):
+                rospy.logfatal("Error: specified file %s does not exist", self.args.file)
+                return 1
+            if not os.path.isfile(self.args.file):
+                rospy.logfatal("Error: specified file %s is not a file", self.args.file)
+                return 1
+            # load file
+            try:
+                f = open(self.args.file, 'r')
+                model_xml = f.read()
+            except IOError as e:
+                rospy.logerr("Error reading file {}: {}".format(self.args.file, e))
+                return 1
+            if model_xml == "":
+                rospy.logerr("Error: file %s is empty", self.args.file)
+                return 1
+        # Load model XML from ROS param
+        elif self.args.param:
+            rospy.loginfo("Loading model XML from ros parameter %s" % self.args.param)
+            model_xml = rospy.get_param(self.args.param)
+            if model_xml == "":
+                rospy.logerr("Error: param does not exist or is empty")
+                return 1
+        # Generate model XML by putting requested model name into request template
+        elif self.args.database:
+            rospy.loginfo("Loading model XML from Gazebo Model Database")
+            model_xml = self.MODEL_DATABASE_TEMPLATE.format(self.args.database)
+        elif self.args.stdin:
+            rospy.loginfo("Loading model XML from stdin")
+            model_xml = sys.stdin.read()
+            if model_xml == "":
+                rospy.logerr("Error: stdin buffer was empty")
+                return 1
+
+        # Parse xml to detect invalid xml before sending to gazebo
+        try:
+            xml_parsed = xml.etree.ElementTree.fromstring(model_xml)
+        except xml.etree.ElementTree.ParseError as e:
+            rospy.logerr('Invalid XML: {}'.format(e))
+            return 1
+
+        # Replace package:// with model:// for mesh tags if flag is set
+        if self.args.package_to_model:
+            for element in xml_parsed.iterfind('.//mesh'):
+                filename_tag = element.get('filename')
+                if filename_tag is None:
+                    continue
+                url = urlsplit(filename_tag)
+                if url.scheme == 'package':
+                    url = SplitResult('model', *url[1:])
+                    element.set('filename', url.geturl())
+
+        # Encode xml object back into string for service call
+        model_xml = xml.etree.ElementTree.tostring(xml_parsed)
+
+        # For Python 3
+        if not isinstance(model_xml, str):
+            model_xml = model_xml.decode(encoding='ascii')
+
+        # Form requested Pose from arguments
+        initial_pose = Pose()
+        initial_pose.position.x = self.args.x
+        initial_pose.position.y = self.args.y
+        initial_pose.position.z = self.args.z
+        q = quaternion_from_euler(self.args.R, self.args.P, self.args.Y)
+        initial_pose.orientation = Quaternion(*q)
+
+        # Spawn model using urdf or sdf service based on arguments
+        success = False
+        if self.args.urdf:
+            success = gazebo_interface.spawn_urdf_model_client(self.args.model, model_xml, self.args.robot_namespace,
+                                                               initial_pose, self.args.reference_frame,
+                                                               self.args.gazebo_namespace)
+        elif self.args.sdf:
+            success = gazebo_interface.spawn_sdf_model_client(self.args.model, model_xml, self.args.robot_namespace,
+                                                              initial_pose, self.args.reference_frame,
+                                                              self.args.gazebo_namespace)
+        if not success:
+            rospy.logerr('Spawn service failed. Exiting.')
+            return 1
+
+        # Apply joint positions if any specified
+        if len(self.args.joints) != 0:
+            joint_names = [joint[0] for joint in self.args.joints]
+            joint_positions = [joint[1] for joint in self.args.joints]
+            success = gazebo_interface.set_model_configuration_client(self.args.model, "",
+                                                                      joint_names, joint_positions,
+                                                                      self.args.gazebo_namespace)
+            if not success:
+                rospy.logerr('SetModelConfiguration service failed. Exiting.')
+                return 1
+
+        # Unpause physics if user requested
+        if self.args.unpause:
+            rospy.loginfo('Unpausing physics')
+            rospy.wait_for_service('%s/unpause_physics' % self.args.gazebo_namespace)
+            try:
+                unpause_physics = rospy.ServiceProxy('%s/unpause_physics' % self.args.gazebo_namespace, Empty)
+                unpause_physics()
+            except rospy.ServiceException as e:
+                rospy.logerr("Unpause physics service call failed: {}".format(e))
+                return 1
+
+        # If bond enabled, setup shutdown callback and wait for shutdown
+        if self.args.bond:
+            rospy.on_shutdown(self._delete_model)
+            rospy.loginfo('Waiting for shutdown to delete model {}'.format(self.args.model))
+            rospy.spin()
+
+        return 0
+
+    def _delete_model(self):
+        '''
+        Delete model from gazebo on shutdown if bond flag enabled
+        '''
+        rospy.loginfo('Deleting model {}'.format(self.args.model))
+        try:
+            delete_model = rospy.ServiceProxy('%s/delete_model' % self.args.gazebo_namespace, DeleteModel)
+            delete_model(model_name=self.args.model)
+        except rospy.ServiceException as e:
+            rospy.logerr("Delete model service call failed: %s", e)
+
+
+if __name__ == "__main__":
+    sm = SpawnModelNode()
+    rospy.init_node('spawn_model', anonymous=True)
+    exit_code = sm.run()
+    sys.exit(exit_code)
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/setup.py
@@ -0,0 +1,9 @@
+#!/usr/bin/env python
+from distutils.core import setup
+from catkin_pkg.python_setup import generate_distutils_setup
+
+d = generate_distutils_setup()
+d['packages'] = ['gazebo_ros']
+d['package_dir'] = {'':'src'}
+
+setup(**d)
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/src/gazebo_ros/gazebo_interface.py
@@ -0,0 +1,52 @@
+#! /usr/bin/env python
+# Wrappers around the services provided by rosified gazebo
+
+import sys
+import rospy
+import os
+import time
+
+from gazebo_msgs.msg import *
+from gazebo_msgs.srv import *
+from geometry_msgs.msg import Point, Pose, Quaternion, Twist, Wrench
+
+
+def spawn_sdf_model_client(model_name, model_xml, robot_namespace, initial_pose, reference_frame, gazebo_namespace):
+    rospy.loginfo("Waiting for service %s/spawn_sdf_model"%gazebo_namespace)
+    rospy.wait_for_service(gazebo_namespace+'/spawn_sdf_model')
+    try:
+      spawn_sdf_model = rospy.ServiceProxy(gazebo_namespace+'/spawn_sdf_model', SpawnModel)
+      rospy.loginfo("Calling service %s/spawn_sdf_model"%gazebo_namespace)
+      resp = spawn_sdf_model(model_name, model_xml, robot_namespace, initial_pose, reference_frame)
+      rospy.loginfo("Spawn status: %s"%resp.status_message)
+      return resp.success
+    except rospy.ServiceException as e:
+      print("Service call failed: %s" % e)
+
+def spawn_urdf_model_client(model_name, model_xml, robot_namespace, initial_pose, reference_frame, gazebo_namespace):
+    rospy.loginfo("Waiting for service %s/spawn_urdf_model"%gazebo_namespace)
+    rospy.wait_for_service(gazebo_namespace+'/spawn_urdf_model')
+    try:
+      spawn_urdf_model = rospy.ServiceProxy(gazebo_namespace+'/spawn_urdf_model', SpawnModel)
+      rospy.loginfo("Calling service %s/spawn_urdf_model"%gazebo_namespace)
+      resp = spawn_urdf_model(model_name, model_xml, robot_namespace, initial_pose, reference_frame)
+      rospy.loginfo("Spawn status: %s"%resp.status_message)
+      return resp.success
+    except rospy.ServiceException as e:
+      print("Service call failed: %s" % e)
+
+def set_model_configuration_client(model_name, model_param_name, joint_names, joint_positions, gazebo_namespace):
+    rospy.loginfo("Waiting for service %s/set_model_configuration"%gazebo_namespace)
+    rospy.wait_for_service(gazebo_namespace+'/set_model_configuration')
+    rospy.loginfo("temporary hack to **fix** the -J joint position option (issue #93), sleeping for 1 second to avoid race condition.");
+    time.sleep(1)
+    try:
+      set_model_configuration = rospy.ServiceProxy(gazebo_namespace+'/set_model_configuration', SetModelConfiguration)
+      rospy.loginfo("Calling service %s/set_model_configuration"%gazebo_namespace)
+      resp = set_model_configuration(model_name, model_param_name, joint_names, joint_positions)
+      rospy.loginfo("Set model configuration status: %s"%resp.status_message)
+
+      return resp.success
+    except rospy.ServiceException as e:
+      print("Service call failed: %s" % e)
+
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/src/gazebo_ros_api_plugin.cpp
@@ -0,0 +1,2753 @@
+/*
+ * Copyright 2013 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+/* Desc: External interfaces for Gazebo
+ * Author: Nate Koenig, John Hsu, Dave Coleman
+ * Date: Jun 10 2013
+ */
+
+#include <gazebo/common/Events.hh>
+#include <gazebo/gazebo_config.h>
+#include <gazebo_ros/gazebo_ros_api_plugin.h>
+#include <chrono>
+#include <thread>
+
+namespace gazebo
+{
+
+GazeboRosApiPlugin::GazeboRosApiPlugin() :
+  physics_reconfigure_initialized_(false),
+  world_created_(false),
+  stop_(false),
+  plugin_loaded_(false),
+  pub_link_states_connection_count_(0),
+  pub_model_states_connection_count_(0),
+  pub_performance_metrics_connection_count_(0),
+  pub_clock_frequency_(0),
+  enable_ros_network_(true)
+{
+  robot_namespace_.clear();
+}
+
+GazeboRosApiPlugin::~GazeboRosApiPlugin()
+{
+  ROS_DEBUG_STREAM_NAMED("api_plugin","GazeboRosApiPlugin Deconstructor start");
+
+  // Unload the sigint event
+  sigint_event_.reset();
+  ROS_DEBUG_STREAM_NAMED("api_plugin","After sigint_event unload");
+
+  // Don't attempt to unload this plugin if it was never loaded in the Load() function
+  if(!plugin_loaded_)
+  {
+    ROS_DEBUG_STREAM_NAMED("api_plugin","Deconstructor skipped because never loaded");
+    return;
+  }
+
+  // Disconnect slots
+  load_gazebo_ros_api_plugin_event_.reset();
+  wrench_update_event_.reset();
+  force_update_event_.reset();
+  time_update_event_.reset();
+  ROS_DEBUG_STREAM_NAMED("api_plugin","Slots disconnected");
+
+  if (pub_link_states_connection_count_ > 0) // disconnect if there are subscribers on exit
+    pub_link_states_event_.reset();
+  if (pub_model_states_connection_count_ > 0) // disconnect if there are subscribers on exit
+    pub_model_states_event_.reset();
+  ROS_DEBUG_STREAM_NAMED("api_plugin","Disconnected World Updates");
+
+  // Stop the multi threaded ROS spinner
+  async_ros_spin_->stop();
+  ROS_DEBUG_STREAM_NAMED("api_plugin","Async ROS Spin Stopped");
+
+  // Shutdown the ROS node
+  nh_->shutdown();
+  ROS_DEBUG_STREAM_NAMED("api_plugin","Node Handle Shutdown");
+
+  // Shutdown ROS queue
+  gazebo_callback_queue_thread_->join();
+  ROS_DEBUG_STREAM_NAMED("api_plugin","Callback Queue Joined");
+
+  // Physics Dynamic Reconfigure
+  physics_reconfigure_thread_->join();
+  ROS_DEBUG_STREAM_NAMED("api_plugin","Physics reconfigure joined");
+
+  // Delete Force and Wrench Jobs
+  lock_.lock();
+  for (std::vector<GazeboRosApiPlugin::ForceJointJob*>::iterator iter=force_joint_jobs_.begin();iter!=force_joint_jobs_.end();)
+  {
+    delete (*iter);
+    iter = force_joint_jobs_.erase(iter);
+  }
+  force_joint_jobs_.clear();
+  ROS_DEBUG_STREAM_NAMED("api_plugin","ForceJointJobs deleted");
+  for (std::vector<GazeboRosApiPlugin::WrenchBodyJob*>::iterator iter=wrench_body_jobs_.begin();iter!=wrench_body_jobs_.end();)
+  {
+    delete (*iter);
+    iter = wrench_body_jobs_.erase(iter);
+  }
+  wrench_body_jobs_.clear();
+  lock_.unlock();
+  ROS_DEBUG_STREAM_NAMED("api_plugin","WrenchBodyJobs deleted");
+
+  ROS_DEBUG_STREAM_NAMED("api_plugin","Unloaded");
+}
+
+void GazeboRosApiPlugin::shutdownSignal()
+{
+  ROS_DEBUG_STREAM_NAMED("api_plugin","shutdownSignal() recieved");
+  stop_ = true;
+}
+
+void GazeboRosApiPlugin::Load(int argc, char** argv)
+{
+  ROS_DEBUG_STREAM_NAMED("api_plugin","Load");
+
+  // connect to sigint event
+  sigint_event_ = gazebo::event::Events::ConnectSigInt(boost::bind(&GazeboRosApiPlugin::shutdownSignal,this));
+
+  // setup ros related
+  if (!ros::isInitialized())
+    ros::init(argc,argv,"gazebo",ros::init_options::NoSigintHandler);
+  else
+    ROS_ERROR_NAMED("api_plugin", "Something other than this gazebo_ros_api plugin started ros::init(...), command line arguments may not be parsed properly.");
+
+  // check if the ros master is available - required
+  while(!ros::master::check())
+  {
+    ROS_WARN_STREAM_NAMED("api_plugin","No ROS master - start roscore to continue...");
+    // wait 0.5 second
+    // can't use ROS Time here b/c node handle is not yet initialized
+    std::this_thread::sleep_for(std::chrono::microseconds(500*1000));
+
+    if(stop_)
+    {
+      ROS_WARN_STREAM_NAMED("api_plugin","Canceled loading Gazebo ROS API plugin by sigint event");
+      return;
+    }
+  }
+
+  nh_.reset(new ros::NodeHandle("~")); // advertise topics and services in this node's namespace
+
+  // Built-in multi-threaded ROS spinning
+  async_ros_spin_.reset(new ros::AsyncSpinner(0)); // will use a thread for each CPU core
+  async_ros_spin_->start();
+
+  /// \brief setup custom callback queue
+  gazebo_callback_queue_thread_.reset(new boost::thread( &GazeboRosApiPlugin::gazeboQueueThread, this) );
+
+  /// \brief start a thread for the physics dynamic reconfigure node
+  physics_reconfigure_thread_.reset(new boost::thread(boost::bind(&GazeboRosApiPlugin::physicsReconfigureThread, this)));
+
+  // below needs the world to be created first
+  load_gazebo_ros_api_plugin_event_ = gazebo::event::Events::ConnectWorldCreated(boost::bind(&GazeboRosApiPlugin::loadGazeboRosApiPlugin,this,_1));
+
+  nh_->getParam("enable_ros_network", enable_ros_network_);
+
+  plugin_loaded_ = true;
+  ROS_INFO_NAMED("api_plugin", "Finished loading Gazebo ROS API Plugin.");
+}
+
+void GazeboRosApiPlugin::loadGazeboRosApiPlugin(std::string world_name)
+{
+  // make sure things are only called once
+  lock_.lock();
+  if (world_created_)
+  {
+    lock_.unlock();
+    return;
+  }
+
+  // set flag to true and load this plugin
+  world_created_ = true;
+  lock_.unlock();
+
+  world_ = gazebo::physics::get_world(world_name);
+  if (!world_)
+  {
+    //ROS_ERROR_NAMED("api_plugin", "world name: [%s]",world->Name().c_str());
+    // connect helper function to signal for scheduling torque/forces, etc
+    ROS_FATAL_NAMED("api_plugin", "cannot load gazebo ros api server plugin, physics::get_world() fails to return world");
+    return;
+  }
+
+  gazebonode_ = gazebo::transport::NodePtr(new gazebo::transport::Node());
+  gazebonode_->Init(world_name);
+  factory_pub_ = gazebonode_->Advertise<gazebo::msgs::Factory>("~/factory");
+  factory_light_pub_ = gazebonode_->Advertise<gazebo::msgs::Light>("~/factory/light");
+  light_modify_pub_ = gazebonode_->Advertise<gazebo::msgs::Light>("~/light/modify");
+  request_pub_ = gazebonode_->Advertise<gazebo::msgs::Request>("~/request");
+  response_sub_ = gazebonode_->Subscribe("~/response",&GazeboRosApiPlugin::onResponse, this);
+  // reset topic connection counts
+  pub_link_states_connection_count_ = 0;
+  pub_model_states_connection_count_ = 0;
+  pub_performance_metrics_connection_count_ = 0;
+
+  // Manage clock for simulated ros time
+  pub_clock_ = nh_->advertise<rosgraph_msgs::Clock>("/clock", 10);
+
+  /// \brief advertise all services
+  if (enable_ros_network_)
+    advertiseServices();
+
+  // set param for use_sim_time if not set by user already
+  if(!(nh_->hasParam("/use_sim_time")))
+    nh_->setParam("/use_sim_time", true);
+
+  nh_->getParam("pub_clock_frequency", pub_clock_frequency_);
+#if GAZEBO_MAJOR_VERSION >= 8
+  last_pub_clock_time_ = world_->SimTime();
+#else
+  last_pub_clock_time_ = world_->GetSimTime();
+#endif
+
+  // hooks for applying forces, publishing simtime on /clock
+  wrench_update_event_ = gazebo::event::Events::ConnectWorldUpdateBegin(boost::bind(&GazeboRosApiPlugin::wrenchBodySchedulerSlot,this));
+  force_update_event_  = gazebo::event::Events::ConnectWorldUpdateBegin(boost::bind(&GazeboRosApiPlugin::forceJointSchedulerSlot,this));
+  time_update_event_   = gazebo::event::Events::ConnectWorldUpdateBegin(boost::bind(&GazeboRosApiPlugin::publishSimTime,this));
+}
+
+void GazeboRosApiPlugin::onResponse(ConstResponsePtr &response)
+{
+
+}
+#ifdef GAZEBO_ROS_HAS_PERFORMANCE_METRICS
+void GazeboRosApiPlugin::onPerformanceMetrics(const boost::shared_ptr<gazebo::msgs::PerformanceMetrics const> &msg)
+{
+  gazebo_msgs::PerformanceMetrics msg_ros;
+  msg_ros.header.stamp = ros::Time::now();
+  msg_ros.real_time_factor = msg->real_time_factor();
+  for (auto sensor: msg->sensor())
+  {
+    gazebo_msgs::SensorPerformanceMetric sensor_msgs;
+    sensor_msgs.sim_update_rate = sensor.sim_update_rate();
+    sensor_msgs.real_update_rate = sensor.real_update_rate();
+    sensor_msgs.name = sensor.name();
+
+    if (sensor.has_fps())
+    {
+      sensor_msgs.fps = sensor.fps();
+    }
+    else{
+      sensor_msgs.fps = -1;
+    }
+
+    msg_ros.sensors.push_back(sensor_msgs);
+  }
+
+  pub_performance_metrics_.publish(msg_ros);
+}
+#endif
+
+void GazeboRosApiPlugin::gazeboQueueThread()
+{
+  static const double timeout = 0.001;
+  while (nh_->ok())
+  {
+    gazebo_queue_.callAvailable(ros::WallDuration(timeout));
+  }
+}
+
+void GazeboRosApiPlugin::advertiseServices()
+{
+  if (! enable_ros_network_)
+  {
+    ROS_INFO_NAMED("api_plugin", "ROS gazebo topics/services are disabled");
+    return;
+  }
+
+  // Advertise spawn services on the custom queue
+  std::string spawn_sdf_model_service_name("spawn_sdf_model");
+  ros::AdvertiseServiceOptions spawn_sdf_model_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::SpawnModel>(
+                                                                  spawn_sdf_model_service_name,
+                                                                  boost::bind(&GazeboRosApiPlugin::spawnSDFModel,this,_1,_2),
+                                                                  ros::VoidPtr(), &gazebo_queue_);
+  spawn_sdf_model_service_ = nh_->advertiseService(spawn_sdf_model_aso);
+
+  // Advertise spawn services on the custom queue
+  std::string spawn_urdf_model_service_name("spawn_urdf_model");
+  ros::AdvertiseServiceOptions spawn_urdf_model_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::SpawnModel>(
+                                                                  spawn_urdf_model_service_name,
+                                                                  boost::bind(&GazeboRosApiPlugin::spawnURDFModel,this,_1,_2),
+                                                                  ros::VoidPtr(), &gazebo_queue_);
+  spawn_urdf_model_service_ = nh_->advertiseService(spawn_urdf_model_aso);
+
+  // Advertise delete services on the custom queue
+  std::string delete_model_service_name("delete_model");
+  ros::AdvertiseServiceOptions delete_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::DeleteModel>(
+                                                                   delete_model_service_name,
+                                                                   boost::bind(&GazeboRosApiPlugin::deleteModel,this,_1,_2),
+                                                                   ros::VoidPtr(), &gazebo_queue_);
+  delete_model_service_ = nh_->advertiseService(delete_aso);
+
+  // Advertise delete service for lights on the custom queue
+  std::string delete_light_service_name("delete_light");
+  ros::AdvertiseServiceOptions delete_light_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::DeleteLight>(
+                                                                   delete_light_service_name,
+                                                                   boost::bind(&GazeboRosApiPlugin::deleteLight,this,_1,_2),
+                                                                   ros::VoidPtr(), &gazebo_queue_);
+  delete_light_service_ = nh_->advertiseService(delete_light_aso);
+
+  // Advertise more services on the custom queue
+  std::string get_model_properties_service_name("get_model_properties");
+  ros::AdvertiseServiceOptions get_model_properties_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::GetModelProperties>(
+                                                                          get_model_properties_service_name,
+                                                                          boost::bind(&GazeboRosApiPlugin::getModelProperties,this,_1,_2),
+                                                                          ros::VoidPtr(), &gazebo_queue_);
+  get_model_properties_service_ = nh_->advertiseService(get_model_properties_aso);
+
+  // Advertise more services on the custom queue
+  std::string get_model_state_service_name("get_model_state");
+  ros::AdvertiseServiceOptions get_model_state_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::GetModelState>(
+                                                                     get_model_state_service_name,
+                                                                     boost::bind(&GazeboRosApiPlugin::getModelState,this,_1,_2),
+                                                                     ros::VoidPtr(), &gazebo_queue_);
+  get_model_state_service_ = nh_->advertiseService(get_model_state_aso);
+
+  // Advertise more services on the custom queue
+  std::string get_world_properties_service_name("get_world_properties");
+  ros::AdvertiseServiceOptions get_world_properties_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::GetWorldProperties>(
+                                                                          get_world_properties_service_name,
+                                                                          boost::bind(&GazeboRosApiPlugin::getWorldProperties,this,_1,_2),
+                                                                          ros::VoidPtr(), &gazebo_queue_);
+  get_world_properties_service_ = nh_->advertiseService(get_world_properties_aso);
+
+  // Advertise more services on the custom queue
+  std::string get_joint_properties_service_name("get_joint_properties");
+  ros::AdvertiseServiceOptions get_joint_properties_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::GetJointProperties>(
+                                                                          get_joint_properties_service_name,
+                                                                          boost::bind(&GazeboRosApiPlugin::getJointProperties,this,_1,_2),
+                                                                          ros::VoidPtr(), &gazebo_queue_);
+  get_joint_properties_service_ = nh_->advertiseService(get_joint_properties_aso);
+
+  // Advertise more services on the custom queue
+  std::string get_link_properties_service_name("get_link_properties");
+  ros::AdvertiseServiceOptions get_link_properties_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::GetLinkProperties>(
+                                                                         get_link_properties_service_name,
+                                                                         boost::bind(&GazeboRosApiPlugin::getLinkProperties,this,_1,_2),
+                                                                         ros::VoidPtr(), &gazebo_queue_);
+  get_link_properties_service_ = nh_->advertiseService(get_link_properties_aso);
+
+  // Advertise more services on the custom queue
+  std::string get_link_state_service_name("get_link_state");
+  ros::AdvertiseServiceOptions get_link_state_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::GetLinkState>(
+                                                                    get_link_state_service_name,
+                                                                    boost::bind(&GazeboRosApiPlugin::getLinkState,this,_1,_2),
+                                                                    ros::VoidPtr(), &gazebo_queue_);
+  get_link_state_service_ = nh_->advertiseService(get_link_state_aso);
+
+  // Advertise more services on the custom queue
+  std::string get_light_properties_service_name("get_light_properties");
+  ros::AdvertiseServiceOptions get_light_properties_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::GetLightProperties>(
+                                                                          get_light_properties_service_name,
+                                                                          boost::bind(&GazeboRosApiPlugin::getLightProperties,this,_1,_2),
+                                                                          ros::VoidPtr(), &gazebo_queue_);
+  get_light_properties_service_ = nh_->advertiseService(get_light_properties_aso);
+
+  // Advertise more services on the custom queue
+  std::string set_light_properties_service_name("set_light_properties");
+  ros::AdvertiseServiceOptions set_light_properties_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::SetLightProperties>(
+                                                                          set_light_properties_service_name,
+                                                                          boost::bind(&GazeboRosApiPlugin::setLightProperties,this,_1,_2),
+                                                                          ros::VoidPtr(), &gazebo_queue_);
+  set_light_properties_service_ = nh_->advertiseService(set_light_properties_aso);
+
+  // Advertise more services on the custom queue
+  std::string get_physics_properties_service_name("get_physics_properties");
+  ros::AdvertiseServiceOptions get_physics_properties_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::GetPhysicsProperties>(
+                                                                            get_physics_properties_service_name,
+                                                                            boost::bind(&GazeboRosApiPlugin::getPhysicsProperties,this,_1,_2),
+                                                                            ros::VoidPtr(), &gazebo_queue_);
+  get_physics_properties_service_ = nh_->advertiseService(get_physics_properties_aso);
+
+  // publish complete link states in world frame
+  ros::AdvertiseOptions pub_link_states_ao =
+    ros::AdvertiseOptions::create<gazebo_msgs::LinkStates>(
+                                                           "link_states",10,
+                                                           boost::bind(&GazeboRosApiPlugin::onLinkStatesConnect,this),
+                                                           boost::bind(&GazeboRosApiPlugin::onLinkStatesDisconnect,this),
+                                                           ros::VoidPtr(), &gazebo_queue_);
+  pub_link_states_ = nh_->advertise(pub_link_states_ao);
+
+  // publish complete model states in world frame
+  ros::AdvertiseOptions pub_model_states_ao =
+    ros::AdvertiseOptions::create<gazebo_msgs::ModelStates>(
+                                                            "model_states",10,
+                                                            boost::bind(&GazeboRosApiPlugin::onModelStatesConnect,this),
+                                                            boost::bind(&GazeboRosApiPlugin::onModelStatesDisconnect,this),
+                                                            ros::VoidPtr(), &gazebo_queue_);
+  pub_model_states_ = nh_->advertise(pub_model_states_ao);
+
+#ifdef GAZEBO_ROS_HAS_PERFORMANCE_METRICS
+  // publish performance metrics
+  ros::AdvertiseOptions pub_performance_metrics_ao =
+    ros::AdvertiseOptions::create<gazebo_msgs::PerformanceMetrics>(
+                                                                   "performance_metrics",10,
+                                                                   boost::bind(&GazeboRosApiPlugin::onPerformanceMetricsConnect,this),
+                                                                   boost::bind(&GazeboRosApiPlugin::onPerformanceMetricsDisconnect,this),
+                                                                   ros::VoidPtr(), &gazebo_queue_);
+  pub_performance_metrics_ = nh_->advertise(pub_performance_metrics_ao);
+#endif
+
+  // Advertise more services on the custom queue
+  std::string set_link_properties_service_name("set_link_properties");
+  ros::AdvertiseServiceOptions set_link_properties_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::SetLinkProperties>(
+                                                                         set_link_properties_service_name,
+                                                                         boost::bind(&GazeboRosApiPlugin::setLinkProperties,this,_1,_2),
+                                                                         ros::VoidPtr(), &gazebo_queue_);
+  set_link_properties_service_ = nh_->advertiseService(set_link_properties_aso);
+
+  // Advertise more services on the custom queue
+  std::string set_physics_properties_service_name("set_physics_properties");
+  ros::AdvertiseServiceOptions set_physics_properties_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::SetPhysicsProperties>(
+                                                                            set_physics_properties_service_name,
+                                                                            boost::bind(&GazeboRosApiPlugin::setPhysicsProperties,this,_1,_2),
+                                                                            ros::VoidPtr(), &gazebo_queue_);
+  set_physics_properties_service_ = nh_->advertiseService(set_physics_properties_aso);
+
+  // Advertise more services on the custom queue
+  std::string set_model_state_service_name("set_model_state");
+  ros::AdvertiseServiceOptions set_model_state_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::SetModelState>(
+                                                                     set_model_state_service_name,
+                                                                     boost::bind(&GazeboRosApiPlugin::setModelState,this,_1,_2),
+                                                                     ros::VoidPtr(), &gazebo_queue_);
+  set_model_state_service_ = nh_->advertiseService(set_model_state_aso);
+
+  // Advertise more services on the custom queue
+  std::string set_model_configuration_service_name("set_model_configuration");
+  ros::AdvertiseServiceOptions set_model_configuration_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::SetModelConfiguration>(
+                                                                             set_model_configuration_service_name,
+                                                                             boost::bind(&GazeboRosApiPlugin::setModelConfiguration,this,_1,_2),
+                                                                             ros::VoidPtr(), &gazebo_queue_);
+  set_model_configuration_service_ = nh_->advertiseService(set_model_configuration_aso);
+
+  // Advertise more services on the custom queue
+  std::string set_joint_properties_service_name("set_joint_properties");
+  ros::AdvertiseServiceOptions set_joint_properties_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::SetJointProperties>(
+                                                                          set_joint_properties_service_name,
+                                                                          boost::bind(&GazeboRosApiPlugin::setJointProperties,this,_1,_2),
+                                                                          ros::VoidPtr(), &gazebo_queue_);
+  set_joint_properties_service_ = nh_->advertiseService(set_joint_properties_aso);
+
+  // Advertise more services on the custom queue
+  std::string set_link_state_service_name("set_link_state");
+  ros::AdvertiseServiceOptions set_link_state_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::SetLinkState>(
+                                                                    set_link_state_service_name,
+                                                                    boost::bind(&GazeboRosApiPlugin::setLinkState,this,_1,_2),
+                                                                    ros::VoidPtr(), &gazebo_queue_);
+  set_link_state_service_ = nh_->advertiseService(set_link_state_aso);
+
+  // Advertise topic on custom queue
+  // topic callback version for set_link_state
+  ros::SubscribeOptions link_state_so =
+    ros::SubscribeOptions::create<gazebo_msgs::LinkState>(
+                                                          "set_link_state",10,
+                                                          boost::bind( &GazeboRosApiPlugin::updateLinkState,this,_1),
+                                                          ros::VoidPtr(), &gazebo_queue_);
+  set_link_state_topic_ = nh_->subscribe(link_state_so);
+
+  // topic callback version for set_model_state
+  ros::SubscribeOptions model_state_so =
+    ros::SubscribeOptions::create<gazebo_msgs::ModelState>(
+                                                           "set_model_state",10,
+                                                           boost::bind( &GazeboRosApiPlugin::updateModelState,this,_1),
+                                                           ros::VoidPtr(), &gazebo_queue_);
+  set_model_state_topic_ = nh_->subscribe(model_state_so);
+
+  // Advertise more services on the custom queue
+  std::string pause_physics_service_name("pause_physics");
+  ros::AdvertiseServiceOptions pause_physics_aso =
+    ros::AdvertiseServiceOptions::create<std_srvs::Empty>(
+                                                          pause_physics_service_name,
+                                                          boost::bind(&GazeboRosApiPlugin::pausePhysics,this,_1,_2),
+                                                          ros::VoidPtr(), &gazebo_queue_);
+  pause_physics_service_ = nh_->advertiseService(pause_physics_aso);
+
+  // Advertise more services on the custom queue
+  std::string unpause_physics_service_name("unpause_physics");
+  ros::AdvertiseServiceOptions unpause_physics_aso =
+    ros::AdvertiseServiceOptions::create<std_srvs::Empty>(
+                                                          unpause_physics_service_name,
+                                                          boost::bind(&GazeboRosApiPlugin::unpausePhysics,this,_1,_2),
+                                                          ros::VoidPtr(), &gazebo_queue_);
+  unpause_physics_service_ = nh_->advertiseService(unpause_physics_aso);
+
+  // Advertise more services on the custom queue
+  std::string apply_body_wrench_service_name("apply_body_wrench");
+  ros::AdvertiseServiceOptions apply_body_wrench_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::ApplyBodyWrench>(
+                                                                       apply_body_wrench_service_name,
+                                                                       boost::bind(&GazeboRosApiPlugin::applyBodyWrench,this,_1,_2),
+                                                                       ros::VoidPtr(), &gazebo_queue_);
+  apply_body_wrench_service_ = nh_->advertiseService(apply_body_wrench_aso);
+
+  // Advertise more services on the custom queue
+  std::string apply_joint_effort_service_name("apply_joint_effort");
+  ros::AdvertiseServiceOptions apply_joint_effort_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::ApplyJointEffort>(
+                                                                        apply_joint_effort_service_name,
+                                                                        boost::bind(&GazeboRosApiPlugin::applyJointEffort,this,_1,_2),
+                                                                        ros::VoidPtr(), &gazebo_queue_);
+  apply_joint_effort_service_ = nh_->advertiseService(apply_joint_effort_aso);
+
+  // Advertise more services on the custom queue
+  std::string clear_joint_forces_service_name("clear_joint_forces");
+  ros::AdvertiseServiceOptions clear_joint_forces_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::JointRequest>(
+                                                                    clear_joint_forces_service_name,
+                                                                    boost::bind(&GazeboRosApiPlugin::clearJointForces,this,_1,_2),
+                                                                    ros::VoidPtr(), &gazebo_queue_);
+  clear_joint_forces_service_ = nh_->advertiseService(clear_joint_forces_aso);
+
+  // Advertise more services on the custom queue
+  std::string clear_body_wrenches_service_name("clear_body_wrenches");
+  ros::AdvertiseServiceOptions clear_body_wrenches_aso =
+    ros::AdvertiseServiceOptions::create<gazebo_msgs::BodyRequest>(
+                                                                   clear_body_wrenches_service_name,
+                                                                   boost::bind(&GazeboRosApiPlugin::clearBodyWrenches,this,_1,_2),
+                                                                   ros::VoidPtr(), &gazebo_queue_);
+  clear_body_wrenches_service_ = nh_->advertiseService(clear_body_wrenches_aso);
+
+  // Advertise more services on the custom queue
+  std::string reset_simulation_service_name("reset_simulation");
+  ros::AdvertiseServiceOptions reset_simulation_aso =
+    ros::AdvertiseServiceOptions::create<std_srvs::Empty>(
+                                                          reset_simulation_service_name,
+                                                          boost::bind(&GazeboRosApiPlugin::resetSimulation,this,_1,_2),
+                                                          ros::VoidPtr(), &gazebo_queue_);
+  reset_simulation_service_ = nh_->advertiseService(reset_simulation_aso);
+
+  // Advertise more services on the custom queue
+  std::string reset_world_service_name("reset_world");
+  ros::AdvertiseServiceOptions reset_world_aso =
+    ros::AdvertiseServiceOptions::create<std_srvs::Empty>(
+                                                          reset_world_service_name,
+                                                          boost::bind(&GazeboRosApiPlugin::resetWorld,this,_1,_2),
+                                                          ros::VoidPtr(), &gazebo_queue_);
+  reset_world_service_ = nh_->advertiseService(reset_world_aso);
+}
+
+void GazeboRosApiPlugin::onLinkStatesConnect()
+{
+  pub_link_states_connection_count_++;
+  if (pub_link_states_connection_count_ == 1) // connect on first subscriber
+    pub_link_states_event_   = gazebo::event::Events::ConnectWorldUpdateBegin(boost::bind(&GazeboRosApiPlugin::publishLinkStates,this));
+}
+
+void GazeboRosApiPlugin::onModelStatesConnect()
+{
+  pub_model_states_connection_count_++;
+  if (pub_model_states_connection_count_ == 1) // connect on first subscriber
+    pub_model_states_event_   = gazebo::event::Events::ConnectWorldUpdateBegin(boost::bind(&GazeboRosApiPlugin::publishModelStates,this));
+}
+
+#ifdef GAZEBO_ROS_HAS_PERFORMANCE_METRICS
+void GazeboRosApiPlugin::onPerformanceMetricsConnect()
+{
+  pub_performance_metrics_connection_count_++;
+  if (pub_performance_metrics_connection_count_ == 1) // connect on first subscriber
+  {
+    performance_metric_sub_ = gazebonode_->Subscribe("/gazebo/performance_metrics",
+      &GazeboRosApiPlugin::onPerformanceMetrics, this);
+  }
+}
+
+void GazeboRosApiPlugin::onPerformanceMetricsDisconnect()
+{
+  pub_performance_metrics_connection_count_--;
+  if (pub_performance_metrics_connection_count_ <= 0) // disconnect with no subscribers
+  {
+    performance_metric_sub_.reset();
+    if (pub_performance_metrics_connection_count_ < 0) // should not be possible
+      ROS_ERROR_NAMED("api_plugin", "One too many disconnect from pub_performance_metrics_ in gazebo_ros.cpp? something weird");
+  }
+}
+#endif
+
+void GazeboRosApiPlugin::onLinkStatesDisconnect()
+{
+  pub_link_states_connection_count_--;
+  if (pub_link_states_connection_count_ <= 0) // disconnect with no subscribers
+  {
+    pub_link_states_event_.reset();
+    if (pub_link_states_connection_count_ < 0) // should not be possible
+      ROS_ERROR_NAMED("api_plugin", "One too many disconnect from pub_link_states_ in gazebo_ros.cpp? something weird");
+  }
+}
+
+void GazeboRosApiPlugin::onModelStatesDisconnect()
+{
+  pub_model_states_connection_count_--;
+  if (pub_model_states_connection_count_ <= 0) // disconnect with no subscribers
+  {
+    pub_model_states_event_.reset();
+    if (pub_model_states_connection_count_ < 0) // should not be possible
+      ROS_ERROR_NAMED("api_plugin", "One too many disconnect from pub_model_states_ in gazebo_ros.cpp? something weird");
+  }
+}
+
+bool GazeboRosApiPlugin::spawnURDFModel(gazebo_msgs::SpawnModel::Request &req,
+                                        gazebo_msgs::SpawnModel::Response &res)
+{
+  // get namespace for the corresponding model plugins
+  robot_namespace_ = req.robot_namespace;
+
+  // incoming entity string
+  std::string model_xml = req.model_xml;
+
+  if (!isURDF(model_xml))
+  {
+    ROS_ERROR_NAMED("api_plugin", "SpawnModel: Failure - entity format is invalid.");
+    res.success = false;
+    res.status_message = "SpawnModel: Failure - entity format is invalid.";
+    return false;
+  }
+
+  /// STRIP DECLARATION <? ... xml version="1.0" ... ?> from model_xml
+  /// @todo: does tinyxml have functionality for this?
+  /// @todo: should gazebo take care of the declaration?
+  {
+    std::string open_bracket("<?");
+    std::string close_bracket("?>");
+    size_t pos1 = model_xml.find(open_bracket,0);
+    size_t pos2 = model_xml.find(close_bracket,0);
+    if (pos1 != std::string::npos && pos2 != std::string::npos)
+      model_xml.replace(pos1,pos2-pos1+2,std::string(""));
+  }
+
+  // Remove comments from URDF
+  {
+    std::string open_comment("<!--");
+    std::string close_comment("-->");
+    size_t pos1;
+    while((pos1 = model_xml.find(open_comment,0)) != std::string::npos){
+      size_t pos2 = model_xml.find(close_comment,0);
+      if (pos2 != std::string::npos)
+        model_xml.replace(pos1,pos2-pos1+3,std::string(""));
+    }
+  }
+
+  // Now, replace package://xxx with the full path to the package
+  {
+    std::string package_prefix("package://");
+    size_t pos1 = model_xml.find(package_prefix,0);
+    while (pos1 != std::string::npos)
+    {
+      size_t pos2 = model_xml.find("/", pos1+10);
+      //ROS_DEBUG_NAMED("api_plugin", " pos %d %d",(int)pos1, (int)pos2);
+      if (pos2 == std::string::npos || pos1 >= pos2)
+      {
+        ROS_ERROR_NAMED("api_plugin", "Malformed package name?");
+        break;
+      }
+
+      std::string package_name = model_xml.substr(pos1+10,pos2-pos1-10);
+      //ROS_DEBUG_NAMED("api_plugin", "package name [%s]", package_name.c_str());
+      std::string package_path = ros::package::getPath(package_name);
+      if (package_path.empty())
+      {
+        ROS_FATAL_NAMED("api_plugin", "Package[%s] does not have a path",package_name.c_str());
+        res.success = false;
+        res.status_message = "urdf reference package name does not exist: " + package_name;
+        return false;
+      }
+      ROS_DEBUG_ONCE_NAMED("api_plugin", "Package name [%s] has path [%s]", package_name.c_str(), package_path.c_str());
+
+      model_xml.replace(pos1,(pos2-pos1),package_path);
+      pos1 = model_xml.find(package_prefix, pos1);
+    }
+  }
+  // ROS_DEBUG_NAMED("api_plugin", "Model XML\n\n%s\n\n ",model_xml.c_str());
+
+  req.model_xml = model_xml;
+
+  // Model is now considered convert to SDF
+  return spawnSDFModel(req,res);
+}
+
+bool GazeboRosApiPlugin::spawnSDFModel(gazebo_msgs::SpawnModel::Request &req,
+                                       gazebo_msgs::SpawnModel::Response &res)
+{
+  // incoming entity name
+  std::string model_name = req.model_name;
+
+  // get namespace for the corresponding model plugins
+  robot_namespace_ = req.robot_namespace;
+
+  // get initial pose of model
+  ignition::math::Vector3d initial_xyz(req.initial_pose.position.x,req.initial_pose.position.y,req.initial_pose.position.z);
+  // get initial roll pitch yaw (fixed frame transform)
+  ignition::math::Quaterniond initial_q(req.initial_pose.orientation.w,req.initial_pose.orientation.x,req.initial_pose.orientation.y,req.initial_pose.orientation.z);
+
+  // refernce frame for initial pose definition, modify initial pose if defined
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::EntityPtr frame = world_->EntityByName(req.reference_frame);
+#else
+  gazebo::physics::EntityPtr frame = world_->GetEntity(req.reference_frame);
+#endif
+  if (frame)
+  {
+    // convert to relative pose
+#if GAZEBO_MAJOR_VERSION >= 8
+    ignition::math::Pose3d frame_pose = frame->WorldPose();
+#else
+    ignition::math::Pose3d frame_pose = frame->GetWorldPose().Ign();
+#endif
+    initial_xyz = frame_pose.Pos() + frame_pose.Rot().RotateVector(initial_xyz);
+    initial_q = frame_pose.Rot() * initial_q;
+  }
+
+  /// @todo: map is really wrong, need to use tf here somehow
+  else if (req.reference_frame == "" || req.reference_frame == "world" || req.reference_frame == "map" || req.reference_frame == "/map")
+  {
+    ROS_DEBUG_NAMED("api_plugin", "SpawnModel: reference_frame is empty/world/map, using inertial frame");
+  }
+  else
+  {
+    res.success = false;
+    res.status_message = "SpawnModel: reference reference_frame not found, did you forget to scope the link by model name?";
+    return true;
+  }
+
+  // incoming robot model string
+  std::string model_xml = req.model_xml;
+
+  // store resulting Gazebo Model XML to be sent to spawn queue
+  // get incoming string containg either an URDF or a Gazebo Model XML
+  // grab from parameter server if necessary convert to SDF if necessary
+  stripXmlDeclaration(model_xml);
+
+  // put string in TiXmlDocument for manipulation
+  TiXmlDocument gazebo_model_xml;
+  gazebo_model_xml.Parse(model_xml.c_str());
+
+  // optional model manipulations: update initial pose && replace model name
+  if (isSDF(model_xml))
+  {
+    updateSDFAttributes(gazebo_model_xml, model_name, initial_xyz, initial_q);
+
+    // Walk recursively through the entire SDF, locate plugin tags and
+    // add robotNamespace as a child with the correct namespace
+    if (!this->robot_namespace_.empty())
+    {
+      // Get root element for SDF
+      // TODO: implement the spawning also with <light></light> and <model></model>
+      TiXmlNode* model_tixml = gazebo_model_xml.FirstChild("sdf");
+      model_tixml = (!model_tixml) ?
+          gazebo_model_xml.FirstChild("gazebo") : model_tixml;
+      if (model_tixml)
+      {
+        walkChildAddRobotNamespace(model_tixml);
+      }
+      else
+      {
+        ROS_WARN_NAMED("api_plugin", "Unable to add robot namespace to xml");
+      }
+    }
+  }
+  else if (isURDF(model_xml))
+  {
+    updateURDFModelPose(gazebo_model_xml, initial_xyz, initial_q);
+    updateURDFName(gazebo_model_xml, model_name);
+
+    // Walk recursively through the entire URDF, locate plugin tags and
+    // add robotNamespace as a child with the correct namespace
+    if (!this->robot_namespace_.empty())
+    {
+      // Get root element for URDF
+      TiXmlNode* model_tixml = gazebo_model_xml.FirstChild("robot");
+      if (model_tixml)
+      {
+        walkChildAddRobotNamespace(model_tixml);
+      }
+      else
+      {
+        ROS_WARN_NAMED("api_plugin", "Unable to add robot namespace to xml");
+      }
+    }
+  }
+  else
+  {
+    ROS_ERROR_NAMED("api_plugin", "GazeboRosApiPlugin SpawnModel Failure: input xml format not recognized");
+    res.success = false;
+    res.status_message = "GazeboRosApiPlugin SpawnModel Failure: input model_xml not SDF or URDF, or cannot be converted to Gazebo compatible format.";
+    return true;
+  }
+
+  // do spawning check if spawn worked, return response
+  return spawnAndConform(gazebo_model_xml, model_name, res);
+}
+
+bool GazeboRosApiPlugin::deleteModel(gazebo_msgs::DeleteModel::Request &req,
+                                     gazebo_msgs::DeleteModel::Response &res)
+{
+  // clear forces, etc for the body in question
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::ModelPtr model = world_->ModelByName(req.model_name);
+#else
+  gazebo::physics::ModelPtr model = world_->GetModel(req.model_name);
+#endif
+  if (!model)
+  {
+    ROS_ERROR_NAMED("api_plugin", "DeleteModel: model [%s] does not exist",req.model_name.c_str());
+    res.success = false;
+    res.status_message = "DeleteModel: model does not exist";
+    return true;
+  }
+
+  // delete wrench jobs on bodies
+  for (unsigned int i = 0 ; i < model->GetChildCount(); i ++)
+  {
+    gazebo::physics::LinkPtr body = boost::dynamic_pointer_cast<gazebo::physics::Link>(model->GetChild(i));
+    if (body)
+    {
+      // look for it in jobs, delete body wrench jobs
+      clearBodyWrenches(body->GetScopedName());
+    }
+  }
+
+  // delete force jobs on joints
+  gazebo::physics::Joint_V joints = model->GetJoints();
+  for (unsigned int i=0;i< joints.size(); i++)
+  {
+    // look for it in jobs, delete joint force jobs
+    clearJointForces(joints[i]->GetName());
+  }
+
+  // send delete model request
+  gazebo::msgs::Request *msg = gazebo::msgs::CreateRequest("entity_delete",req.model_name);
+  request_pub_->Publish(*msg,true);
+  delete msg;
+  msg = nullptr;
+
+  ros::Duration model_spawn_timeout(60.0);
+  ros::Time timeout = ros::Time::now() + model_spawn_timeout;
+  // wait and verify that model is deleted
+  while (true)
+  {
+    if (ros::Time::now() > timeout)
+    {
+      res.success = false;
+      res.status_message = "DeleteModel: Model pushed to delete queue, but delete service timed out waiting for model to disappear from simulation";
+      return true;
+    }
+    {
+      //boost::recursive_mutex::scoped_lock lock(*world->GetMRMutex());
+#if GAZEBO_MAJOR_VERSION >= 8
+      if (!world_->ModelByName(req.model_name)) break;
+#else
+      if (!world_->GetModel(req.model_name)) break;
+#endif
+    }
+    ROS_DEBUG_NAMED("api_plugin", "Waiting for model deletion (%s)",req.model_name.c_str());
+    std::this_thread::sleep_for(std::chrono::microseconds(1000));
+  }
+
+  // set result
+  res.success = true;
+  res.status_message = "DeleteModel: successfully deleted model";
+  return true;
+}
+
+bool GazeboRosApiPlugin::deleteLight(gazebo_msgs::DeleteLight::Request &req,
+                                     gazebo_msgs::DeleteLight::Response &res)
+{
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::LightPtr phy_light = world_->LightByName(req.light_name);
+#else
+  gazebo::physics::LightPtr phy_light = world_->Light(req.light_name);
+#endif
+
+  if (phy_light == NULL)
+  {
+    res.success = false;
+    res.status_message = "DeleteLight: Requested light " + req.light_name + " not found!";
+  }
+  else
+  {
+    gazebo::msgs::Request* msg = gazebo::msgs::CreateRequest("entity_delete", req.light_name);
+    request_pub_->Publish(*msg, true);
+    delete msg;
+    msg = nullptr;
+
+    res.success = false;
+
+    for (int i = 0; i < 100; i++)
+    {
+#if GAZEBO_MAJOR_VERSION >= 8
+      phy_light = world_->LightByName(req.light_name);
+#else
+      phy_light = world_->Light(req.light_name);
+#endif
+      if (phy_light == NULL)
+      {
+        res.success = true;
+        res.status_message = "DeleteLight: " + req.light_name + " successfully deleted";
+        return true;
+      }
+      // Check every 100ms
+      std::this_thread::sleep_for(std::chrono::microseconds(100000));
+    }
+  }
+
+  res.status_message = "DeleteLight: Timeout reached while removing light \"" + req.light_name
+                       + "\"";
+
+  return true;
+}
+
+bool GazeboRosApiPlugin::getModelState(gazebo_msgs::GetModelState::Request &req,
+                                       gazebo_msgs::GetModelState::Response &res)
+{
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::ModelPtr model = world_->ModelByName(req.model_name);
+  gazebo::physics::EntityPtr frame = world_->EntityByName(req.relative_entity_name);
+#else
+  gazebo::physics::ModelPtr model = world_->GetModel(req.model_name);
+  gazebo::physics::EntityPtr frame = world_->GetEntity(req.relative_entity_name);
+#endif
+  if (!model)
+  {
+    ROS_ERROR_NAMED("api_plugin", "GetModelState: model [%s] does not exist",req.model_name.c_str());
+    res.success = false;
+    res.status_message = "GetModelState: model does not exist";
+    return true;
+  }
+  else
+  {
+     /**
+     * @brief creates a header for the result
+     * @author Markus Bader markus.bader@tuwien.ac.at
+     * @date 21th Nov 2014
+     **/
+    {
+      std::map<std::string, unsigned int>::iterator it = access_count_get_model_state_.find(req.model_name);
+      if(it == access_count_get_model_state_.end())
+      {
+        access_count_get_model_state_.insert( std::pair<std::string, unsigned int>(req.model_name, 1) );
+        res.header.seq = 1;
+      }
+      else
+      {
+        it->second++;
+        res.header.seq = it->second;
+      }
+      res.header.stamp = ros::Time::now();
+      res.header.frame_id = req.relative_entity_name; /// @brief this is a redundant information
+    }
+    // get model pose
+    // get model twist
+#if GAZEBO_MAJOR_VERSION >= 8
+    ignition::math::Pose3d      model_pose = model->WorldPose();
+    ignition::math::Vector3d model_linear_vel  = model->WorldLinearVel();
+    ignition::math::Vector3d model_angular_vel = model->WorldAngularVel();
+#else
+    ignition::math::Pose3d      model_pose = model->GetWorldPose().Ign();
+    ignition::math::Vector3d model_linear_vel  = model->GetWorldLinearVel().Ign();
+    ignition::math::Vector3d model_angular_vel = model->GetWorldAngularVel().Ign();
+#endif
+    ignition::math::Vector3d    model_pos = model_pose.Pos();
+    ignition::math::Quaterniond model_rot = model_pose.Rot();
+
+
+
+    if (frame)
+    {
+      // convert to relative pose, rates
+#if GAZEBO_MAJOR_VERSION >= 8
+      ignition::math::Pose3d frame_pose = frame->WorldPose();
+      ignition::math::Vector3d frame_vpos = frame->WorldLinearVel(); // get velocity in gazebo frame
+      ignition::math::Vector3d frame_veul = frame->WorldAngularVel(); // get velocity in gazebo frame
+#else
+      ignition::math::Pose3d frame_pose = frame->GetWorldPose().Ign();
+      ignition::math::Vector3d frame_vpos = frame->GetWorldLinearVel().Ign(); // get velocity in gazebo frame
+      ignition::math::Vector3d frame_veul = frame->GetWorldAngularVel().Ign(); // get velocity in gazebo frame
+#endif
+      ignition::math::Pose3d model_rel_pose = model_pose - frame_pose;
+      model_pos = model_rel_pose.Pos();
+      model_rot = model_rel_pose.Rot();
+
+      model_linear_vel = frame_pose.Rot().RotateVectorReverse(model_linear_vel - frame_vpos);
+      model_angular_vel = frame_pose.Rot().RotateVectorReverse(model_angular_vel - frame_veul);
+    }
+    /// @todo: FIXME map is really wrong, need to use tf here somehow
+    else if (req.relative_entity_name == "" || req.relative_entity_name == "world" || req.relative_entity_name == "map" || req.relative_entity_name == "/map")
+    {
+      ROS_DEBUG_NAMED("api_plugin", "GetModelState: relative_entity_name is empty/world/map, using inertial frame");
+    }
+    else
+    {
+      res.success = false;
+      res.status_message = "GetModelState: reference relative_entity_name not found, did you forget to scope the body by model name?";
+      return true;
+    }
+
+    // fill in response
+    res.pose.position.x = model_pos.X();
+    res.pose.position.y = model_pos.Y();
+    res.pose.position.z = model_pos.Z();
+    res.pose.orientation.w = model_rot.W();
+    res.pose.orientation.x = model_rot.X();
+    res.pose.orientation.y = model_rot.Y();
+    res.pose.orientation.z = model_rot.Z();
+
+    res.twist.linear.x = model_linear_vel.X();
+    res.twist.linear.y = model_linear_vel.Y();
+    res.twist.linear.z = model_linear_vel.Z();
+    res.twist.angular.x = model_angular_vel.X();
+    res.twist.angular.y = model_angular_vel.Y();
+    res.twist.angular.z = model_angular_vel.Z();
+
+    res.success = true;
+    res.status_message = "GetModelState: got properties";
+    return true;
+  }
+  return true;
+}
+
+bool GazeboRosApiPlugin::getModelProperties(gazebo_msgs::GetModelProperties::Request &req,
+                                            gazebo_msgs::GetModelProperties::Response &res)
+{
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::ModelPtr model = world_->ModelByName(req.model_name);
+#else
+  gazebo::physics::ModelPtr model = world_->GetModel(req.model_name);
+#endif
+  if (!model)
+  {
+    ROS_ERROR_NAMED("api_plugin", "GetModelProperties: model [%s] does not exist",req.model_name.c_str());
+    res.success = false;
+    res.status_message = "GetModelProperties: model does not exist";
+    return true;
+  }
+  else
+  {
+    // get model parent name
+    gazebo::physics::ModelPtr parent_model = boost::dynamic_pointer_cast<gazebo::physics::Model>(model->GetParent());
+    if (parent_model) res.parent_model_name = parent_model->GetName();
+
+    // get list of child bodies, geoms
+    res.body_names.clear();
+    res.geom_names.clear();
+    for (unsigned int i = 0 ; i < model->GetChildCount(); i ++)
+    {
+      gazebo::physics::LinkPtr body = boost::dynamic_pointer_cast<gazebo::physics::Link>(model->GetChild(i));
+      if (body)
+      {
+        res.body_names.push_back(body->GetName());
+        // get list of geoms
+        for (unsigned int j = 0; j < body->GetChildCount() ; j++)
+        {
+          gazebo::physics::CollisionPtr geom = boost::dynamic_pointer_cast<gazebo::physics::Collision>(body->GetChild(j));
+          if (geom)
+            res.geom_names.push_back(geom->GetName());
+        }
+      }
+    }
+
+    // get list of joints
+    res.joint_names.clear();
+
+    gazebo::physics::Joint_V joints = model->GetJoints();
+    for (unsigned int i=0;i< joints.size(); i++)
+      res.joint_names.push_back( joints[i]->GetName() );
+
+    // get children model names
+    res.child_model_names.clear();
+    for (unsigned int j = 0; j < model->GetChildCount(); j++)
+    {
+      gazebo::physics::ModelPtr child_model = boost::dynamic_pointer_cast<gazebo::physics::Model>(model->GetChild(j));
+      if (child_model)
+        res.child_model_names.push_back(child_model->GetName() );
+    }
+
+    // is model static
+    res.is_static = model->IsStatic();
+
+    res.success = true;
+    res.status_message = "GetModelProperties: got properties";
+    return true;
+  }
+  return true;
+}
+
+bool GazeboRosApiPlugin::getWorldProperties(gazebo_msgs::GetWorldProperties::Request &req,
+                                            gazebo_msgs::GetWorldProperties::Response &res)
+{
+  res.model_names.clear();
+#if GAZEBO_MAJOR_VERSION >= 8
+  res.sim_time = world_->SimTime().Double();
+  for (unsigned int i = 0; i < world_->ModelCount(); i ++)
+    res.model_names.push_back(world_->ModelByIndex(i)->GetName());
+#else
+  res.sim_time = world_->GetSimTime().Double();
+  for (unsigned int i = 0; i < world_->GetModelCount(); i ++)
+    res.model_names.push_back(world_->GetModel(i)->GetName());
+#endif
+  gzerr << "disabling rendering has not been implemented, rendering is always enabled\n";
+  res.rendering_enabled = true; //world->GetRenderEngineEnabled();
+  res.success = true;
+  res.status_message = "GetWorldProperties: got properties";
+  return true;
+}
+
+bool GazeboRosApiPlugin::getJointProperties(gazebo_msgs::GetJointProperties::Request &req,
+                                            gazebo_msgs::GetJointProperties::Response &res)
+{
+  gazebo::physics::JointPtr joint;
+#if GAZEBO_MAJOR_VERSION >= 8
+  for (unsigned int i = 0; i < world_->ModelCount(); i ++)
+  {
+    joint = world_->ModelByIndex(i)->GetJoint(req.joint_name);
+#else
+  for (unsigned int i = 0; i < world_->GetModelCount(); i ++)
+  {
+    joint = world_->GetModel(i)->GetJoint(req.joint_name);
+#endif
+    if (joint) break;
+  }
+
+  if (!joint)
+  {
+    res.success = false;
+    res.status_message = "GetJointProperties: joint not found";
+    return true;
+  }
+  else
+  {
+    /// @todo: FIXME
+    res.type = res.REVOLUTE;
+
+    res.damping.clear(); // to be added to gazebo
+    //res.damping.push_back(joint->GetDamping(0));
+
+    res.position.clear();
+#if GAZEBO_MAJOR_VERSION >= 8
+    res.position.push_back(joint->Position(0));
+#else
+    res.position.push_back(joint->GetAngle(0).Radian());
+#endif
+
+    res.rate.clear(); // use GetVelocity(i)
+    res.rate.push_back(joint->GetVelocity(0));
+
+    res.success = true;
+    res.status_message = "GetJointProperties: got properties";
+    return true;
+  }
+}
+
+bool GazeboRosApiPlugin::getLinkProperties(gazebo_msgs::GetLinkProperties::Request &req,
+                                           gazebo_msgs::GetLinkProperties::Response &res)
+{
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::LinkPtr body = boost::dynamic_pointer_cast<gazebo::physics::Link>(world_->EntityByName(req.link_name));
+#else
+  gazebo::physics::LinkPtr body = boost::dynamic_pointer_cast<gazebo::physics::Link>(world_->GetEntity(req.link_name));
+#endif
+  if (!body)
+  {
+    res.success = false;
+    res.status_message = "GetLinkProperties: link not found, did you forget to scope the link by model name?";
+    return true;
+  }
+  else
+  {
+    /// @todo: validate
+    res.gravity_mode = body->GetGravityMode();
+
+    gazebo::physics::InertialPtr inertia = body->GetInertial();
+
+#if GAZEBO_MAJOR_VERSION >= 8
+    res.mass = body->GetInertial()->Mass();
+
+    res.ixx = inertia->IXX();
+    res.iyy = inertia->IYY();
+    res.izz = inertia->IZZ();
+    res.ixy = inertia->IXY();
+    res.ixz = inertia->IXZ();
+    res.iyz = inertia->IYZ();
+
+    ignition::math::Vector3d com = body->GetInertial()->CoG();
+#else
+    res.mass = body->GetInertial()->GetMass();
+
+    res.ixx = inertia->GetIXX();
+    res.iyy = inertia->GetIYY();
+    res.izz = inertia->GetIZZ();
+    res.ixy = inertia->GetIXY();
+    res.ixz = inertia->GetIXZ();
+    res.iyz = inertia->GetIYZ();
+
+    ignition::math::Vector3d com = body->GetInertial()->GetCoG().Ign();
+#endif
+    res.com.position.x = com.X();
+    res.com.position.y = com.Y();
+    res.com.position.z = com.Z();
+    res.com.orientation.x = 0; // @todo: gazebo do not support rotated inertia yet
+    res.com.orientation.y = 0;
+    res.com.orientation.z = 0;
+    res.com.orientation.w = 1;
+
+    res.success = true;
+    res.status_message = "GetLinkProperties: got properties";
+    return true;
+  }
+}
+
+bool GazeboRosApiPlugin::getLinkState(gazebo_msgs::GetLinkState::Request &req,
+                                      gazebo_msgs::GetLinkState::Response &res)
+{
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::LinkPtr body = boost::dynamic_pointer_cast<gazebo::physics::Link>(world_->EntityByName(req.link_name));
+  gazebo::physics::EntityPtr frame = world_->EntityByName(req.reference_frame);
+#else
+  gazebo::physics::LinkPtr body = boost::dynamic_pointer_cast<gazebo::physics::Link>(world_->GetEntity(req.link_name));
+  gazebo::physics::EntityPtr frame = world_->GetEntity(req.reference_frame);
+#endif
+
+  if (!body)
+  {
+    res.success = false;
+    res.status_message = "GetLinkState: link not found, did you forget to scope the link by model name?";
+    return true;
+  }
+
+  // get body pose
+  // Get inertial rates
+#if GAZEBO_MAJOR_VERSION >= 8
+  ignition::math::Pose3d body_pose = body->WorldPose();
+  ignition::math::Vector3d body_vpos = body->WorldLinearVel(); // get velocity in gazebo frame
+  ignition::math::Vector3d body_veul = body->WorldAngularVel(); // get velocity in gazebo frame
+#else
+  ignition::math::Pose3d body_pose = body->GetWorldPose().Ign();
+  ignition::math::Vector3d body_vpos = body->GetWorldLinearVel().Ign(); // get velocity in gazebo frame
+  ignition::math::Vector3d body_veul = body->GetWorldAngularVel().Ign(); // get velocity in gazebo frame
+#endif
+
+  if (frame)
+  {
+    // convert to relative pose, rates
+#if GAZEBO_MAJOR_VERSION >= 8
+    ignition::math::Pose3d frame_pose = frame->WorldPose();
+    ignition::math::Vector3d frame_vpos = frame->WorldLinearVel(); // get velocity in gazebo frame
+    ignition::math::Vector3d frame_veul = frame->WorldAngularVel(); // get velocity in gazebo frame
+#else
+    ignition::math::Pose3d frame_pose = frame->GetWorldPose().Ign();
+    ignition::math::Vector3d frame_vpos = frame->GetWorldLinearVel().Ign(); // get velocity in gazebo frame
+    ignition::math::Vector3d frame_veul = frame->GetWorldAngularVel().Ign(); // get velocity in gazebo frame
+#endif
+    body_pose = body_pose - frame_pose;
+
+    body_vpos = frame_pose.Rot().RotateVectorReverse(body_vpos - frame_vpos);
+    body_veul = frame_pose.Rot().RotateVectorReverse(body_veul - frame_veul);
+  }
+  /// @todo: FIXME map is really wrong, need to use tf here somehow
+  else if (req.reference_frame == "" || req.reference_frame == "world" || req.reference_frame == "map" || req.reference_frame == "/map")
+  {
+    ROS_DEBUG_NAMED("api_plugin", "GetLinkState: reference_frame is empty/world/map, using inertial frame");
+  }
+  else
+  {
+    res.success = false;
+    res.status_message = "GetLinkState: reference reference_frame not found, did you forget to scope the link by model name?";
+    return true;
+  }
+
+  res.link_state.link_name = req.link_name;
+  res.link_state.pose.position.x = body_pose.Pos().X();
+  res.link_state.pose.position.y = body_pose.Pos().Y();
+  res.link_state.pose.position.z = body_pose.Pos().Z();
+  res.link_state.pose.orientation.x = body_pose.Rot().X();
+  res.link_state.pose.orientation.y = body_pose.Rot().Y();
+  res.link_state.pose.orientation.z = body_pose.Rot().Z();
+  res.link_state.pose.orientation.w = body_pose.Rot().W();
+  res.link_state.twist.linear.x = body_vpos.X();
+  res.link_state.twist.linear.y = body_vpos.Y();
+  res.link_state.twist.linear.z = body_vpos.Z();
+  res.link_state.twist.angular.x = body_veul.X();
+  res.link_state.twist.angular.y = body_veul.Y();
+  res.link_state.twist.angular.z = body_veul.Z();
+  res.link_state.reference_frame = req.reference_frame;
+
+  res.success = true;
+  res.status_message = "GetLinkState: got state";
+  return true;
+}
+
+bool GazeboRosApiPlugin::getLightProperties(gazebo_msgs::GetLightProperties::Request &req,
+                                               gazebo_msgs::GetLightProperties::Response &res)
+{
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::LightPtr phy_light = world_->LightByName(req.light_name);
+#else
+  gazebo::physics::LightPtr phy_light = world_->Light(req.light_name);
+#endif
+
+  if (phy_light == NULL)
+  {
+      res.success = false;
+      res.status_message = "getLightProperties: Requested light " + req.light_name + " not found!";
+  }
+  else
+  {
+    gazebo::msgs::Light light;
+    phy_light->FillMsg(light);
+
+    res.diffuse.r = light.diffuse().r();
+    res.diffuse.g = light.diffuse().g();
+    res.diffuse.b = light.diffuse().b();
+    res.diffuse.a = light.diffuse().a();
+
+    res.attenuation_constant = light.attenuation_constant();
+    res.attenuation_linear = light.attenuation_linear();
+    res.attenuation_quadratic = light.attenuation_quadratic();
+
+    res.success = true;
+  }
+
+  return true;
+}
+
+bool GazeboRosApiPlugin::setLightProperties(gazebo_msgs::SetLightProperties::Request &req,
+                                               gazebo_msgs::SetLightProperties::Response &res)
+{
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::LightPtr phy_light = world_->LightByName(req.light_name);
+#else
+  gazebo::physics::LightPtr phy_light = world_->Light(req.light_name);
+#endif
+
+  if (phy_light == NULL)
+  {
+    res.success = false;
+    res.status_message = "setLightProperties: Requested light " + req.light_name + " not found!";
+  }
+  else
+  {
+    gazebo::msgs::Light light;
+
+    phy_light->FillMsg(light);
+
+    light.set_cast_shadows(req.cast_shadows);
+
+    light.mutable_diffuse()->set_r(req.diffuse.r);
+    light.mutable_diffuse()->set_g(req.diffuse.g);
+    light.mutable_diffuse()->set_b(req.diffuse.b);
+    light.mutable_diffuse()->set_a(req.diffuse.a);
+
+    light.mutable_specular()->set_r(req.specular.r);
+    light.mutable_specular()->set_g(req.specular.g);
+    light.mutable_specular()->set_b(req.specular.b);
+    light.mutable_specular()->set_a(req.specular.a);
+
+    light.set_attenuation_constant(req.attenuation_constant);
+    light.set_attenuation_linear(req.attenuation_linear);
+    light.set_attenuation_quadratic(req.attenuation_quadratic);
+
+    light.mutable_direction()->set_x(req.direction.x);
+    light.mutable_direction()->set_y(req.direction.y);
+    light.mutable_direction()->set_z(req.direction.z);
+
+    light.mutable_pose()->mutable_position()->set_x(req.pose.position.x);
+    light.mutable_pose()->mutable_position()->set_y(req.pose.position.y);
+    light.mutable_pose()->mutable_position()->set_z(req.pose.position.z);
+    light.mutable_pose()->mutable_orientation()->set_w(req.pose.orientation.w);
+    light.mutable_pose()->mutable_orientation()->set_x(req.pose.orientation.x);
+    light.mutable_pose()->mutable_orientation()->set_y(req.pose.orientation.y);
+    light.mutable_pose()->mutable_orientation()->set_z(req.pose.orientation.z);
+
+    light_modify_pub_->Publish(light, true);
+
+    res.success = true;
+  }
+
+  return true;
+}
+
+bool GazeboRosApiPlugin::setLinkProperties(gazebo_msgs::SetLinkProperties::Request &req,
+                                           gazebo_msgs::SetLinkProperties::Response &res)
+{
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::LinkPtr body = boost::dynamic_pointer_cast<gazebo::physics::Link>(world_->EntityByName(req.link_name));
+#else
+  gazebo::physics::LinkPtr body = boost::dynamic_pointer_cast<gazebo::physics::Link>(world_->GetEntity(req.link_name));
+#endif
+  if (!body)
+  {
+    res.success = false;
+    res.status_message = "SetLinkProperties: link not found, did you forget to scope the link by model name?";
+    return true;
+  }
+  else
+  {
+    gazebo::physics::InertialPtr mass = body->GetInertial();
+    // @todo: FIXME: add inertia matrix rotation to Gazebo
+    // mass.SetInertiaRotation(ignition::math::Quaterniondion(req.com.orientation.w,res.com.orientation.x,req.com.orientation.y req.com.orientation.z));
+    mass->SetCoG(ignition::math::Vector3d(req.com.position.x,req.com.position.y,req.com.position.z));
+    mass->SetInertiaMatrix(req.ixx,req.iyy,req.izz,req.ixy,req.ixz,req.iyz);
+    mass->SetMass(req.mass);
+    body->SetGravityMode(req.gravity_mode);
+    // @todo: mass change unverified
+    res.success = true;
+    res.status_message = "SetLinkProperties: properties set";
+    return true;
+  }
+}
+
+bool GazeboRosApiPlugin::setPhysicsProperties(gazebo_msgs::SetPhysicsProperties::Request &req,
+                                              gazebo_msgs::SetPhysicsProperties::Response &res)
+{
+  // pause simulation if requested
+  bool is_paused = world_->IsPaused();
+  world_->SetPaused(true);
+  world_->SetGravity(ignition::math::Vector3d(req.gravity.x,req.gravity.y,req.gravity.z));
+
+  // supported updates
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::PhysicsEnginePtr pe = (world_->Physics());
+#else
+  gazebo::physics::PhysicsEnginePtr pe = (world_->GetPhysicsEngine());
+#endif
+  pe->SetMaxStepSize(req.time_step);
+  pe->SetRealTimeUpdateRate(req.max_update_rate);
+
+  if (pe->GetType() == "ode")
+  {
+    // stuff only works in ODE right now
+    pe->SetAutoDisableFlag(req.ode_config.auto_disable_bodies);
+    pe->SetParam("precon_iters", int(req.ode_config.sor_pgs_precon_iters));
+    pe->SetParam("iters", int(req.ode_config.sor_pgs_iters));
+    pe->SetParam("sor", req.ode_config.sor_pgs_w);
+    pe->SetParam("cfm", req.ode_config.cfm);
+    pe->SetParam("erp", req.ode_config.erp);
+    pe->SetParam("contact_surface_layer",
+        req.ode_config.contact_surface_layer);
+    pe->SetParam("contact_max_correcting_vel",
+        req.ode_config.contact_max_correcting_vel);
+    pe->SetParam("max_contacts", int(req.ode_config.max_contacts));
+
+    world_->SetPaused(is_paused);
+
+    res.success = true;
+    res.status_message = "physics engine updated";
+  }
+  else
+  {
+    /// \TODO: add support for simbody, dart and bullet physics properties.
+    ROS_ERROR_NAMED("api_plugin", "ROS set_physics_properties service call does not yet support physics engine [%s].", pe->GetType().c_str());
+    res.success = false;
+    res.status_message = "Physics engine [" + pe->GetType() + "]: set_physics_properties not supported.";
+  }
+  return res.success;
+}
+
+bool GazeboRosApiPlugin::getPhysicsProperties(gazebo_msgs::GetPhysicsProperties::Request &req,
+                                              gazebo_msgs::GetPhysicsProperties::Response &res)
+{
+  // supported updates
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::PhysicsEnginePtr pe = (world_->Physics());
+#else
+  gazebo::physics::PhysicsEnginePtr pe = (world_->GetPhysicsEngine());
+#endif
+  res.time_step = pe->GetMaxStepSize();
+  res.pause = world_->IsPaused();
+  res.max_update_rate = pe->GetRealTimeUpdateRate();
+  ignition::math::Vector3d gravity = world_->Gravity();
+  res.gravity.x = gravity.X();
+  res.gravity.y = gravity.Y();
+  res.gravity.z = gravity.Z();
+
+  // stuff only works in ODE right now
+  if (pe->GetType() == "ode")
+  {
+    res.ode_config.auto_disable_bodies =
+      pe->GetAutoDisableFlag();
+    res.ode_config.sor_pgs_precon_iters = boost::any_cast<int>(
+      pe->GetParam("precon_iters"));
+    res.ode_config.sor_pgs_iters = boost::any_cast<int>(
+        pe->GetParam("iters"));
+    res.ode_config.sor_pgs_w = boost::any_cast<double>(
+        pe->GetParam("sor"));
+    res.ode_config.contact_surface_layer = boost::any_cast<double>(
+      pe->GetParam("contact_surface_layer"));
+    res.ode_config.contact_max_correcting_vel = boost::any_cast<double>(
+      pe->GetParam("contact_max_correcting_vel"));
+    res.ode_config.cfm = boost::any_cast<double>(
+        pe->GetParam("cfm"));
+    res.ode_config.erp = boost::any_cast<double>(
+        pe->GetParam("erp"));
+    res.ode_config.max_contacts = boost::any_cast<int>(
+      pe->GetParam("max_contacts"));
+
+    res.success = true;
+    res.status_message = "GetPhysicsProperties: got properties";
+  }
+  else
+  {
+    /// \TODO: add support for simbody, dart and bullet physics properties.
+    ROS_ERROR_NAMED("api_plugin", "ROS get_physics_properties service call does not yet support physics engine [%s].", pe->GetType().c_str());
+    res.success = false;
+    res.status_message = "Physics engine [" + pe->GetType() + "]: get_physics_properties not supported.";
+  }
+  return res.success;
+}
+
+bool GazeboRosApiPlugin::setJointProperties(gazebo_msgs::SetJointProperties::Request &req,
+                                            gazebo_msgs::SetJointProperties::Response &res)
+{
+  /// @todo: current settings only allows for setting of 1DOF joints (e.g. HingeJoint and SliderJoint) correctly.
+  gazebo::physics::JointPtr joint;
+#if GAZEBO_MAJOR_VERSION >= 8
+  for (unsigned int i = 0; i < world_->ModelCount(); i ++)
+  {
+    joint = world_->ModelByIndex(i)->GetJoint(req.joint_name);
+#else
+  for (unsigned int i = 0; i < world_->GetModelCount(); i ++)
+  {
+    joint = world_->GetModel(i)->GetJoint(req.joint_name);
+#endif
+    if (joint) break;
+  }
+
+  if (!joint)
+  {
+    res.success = false;
+    res.status_message = "SetJointProperties: joint not found";
+    return true;
+  }
+  else
+  {
+    for(unsigned int i=0;i< req.ode_joint_config.damping.size();i++)
+      joint->SetDamping(i,req.ode_joint_config.damping[i]);
+    for(unsigned int i=0;i< req.ode_joint_config.hiStop.size();i++)
+      joint->SetParam("hi_stop",i,req.ode_joint_config.hiStop[i]);
+    for(unsigned int i=0;i< req.ode_joint_config.loStop.size();i++)
+      joint->SetParam("lo_stop",i,req.ode_joint_config.loStop[i]);
+    for(unsigned int i=0;i< req.ode_joint_config.erp.size();i++)
+      joint->SetParam("erp",i,req.ode_joint_config.erp[i]);
+    for(unsigned int i=0;i< req.ode_joint_config.cfm.size();i++)
+      joint->SetParam("cfm",i,req.ode_joint_config.cfm[i]);
+    for(unsigned int i=0;i< req.ode_joint_config.stop_erp.size();i++)
+      joint->SetParam("stop_erp",i,req.ode_joint_config.stop_erp[i]);
+    for(unsigned int i=0;i< req.ode_joint_config.stop_cfm.size();i++)
+      joint->SetParam("stop_cfm",i,req.ode_joint_config.stop_cfm[i]);
+    for(unsigned int i=0;i< req.ode_joint_config.fudge_factor.size();i++)
+      joint->SetParam("fudge_factor",i,req.ode_joint_config.fudge_factor[i]);
+    for(unsigned int i=0;i< req.ode_joint_config.fmax.size();i++)
+      joint->SetParam("fmax",i,req.ode_joint_config.fmax[i]);
+    for(unsigned int i=0;i< req.ode_joint_config.vel.size();i++)
+      joint->SetParam("vel",i,req.ode_joint_config.vel[i]);
+
+    res.success = true;
+    res.status_message = "SetJointProperties: properties set";
+    return true;
+  }
+}
+
+bool GazeboRosApiPlugin::setModelState(gazebo_msgs::SetModelState::Request &req,
+                                       gazebo_msgs::SetModelState::Response &res)
+{
+  ignition::math::Vector3d target_pos(req.model_state.pose.position.x,req.model_state.pose.position.y,req.model_state.pose.position.z);
+  ignition::math::Quaterniond target_rot(req.model_state.pose.orientation.w,req.model_state.pose.orientation.x,req.model_state.pose.orientation.y,req.model_state.pose.orientation.z);
+  target_rot.Normalize(); // eliminates invalid rotation (0, 0, 0, 0)
+  ignition::math::Pose3d target_pose(target_pos,target_rot);
+  ignition::math::Vector3d target_pos_dot(req.model_state.twist.linear.x,req.model_state.twist.linear.y,req.model_state.twist.linear.z);
+  ignition::math::Vector3d target_rot_dot(req.model_state.twist.angular.x,req.model_state.twist.angular.y,req.model_state.twist.angular.z);
+
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::ModelPtr model = world_->ModelByName(req.model_state.model_name);
+#else
+  gazebo::physics::ModelPtr model = world_->GetModel(req.model_state.model_name);
+#endif
+  if (!model)
+  {
+    ROS_ERROR_NAMED("api_plugin", "Updating ModelState: model [%s] does not exist",req.model_state.model_name.c_str());
+    res.success = false;
+    res.status_message = "SetModelState: model does not exist";
+    return true;
+  }
+  else
+  {
+#if GAZEBO_MAJOR_VERSION >= 8
+    gazebo::physics::EntityPtr relative_entity = world_->EntityByName(req.model_state.reference_frame);
+#else
+    gazebo::physics::EntityPtr relative_entity = world_->GetEntity(req.model_state.reference_frame);
+#endif
+    if (relative_entity)
+    {
+#if GAZEBO_MAJOR_VERSION >= 8
+      ignition::math::Pose3d  frame_pose = relative_entity->WorldPose(); // - myBody->GetCoMPose();
+#else
+      ignition::math::Pose3d  frame_pose = relative_entity->GetWorldPose().Ign(); // - myBody->GetCoMPose();
+#endif
+
+      target_pose = target_pose + frame_pose;
+
+      // Velocities should be commanded in the requested reference
+      // frame, so we need to translate them to the world frame
+      target_pos_dot = frame_pose.Rot().RotateVector(target_pos_dot);
+      target_rot_dot = frame_pose.Rot().RotateVector(target_rot_dot);
+    }
+    /// @todo: FIXME map is really wrong, need to use tf here somehow
+    else if (req.model_state.reference_frame == "" || req.model_state.reference_frame == "world" || req.model_state.reference_frame == "map" || req.model_state.reference_frame == "/map" )
+    {
+      ROS_DEBUG_NAMED("api_plugin", "Updating ModelState: reference frame is empty/world/map, usig inertial frame");
+    }
+    else
+    {
+      ROS_ERROR_NAMED("api_plugin", "Updating ModelState: for model[%s], specified reference frame entity [%s] does not exist",
+                req.model_state.model_name.c_str(),req.model_state.reference_frame.c_str());
+      res.success = false;
+      res.status_message = "SetModelState: specified reference frame entity does not exist";
+      return true;
+    }
+
+    //ROS_ERROR_NAMED("api_plugin", "target state: %f %f %f",target_pose.Pos().X(),target_pose.Pos().Y(),target_pose.Pos().Z());
+    bool is_paused = world_->IsPaused();
+    world_->SetPaused(true);
+    model->SetWorldPose(target_pose);
+    world_->SetPaused(is_paused);
+#if GAZEBO_MAJOR_VERSION >= 8
+    //ignition::math::Pose3d p3d = model->WorldPose();
+#else
+    //ignition::math::Pose3d p3d = model->GetWorldPose().Ign();
+#endif
+    //ROS_ERROR_NAMED("api_plugin", "model updated state: %f %f %f",p3d.Pos().X(),p3d.Pos().Y(),p3d.Pos().Z());
+
+    // set model velocity
+    model->SetLinearVel(target_pos_dot);
+    model->SetAngularVel(target_rot_dot);
+
+    res.success = true;
+    res.status_message = "SetModelState: set model state done";
+    return true;
+  }
+}
+
+void GazeboRosApiPlugin::updateModelState(const gazebo_msgs::ModelState::ConstPtr& model_state)
+{
+  gazebo_msgs::SetModelState::Response res;
+  gazebo_msgs::SetModelState::Request req;
+  req.model_state = *model_state;
+  /*bool success =*/ setModelState(req,res);
+}
+
+bool GazeboRosApiPlugin::applyJointEffort(gazebo_msgs::ApplyJointEffort::Request &req,
+                                          gazebo_msgs::ApplyJointEffort::Response &res)
+{
+  gazebo::physics::JointPtr joint;
+#if GAZEBO_MAJOR_VERSION >= 8
+  for (unsigned int i = 0; i < world_->ModelCount(); i ++)
+  {
+    joint = world_->ModelByIndex(i)->GetJoint(req.joint_name);
+#else
+  for (unsigned int i = 0; i < world_->GetModelCount(); i ++)
+  {
+    joint = world_->GetModel(i)->GetJoint(req.joint_name);
+#endif
+    if (joint)
+    {
+      GazeboRosApiPlugin::ForceJointJob* fjj = new GazeboRosApiPlugin::ForceJointJob;
+      fjj->joint = joint;
+      fjj->force = req.effort;
+      fjj->start_time = req.start_time;
+#if GAZEBO_MAJOR_VERSION >= 8
+      if (fjj->start_time < ros::Time(world_->SimTime().Double()))
+        fjj->start_time = ros::Time(world_->SimTime().Double());
+#else
+      if (fjj->start_time < ros::Time(world_->GetSimTime().Double()))
+        fjj->start_time = ros::Time(world_->GetSimTime().Double());
+#endif
+      fjj->duration = req.duration;
+      lock_.lock();
+      force_joint_jobs_.push_back(fjj);
+      lock_.unlock();
+
+      res.success = true;
+      res.status_message = "ApplyJointEffort: effort set";
+      return true;
+    }
+  }
+
+  res.success = false;
+  res.status_message = "ApplyJointEffort: joint not found";
+  return true;
+}
+
+bool GazeboRosApiPlugin::resetSimulation(std_srvs::Empty::Request &req,std_srvs::Empty::Response &res)
+{
+  world_->Reset();
+  return true;
+}
+
+bool GazeboRosApiPlugin::resetWorld(std_srvs::Empty::Request &req,std_srvs::Empty::Response &res)
+{
+  world_->ResetEntities(gazebo::physics::Base::MODEL);
+  return true;
+}
+
+bool GazeboRosApiPlugin::pausePhysics(std_srvs::Empty::Request &req,std_srvs::Empty::Response &res)
+{
+  world_->SetPaused(true);
+  return true;
+}
+
+bool GazeboRosApiPlugin::unpausePhysics(std_srvs::Empty::Request &req,std_srvs::Empty::Response &res)
+{
+  world_->SetPaused(false);
+  return true;
+}
+
+bool GazeboRosApiPlugin::clearJointForces(gazebo_msgs::JointRequest::Request &req,
+                                          gazebo_msgs::JointRequest::Response &res)
+{
+  return clearJointForces(req.joint_name);
+}
+bool GazeboRosApiPlugin::clearJointForces(std::string joint_name)
+{
+  bool search = true;
+  lock_.lock();
+  while(search)
+  {
+    search = false;
+    for (std::vector<GazeboRosApiPlugin::ForceJointJob*>::iterator iter=force_joint_jobs_.begin();iter!=force_joint_jobs_.end();++iter)
+    {
+      if ((*iter)->joint->GetName() == joint_name)
+      {
+        // found one, search through again
+        search = true;
+        delete (*iter);
+        force_joint_jobs_.erase(iter);
+        break;
+      }
+    }
+  }
+  lock_.unlock();
+  return true;
+}
+
+bool GazeboRosApiPlugin::clearBodyWrenches(gazebo_msgs::BodyRequest::Request &req,
+                                           gazebo_msgs::BodyRequest::Response &res)
+{
+  return clearBodyWrenches(req.body_name);
+}
+bool GazeboRosApiPlugin::clearBodyWrenches(std::string body_name)
+{
+  bool search = true;
+  lock_.lock();
+  while(search)
+  {
+    search = false;
+    for (std::vector<GazeboRosApiPlugin::WrenchBodyJob*>::iterator iter=wrench_body_jobs_.begin();iter!=wrench_body_jobs_.end();++iter)
+    {
+      //ROS_ERROR_NAMED("api_plugin", "search %s %s",(*iter)->body->GetScopedName().c_str(), body_name.c_str());
+      if ((*iter)->body->GetScopedName() == body_name)
+      {
+        // found one, search through again
+        search = true;
+        delete (*iter);
+        wrench_body_jobs_.erase(iter);
+        break;
+      }
+    }
+  }
+  lock_.unlock();
+  return true;
+}
+
+bool GazeboRosApiPlugin::setModelConfiguration(gazebo_msgs::SetModelConfiguration::Request &req,
+                                               gazebo_msgs::SetModelConfiguration::Response &res)
+{
+  std::string gazebo_model_name = req.model_name;
+
+  // search for model with name
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::ModelPtr gazebo_model = world_->ModelByName(req.model_name);
+#else
+  gazebo::physics::ModelPtr gazebo_model = world_->GetModel(req.model_name);
+#endif
+  if (!gazebo_model)
+  {
+    ROS_ERROR_NAMED("api_plugin", "SetModelConfiguration: model [%s] does not exist",gazebo_model_name.c_str());
+    res.success = false;
+    res.status_message = "SetModelConfiguration: model does not exist";
+    return true;
+  }
+
+  if (req.joint_names.size() == req.joint_positions.size())
+  {
+    std::map<std::string, double> joint_position_map;
+    for (unsigned int i = 0; i < req.joint_names.size(); i++)
+    {
+      joint_position_map[req.joint_names[i]] = req.joint_positions[i];
+    }
+
+    // make the service call to pause gazebo
+    bool is_paused = world_->IsPaused();
+    if (!is_paused) world_->SetPaused(true);
+
+    gazebo_model->SetJointPositions(joint_position_map);
+
+    // resume paused state before this call
+    world_->SetPaused(is_paused);
+
+    res.success = true;
+    res.status_message = "SetModelConfiguration: success";
+    return true;
+  }
+  else
+  {
+    res.success = false;
+    res.status_message = "SetModelConfiguration: joint name and position list have different lengths";
+    return true;
+  }
+}
+
+bool GazeboRosApiPlugin::setLinkState(gazebo_msgs::SetLinkState::Request &req,
+                                      gazebo_msgs::SetLinkState::Response &res)
+{
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::LinkPtr body = boost::dynamic_pointer_cast<gazebo::physics::Link>(world_->EntityByName(req.link_state.link_name));
+  gazebo::physics::LinkPtr frame = boost::dynamic_pointer_cast<gazebo::physics::Link>(world_->EntityByName(req.link_state.reference_frame));
+#else
+  gazebo::physics::LinkPtr body = boost::dynamic_pointer_cast<gazebo::physics::Link>(world_->GetEntity(req.link_state.link_name));
+  gazebo::physics::EntityPtr frame = world_->GetEntity(req.link_state.reference_frame);
+#endif
+  if (!body)
+  {
+    ROS_ERROR_NAMED("api_plugin", "Updating LinkState: link [%s] does not exist",req.link_state.link_name.c_str());
+    res.success = false;
+    res.status_message = "SetLinkState: link does not exist";
+    return true;
+  }
+
+  /// @todo: FIXME map is really wrong, unless using tf here somehow
+  // get reference frame (body/model(link)) pose and
+  // transform target pose to absolute world frame
+  ignition::math::Vector3d target_pos(req.link_state.pose.position.x,req.link_state.pose.position.y,req.link_state.pose.position.z);
+  ignition::math::Quaterniond target_rot(req.link_state.pose.orientation.w,req.link_state.pose.orientation.x,req.link_state.pose.orientation.y,req.link_state.pose.orientation.z);
+  ignition::math::Pose3d target_pose(target_pos,target_rot);
+  ignition::math::Vector3d target_linear_vel(req.link_state.twist.linear.x,req.link_state.twist.linear.y,req.link_state.twist.linear.z);
+  ignition::math::Vector3d target_angular_vel(req.link_state.twist.angular.x,req.link_state.twist.angular.y,req.link_state.twist.angular.z);
+
+  if (frame)
+  {
+#if GAZEBO_MAJOR_VERSION >= 8
+    ignition::math::Pose3d  frame_pose = frame->WorldPose(); // - myBody->GetCoMPose();
+    ignition::math::Vector3d frame_linear_vel = frame->WorldLinearVel();
+    ignition::math::Vector3d frame_angular_vel = frame->WorldAngularVel();
+#else
+    ignition::math::Pose3d  frame_pose = frame->GetWorldPose().Ign(); // - myBody->GetCoMPose();
+    ignition::math::Vector3d frame_linear_vel = frame->GetWorldLinearVel().Ign();
+    ignition::math::Vector3d frame_angular_vel = frame->GetWorldAngularVel().Ign();
+#endif
+    ignition::math::Vector3d frame_pos = frame_pose.Pos();
+    ignition::math::Quaterniond frame_rot = frame_pose.Rot();
+
+    //std::cout << " debug : " << frame->GetName() << " : " << frame_pose << " : " << target_pose << std::endl;
+    target_pose = target_pose + frame_pose;
+
+    target_linear_vel -= frame_linear_vel;
+    target_angular_vel -= frame_angular_vel;
+  }
+  else if (req.link_state.reference_frame == "" || req.link_state.reference_frame == "world" || req.link_state.reference_frame == "map" || req.link_state.reference_frame == "/map")
+  {
+    ROS_INFO_NAMED("api_plugin", "Updating LinkState: reference_frame is empty/world/map, using inertial frame");
+  }
+  else
+  {
+    ROS_ERROR_NAMED("api_plugin", "Updating LinkState: reference_frame is not a valid entity name");
+    res.success = false;
+    res.status_message = "SetLinkState: failed";
+    return true;
+  }
+
+  //std::cout << " debug : " << target_pose << std::endl;
+  //boost::recursive_mutex::scoped_lock lock(*world->GetMRMutex());
+
+  bool is_paused = world_->IsPaused();
+  if (!is_paused) world_->SetPaused(true);
+  body->SetWorldPose(target_pose);
+  world_->SetPaused(is_paused);
+
+  // set body velocity to desired twist
+  body->SetLinearVel(target_linear_vel);
+  body->SetAngularVel(target_angular_vel);
+
+  res.success = true;
+  res.status_message = "SetLinkState: success";
+  return true;
+}
+
+void GazeboRosApiPlugin::updateLinkState(const gazebo_msgs::LinkState::ConstPtr& link_state)
+{
+  gazebo_msgs::SetLinkState::Request req;
+  gazebo_msgs::SetLinkState::Response res;
+  req.link_state = *link_state;
+  /*bool success = */ setLinkState(req,res);
+}
+
+void GazeboRosApiPlugin::transformWrench( ignition::math::Vector3d &target_force, ignition::math::Vector3d &target_torque,
+                                          const ignition::math::Vector3d &reference_force,
+                                          const ignition::math::Vector3d &reference_torque,
+                                          const ignition::math::Pose3d &target_to_reference )
+{
+  // rotate force into target frame
+  target_force = target_to_reference.Rot().RotateVector(reference_force);
+  // rotate torque into target frame
+  target_torque = target_to_reference.Rot().RotateVector(reference_torque);
+
+  // target force is the refence force rotated by the target->reference transform
+  target_torque = target_torque + target_to_reference.Pos().Cross(target_force);
+}
+
+bool GazeboRosApiPlugin::applyBodyWrench(gazebo_msgs::ApplyBodyWrench::Request &req,
+                                         gazebo_msgs::ApplyBodyWrench::Response &res)
+{
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::LinkPtr body = boost::dynamic_pointer_cast<gazebo::physics::Link>(world_->EntityByName(req.body_name));
+  gazebo::physics::EntityPtr frame = world_->EntityByName(req.reference_frame);
+#else
+  gazebo::physics::LinkPtr body = boost::dynamic_pointer_cast<gazebo::physics::Link>(world_->GetEntity(req.body_name));
+  gazebo::physics::EntityPtr frame = world_->GetEntity(req.reference_frame);
+#endif
+  if (!body)
+  {
+    ROS_ERROR_NAMED("api_plugin", "ApplyBodyWrench: body [%s] does not exist",req.body_name.c_str());
+    res.success = false;
+    res.status_message = "ApplyBodyWrench: body does not exist";
+    return true;
+  }
+
+  // target wrench
+  ignition::math::Vector3d reference_force(req.wrench.force.x,req.wrench.force.y,req.wrench.force.z);
+  ignition::math::Vector3d reference_torque(req.wrench.torque.x,req.wrench.torque.y,req.wrench.torque.z);
+  ignition::math::Vector3d reference_point(req.reference_point.x,req.reference_point.y,req.reference_point.z);
+
+  ignition::math::Vector3d target_force;
+  ignition::math::Vector3d target_torque;
+
+  /// shift wrench to body frame if a non-zero reference point is given
+  ///   @todo: to be more general, should we make the reference point a reference pose?
+  reference_torque = reference_torque + reference_point.Cross(reference_force);
+
+  /// @todo: FIXME map is really wrong, need to use tf here somehow
+  if (frame)
+  {
+    // get reference frame (body/model(body)) pose and
+    // transform target pose to absolute world frame
+    // @todo: need to modify wrench (target force and torque by frame)
+    //        transform wrench from reference_point in reference_frame
+    //        into the reference frame of the body
+    //        first, translate by reference point to the body frame
+#if GAZEBO_MAJOR_VERSION >= 8
+    ignition::math::Pose3d framePose = frame->WorldPose();
+    ignition::math::Pose3d bodyPose = body->WorldPose();
+#else
+    ignition::math::Pose3d framePose = frame->GetWorldPose().Ign();
+    ignition::math::Pose3d bodyPose = body->GetWorldPose().Ign();
+#endif
+    ignition::math::Pose3d target_to_reference = framePose - bodyPose;
+    ROS_DEBUG_NAMED("api_plugin", "reference frame for applied wrench: [%f %f %f, %f %f %f]-[%f %f %f, %f %f %f]=[%f %f %f, %f %f %f]",
+              bodyPose.Pos().X(),
+              bodyPose.Pos().Y(),
+              bodyPose.Pos().Z(),
+              bodyPose.Rot().Euler().X(),
+              bodyPose.Rot().Euler().Y(),
+              bodyPose.Rot().Euler().Z(),
+              framePose.Pos().X(),
+              framePose.Pos().Y(),
+              framePose.Pos().Z(),
+              framePose.Rot().Euler().X(),
+              framePose.Rot().Euler().Y(),
+              framePose.Rot().Euler().Z(),
+              target_to_reference.Pos().X(),
+              target_to_reference.Pos().Y(),
+              target_to_reference.Pos().Z(),
+              target_to_reference.Rot().Euler().X(),
+              target_to_reference.Rot().Euler().Y(),
+              target_to_reference.Rot().Euler().Z()
+              );
+    transformWrench(target_force, target_torque, reference_force, reference_torque, target_to_reference);
+    ROS_ERROR_NAMED("api_plugin", "wrench defined as [%s]:[%f %f %f, %f %f %f] --> applied as [%s]:[%f %f %f, %f %f %f]",
+              frame->GetName().c_str(),
+              reference_force.X(),
+              reference_force.Y(),
+              reference_force.Z(),
+              reference_torque.X(),
+              reference_torque.Y(),
+              reference_torque.Z(),
+              body->GetName().c_str(),
+              target_force.X(),
+              target_force.Y(),
+              target_force.Z(),
+              target_torque.X(),
+              target_torque.Y(),
+              target_torque.Z()
+              );
+
+  }
+  else if (req.reference_frame == "" || req.reference_frame == "world" || req.reference_frame == "map" || req.reference_frame == "/map")
+  {
+    ROS_INFO_NAMED("api_plugin", "ApplyBodyWrench: reference_frame is empty/world/map, using inertial frame, transferring from body relative to inertial frame");
+    // FIXME: transfer to inertial frame
+#if GAZEBO_MAJOR_VERSION >= 8
+    ignition::math::Pose3d target_to_reference = body->WorldPose();
+#else
+    ignition::math::Pose3d target_to_reference = body->GetWorldPose().Ign();
+#endif
+    target_force = reference_force;
+    target_torque = reference_torque;
+
+  }
+  else
+  {
+    ROS_ERROR_NAMED("api_plugin", "ApplyBodyWrench: reference_frame is not a valid entity name");
+    res.success = false;
+    res.status_message = "ApplyBodyWrench: reference_frame not found";
+    return true;
+  }
+
+  // apply wrench
+  // schedule a job to do below at appropriate times:
+  // body->SetForce(force)
+  // body->SetTorque(torque)
+  GazeboRosApiPlugin::WrenchBodyJob* wej = new GazeboRosApiPlugin::WrenchBodyJob;
+  wej->body = body;
+  wej->force = target_force;
+  wej->torque = target_torque;
+  wej->start_time = req.start_time;
+#if GAZEBO_MAJOR_VERSION >= 8
+  if (wej->start_time < ros::Time(world_->SimTime().Double()))
+    wej->start_time = ros::Time(world_->SimTime().Double());
+#else
+  if (wej->start_time < ros::Time(world_->GetSimTime().Double()))
+    wej->start_time = ros::Time(world_->GetSimTime().Double());
+#endif
+  wej->duration = req.duration;
+  lock_.lock();
+  wrench_body_jobs_.push_back(wej);
+  lock_.unlock();
+
+  res.success = true;
+  res.status_message = "";
+  return true;
+}
+
+bool GazeboRosApiPlugin::isURDF(std::string model_xml)
+{
+  TiXmlDocument doc_in;
+  doc_in.Parse(model_xml.c_str());
+  if (doc_in.FirstChild("robot"))
+    return true;
+  else
+    return false;
+}
+
+bool GazeboRosApiPlugin::isSDF(std::string model_xml)
+{
+  // FIXME: very crude check
+  TiXmlDocument doc_in;
+  doc_in.Parse(model_xml.c_str());
+  if (doc_in.FirstChild("gazebo") ||
+      doc_in.FirstChild("sdf")) // sdf
+    return true;
+  else
+    return false;
+}
+
+void GazeboRosApiPlugin::wrenchBodySchedulerSlot()
+{
+  // MDMutex locks in case model is getting deleted, don't have to do this if we delete jobs first
+  // boost::recursive_mutex::scoped_lock lock(*world->GetMDMutex());
+  lock_.lock();
+  for (std::vector<GazeboRosApiPlugin::WrenchBodyJob*>::iterator iter=wrench_body_jobs_.begin();iter!=wrench_body_jobs_.end();)
+  {
+    // check times and apply wrench if necessary
+#if GAZEBO_MAJOR_VERSION >= 8
+    ros::Time simTime = ros::Time(world_->SimTime().Double());
+#else
+    ros::Time simTime = ros::Time(world_->GetSimTime().Double());
+#endif
+    if (simTime >= (*iter)->start_time)
+      if (simTime <= (*iter)->start_time+(*iter)->duration ||
+          (*iter)->duration.toSec() < 0.0)
+      {
+        if ((*iter)->body) // if body exists
+        {
+          (*iter)->body->SetForce((*iter)->force);
+          (*iter)->body->SetTorque((*iter)->torque);
+        }
+        else
+          (*iter)->duration.fromSec(0.0); // mark for delete
+      }
+
+    if (simTime > (*iter)->start_time+(*iter)->duration &&
+        (*iter)->duration.toSec() >= 0.0)
+    {
+      // remove from queue once expires
+      delete (*iter);
+      iter = wrench_body_jobs_.erase(iter);
+    }
+    else
+      ++iter;
+  }
+  lock_.unlock();
+}
+
+void GazeboRosApiPlugin::forceJointSchedulerSlot()
+{
+  // MDMutex locks in case model is getting deleted, don't have to do this if we delete jobs first
+  // boost::recursive_mutex::scoped_lock lock(*world->GetMDMutex());
+  lock_.lock();
+  for (std::vector<GazeboRosApiPlugin::ForceJointJob*>::iterator iter=force_joint_jobs_.begin();iter!=force_joint_jobs_.end();)
+  {
+    // check times and apply force if necessary
+#if GAZEBO_MAJOR_VERSION >= 8
+    ros::Time simTime = ros::Time(world_->SimTime().Double());
+#else
+    ros::Time simTime = ros::Time(world_->GetSimTime().Double());
+#endif
+    if (simTime >= (*iter)->start_time)
+      if (simTime <= (*iter)->start_time+(*iter)->duration ||
+          (*iter)->duration.toSec() < 0.0)
+      {
+        if ((*iter)->joint) // if joint exists
+          (*iter)->joint->SetForce(0,(*iter)->force);
+        else
+          (*iter)->duration.fromSec(0.0); // mark for delete
+      }
+
+    if (simTime > (*iter)->start_time+(*iter)->duration &&
+        (*iter)->duration.toSec() >= 0.0)
+    {
+      // remove from queue once expires
+      iter = force_joint_jobs_.erase(iter);
+    }
+    else
+      ++iter;
+  }
+  lock_.unlock();
+}
+
+void GazeboRosApiPlugin::publishSimTime()
+{
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::common::Time sim_time = world_->SimTime();
+#else
+  gazebo::common::Time sim_time = world_->GetSimTime();
+#endif
+  if (pub_clock_frequency_ > 0 && (sim_time - last_pub_clock_time_).Double() < 1.0/pub_clock_frequency_)
+    return;
+
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::common::Time currentTime = world_->SimTime();
+#else
+  gazebo::common::Time currentTime = world_->GetSimTime();
+#endif
+  rosgraph_msgs::Clock ros_time_;
+  ros_time_.clock.fromSec(currentTime.Double());
+  //  publish time to ros
+  last_pub_clock_time_ = sim_time;
+  pub_clock_.publish(ros_time_);
+}
+
+void GazeboRosApiPlugin::publishLinkStates()
+{
+  gazebo_msgs::LinkStates link_states;
+
+  // fill link_states
+#if GAZEBO_MAJOR_VERSION >= 8
+  for (unsigned int i = 0; i < world_->ModelCount(); i ++)
+  {
+    gazebo::physics::ModelPtr model = world_->ModelByIndex(i);
+#else
+  for (unsigned int i = 0; i < world_->GetModelCount(); i ++)
+  {
+    gazebo::physics::ModelPtr model = world_->GetModel(i);
+#endif
+
+    for (unsigned int j = 0 ; j < model->GetChildCount(); j ++)
+    {
+      gazebo::physics::LinkPtr body = boost::dynamic_pointer_cast<gazebo::physics::Link>(model->GetChild(j));
+
+      if (body)
+      {
+        link_states.name.push_back(body->GetScopedName());
+        geometry_msgs::Pose pose;
+#if GAZEBO_MAJOR_VERSION >= 8
+        ignition::math::Pose3d  body_pose = body->WorldPose(); // - myBody->GetCoMPose();
+        ignition::math::Vector3d linear_vel  = body->WorldLinearVel();
+        ignition::math::Vector3d angular_vel = body->WorldAngularVel();
+#else
+        ignition::math::Pose3d  body_pose = body->GetWorldPose().Ign(); // - myBody->GetCoMPose();
+        ignition::math::Vector3d linear_vel  = body->GetWorldLinearVel().Ign();
+        ignition::math::Vector3d angular_vel = body->GetWorldAngularVel().Ign();
+#endif
+        ignition::math::Vector3d pos = body_pose.Pos();
+        ignition::math::Quaterniond rot = body_pose.Rot();
+        pose.position.x = pos.X();
+        pose.position.y = pos.Y();
+        pose.position.z = pos.Z();
+        pose.orientation.w = rot.W();
+        pose.orientation.x = rot.X();
+        pose.orientation.y = rot.Y();
+        pose.orientation.z = rot.Z();
+        link_states.pose.push_back(pose);
+        geometry_msgs::Twist twist;
+        twist.linear.x = linear_vel.X();
+        twist.linear.y = linear_vel.Y();
+        twist.linear.z = linear_vel.Z();
+        twist.angular.x = angular_vel.X();
+        twist.angular.y = angular_vel.Y();
+        twist.angular.z = angular_vel.Z();
+        link_states.twist.push_back(twist);
+      }
+    }
+  }
+
+  pub_link_states_.publish(link_states);
+}
+
+void GazeboRosApiPlugin::publishModelStates()
+{
+  gazebo_msgs::ModelStates model_states;
+
+  // fill model_states
+#if GAZEBO_MAJOR_VERSION >= 8
+  for (unsigned int i = 0; i < world_->ModelCount(); i ++)
+  {
+    gazebo::physics::ModelPtr model = world_->ModelByIndex(i);
+    ignition::math::Pose3d  model_pose = model->WorldPose(); // - myBody->GetCoMPose();
+    ignition::math::Vector3d linear_vel  = model->WorldLinearVel();
+    ignition::math::Vector3d angular_vel = model->WorldAngularVel();
+#else
+  for (unsigned int i = 0; i < world_->GetModelCount(); i ++)
+  {
+    gazebo::physics::ModelPtr model = world_->GetModel(i);
+    ignition::math::Pose3d  model_pose = model->GetWorldPose().Ign(); // - myBody->GetCoMPose();
+    ignition::math::Vector3d linear_vel  = model->GetWorldLinearVel().Ign();
+    ignition::math::Vector3d angular_vel = model->GetWorldAngularVel().Ign();
+#endif
+    ignition::math::Vector3d pos = model_pose.Pos();
+    ignition::math::Quaterniond rot = model_pose.Rot();
+    geometry_msgs::Pose pose;
+    pose.position.x = pos.X();
+    pose.position.y = pos.Y();
+    pose.position.z = pos.Z();
+    pose.orientation.w = rot.W();
+    pose.orientation.x = rot.X();
+    pose.orientation.y = rot.Y();
+    pose.orientation.z = rot.Z();
+    model_states.pose.push_back(pose);
+    model_states.name.push_back(model->GetName());
+    geometry_msgs::Twist twist;
+    twist.linear.x = linear_vel.X();
+    twist.linear.y = linear_vel.Y();
+    twist.linear.z = linear_vel.Z();
+    twist.angular.x = angular_vel.X();
+    twist.angular.y = angular_vel.Y();
+    twist.angular.z = angular_vel.Z();
+    model_states.twist.push_back(twist);
+  }
+  pub_model_states_.publish(model_states);
+}
+
+void GazeboRosApiPlugin::physicsReconfigureCallback(gazebo_ros::PhysicsConfig &config, uint32_t level)
+{
+  if (!physics_reconfigure_initialized_)
+  {
+    gazebo_msgs::GetPhysicsProperties srv;
+    physics_reconfigure_get_client_.call(srv);
+
+    config.time_step                   = srv.response.time_step;
+    config.max_update_rate             = srv.response.max_update_rate;
+    config.gravity_x                   = srv.response.gravity.x;
+    config.gravity_y                   = srv.response.gravity.y;
+    config.gravity_z                   = srv.response.gravity.z;
+    config.auto_disable_bodies         = srv.response.ode_config.auto_disable_bodies;
+    config.sor_pgs_precon_iters        = srv.response.ode_config.sor_pgs_precon_iters;
+    config.sor_pgs_iters               = srv.response.ode_config.sor_pgs_iters;
+    config.sor_pgs_rms_error_tol       = srv.response.ode_config.sor_pgs_rms_error_tol;
+    config.sor_pgs_w                   = srv.response.ode_config.sor_pgs_w;
+    config.contact_surface_layer       = srv.response.ode_config.contact_surface_layer;
+    config.contact_max_correcting_vel  = srv.response.ode_config.contact_max_correcting_vel;
+    config.cfm                         = srv.response.ode_config.cfm;
+    config.erp                         = srv.response.ode_config.erp;
+    config.max_contacts                = srv.response.ode_config.max_contacts;
+    physics_reconfigure_initialized_ = true;
+  }
+  else
+  {
+    bool changed = false;
+    gazebo_msgs::GetPhysicsProperties srv;
+    physics_reconfigure_get_client_.call(srv);
+
+    // check for changes
+    if (config.time_step                      != srv.response.time_step)                                 changed = true;
+    if (config.max_update_rate                != srv.response.max_update_rate)                           changed = true;
+    if (config.gravity_x                      != srv.response.gravity.x)                                 changed = true;
+    if (config.gravity_y                      != srv.response.gravity.y)                                 changed = true;
+    if (config.gravity_z                      != srv.response.gravity.z)                                 changed = true;
+    if (config.auto_disable_bodies            != srv.response.ode_config.auto_disable_bodies)            changed = true;
+    if ((uint32_t)config.sor_pgs_precon_iters != srv.response.ode_config.sor_pgs_precon_iters)           changed = true;
+    if ((uint32_t)config.sor_pgs_iters        != srv.response.ode_config.sor_pgs_iters)                  changed = true;
+    if (config.sor_pgs_rms_error_tol          != srv.response.ode_config.sor_pgs_rms_error_tol)          changed = true;
+    if (config.sor_pgs_w                      != srv.response.ode_config.sor_pgs_w)                      changed = true;
+    if (config.contact_surface_layer          != srv.response.ode_config.contact_surface_layer)          changed = true;
+    if (config.contact_max_correcting_vel     != srv.response.ode_config.contact_max_correcting_vel)     changed = true;
+    if (config.cfm                            != srv.response.ode_config.cfm)                            changed = true;
+    if (config.erp                            != srv.response.ode_config.erp)                            changed = true;
+    if ((uint32_t)config.max_contacts         != srv.response.ode_config.max_contacts)                   changed = true;
+
+    if (changed)
+    {
+      // pause simulation if requested
+      gazebo_msgs::SetPhysicsProperties srv;
+      srv.request.time_step                             = config.time_step                   ;
+      srv.request.max_update_rate                       = config.max_update_rate             ;
+      srv.request.gravity.x                             = config.gravity_x                   ;
+      srv.request.gravity.y                             = config.gravity_y                   ;
+      srv.request.gravity.z                             = config.gravity_z                   ;
+      srv.request.ode_config.auto_disable_bodies        = config.auto_disable_bodies         ;
+      srv.request.ode_config.sor_pgs_precon_iters       = config.sor_pgs_precon_iters        ;
+      srv.request.ode_config.sor_pgs_iters              = config.sor_pgs_iters               ;
+      srv.request.ode_config.sor_pgs_rms_error_tol      = config.sor_pgs_rms_error_tol       ;
+      srv.request.ode_config.sor_pgs_w                  = config.sor_pgs_w                   ;
+      srv.request.ode_config.contact_surface_layer      = config.contact_surface_layer       ;
+      srv.request.ode_config.contact_max_correcting_vel = config.contact_max_correcting_vel  ;
+      srv.request.ode_config.cfm                        = config.cfm                         ;
+      srv.request.ode_config.erp                        = config.erp                         ;
+      srv.request.ode_config.max_contacts               = config.max_contacts                ;
+      physics_reconfigure_set_client_.call(srv);
+      ROS_INFO_NAMED("api_plugin", "physics dynamics reconfigure update complete");
+    }
+    ROS_INFO_NAMED("api_plugin", "physics dynamics reconfigure complete");
+  }
+}
+
+void GazeboRosApiPlugin::physicsReconfigureThread()
+{
+  physics_reconfigure_set_client_ = nh_->serviceClient<gazebo_msgs::SetPhysicsProperties>("set_physics_properties");
+  physics_reconfigure_get_client_ = nh_->serviceClient<gazebo_msgs::GetPhysicsProperties>("get_physics_properties");
+
+  // Wait until the rest of this plugin is loaded and the services are being offered
+  physics_reconfigure_set_client_.waitForExistence();
+  physics_reconfigure_get_client_.waitForExistence();
+
+  physics_reconfigure_srv_.reset(new dynamic_reconfigure::Server<gazebo_ros::PhysicsConfig>());
+
+  physics_reconfigure_callback_ = boost::bind(&GazeboRosApiPlugin::physicsReconfigureCallback, this, _1, _2);
+  physics_reconfigure_srv_->setCallback(physics_reconfigure_callback_);
+
+  ROS_INFO_NAMED("api_plugin", "Physics dynamic reconfigure ready.");
+}
+
+void GazeboRosApiPlugin::stripXmlDeclaration(std::string &model_xml)
+{
+  // incoming robot model string is a string containing a Gazebo Model XML
+  /// STRIP DECLARATION <? ... xml version="1.0" ... ?> from model_xml
+  /// @todo: does tinyxml have functionality for this?
+  /// @todo: should gazebo take care of the declaration?
+  std::string open_bracket("<?");
+  std::string close_bracket("?>");
+  size_t pos1 = model_xml.find(open_bracket,0);
+  size_t pos2 = model_xml.find(close_bracket,0);
+  if (pos1 != std::string::npos && pos2 != std::string::npos)
+    model_xml.replace(pos1,pos2-pos1+2,std::string(""));
+}
+
+void GazeboRosApiPlugin::updateSDFAttributes(TiXmlDocument &gazebo_model_xml,
+                                             const std::string &model_name,
+                                             const ignition::math::Vector3d &initial_xyz,
+                                             const ignition::math::Quaterniond &initial_q)
+{
+  // This function can handle both regular SDF files and <include> SDFs that are used with the
+  // Gazebo Model Database
+
+  TiXmlElement* pose_element; // This is used by both reguar and database SDFs
+
+  // Check SDF for requires SDF element
+  TiXmlElement* gazebo_tixml = gazebo_model_xml.FirstChildElement("sdf");
+  if (!gazebo_tixml)
+  {
+    ROS_WARN_NAMED("api_plugin", "Could not find <sdf> element in sdf, so name and initial position cannot be applied");
+    return;
+  }
+
+  // Check SDF for optional model element. May not have one
+  TiXmlElement* model_tixml = gazebo_tixml->FirstChildElement("model");
+  if (model_tixml)
+  {
+    // Update entity name
+    if (model_tixml->Attribute("name") != NULL)
+    {
+      // removing old entity name
+      model_tixml->RemoveAttribute("name");
+    }
+    // replace with user specified name
+    model_tixml->SetAttribute("name",model_name);
+  }
+  else
+  {
+    // Check SDF for world element
+    TiXmlElement* world_tixml = gazebo_tixml->FirstChildElement("world");
+    if (!world_tixml)
+    {
+      ROS_WARN_NAMED("api_plugin", "Could not find <model> or <world> element in sdf, so name and initial position cannot be applied");
+      return;
+    }
+    // If not <model> element, check SDF for required include element
+    model_tixml = world_tixml->FirstChildElement("include");
+    if (!model_tixml)
+    {
+      ROS_WARN_NAMED("api_plugin", "Could not find <include> element in sdf, so name and initial position cannot be applied");
+      return;
+    }
+
+    // Check for name element
+    TiXmlElement* name_tixml = model_tixml->FirstChildElement("name");
+    if (!name_tixml)
+    {
+      // Create the name element
+      name_tixml = new TiXmlElement("name");
+      model_tixml->LinkEndChild(name_tixml);
+    }
+
+    // Set the text within the name element
+    TiXmlText* text = new TiXmlText(model_name);
+    name_tixml->LinkEndChild( text );
+  }
+
+
+  // Check for the pose element
+  pose_element = model_tixml->FirstChildElement("pose");
+  ignition::math::Pose3d model_pose;
+
+  // Create the pose element if it doesn't exist
+  // Remove it if it exists, since we are inserting a new one
+  if (pose_element)
+  {
+    // save pose_element in ignition::math::Pose3d and remove child
+    model_pose = this->parsePose(pose_element->GetText());
+    model_tixml->RemoveChild(pose_element);
+  }
+
+  // Set and link the pose element after adding initial pose
+  {
+    // add pose_element Pose to initial pose
+    ignition::math::Pose3d new_model_pose = model_pose + ignition::math::Pose3d(initial_xyz, initial_q);
+
+    // Create the string of 6 numbers
+    std::ostringstream pose_stream;
+    ignition::math::Vector3d model_rpy = new_model_pose.Rot().Euler(); // convert to Euler angles for Gazebo XML
+    pose_stream << new_model_pose.Pos().X() << " " << new_model_pose.Pos().Y() << " " << new_model_pose.Pos().Z() << " "
+                << model_rpy.X() << " " << model_rpy.Y() << " " << model_rpy.Z();
+
+    // Add value to pose element
+    TiXmlText* text = new TiXmlText(pose_stream.str());
+    TiXmlElement* new_pose_element = new TiXmlElement("pose");
+    new_pose_element->LinkEndChild(text);
+    model_tixml->LinkEndChild(new_pose_element);
+  }
+}
+
+ignition::math::Pose3d GazeboRosApiPlugin::parsePose(const std::string &str)
+{
+  std::vector<std::string> pieces;
+  std::vector<double> vals;
+
+  boost::split(pieces, str, boost::is_any_of(" "));
+  for (unsigned int i = 0; i < pieces.size(); ++i)
+  {
+    if (pieces[i] != "")
+    {
+      try
+      {
+        vals.push_back(boost::lexical_cast<double>(pieces[i].c_str()));
+      }
+      catch(boost::bad_lexical_cast &e)
+      {
+        sdferr << "xml key [" << str
+          << "][" << i << "] value [" << pieces[i]
+          << "] is not a valid double from a 3-tuple\n";
+        return ignition::math::Pose3d();
+      }
+    }
+  }
+
+  if (vals.size() == 6)
+    return ignition::math::Pose3d(vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);
+  else
+  {
+    ROS_ERROR_NAMED("api_plugin", "Beware: failed to parse string [%s] as ignition::math::Pose3d, returning zeros.", str.c_str());
+    return ignition::math::Pose3d();
+  }
+}
+
+ignition::math::Vector3d GazeboRosApiPlugin::parseVector3(const std::string &str)
+{
+  std::vector<std::string> pieces;
+  std::vector<double> vals;
+
+  boost::split(pieces, str, boost::is_any_of(" "));
+  for (unsigned int i = 0; i < pieces.size(); ++i)
+  {
+    if (pieces[i] != "")
+    {
+      try
+      {
+        vals.push_back(boost::lexical_cast<double>(pieces[i].c_str()));
+      }
+      catch(boost::bad_lexical_cast &e)
+      {
+        sdferr << "xml key [" << str
+          << "][" << i << "] value [" << pieces[i]
+          << "] is not a valid double from a 3-tuple\n";
+        return ignition::math::Vector3d();
+      }
+    }
+  }
+
+  if (vals.size() == 3)
+    return ignition::math::Vector3d(vals[0], vals[1], vals[2]);
+  else
+  {
+    ROS_ERROR_NAMED("api_plugin", "Beware: failed to parse string [%s] as ignition::math::Vector3d, returning zeros.", str.c_str());
+    return ignition::math::Vector3d();
+  }
+}
+
+void GazeboRosApiPlugin::updateURDFModelPose(TiXmlDocument &gazebo_model_xml,
+                                             const ignition::math::Vector3d &initial_xyz,
+                                             const ignition::math::Quaterniond &initial_q)
+{
+  TiXmlElement* model_tixml = (gazebo_model_xml.FirstChildElement("robot"));
+  if (model_tixml)
+  {
+    // replace initial pose of model
+    // find first instance of xyz and rpy, replace with initial pose
+    TiXmlElement* origin_key = model_tixml->FirstChildElement("origin");
+
+    if (!origin_key)
+    {
+      origin_key = new TiXmlElement("origin");
+      model_tixml->LinkEndChild(origin_key);
+    }
+
+    ignition::math::Vector3d xyz;
+    ignition::math::Vector3d rpy;
+    if (origin_key->Attribute("xyz"))
+    {
+      xyz = this->parseVector3(origin_key->Attribute("xyz"));
+      origin_key->RemoveAttribute("xyz");
+    }
+    if (origin_key->Attribute("rpy"))
+    {
+      rpy = this->parseVector3(origin_key->Attribute("rpy"));
+      origin_key->RemoveAttribute("rpy");
+    }
+
+    // add xyz, rpy to initial pose
+    ignition::math::Pose3d model_pose = ignition::math::Pose3d(xyz, ignition::math::Quaterniond(rpy))
+                                      + ignition::math::Pose3d(initial_xyz, initial_q);
+
+    std::ostringstream xyz_stream;
+    xyz_stream << model_pose.Pos().X() << " " << model_pose.Pos().Y() << " " << model_pose.Pos().Z();
+
+    std::ostringstream rpy_stream;
+    ignition::math::Vector3d model_rpy = model_pose.Rot().Euler(); // convert to Euler angles for Gazebo XML
+    rpy_stream << model_rpy.X() << " " << model_rpy.Y() << " " << model_rpy.Z();
+
+    origin_key->SetAttribute("xyz",xyz_stream.str());
+    origin_key->SetAttribute("rpy",rpy_stream.str());
+  }
+  else
+    ROS_WARN_NAMED("api_plugin", "Could not find <model> element in sdf, so name and initial position is not applied");
+}
+
+void GazeboRosApiPlugin::updateURDFName(TiXmlDocument &gazebo_model_xml, const std::string &model_name)
+{
+  TiXmlElement* model_tixml = gazebo_model_xml.FirstChildElement("robot");
+  // replace model name if one is specified by the user
+  if (model_tixml)
+  {
+    if (model_tixml->Attribute("name") != NULL)
+    {
+      // removing old model name
+      model_tixml->RemoveAttribute("name");
+    }
+    // replace with user specified name
+    model_tixml->SetAttribute("name",model_name);
+  }
+  else
+    ROS_WARN_NAMED("api_plugin", "Could not find <robot> element in URDF, name not replaced");
+}
+
+void GazeboRosApiPlugin::walkChildAddRobotNamespace(TiXmlNode* model_xml)
+{
+  TiXmlNode* child = 0;
+  child = model_xml->IterateChildren(child);
+  while (child != NULL)
+  {
+    if (child->Type() == TiXmlNode::TINYXML_ELEMENT &&
+        child->ValueStr().compare(std::string("plugin")) == 0)
+    {
+      if (child->FirstChildElement("robotNamespace") == NULL)
+      {
+        TiXmlElement* child_elem = child->ToElement()->FirstChildElement("robotNamespace");
+        while (child_elem)
+        {
+          child->ToElement()->RemoveChild(child_elem);
+          child_elem = child->ToElement()->FirstChildElement("robotNamespace");
+        }
+        TiXmlElement* key = new TiXmlElement("robotNamespace");
+        TiXmlText* val = new TiXmlText(robot_namespace_);
+        key->LinkEndChild(val);
+        child->ToElement()->LinkEndChild(key);
+      }
+    }
+    walkChildAddRobotNamespace(child);
+    child = model_xml->IterateChildren(child);
+  }
+}
+
+bool GazeboRosApiPlugin::spawnAndConform(TiXmlDocument &gazebo_model_xml, const std::string &model_name,
+                                         gazebo_msgs::SpawnModel::Response &res)
+{
+  std::string entity_type = gazebo_model_xml.RootElement()->FirstChild()->Value();
+  // Convert the entity type to lower case
+  std::transform(entity_type.begin(), entity_type.end(), entity_type.begin(), ::tolower);
+
+  bool isLight = (entity_type == "light");
+
+  // push to factory iface
+  std::ostringstream stream;
+  stream << gazebo_model_xml;
+  std::string gazebo_model_xml_string = stream.str();
+  ROS_DEBUG_NAMED("api_plugin.xml", "Gazebo Model XML\n\n%s\n\n ",gazebo_model_xml_string.c_str());
+
+  // publish to factory topic
+  gazebo::msgs::Factory msg;
+  gazebo::msgs::Init(msg, "spawn_model");
+  msg.set_sdf( gazebo_model_xml_string );
+
+  //ROS_ERROR_NAMED("api_plugin", "attempting to spawn model name [%s] [%s]", model_name.c_str(),gazebo_model_xml_string.c_str());
+
+  // FIXME: should use entity_info or add lock to World::receiveMutex
+  // looking for Model to see if it exists already
+  gazebo::msgs::Request *entity_info_msg = gazebo::msgs::CreateRequest("entity_info", model_name);
+  request_pub_->Publish(*entity_info_msg,true);
+  delete entity_info_msg;
+  entity_info_msg = nullptr;
+  // todo: should wait for response response_sub_, check to see that if _msg->response == "nonexistant"
+
+#if GAZEBO_MAJOR_VERSION >= 8
+  gazebo::physics::ModelPtr model = world_->ModelByName(model_name);
+  gazebo::physics::LightPtr light = world_->LightByName(model_name);
+#else
+  gazebo::physics::ModelPtr model = world_->GetModel(model_name);
+  gazebo::physics::LightPtr light = world_->Light(model_name);
+#endif
+  if ((isLight && light != NULL) || (model != NULL))
+  {
+    ROS_ERROR_NAMED("api_plugin", "SpawnModel: Failure - model name %s already exist.",model_name.c_str());
+    res.success = false;
+    res.status_message = "SpawnModel: Failure - entity already exists.";
+    return true;
+  }
+
+  // for Gazebo 7 and up, use a different method to spawn lights
+  if (isLight)
+  {
+    // Publish the light message to spawn the light (Gazebo 7 and up)
+    sdf::SDF sdf_light;
+    sdf_light.SetFromString(gazebo_model_xml_string);
+    gazebo::msgs::Light msg = gazebo::msgs::LightFromSDF(sdf_light.Root()->GetElement("light"));
+    msg.set_name(model_name);
+    factory_light_pub_->Publish(msg);
+  }
+  else
+  {
+    // Publish the factory message
+    factory_pub_->Publish(msg);
+  }
+  /// FIXME: should change publish to direct invocation World::LoadModel() and/or
+  ///        change the poll for Model existence to common::Events based check.
+
+  /// \brief poll and wait, verify that the model is spawned within Hardcoded 10 seconds
+  ros::Duration model_spawn_timeout(10.0);
+  ros::Time timeout = ros::Time::now() + model_spawn_timeout;
+
+  while (ros::ok())
+  {
+    if (ros::Time::now() > timeout)
+    {
+      res.success = false;
+      res.status_message = "SpawnModel: Entity pushed to spawn queue, but spawn service timed out waiting for entity to appear in simulation under the name " + model_name;
+      return true;
+    }
+
+    {
+      //boost::recursive_mutex::scoped_lock lock(*world->GetMRMutex());
+#if GAZEBO_MAJOR_VERSION >= 8
+      if ((isLight && world_->LightByName(model_name) != NULL)
+          || (world_->ModelByName(model_name) != NULL))
+#else
+      if ((isLight && world_->Light(model_name) != NULL)
+          || (world_->GetModel(model_name) != NULL))
+#endif
+        break;
+    }
+
+    ROS_DEBUG_STREAM_ONCE_NAMED("api_plugin","Waiting for " << timeout - ros::Time::now()
+      << " for entity " << model_name << " to spawn");
+
+    std::this_thread::sleep_for(std::chrono::microseconds(2000));
+  }
+
+  // set result
+  res.success = true;
+  res.status_message = "SpawnModel: Successfully spawned entity";
+  return true;
+}
+
+// Register this plugin with the simulator
+GZ_REGISTER_SYSTEM_PLUGIN(GazeboRosApiPlugin)
+}
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/src/gazebo_ros_paths_plugin.cpp
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2012-2014 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+/*
+ * Author: John Hsu, Nate Koenig, Dave Coleman
+ * Desc: External interfaces for Gazebo
+ */
+
+#include <gazebo/common/SystemPaths.hh>
+#include <gazebo/common/Plugin.hh>
+
+#include <ros/ros.h>
+#include <ros/package.h>
+
+#include <map>
+
+#ifdef _WIN32
+int setenv(const char *name, const char *value, int overwrite)
+{
+    int errcode = 0;
+    if(!overwrite) {
+        size_t envsize = 0;
+        errcode = ::getenv_s(&envsize, NULL, 0, name);
+        if(errcode || envsize) return errcode;
+    }
+    return ::_putenv_s(name, value);
+}
+#endif
+
+namespace gazebo
+{
+
+typedef std::vector<std::string> V_string;
+typedef std::map<std::string, std::string> M_string;
+
+class GazeboRosPathsPlugin : public SystemPlugin
+{
+public:
+  GazeboRosPathsPlugin()
+  {
+    this->LoadPaths();
+  }
+
+  ~GazeboRosPathsPlugin()
+  {
+  };
+
+  void Init()
+  {
+  }
+
+  void Load(int argc, char** argv)
+  {
+  }
+
+  /**
+   * @brief Set Gazebo Path/Resources Configurations GAZEBO_MODEL_PATH, PLUGIN_PATH and
+            GAZEBO_MEDIA_PATH by adding paths to GazeboConfig based on ros::package
+   */
+  void LoadPaths()
+  {
+    // set gazebo media paths by adding all packages that exports "gazebo_media_path" for gazebo
+    gazebo::common::SystemPaths::Instance()->gazeboPathsFromEnv = false;
+    std::vector<std::string> gazebo_media_paths;
+    ros::package::getPlugins("gazebo_ros","gazebo_media_path",gazebo_media_paths);
+    for (std::vector<std::string>::iterator iter=gazebo_media_paths.begin(); iter != gazebo_media_paths.end(); iter++)
+    {
+      ROS_DEBUG_NAMED("paths_plugin", "Media path %s",iter->c_str());
+      gazebo::common::SystemPaths::Instance()->AddGazeboPaths(iter->c_str());
+    }
+
+    // set gazebo plugins paths by adding all packages that exports "plugin_path" for gazebo
+    gazebo::common::SystemPaths::Instance()->pluginPathsFromEnv = false;
+    std::vector<std::string> plugin_paths;
+    ros::package::getPlugins("gazebo_ros","plugin_path",plugin_paths);
+    for (std::vector<std::string>::iterator iter=plugin_paths.begin(); iter != plugin_paths.end(); iter++)
+    {
+      ROS_DEBUG_NAMED("paths_plugin", "plugin path %s",(*iter).c_str());
+      gazebo::common::SystemPaths::Instance()->AddPluginPaths(iter->c_str());
+    }
+
+    // set model paths by adding all packages that exports "gazebo_model_path" for gazebo
+    gazebo::common::SystemPaths::Instance()->modelPathsFromEnv = false;
+    std::vector<std::string> model_paths;
+    ros::package::getPlugins("gazebo_ros","gazebo_model_path",model_paths);
+    for (std::vector<std::string>::iterator iter=model_paths.begin(); iter != model_paths.end(); iter++)
+    {
+      ROS_DEBUG_NAMED("paths_plugin", "Model path %s",(*iter).c_str());
+      gazebo::common::SystemPaths::Instance()->AddModelPaths(iter->c_str());
+    }
+
+    // set .gazeborc path to something else, so we don't pick up default ~/.gazeborc
+    std::string gazeborc = ros::package::getPath("gazebo_ros")+"/.do_not_use_gazeborc";
+    setenv("GAZEBORC",gazeborc.c_str(),1);
+  }
+
+};
+
+// Register this plugin with the simulator
+GZ_REGISTER_SYSTEM_PLUGIN(GazeboRosPathsPlugin)
+
+}
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/test/CMakeLists.txt
@@ -0,0 +1,22 @@
+set (rostests_python
+  ros_network/ros_network_default.test
+  ros_network/ros_network_disabled.test
+)
+
+if(CATKIN_ENABLE_TESTING)
+  find_package(rostest REQUIRED)
+    foreach (rostest ${rostests_python})
+      # We don't set a timeout here because we trust rostest to enforce the
+      # timeout specified in each .test file.
+      add_rostest(${rostest} rostest ${CMAKE_CURRENT_SOURCE_DIR}/${rostest})
+      # Check for test result file and create one if needed.  rostest can fail to
+      # generate a file if it throws an exception.
+      add_test(check_${rostest} rosrun rosunit check_test_ran.py 
+               --rostest ${ROS_PACKAGE_NAME} ${CMAKE_CURRENT_SOURCE_DIR}/${rostest})
+  endforeach()
+endif()
+
+install(PROGRAMS
+  ros_network/ros_api_checker
+  DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}/test
+)
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/test/ros_network/gazebo_network_api.yaml
@@ -0,0 +1,146 @@
+strict: true
+
+##########################################################
+# Published topics
+topics:
+  # System
+  - topic: /clock
+    type: rosgraph_msgs/Clock
+    num_publishers: 1
+    num_subscribers: -1
+
+  - topic: /rosout
+    type: rosgraph_msgs/Log
+    num_publishers: -1
+    num_subscribers: -1
+
+  # Gazebo
+  - topic: /gazebo/set_model_state
+    type: gazebo_msgs/ModelState
+    num_publishers: 0
+    num_subscribers: -1
+
+  - topic: /gazebo/set_link_state
+    type: gazebo_msgs/LinkState
+    num_publishers: 0
+    num_subscribers: -1
+
+  - topic: /gazebo/link_states
+    type: gazebo_msgs/LinkStates
+    num_publishers: 1
+    num_subscribers: -1
+
+  - topic: /gazebo/model_states
+    type: gazebo_msgs/ModelStates
+    num_publishers: 1
+    num_subscribers: -1
+
+  - topic: /gazebo/parameter_descriptions
+    type: dynamic_reconfigure/ConfigDescription
+    num_publishers: 1
+    num_subscribers: -1
+
+  - topic: /gazebo/parameter_updates
+    type: dynamic_reconfigure/Config
+    num_publishers: 1
+    num_subscribers: -1
+
+##########################################################
+# Published services
+services:
+  # Gazebo
+  - service: /gazebo/apply_joint_effort
+    type: gazebo_msgs/ApplyJointEffort
+
+  - service: /gazebo/get_physics_properties
+    type: gazebo_msgs/GetPhysicsProperties
+
+  - service: /gazebo/set_link_state
+    type: gazebo_msgs/SetLinkState
+
+  - service: /gazebo/set_joint_properties
+    type: gazebo_msgs/SetJointProperties
+
+  - service: /gazebo/reset_world
+    type: std_srvs/Empty
+
+  - service: /gazebo/set_model_configuration
+    type: gazebo_msgs/SetModelConfiguration
+
+  - service: /gazebo/get_world_properties
+    type: gazebo_msgs/GetWorldProperties
+
+  - service: /gazebo/delete_light
+    type: gazebo_msgs/DeleteLight
+
+  - service: /gazebo/set_parameters
+    type: dynamic_reconfigure/Reconfigure
+
+  - service: /gazebo/spawn_sdf_model
+    type: gazebo_msgs/SpawnModel
+
+  - service: /gazebo/unpause_physics
+    type: std_srvs/Empty
+
+  - service: /gazebo/pause_physics
+    type: std_srvs/Empty
+
+  - service: /gazebo/get_joint_properties
+    type: gazebo_msgs/GetJointProperties
+
+  - service: /gazebo/set_logger_level
+    type: roscpp/SetLoggerLevel
+
+  - service: /gazebo/get_light_properties
+    type: gazebo_msgs/GetLightProperties
+
+  - service: /gazebo/clear_body_wrenches
+    type: gazebo_msgs/BodyRequest
+
+  - service: /gazebo/clear_joint_forces
+    type: gazebo_msgs/JointRequest
+
+  - service: /gazebo/set_physics_properties
+    type: gazebo_msgs/SetPhysicsProperties
+
+  - service: /gazebo/get_model_state
+    type: gazebo_msgs/GetModelState
+
+  - service: /gazebo/reset_simulation
+    type: std_srvs/Empty
+
+  - service: /gazebo/delete_model
+    type: gazebo_msgs/DeleteModel
+
+  - service: /gazebo/spawn_urdf_model
+    type: gazebo_msgs/SpawnModel
+
+  - service: /gazebo/set_link_properties
+    type: gazebo_msgs/SetLinkProperties
+
+  - service: /gazebo/set_model_state
+    type: gazebo_msgs/SetModelState
+
+  - service: /gazebo/apply_body_wrench
+    type: gazebo_msgs/ApplyBodyWrench
+
+  - service: /gazebo/get_link_state
+    type: gazebo_msgs/GetLinkState
+
+  - service: /gazebo/get_loggers
+    type: roscpp/GetLoggers
+
+  - service: /gazebo/get_model_properties
+    type: gazebo_msgs/GetModelProperties
+
+  - service: /gazebo/set_light_properties
+    type: gazebo_msgs/SetLightProperties
+  
+  - service: /gazebo/get_link_properties
+    type: gazebo_msgs/GetLinkProperties
+
+  - service: /ros_network_by_default/get_loggers
+    type: roscpp/GetLoggers
+
+  - service: /ros_network_by_default/set_logger_level
+    type: roscpp/SetLoggerLevel
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/test/ros_network/no_gazebo_network_api.yaml
@@ -0,0 +1,31 @@
+strict: true
+
+##########################################################
+# Published topics
+topics:
+  # System
+  - topic: /clock
+    type: rosgraph_msgs/Clock
+    num_publishers: 1
+    num_subscribers: -1
+
+  - topic: /rosout
+    type: rosgraph_msgs/Log
+    num_publishers: -1
+    num_subscribers: -1
+
+##########################################################
+# Published services
+services:
+  # System
+  - service: /gazebo/set_logger_level
+    type: roscpp/SetLoggerLevel
+
+  - service: /gazebo/get_loggers
+    type: roscpp/GetLoggers
+
+  - service: /ros_network_by_default/get_loggers
+    type: roscpp/GetLoggers
+
+  - service: /ros_network_by_default/set_logger_level
+    type: roscpp/SetLoggerLevel
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/test/ros_network/ros_api_checker
@@ -0,0 +1,196 @@
+#!/usr/bin/env python
+
+# The script was originally written by Brian Gerkey under
+# the works of the Virtual Robotics Challenge
+#
+# Copyright Open Source Robotics Foundation
+#
+
+from __future__ import print_function
+import unittest
+import rostest
+import subprocess
+import sys
+import time
+import re
+import rospy
+
+class Tester(unittest.TestCase):
+
+    def _test_extra_topics(self, topics):
+        cmd = ['rostopic', 'list']
+        po = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
+        out, err = po.communicate()
+        self.assertEqual(po.returncode, 0, 'rostopic failed (%s). stdout: %s stderr: %s'%(cmd, out, err))
+        topics_actual = set(out.split('\n')) - set([''])
+        topics_expected = set([x['topic'] for x in topics])
+        topics_extra = topics_actual - topics_expected
+        self.assertEqual(topics_extra, set([]))
+
+    def _test_extra_services(self, services):
+        cmd = ['rosservice', 'list']
+        po = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
+        out, err = po.communicate()
+        self.assertEqual(po.returncode, 0, 'rosservice failed (%s). stdout: %s stderr: %s'%(cmd, out, err))
+        services_actual = set(out.split('\n')) - set([''])
+        services_expected = set([x['service'] for x in services])
+        services_extra = services_actual - services_expected
+        self.assertEqual(services_extra, set([]))
+
+    def _test_topic(self, t):
+        self.assertIn('topic', t)
+        self.assertIn('type', t)
+        self.assertIn('num_publishers', t)
+        self.assertIn('num_subscribers', t)
+
+        cmd = ['rostopic', 'info', t['topic']]
+        po = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
+        out, err = po.communicate()
+        self.assertEqual(po.returncode, 0, 'rostopic info failed (%s). stdout: %s stderr: %s'%(cmd, out, err))
+        self._parse_rostopic(t, out)
+
+    def _parse_rostopic(self, t, out):
+        # Should probably do this through a library API instead...
+
+        # Step 0: make sure we have enough output
+        outsplit = out.split('\n')
+        self.assertTrue(len(outsplit) >= 5)
+
+        type_re = re.compile('\w*Type: (.*)')
+        pub_start_re = re.compile('Publishers:.*')
+        sub_start_re = re.compile('Subscribers:.*')
+        pub_sub_re = re.compile(' *\* *([^ ]*).*')
+
+        # Step 1: check type
+        m = type_re.match(outsplit[0])
+        self.assertEqual(len(m.groups()), 1)
+        self.assertEqual(m.groups()[0], t['type'])
+
+        # Step 2: check num_publishers and num_subscribers
+        state = None
+        pubs = 0
+        subs = 0
+        for l in outsplit:
+            if pub_start_re.match(l):
+                state = 'in_pubs'
+            elif sub_start_re.match(l):
+                state = 'in_subs'
+            else:
+                m = pub_sub_re.match(l)
+                if m and len(m.groups()) == 1:
+                    if state == 'in_pubs':
+                        pubs += 1
+                    elif state == 'in_subs':
+                        subs += 1
+        if t['num_publishers'] >= 0:
+            self.assertEqual(pubs, t['num_publishers'])
+        if t['num_subscribers'] >= 0:
+            self.assertEqual(subs, t['num_subscribers'])
+
+    def _test_service(self, s):
+        self.assertIn('service', s)
+        self.assertIn('type', s)
+
+        cmd = ['rosservice', 'info', s['service']]
+        po = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
+        out, err = po.communicate()
+        self.assertEqual(po.returncode, 0, 'rosservice info failed (%s). stdout: %s stderr: %s'%(cmd, out, err))
+        self._parse_rosservice(s, out)
+
+    def _parse_rosservice(self, s, out):
+        # Should probably do this through a library API instead...
+
+        # Step 0: make sure we have enough output
+        outsplit = out.split('\n')
+        self.assertTrue(len(outsplit) >= 4)
+
+        type_re = re.compile('Type: (.*)')
+
+        # Step 1: check type
+        m = type_re.match(outsplit[2])
+        self.assertEqual(len(m.groups()), 1)
+        self.assertEqual(m.groups()[0], s['type'])
+
+def load_config(files):
+    import yaml
+    topics = []
+    services = []
+    strict = False
+    for f in files:
+        # Ignore args passed in by rostest
+        if f[:2] == '--' or f[:2] == '__':
+            continue
+        # Let parsing exceptions leak out; we'll catch them by noticing the
+        # absence of a test result file.
+        y = yaml.load(open(f))
+        for t in y['topics']:
+            topics.append(t)
+        if 'services' in y:
+            for s in y['services']:
+                services.append(s)
+
+        # TODO: This logic will enforce strictness if any of the provided files
+        # sets strict to true, which isn't necessarily the right thing.
+        if 'strict' in y and y['strict']:
+            strict = True
+    return topics, services, strict
+
+def generate_topic_test(t):
+    def test_func(self):
+        self._test_topic(t)
+    return test_func
+
+def generate_service_test(t):
+    def test_func(self):
+        self._test_service(t)
+    return test_func
+
+def generate_test_extra_topics(topics):
+    def test_func(self):
+        self._test_extra_topics(topics)
+    return test_func
+
+def generate_test_extra_services(services):
+    def test_func(self):
+        self._test_extra_services(services)
+    return test_func
+
+def add_tests(topics, services, strict):
+    for t in topics:
+        test_func = generate_topic_test(t)
+        test_name = "test_topic_%s"%(t['topic'].replace('/','_'))
+        setattr(Tester, test_name, test_func)
+    for s in services:
+        test_func = generate_service_test(s)
+        test_name = "test_service_%s"%(s['service'].replace('/','_'))
+        setattr(Tester, test_name, test_func)
+    if strict:
+        test_func = generate_test_extra_topics(topics)
+        test_name = "test_extra_topics"
+        setattr(Tester, test_name, test_func)
+        test_func = generate_test_extra_services(services)
+        test_name = "test_extra_services"
+        setattr(Tester, test_name, test_func)
+
+if __name__ == '__main__':
+    rospy.init_node('rosapi_checker', anonymous=True)
+
+    # Dynamically generate test cases and stuff them into the Tester class
+    topics, services, strict = load_config(sys.argv[1:])
+    # The rostest node itself will advertise a couple of services
+    services.append({'service': '%s/get_loggers'%(rospy.get_name()),
+                     'type': 'roscpp/GetLoggers'})
+    services.append({'service': '%s/set_logger_level'%(rospy.get_name()),
+                     'type': 'roscpp/SetLoggerLevel'})
+    add_tests(topics, services, strict)
+
+    # Wait until /clock is being published; this can take an unpredictable
+    # amount of time when we're downloading models.
+    while rospy.Time.now().to_sec() == 0.0:
+        print('Waiting for Gazebo to start...')
+        time.sleep(1.0)
+    # Take an extra nap, to allow plugins to be loaded
+    time.sleep(5.0)
+    print('OK, starting test.')
+
+    rostest.run('gazebo_ros', 'api_check', Tester, sys.argv)
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/test/ros_network/ros_network_default.test
@@ -0,0 +1,19 @@
+<?xml version="1.0"?>
+<launch>
+
+  <!-- Changed GAZEBO_MASTER_URI to avoid collision with the other test-->
+  <env name="GAZEBO_MASTER_URI" value="http://localhost:11346" />
+
+  <include file="$(find gazebo_ros)/launch/empty_world.launch">
+    <arg name="paused"   value="false"/>
+    <arg name="gui"      value="false"/>
+    <arg name="headless" value="false"/>
+    <arg name="debug"    value="false"/>
+    <arg name="enable_ros_network" value="true" />
+  </include>
+
+  <!-- the long timeout is just in case that gazebo needs to download models -->
+  <test pkg="gazebo_ros" type="ros_api_checker" test-name="ros_network_by_default"
+      args="$(find gazebo_ros)/test/ros_network/gazebo_network_api.yaml"
+      time-limit="100.0"/>
+</launch>
--- /dev/null
+++ ros-noetic-gazebo-ros-2.9.2/test/ros_network/ros_network_disabled.test
@@ -0,0 +1,15 @@
+<?xml version="1.0"?>
+<launch>
+  <include file="$(find gazebo_ros)/launch/empty_world.launch">
+    <arg name="paused"   value="false"/>
+    <arg name="gui"      value="false"/>
+    <arg name="headless" value="false"/>
+    <arg name="debug"    value="false"/>
+    <arg name="enable_ros_network" value="false"/>
+  </include>
+
+  <!-- the long timeout is just in case that gazebo needs to download models -->
+  <test pkg="gazebo_ros" type="ros_api_checker" test-name="ros_network_by_default"
+      args="$(find gazebo_ros)/test/ros_network/no_gazebo_network_api.yaml"
+      time-limit="100.0"/>
+</launch>
