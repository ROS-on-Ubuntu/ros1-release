Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 ros-noetic-bondcpp (1.8.6-0jammy) jammy; urgency=high
 .
   * narrow down required boost dependencies (#68 <https://github.com/ros/bond_core/issues/68>)
   * Contributors: Mikael Arguedas
Author: Michael Carroll <michael@openrobotics.org>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2024-08-18

--- /dev/null
+++ ros-noetic-bondcpp-1.8.6/CHANGELOG.rst
@@ -0,0 +1,196 @@
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Changelog for package bondcpp
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+1.8.6 (2020-08-28)
+------------------
+* narrow down required boost dependencies (`#68 <https://github.com/ros/bond_core/issues/68>`_)
+* Contributors: Mikael Arguedas
+
+1.8.5 (2020-05-14)
+------------------
+* Bump CMake minimum version to use CMP0048 (`#58 <https://github.com/ros/bond_core/issues/58>`_)
+* Contributors: Michael Carroll
+
+1.8.4 (2020-02-24)
+------------------
+* Solved static linking problems with bondcpp (`#44 <https://github.com/ros/bond_core/issues/44>`_)
+* Add BONDCPP_DECL for Bond class (`#2 <https://github.com/ros/bond_core/issues/2>`_) (`#45 <https://github.com/ros/bond_core/issues/45>`_)
+* Make Michael Carroll the maintainer (`#40 <https://github.com/ros/bond_core/issues/40>`_)
+* Contributors: James Xu, Mikael Arguedas, ivanpauno
+
+1.8.3 (2018-08-17)
+------------------
+* Argument to Boost Milliseconds must be integral in Boost >= 1.67 (`#37 <https://github.com/ros/bond_core/issues/37>`_)
+  * Argument to Boost milliseconds  must be integral
+  * Fix style
+  * More consistent type
+* Contributors: Paul-Edouard Sarlin
+
+1.8.2 (2018-04-27)
+------------------
+* uuid dependency fixup (`#36 <https://github.com/ros/bond_core/issues/36>`_)
+  * dont export uuid dependency as this isnt anywhere in the public api
+  * fixx uuid dependency in test_bond as well
+* Contributors: Mikael Arguedas
+
+1.8.1 (2017-10-27)
+------------------
+* fix package.xml to comply with schema (`#30 <https://github.com/ros/bond_core/issues/30>`_)
+* Contributors: Mikael Arguedas
+
+1.8.0 (2017-07-27)
+------------------
+* Use SteadyTime and SteadyTimer for bond timeouts (`#18 <https://github.com/ros/bond_core/issues/18>`_)
+* C++ style (`#28 <https://github.com/ros/bond_core/issues/28>`_)
+* switch to package format 2 (`#27 <https://github.com/ros/bond_core/issues/27>`_)
+* remove trailing whitespaces (`#26 <https://github.com/ros/bond_core/issues/26>`_)
+* Contributors: Felix Ruess, Mikael Arguedas
+
+1.7.19 (2017-03-27)
+-------------------
+* fix unused var warning
+* Contributors: Mikael Arguedas
+
+1.7.18 (2016-10-24)
+-------------------
+* fix -isystem /usr/include build breakage in gcc6
+* Contributors: Mikael Arguedas
+
+1.7.17 (2016-03-15)
+-------------------
+* update maintainer
+* Contributors: Mikael Arguedas
+
+1.7.16 (2014-10-30)
+-------------------
+* Fix depedency version
+* Contributors: Esteve Fernandez
+
+1.7.15 (2014-10-28)
+-------------------
+* Added version dependency.
+* Removed redundant include_directories
+* Added cmake_modules in alphabetical order
+* Use FindUUID.cmake from cmake-modules to find the UUID libraries `#8 <https://github.com/ros/bond_core/pull/8>`_
+* Contributors: Esteve Fernandez
+
+1.7.14 (2014-05-08)
+-------------------
+* Update maintainer field
+* Contributors: Esteve Fernandez, Vincent Rabaud
+
+1.7.13 (2013-08-21)
+-------------------
+* Use c++ style reinterpret_cast rather than c style cast
+* use rpc for uuid on windows
+* add missing archive/library/runtime destinations for library
+* Contributors: David Hodo, Dirk Thomas, William Woodall
+
+1.7.12 (2013-06-06)
+-------------------
+* fix dependency on exported targets if the variable is empty
+* use EXPORTED_TARGETS variable instead of explicit target names
+* Contributors: Dirk Thomas
+
+1.7.11 (2013-03-13)
+-------------------
+
+1.7.10 (2013-01-13)
+-------------------
+* add missing link library uuid `#6 <https://github.com/ros/bond_core/issues/6>`_
+* Contributors: Dirk Thomas
+
+1.7.9 (2012-12-27)
+------------------
+* modified dep type of catkin
+* Contributors: Dirk Thomas
+
+1.7.8 (2012-12-13)
+------------------
+
+1.7.7 (2012-12-06)
+------------------
+* Added missing link against catkin_LIBRARIES
+* Updated url tags in package.xml's `#1 <https://github.com/ros/bond_core/pull/1>`_
+* updated catkin_package(DEPENDS)
+* Contributors: Dirk Thomas, William Woodall
+
+1.7.6 (2012-10-30)
+------------------
+* fix catkin function order
+* Contributors: Dirk Thomas
+
+1.7.5 (2012-10-27)
+------------------
+* clean up package.xml files
+* add missing target dependency to gencpp
+* Contributors: Dirk Thomas
+
+1.7.4 (2012-10-06)
+------------------
+
+1.7.3 (2012-10-02 00:19)
+------------------------
+* fix package building issues
+* Contributors: Vincent Rabaud
+
+1.7.2 (2012-10-02 00:06)
+------------------------
+* add the missing catkin dependency
+* Contributors: Vincent Rabaud
+
+1.7.1 (2012-10-01 19:00)
+------------------------
+* add missing dependencies
+* Contributors: Vincent Rabaud
+
+1.7.0 (2012-10-01 16:51)
+------------------------
+* catkinize bond
+* catkinize the package and bump to 1.7.0 even though it is not tagged yet
+* add link flag for OSX
+* removed spurious reference to libroslib
+* bondcpp now explicitly links against the ros library.  `#5334 <https://github.com/ros/bond_core/issues/5334>`_
+* Changed ros::Time/Duration to ros::WallTime/WallDuration so Bond still works when time stops.  Fixes `#5035 <https://github.com/ros/bond_core/issues/5035>`_
+* Fixed destruction bug: doesn't destroy things if the bond was never started.
+* Can now set a bond's callback queue
+  --HG--
+  extra : convert_revision : svn%3Aeb33c2ac-9c88-4c90-87e0-44a10359b0c3/stacks/common/trunk%4037081
+* Modified bond's state machine to handle "alive" messages from the sibling when already dead.
+  --HG--
+  extra : convert_revision : svn%3Aeb33c2ac-9c88-4c90-87e0-44a10359b0c3/stacks/common/trunk%4036189
+* Added global "bond_disable_heartbeat_timeout" parameter
+  --HG--
+  extra : convert_revision : svn%3Aeb33c2ac-9c88-4c90-87e0-44a10359b0c3/stacks/common/trunk%4036106
+* typo
+  --HG--
+  extra : convert_revision : svn%3Aeb33c2ac-9c88-4c90-87e0-44a10359b0c3/stacks/common/trunk%4035731
+* rosdep and packages are not the same
+  --HG--
+  extra : convert_revision : svn%3Aeb33c2ac-9c88-4c90-87e0-44a10359b0c3/stacks/common/trunk%4035730
+* patch from stevenbellens for fedora uuid support `#4756 <https://github.com/ros/bond_core/issues/4756>`_
+  --HG--
+  extra : convert_revision : svn%3Aeb33c2ac-9c88-4c90-87e0-44a10359b0c3/stacks/common/trunk%4035729
+* Re-ordering locking in bondcpp's destructor
+  --HG--
+  extra : convert_revision : svn%3Aeb33c2ac-9c88-4c90-87e0-44a10359b0c3/stacks/common/trunk%4035719
+* In bond, wait_until_formed and wait_until_broken terminate when ROS shuts down.
+  --HG--
+  extra : convert_revision : svn%3Aeb33c2ac-9c88-4c90-87e0-44a10359b0c3/stacks/common/trunk%4035632
+* Bond no longer warns on destructor when the other side disappeared.
+  --HG--
+  extra : convert_revision : svn%3Aeb33c2ac-9c88-4c90-87e0-44a10359b0c3/stacks/common/trunk%4035573
+* removed wiki syntax from description
+  --HG--
+  extra : convert_revision : svn%3Aeb33c2ac-9c88-4c90-87e0-44a10359b0c3/stacks/common/trunk%4035392
+* Creating package descriptions for bondpy, bondcpp, and test_bond.
+  --HG--
+  extra : convert_revision : svn%3Aeb33c2ac-9c88-4c90-87e0-44a10359b0c3/stacks/common/trunk%4035354
+* The bond state machine more gracefully handles excessive requests to die.
+  --HG--
+  extra : convert_revision : svn%3Aeb33c2ac-9c88-4c90-87e0-44a10359b0c3/stacks/common/trunk%4032653
+* Moving bond into common
+  --HG--
+  extra : convert_revision : svn%3Aeb33c2ac-9c88-4c90-87e0-44a10359b0c3/stacks/common/trunk%4032634
+* Contributors: Brian Gerkey, Stuart Glaser, Vincent Rabaud, kwc, sglaser, tfoote
--- /dev/null
+++ ros-noetic-bondcpp-1.8.6/CMakeLists.txt
@@ -0,0 +1,41 @@
+cmake_minimum_required(VERSION 3.0.2)
+project(bondcpp)
+
+find_package(Boost REQUIRED date_time thread)
+find_package(catkin REQUIRED bond cmake_modules roscpp smclib)
+find_package(UUID REQUIRED)
+
+include_directories(
+  include
+  ${catkin_INCLUDE_DIRS}
+  ${Boost_INCLUDE_DIRS}
+  ${UUID_INCLUDE_DIRS}
+)
+
+catkin_package(
+  INCLUDE_DIRS include
+  LIBRARIES ${PROJECT_NAME}
+  CATKIN_DEPENDS bond roscpp smclib
+  DEPENDS Boost UUID
+)
+
+add_library(${PROJECT_NAME}
+  src/timeout.cpp
+  src/bond.cpp
+  src/BondSM_sm.cpp
+)
+target_link_libraries(${PROJECT_NAME} ${UUID_LIBRARIES} ${catkin_LIBRARIES} ${Boost_LIBRARIES})
+
+if(catkin_EXPORTED_TARGETS)
+  add_dependencies(${PROJECT_NAME} ${catkin_EXPORTED_TARGETS})
+endif()
+
+# install stuff
+install(DIRECTORY include/${PROJECT_NAME}/
+  DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
+)
+install(TARGETS ${PROJECT_NAME}
+  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION}
+)
--- /dev/null
+++ ros-noetic-bondcpp-1.8.6/include/bondcpp/BondSM_sm.h
@@ -0,0 +1,202 @@
+#ifndef BONDCPP__BONDSM_SM_H_
+#define BONDCPP__BONDSM_SM_H_
+
+/*
+ * ex: set ro:
+ * DO NOT EDIT.
+ * generated by smc (http://smc.sourceforge.net/)
+ * from file : BondSM_sm.sm
+ */
+
+
+#define SMC_USES_IOSTREAMS
+
+#include <smclib/statemap.h>
+
+// Forward declarations.
+class SM;
+class SM_WaitingForSister;
+class SM_Alive;
+class SM_AwaitSisterDeath;
+class SM_Dead;
+class SM_Default;
+class BondSMState;
+class BondSMContext;
+class BondSM;
+
+class BondSMState :
+    public statemap::State
+{
+public:
+    BondSMState(const char *name, int stateId)
+    : statemap::State(name, stateId)
+    {};
+
+    virtual void Entry(BondSMContext&) {}
+    virtual void Exit(BondSMContext&) {}
+
+    virtual void ConnectTimeout(BondSMContext& context);
+    virtual void Die(BondSMContext& context);
+    virtual void DisconnectTimeout(BondSMContext& context);
+    virtual void HeartbeatTimeout(BondSMContext& context);
+    virtual void SisterAlive(BondSMContext& context);
+    virtual void SisterDead(BondSMContext& context);
+
+protected:
+    virtual void Default(BondSMContext& context);
+};
+
+class SM
+{
+public:
+    static SM_WaitingForSister WaitingForSister;
+    static SM_Alive Alive;
+    static SM_AwaitSisterDeath AwaitSisterDeath;
+    static SM_Dead Dead;
+};
+
+class SM_Default :
+    public BondSMState
+{
+public:
+    SM_Default(const char *name, int stateId)
+    : BondSMState(name, stateId)
+    {};
+};
+
+class SM_WaitingForSister :
+    public SM_Default
+{
+public:
+    SM_WaitingForSister(const char *name, int stateId)
+    : SM_Default(name, stateId)
+    {};
+
+    void ConnectTimeout(BondSMContext& context);
+    void Die(BondSMContext& context);
+    void SisterAlive(BondSMContext& context);
+    void SisterDead(BondSMContext& context);
+};
+
+class SM_Alive :
+    public SM_Default
+{
+public:
+    SM_Alive(const char *name, int stateId)
+    : SM_Default(name, stateId)
+    {};
+
+    void Die(BondSMContext& context);
+    void HeartbeatTimeout(BondSMContext& context);
+    void SisterAlive(BondSMContext& context);
+    void SisterDead(BondSMContext& context);
+};
+
+class SM_AwaitSisterDeath :
+    public SM_Default
+{
+public:
+    SM_AwaitSisterDeath(const char *name, int stateId)
+    : SM_Default(name, stateId)
+    {};
+
+    void Die(BondSMContext& context);
+    void DisconnectTimeout(BondSMContext& context);
+    void HeartbeatTimeout(BondSMContext& context);
+    void SisterAlive(BondSMContext& context);
+    void SisterDead(BondSMContext& context);
+};
+
+class SM_Dead :
+    public SM_Default
+{
+public:
+    SM_Dead(const char *name, int stateId)
+    : SM_Default(name, stateId)
+    {};
+
+    void ConnectTimeout(BondSMContext& context);
+    void Die(BondSMContext& context);
+    void DisconnectTimeout(BondSMContext& context);
+    void HeartbeatTimeout(BondSMContext& context);
+    void SisterAlive(BondSMContext& context);
+    void SisterDead(BondSMContext& context);
+};
+
+class BondSMContext :
+    public statemap::FSMContext
+{
+public:
+    BondSMContext(BondSM& owner)
+    : FSMContext(SM::WaitingForSister),
+      _owner(owner)
+    {};
+
+    BondSMContext(BondSM& owner, const statemap::State& state)
+    : FSMContext(state),
+      _owner(owner)
+    {};
+
+    virtual void enterStartState()
+    {
+        getState().Entry(*this);
+        return;
+    }
+
+    BondSM& getOwner() const
+    {
+        return (_owner);
+    };
+
+    BondSMState& getState() const
+    {
+        if (_state == NULL)
+        {
+            throw statemap::StateUndefinedException();
+        }
+
+        return (dynamic_cast<BondSMState&>(*_state));
+    };
+
+    void ConnectTimeout()
+    {
+        (getState()).ConnectTimeout(*this);
+    };
+
+    void Die()
+    {
+        (getState()).Die(*this);
+    };
+
+    void DisconnectTimeout()
+    {
+        (getState()).DisconnectTimeout(*this);
+    };
+
+    void HeartbeatTimeout()
+    {
+        (getState()).HeartbeatTimeout(*this);
+    };
+
+    void SisterAlive()
+    {
+        (getState()).SisterAlive(*this);
+    };
+
+    void SisterDead()
+    {
+        (getState()).SisterDead(*this);
+    };
+
+private:
+    BondSM& _owner;
+};
+
+
+/*
+ * Local variables:
+ *  buffer-read-only: t
+ * End:
+ */
+
+#endif  // BONDCPP__BONDSM_SM_H_
--- /dev/null
+++ ros-noetic-bondcpp-1.8.6/include/bondcpp/bond.h
@@ -0,0 +1,213 @@
+/*
+ * Copyright (c) 2009, Willow Garage, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the Willow Garage, Inc. nor the names of its
+ *       contributors may be used to endorse or promote products derived from
+ *       this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** \author Stuart Glaser */
+
+#ifndef BONDCPP__BOND_H_
+#define BONDCPP__BOND_H_
+
+#include <boost/scoped_ptr.hpp>
+#include <boost/thread/mutex.hpp>
+#include <boost/thread/condition.hpp>
+
+#include <ros/ros.h>
+#include <ros/macros.h>
+
+#include <bondcpp/timeout.h>
+#include <bond/Constants.h>
+#include <bond/Status.h>
+#include "BondSM_sm.h"
+
+#include <string>
+#include <vector>
+
+#ifdef ROS_BUILD_SHARED_LIBS // ros is being built around shared libraries
+  #ifdef bondcpp_EXPORTS // we are building a shared lib/dll
+    #define BONDCPP_DECL ROS_HELPER_EXPORT
+  #else // we are using shared lib/dll
+    #define BONDCPP_DECL ROS_HELPER_IMPORT
+  #endif
+#else // ros is being built around static libraries
+  #define BONDCPP_DECL
+#endif
+
+namespace bond {
+
+/** \brief Forms a bond to monitor another process.
+ *
+ * The bond::Bond class implements a bond, allowing you to monitor
+ * another process and be notified when it dies.  In turn, it will be
+ * notified when you die.
+ */
+class BONDCPP_DECL Bond
+{
+public:
+  /** \brief Constructs a bond, but does not connect
+   *
+   * \param topic The topic used to exchange the bond status messages.
+   * \param id The ID of the bond, which should match the ID used on
+   *           the sister's end.
+   * \param on_broken callback that will be called when the bond is broken.
+   * \param on_formed callback that will be called when the bond is formed.
+   */
+  Bond(const std::string &topic, const std::string &id,
+       boost::function<void(void)> on_broken = boost::function<void(void)>(),
+       boost::function<void(void)> on_formed = boost::function<void(void)>());
+
+  /** \brief Destructs the object, breaking the bond if it is still formed.
+   */
+  ~Bond();
+
+  double getConnectTimeout() const { return connect_timeout_; }
+  void setConnectTimeout(double dur);
+  double getDisconnectTimeout() const { return disconnect_timeout_; }
+  void setDisconnectTimeout(double dur);
+  double getHeartbeatTimeout() const { return heartbeat_timeout_; }
+  void setHeartbeatTimeout(double dur);
+  double getHeartbeatPeriod() const { return heartbeat_period_; }
+  void setHeartbeatPeriod(double dur);
+
+  void setCallbackQueue(ros::CallbackQueueInterface *queue);
+
+  /** \brief Starts the bond and connects to the sister process.
+   */
+  void start();
+
+  /** \brief Sets the formed callback.
+   */
+  void setFormedCallback(boost::function<void(void)> on_formed);
+
+  /** \brief Sets the broken callback
+   */
+  void setBrokenCallback(boost::function<void(void)> on_broken);
+
+  /** \brief Blocks until the bond is formed for at most 'duration'.
+   *
+   * \param timeout Maximum duration to wait.  If -1 then this call will not timeout.
+   * \return true iff the bond has been formed.
+   */
+  bool waitUntilFormed(ros::Duration timeout = ros::Duration(-1));
+
+  /** \brief Blocks until the bond is formed for at most 'duration'.
+   *
+   * \param timeout Maximum duration to wait.  If -1 then this call will not timeout.
+   * \return true iff the bond has been formed.
+   */
+  bool waitUntilFormed(ros::WallDuration timeout = ros::WallDuration(-1));
+
+  /** \brief Blocks until the bond is broken for at most 'duration'.
+   *
+   * \param timeout Maximum duration to wait.  If -1 then this call will not timeout.
+   * \return true iff the bond has been broken, even if it has never been formed.
+   */
+  bool waitUntilBroken(ros::Duration timeout = ros::Duration(-1));
+
+  /** \brief Blocks until the bond is broken for at most 'duration'.
+   *
+   * \param timeout Maximum duration to wait.  If -1 then this call will not timeout.
+   * \return true iff the bond has been broken, even if it has never been formed.
+   */
+  bool waitUntilBroken(ros::WallDuration timeout = ros::WallDuration(-1));
+
+  /** \brief Indicates if the bond is broken
+   * \return true iff the bond has been broken.
+   */
+  bool isBroken();
+
+  /** \brief Breaks the bond, notifying the other process.
+   */
+  void breakBond();
+
+  std::string getTopic() { return topic_; }
+  std::string getId() { return id_; }
+  std::string getInstanceId() { return instance_id_; }
+
+private:
+  friend class ::BondSM;
+
+  ros::NodeHandle nh_;
+  boost::scoped_ptr<BondSM> bondsm_;
+  BondSMContext sm_;
+
+  std::string topic_;
+  std::string id_;
+  std::string instance_id_;
+  std::string sister_instance_id_;
+  boost::function<void(void)> on_broken_;
+  boost::function<void(void)> on_formed_;
+  bool sisterDiedFirst_;
+  bool started_;
+
+  boost::mutex mutex_;
+  boost::condition condition_;
+
+  double connect_timeout_;
+  double heartbeat_timeout_;
+  double disconnect_timeout_;
+  double heartbeat_period_;
+
+  Timeout connect_timer_;
+  Timeout heartbeat_timer_;
+  Timeout disconnect_timer_;
+
+  ros::Subscriber sub_;
+  ros::Publisher pub_;
+  ros::SteadyTimer publishingTimer_;
+
+  void onConnectTimeout();
+  void onHeartbeatTimeout();
+  void onDisconnectTimeout();
+
+  void bondStatusCB(const bond::Status::ConstPtr &msg);
+
+  void doPublishing(const ros::SteadyTimerEvent &e);
+  void publishStatus(bool active);
+
+  std::vector<boost::function<void(void)> > pending_callbacks_;
+  void flushPendingCallbacks();
+};
+
+}  // namespace bond
+
+
+// Internal use only
+struct BondSM
+{
+  BondSM(bond::Bond *b_) : b(b_) {}
+  void Connected();
+  void SisterDied();
+  void Death();
+  void Heartbeat();
+  void StartDying();
+
+private:
+  bond::Bond *b;
+};
+
+#endif  // BONDCPP__BOND_H_
--- /dev/null
+++ ros-noetic-bondcpp-1.8.6/include/bondcpp/timeout.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2009, Willow Garage, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the Willow Garage, Inc. nor the names of its
+ *       contributors may be used to endorse or promote products derived from
+ *       this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef BONDCPP__TIMEOUT_H_
+#define BONDCPP__TIMEOUT_H_
+
+#include <ros/ros.h>
+
+namespace bond {
+
+class Timeout
+{
+public:
+  Timeout(
+    const ros::Duration &d,
+    boost::function<void(void)> on_timeout = boost::function<void(void)>());
+  Timeout(
+    const ros::WallDuration &d,
+    boost::function<void(void)> on_timeout = boost::function<void(void)>());
+  ~Timeout();
+
+  // Undefined what these do to a running timeout
+  void setDuration(const ros::Duration &d);
+  void setDuration(const ros::WallDuration &d);
+
+  void reset();
+  void cancel();
+  ros::WallDuration left();
+
+private:
+  ros::NodeHandle nh_;
+  ros::SteadyTimer timer_;
+  ros::SteadyTime deadline_;
+  ros::WallDuration duration_;
+  boost::function<void(void)> on_timeout_;
+
+  void timerCallback(const ros::SteadyTimerEvent &e);
+};
+
+
+}  // namespace bond
+
+#endif  // BONDCPP__TIMEOUT_H_
--- /dev/null
+++ ros-noetic-bondcpp-1.8.6/mainpage.dox
@@ -0,0 +1,26 @@
+/**
+\mainpage
+\htmlinclude manifest.html
+
+\b bondcpp is the C++ implementation of a bond, which allows two
+processes to monitor each other and be informed on the death of the
+other.  You can be informed either by a callback or by polling that
+the other process in the bond is no longer alive.
+
+\section codeapi Code API
+
+The main class is bond::Bond
+
+<!--
+Provide links to specific auto-generated API documentation within your
+package that is of particular interest to a reader. Doxygen will
+document pretty much every part of your code, so do your best here to
+point the reader to the actual API.
+
+If your codebase is fairly large or has different sets of APIs, you
+should use the doxygen 'group' tag to keep these APIs together. For
+example, the roscpp documentation has 'libros' group.
+-->
+
+
+*/
--- /dev/null
+++ ros-noetic-bondcpp-1.8.6/package.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0"?>
+<?xml-model href="http://download.ros.org/schema/package_format2.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
+<package format="2">
+  <name>bondcpp</name>
+  <version>1.8.6</version>
+  <description>
+    C++ implementation of bond, a mechanism for checking when
+    another process has terminated.
+  </description>
+  <maintainer email="michael@openrobotics.org">Michael Carroll</maintainer>
+  <license>BSD</license>
+
+  <url type="website">http://www.ros.org/wiki/bondcpp</url>
+  <url type="bugtracker">https://github.com/ros/bond_core/issues</url>
+  <url type="repository">https://github.com/ros/bond_core</url>
+  <author>Stuart Glaser</author>
+
+  <buildtool_depend>catkin</buildtool_depend>
+
+  <build_depend version_gte="0.3.2">cmake_modules</build_depend>
+
+  <depend>bond</depend>
+  <depend>libboost-dev</depend>
+  <depend>libboost-date-time-dev</depend>
+  <depend>libboost-thread-dev</depend>
+  <depend>roscpp</depend>
+  <depend>smclib</depend>
+  <depend>uuid</depend>
+</package>
--- /dev/null
+++ ros-noetic-bondcpp-1.8.6/src/BondSM_sm.cpp
@@ -0,0 +1,361 @@
+/*
+ * ex: set ro:
+ * DO NOT EDIT.
+ * generated by smc (http://smc.sourceforge.net/)
+ * from file : BondSM_sm.sm
+ */
+
+#include "bondcpp/bond.h"
+#include "bondcpp/BondSM_sm.h"
+
+// Static class declarations.
+SM_WaitingForSister SM::WaitingForSister("SM::WaitingForSister", 0);
+SM_Alive SM::Alive("SM::Alive", 1);
+SM_AwaitSisterDeath SM::AwaitSisterDeath("SM::AwaitSisterDeath", 2);
+SM_Dead SM::Dead("SM::Dead", 3);
+
+void BondSMState::ConnectTimeout(BondSMContext& context)
+{
+    Default(context);
+    return;
+}
+
+void BondSMState::Die(BondSMContext& context)
+{
+    Default(context);
+    return;
+}
+
+void BondSMState::DisconnectTimeout(BondSMContext& context)
+{
+    Default(context);
+    return;
+}
+
+void BondSMState::HeartbeatTimeout(BondSMContext& context)
+{
+    Default(context);
+    return;
+}
+
+void BondSMState::SisterAlive(BondSMContext& context)
+{
+    Default(context);
+    return;
+}
+
+void BondSMState::SisterDead(BondSMContext& context)
+{
+    Default(context);
+    return;
+}
+
+void BondSMState::Default(BondSMContext& context)
+{
+    throw (
+        statemap::TransitionUndefinedException(
+            context.getState().getName(),
+            context.getTransition()));
+
+    return;
+}
+
+void SM_WaitingForSister::ConnectTimeout(BondSMContext& context)
+{
+    BondSM& ctxt(context.getOwner());
+
+    (context.getState()).Exit(context);
+    context.clearState();
+    try
+    {
+        ctxt.Death();
+        context.setState(SM::Dead);
+    }
+    catch (...)
+    {
+        context.setState(SM::Dead);
+        throw;
+    }
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_WaitingForSister::Die(BondSMContext& context)
+{
+    BondSM& ctxt(context.getOwner());
+
+    (context.getState()).Exit(context);
+    context.clearState();
+    try
+    {
+        ctxt.Death();
+        context.setState(SM::Dead);
+    }
+    catch (...)
+    {
+        context.setState(SM::Dead);
+        throw;
+    }
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_WaitingForSister::SisterAlive(BondSMContext& context)
+{
+    BondSM& ctxt(context.getOwner());
+
+    (context.getState()).Exit(context);
+    context.clearState();
+    try
+    {
+        ctxt.Connected();
+        context.setState(SM::Alive);
+    }
+    catch (...)
+    {
+        context.setState(SM::Alive);
+        throw;
+    }
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_WaitingForSister::SisterDead(BondSMContext& context)
+{
+    BondSM& ctxt(context.getOwner());
+
+    (context.getState()).Exit(context);
+    context.clearState();
+    try
+    {
+        ctxt.Connected();
+        ctxt.SisterDied();
+        ctxt.Death();
+        context.setState(SM::Dead);
+    }
+    catch (...)
+    {
+        context.setState(SM::Dead);
+        throw;
+    }
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_Alive::Die(BondSMContext& context)
+{
+    BondSM& ctxt(context.getOwner());
+
+    (context.getState()).Exit(context);
+    context.clearState();
+    try
+    {
+        ctxt.StartDying();
+        context.setState(SM::AwaitSisterDeath);
+    }
+    catch (...)
+    {
+        context.setState(SM::AwaitSisterDeath);
+        throw;
+    }
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_Alive::HeartbeatTimeout(BondSMContext& context)
+{
+    BondSM& ctxt(context.getOwner());
+
+    (context.getState()).Exit(context);
+    context.clearState();
+    try
+    {
+        ctxt.Death();
+        context.setState(SM::Dead);
+    }
+    catch (...)
+    {
+        context.setState(SM::Dead);
+        throw;
+    }
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_Alive::SisterAlive(BondSMContext& context)
+{
+    BondSM& ctxt(context.getOwner());
+
+    (context.getState()).Exit(context);
+    context.clearState();
+    try
+    {
+        ctxt.Heartbeat();
+        context.setState(SM::Alive);
+    }
+    catch (...)
+    {
+        context.setState(SM::Alive);
+        throw;
+    }
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_Alive::SisterDead(BondSMContext& context)
+{
+    BondSM& ctxt(context.getOwner());
+
+    (context.getState()).Exit(context);
+    context.clearState();
+    try
+    {
+        ctxt.SisterDied();
+        ctxt.Death();
+        context.setState(SM::Dead);
+    }
+    catch (...)
+    {
+        context.setState(SM::Dead);
+        throw;
+    }
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_AwaitSisterDeath::Die(BondSMContext& context)
+{
+    (context.getState()).Exit(context);
+    context.setState(SM::AwaitSisterDeath);
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_AwaitSisterDeath::DisconnectTimeout(BondSMContext& context)
+{
+    BondSM& ctxt(context.getOwner());
+
+    (context.getState()).Exit(context);
+    context.clearState();
+    try
+    {
+        ctxt.Death();
+        context.setState(SM::Dead);
+    }
+    catch (...)
+    {
+        context.setState(SM::Dead);
+        throw;
+    }
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_AwaitSisterDeath::HeartbeatTimeout(BondSMContext& context)
+{
+    (context.getState()).Exit(context);
+    context.setState(SM::AwaitSisterDeath);
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_AwaitSisterDeath::SisterAlive(BondSMContext& context)
+{
+    (context.getState()).Exit(context);
+    context.setState(SM::AwaitSisterDeath);
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_AwaitSisterDeath::SisterDead(BondSMContext& context)
+{
+    BondSM& ctxt(context.getOwner());
+
+    (context.getState()).Exit(context);
+    context.clearState();
+    try
+    {
+        ctxt.Death();
+        context.setState(SM::Dead);
+    }
+    catch (...)
+    {
+        context.setState(SM::Dead);
+        throw;
+    }
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_Dead::ConnectTimeout(BondSMContext& context)
+{
+    (context.getState()).Exit(context);
+    context.setState(SM::Dead);
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_Dead::Die(BondSMContext& context)
+{
+    (context.getState()).Exit(context);
+    context.setState(SM::Dead);
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_Dead::DisconnectTimeout(BondSMContext& context)
+{
+    (context.getState()).Exit(context);
+    context.setState(SM::Dead);
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_Dead::HeartbeatTimeout(BondSMContext& context)
+{
+    (context.getState()).Exit(context);
+    context.setState(SM::Dead);
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_Dead::SisterAlive(BondSMContext& context)
+{
+    (context.getState()).Exit(context);
+    context.setState(SM::Dead);
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+void SM_Dead::SisterDead(BondSMContext& context)
+{
+    (context.getState()).Exit(context);
+    context.setState(SM::Dead);
+    (context.getState()).Entry(context);
+
+    return;
+}
+
+/*
+ * Local variables:
+ *  buffer-read-only: t
+ * End:
+ */
--- /dev/null
+++ ros-noetic-bondcpp-1.8.6/src/bond.cpp
@@ -0,0 +1,419 @@
+/*
+ * Copyright (c) 2009, Willow Garage, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the Willow Garage, Inc. nor the names of its
+ *       contributors may be used to endorse or promote products derived from
+ *       this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+// Author: Stuart Glaser
+
+#include <bondcpp/bond.h>
+#include <boost/thread/thread_time.hpp>
+#include <boost/date_time/posix_time/posix_time_types.hpp>
+
+#ifdef _WIN32
+#include <Rpc.h>
+#else
+#include <uuid/uuid.h>
+#endif
+
+#include <algorithm>
+#include <string>
+#include <vector>
+
+namespace bond {
+
+static std::string makeUUID()
+{
+#ifdef _WIN32
+  UUID uuid;
+  UuidCreate(&uuid);
+  unsigned char *str;
+  UuidToStringA(&uuid, &str);
+  std::string return_string(reinterpret_cast<char *>(str));
+  RpcStringFreeA(&str);
+  return return_string;
+#else
+  uuid_t uuid;
+  uuid_generate_random(uuid);
+  char uuid_str[40];
+  uuid_unparse(uuid, uuid_str);
+  return std::string(uuid_str);
+#endif
+}
+
+Bond::Bond(const std::string &topic, const std::string &id,
+           boost::function<void(void)> on_broken,
+           boost::function<void(void)> on_formed)
+  :
+
+  bondsm_(new BondSM(this)),
+  sm_(*bondsm_),
+  topic_(topic),
+  id_(id),
+  instance_id_(makeUUID()),
+  on_broken_(on_broken),
+  on_formed_(on_formed),
+  sisterDiedFirst_(false),
+  started_(false),
+
+  connect_timer_(ros::WallDuration(), boost::bind(&Bond::onConnectTimeout, this)),
+  heartbeat_timer_(ros::WallDuration(), boost::bind(&Bond::onHeartbeatTimeout, this)),
+  disconnect_timer_(ros::WallDuration(), boost::bind(&Bond::onDisconnectTimeout, this))
+{
+  setConnectTimeout(bond::Constants::DEFAULT_CONNECT_TIMEOUT);
+  setDisconnectTimeout(bond::Constants::DEFAULT_DISCONNECT_TIMEOUT);
+  setHeartbeatTimeout(bond::Constants::DEFAULT_HEARTBEAT_TIMEOUT);
+  setHeartbeatPeriod(bond::Constants::DEFAULT_HEARTBEAT_PERIOD);
+}
+
+Bond::~Bond()
+{
+  if (!started_) {
+    return;
+  }
+
+  breakBond();
+  if (!waitUntilBroken(ros::Duration(1.0))) {
+    ROS_DEBUG("Bond failed to break on destruction %s (%s)", id_.c_str(), instance_id_.c_str());
+  }
+
+  // Must destroy the subscription before locking mutex_: shutdown()
+  // will block until the status callback completes, and the status
+  // callback locks mutex_ (in flushPendingCallbacks).
+  sub_.shutdown();
+
+  // Stops the timers before locking the mutex.  Makes sure none of
+  // the callbacks are running when we aquire the mutex.
+  publishingTimer_.stop();
+  connect_timer_.cancel();
+  heartbeat_timer_.cancel();
+  disconnect_timer_.cancel();
+
+  boost::mutex::scoped_lock lock(mutex_);
+  pub_.shutdown();
+}
+
+
+void Bond::setConnectTimeout(double dur)
+{
+  if (started_) {
+    ROS_ERROR("Cannot set timeouts after calling start()");
+    return;
+  }
+
+  connect_timeout_ = dur;
+  connect_timer_.setDuration(ros::WallDuration(connect_timeout_));
+}
+
+void Bond::setDisconnectTimeout(double dur)
+{
+  if (started_) {
+    ROS_ERROR("Cannot set timeouts after calling start()");
+    return;
+  }
+
+  disconnect_timeout_ = dur;
+  disconnect_timer_.setDuration(ros::WallDuration(disconnect_timeout_));
+}
+
+void Bond::setHeartbeatTimeout(double dur)
+{
+  if (started_) {
+    ROS_ERROR("Cannot set timeouts after calling start()");
+    return;
+  }
+
+  heartbeat_timeout_ = dur;
+  heartbeat_timer_.setDuration(ros::WallDuration(heartbeat_timeout_));
+}
+
+void Bond::setHeartbeatPeriod(double dur)
+{
+  if (started_) {
+    ROS_ERROR("Cannot set timeouts after calling start()");
+    return;
+  }
+
+  heartbeat_period_ = dur;
+}
+
+void Bond::setCallbackQueue(ros::CallbackQueueInterface *queue)
+{
+  if (started_) {
+    ROS_ERROR("Cannot set callback queue after calling start()");
+    return;
+  }
+
+  nh_.setCallbackQueue(queue);
+}
+
+
+void Bond::start()
+{
+  boost::mutex::scoped_lock lock(mutex_);
+  connect_timer_.reset();
+  pub_ = nh_.advertise<bond::Status>(topic_, 5);
+  sub_ = nh_.subscribe<bond::Status>(topic_, 30, boost::bind(&Bond::bondStatusCB, this, _1));
+
+  publishingTimer_ = nh_.createSteadyTimer(
+    ros::WallDuration(heartbeat_period_), &Bond::doPublishing, this);
+  started_ = true;
+}
+
+void Bond::setFormedCallback(boost::function<void(void)> on_formed)
+{
+  boost::mutex::scoped_lock lock(mutex_);
+  on_formed_ = on_formed;
+}
+
+void Bond::setBrokenCallback(boost::function<void(void)> on_broken)
+{
+  boost::mutex::scoped_lock lock(mutex_);
+  on_broken_ = on_broken;
+}
+
+bool Bond::waitUntilFormed(ros::Duration timeout)
+{
+  return waitUntilFormed(ros::WallDuration(timeout.sec, timeout.nsec));
+}
+bool Bond::waitUntilFormed(ros::WallDuration timeout)
+{
+  boost::mutex::scoped_lock lock(mutex_);
+  ros::SteadyTime deadline(ros::SteadyTime::now() + timeout);
+
+  while (sm_.getState().getId() == SM::WaitingForSister.getId()) {
+    if (!ros::ok()) {
+      break;
+    }
+
+    ros::WallDuration wait_time = ros::WallDuration(0.1);
+    if (timeout >= ros::WallDuration(0.0)) {
+      wait_time = std::min(wait_time, deadline - ros::SteadyTime::now());
+    }
+
+    if (wait_time <= ros::WallDuration(0.0)) {
+      break;  // The deadline has expired
+    }
+
+    condition_.timed_wait(mutex_, boost::posix_time::milliseconds(
+      static_cast<int64_t>(wait_time.toSec() * 1000.0f)));
+  }
+  return sm_.getState().getId() != SM::WaitingForSister.getId();
+}
+
+bool Bond::waitUntilBroken(ros::Duration timeout)
+{
+  return waitUntilBroken(ros::WallDuration(timeout.sec, timeout.nsec));
+}
+bool Bond::waitUntilBroken(ros::WallDuration timeout)
+{
+  boost::mutex::scoped_lock lock(mutex_);
+  ros::SteadyTime deadline(ros::SteadyTime::now() + timeout);
+
+  while (sm_.getState().getId() != SM::Dead.getId()) {
+    if (!ros::ok()) {
+      break;
+    }
+
+    ros::WallDuration wait_time = ros::WallDuration(0.1);
+    if (timeout >= ros::WallDuration(0.0)) {
+      wait_time = std::min(wait_time, deadline - ros::SteadyTime::now());
+    }
+
+    if (wait_time <= ros::WallDuration(0.0)) {
+      break;  // The deadline has expired
+    }
+
+    condition_.timed_wait(mutex_, boost::posix_time::milliseconds(
+      static_cast<int64_t>(wait_time.toSec() * 1000.0f)));
+  }
+  return sm_.getState().getId() == SM::Dead.getId();
+}
+
+bool Bond::isBroken()
+{
+  boost::mutex::scoped_lock lock(mutex_);
+  return sm_.getState().getId() == SM::Dead.getId();
+}
+
+void Bond::breakBond()
+{
+  {
+    boost::mutex::scoped_lock lock(mutex_);
+    if (sm_.getState().getId() != SM::Dead.getId()) {
+      sm_.Die();
+      publishStatus(false);
+    }
+  }
+  flushPendingCallbacks();
+}
+
+
+void Bond::onConnectTimeout()
+{
+  {
+    boost::mutex::scoped_lock lock(mutex_);
+    sm_.ConnectTimeout();
+  }
+  flushPendingCallbacks();
+}
+void Bond::onHeartbeatTimeout()
+{
+  // Checks that heartbeat timeouts haven't been disabled globally.
+  bool disable_heartbeat_timeout;
+  nh_.param(bond::Constants::DISABLE_HEARTBEAT_TIMEOUT_PARAM, disable_heartbeat_timeout, false);
+  if (disable_heartbeat_timeout) {
+    ROS_WARN("Heartbeat timeout is disabled.  Not breaking bond (topic: %s, id: %s)",
+             topic_.c_str(), id_.c_str());
+    return;
+  }
+
+  {
+    boost::mutex::scoped_lock lock(mutex_);
+    sm_.HeartbeatTimeout();
+  }
+  flushPendingCallbacks();
+}
+void Bond::onDisconnectTimeout()
+{
+  {
+    boost::mutex::scoped_lock lock(mutex_);
+    sm_.DisconnectTimeout();
+  }
+  flushPendingCallbacks();
+}
+
+void Bond::bondStatusCB(const bond::Status::ConstPtr &msg)
+{
+  // Filters out messages from other bonds and messages from ourself
+  if (msg->id == id_ && msg->instance_id != instance_id_) {
+    {
+      boost::mutex::scoped_lock lock(mutex_);
+
+      if (sister_instance_id_.empty()) {
+        sister_instance_id_ = msg->instance_id;
+      }
+      if (sister_instance_id_ != msg->instance_id) {
+        ROS_ERROR(
+          "More than two locations are trying to use a single bond (topic: %s, id: %s).  "
+          "You should only instantiate at most two bond instances for each (topic, id) pair.",
+          topic_.c_str(), id_.c_str());
+        return;
+      }
+
+      if (msg->active) {
+        sm_.SisterAlive();
+      } else {
+        sm_.SisterDead();
+
+        // Immediate ack for sister's death notification
+        if (sisterDiedFirst_) {
+          publishStatus(false);
+        }
+      }
+    }
+    flushPendingCallbacks();
+  }
+}
+
+void Bond::doPublishing(const ros::SteadyTimerEvent &)
+{
+  boost::mutex::scoped_lock lock(mutex_);
+  if (sm_.getState().getId() == SM::WaitingForSister.getId() ||
+      sm_.getState().getId() == SM::Alive.getId()) {
+    publishStatus(true);
+  } else if (sm_.getState().getId() == SM::AwaitSisterDeath.getId()) {
+    publishStatus(false);
+  } else {
+    publishingTimer_.stop();
+  }
+}
+
+void Bond::publishStatus(bool active)
+{
+  bond::Status::Ptr msg(new bond::Status);
+  msg->header.stamp = ros::Time::now();
+  msg->id = id_;
+  msg->instance_id = instance_id_;
+  msg->active = active;
+  msg->heartbeat_timeout = heartbeat_timeout_;
+  msg->heartbeat_period = heartbeat_period_;
+  pub_.publish(msg);
+}
+
+
+void Bond::flushPendingCallbacks()
+{
+  std::vector<boost::function<void(void)> > callbacks;
+  {
+    boost::mutex::scoped_lock lock(mutex_);
+    callbacks = pending_callbacks_;
+    pending_callbacks_.clear();
+  }
+
+  for (size_t i = 0; i < callbacks.size(); ++i) {
+    callbacks[i]();
+  }
+}
+
+}  // namespace bond
+
+
+void BondSM::Connected()
+{
+  b->connect_timer_.cancel();
+  b->condition_.notify_all();
+  if (b->on_formed_) {
+    b->pending_callbacks_.push_back(b->on_formed_);
+  }
+}
+
+void BondSM::SisterDied()
+{
+  b->sisterDiedFirst_ = true;
+}
+
+void BondSM::Death()
+{
+  b->condition_.notify_all();
+  b->heartbeat_timer_.cancel();
+  b->disconnect_timer_.cancel();
+  if (b->on_broken_) {
+    b->pending_callbacks_.push_back(b->on_broken_);
+  }
+}
+
+void BondSM::Heartbeat()
+{
+  b->heartbeat_timer_.reset();
+}
+
+void BondSM::StartDying()
+{
+  b->heartbeat_timer_.cancel();
+  b->disconnect_timer_.reset();
+  b->publishingTimer_.setPeriod(ros::WallDuration(bond::Constants::DEAD_PUBLISH_PERIOD));
+}
--- /dev/null
+++ ros-noetic-bondcpp-1.8.6/src/timeout.cpp
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2009, Willow Garage, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the Willow Garage, Inc. nor the names of its
+ *       contributors may be used to endorse or promote products derived from
+ *       this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "bondcpp/timeout.h"
+
+#include <algorithm>
+
+namespace bond {
+
+Timeout::Timeout(const ros::Duration &d,
+                 boost::function<void(void)> on_timeout)
+  : duration_(d.sec, d.nsec), on_timeout_(on_timeout)
+{
+}
+
+Timeout::Timeout(const ros::WallDuration &d,
+                 boost::function<void(void)> on_timeout)
+  : duration_(d), on_timeout_(on_timeout)
+{
+}
+
+Timeout::~Timeout()
+{
+  timer_.stop();
+}
+
+void Timeout::setDuration(const ros::Duration &d)
+{
+  duration_ = ros::WallDuration(d.sec, d.nsec);
+}
+
+void Timeout::setDuration(const ros::WallDuration &d)
+{
+  duration_ = d;
+}
+
+
+void Timeout::reset()
+{
+  timer_.stop();
+  timer_ = nh_.createSteadyTimer(duration_, &Timeout::timerCallback, this, true);
+  deadline_ = ros::SteadyTime::now() + duration_;
+}
+
+void Timeout::cancel()
+{
+  timer_.stop();
+}
+
+ros::WallDuration Timeout::left()
+{
+  return std::max(ros::WallDuration(0.0), deadline_ - ros::SteadyTime::now());
+}
+
+void Timeout::timerCallback(const ros::SteadyTimerEvent &)
+{
+  if (on_timeout_) {
+    on_timeout_();
+  }
+}
+
+}  // namespace bond
